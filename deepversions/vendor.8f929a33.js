var e,
	t,
	n = Object.defineProperty,
	r = Object.defineProperties,
	i = Object.getOwnPropertyDescriptors,
	s = Object.getOwnPropertySymbols,
	o = Object.prototype.hasOwnProperty,
	a = Object.prototype.propertyIsEnumerable,
	l = (e, t, r) => (t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)),
	u = (e, t) => {
		for (var n in t || (t = {})) o.call(t, n) && l(e, n, t[n]);
		if (s) for (var n of s(t)) a.call(t, n) && l(e, n, t[n]);
		return e;
	},
	c = (e, t) => r(e, i(t)),
	h = (e, t) => {
		var n = {};
		for (var r in e) o.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
		if (null != e && s) for (var r of s(e)) t.indexOf(r) < 0 && a.call(e, r) && (n[r] = e[r]);
		return n;
	};
function d(e, t) {
	const n = Object.create(null),
		r = e.split(",");
	for (let i = 0; i < r.length; i++) n[r[i]] = !0;
	return t ? (e) => !!n[e.toLowerCase()] : (e) => !!n[e];
}
const p = () => {},
	f = Object.assign,
	m = Object.prototype.hasOwnProperty,
	v = (e, t) => m.call(e, t),
	g = Array.isArray,
	y = (e) => "[object Map]" === w(e),
	b = (e) => "symbol" == typeof e,
	x = (e) => null !== e && "object" == typeof e,
	_ = Object.prototype.toString,
	w = (e) => _.call(e),
	C = (e) => "string" == typeof e && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
	S = (e, t) => !Object.is(e, t);
let E;
const T = [];
class k {
	constructor(e = !1) {
		(this.active = !0), (this.effects = []), (this.cleanups = []), !e && E && ((this.parent = E), (this.index = (E.scopes || (E.scopes = [])).push(this) - 1));
	}
	run(e) {
		if (this.active)
			try {
				return this.on(), e();
			} finally {
				this.off();
			}
	}
	on() {
		this.active && (T.push(this), (E = this));
	}
	off() {
		this.active && (T.pop(), (E = T[T.length - 1]));
	}
	stop(e) {
		if (this.active) {
			if ((this.effects.forEach((e) => e.stop()), this.cleanups.forEach((e) => e()), this.scopes && this.scopes.forEach((e) => e.stop(!0)), this.parent && !e)) {
				const e = this.parent.scopes.pop();
				e && e !== this && ((this.parent.scopes[this.index] = e), (e.index = this.index));
			}
			this.active = !1;
		}
	}
}
function A() {
	return E;
}
function M(e) {
	E && E.cleanups.push(e);
}
const I = (e) => {
		const t = new Set(e);
		return (t.w = 0), (t.n = 0), t;
	},
	R = (e) => (e.w & N) > 0,
	L = (e) => (e.n & N) > 0,
	O = new WeakMap();
let P = 0,
	N = 1;
const D = [];
let B;
const F = Symbol(""),
	H = Symbol("");
class V {
	constructor(e, t = null, n) {
		(this.fn = e),
			(this.scheduler = t),
			(this.active = !0),
			(this.deps = []),
			(function (e, t) {
				(t = t || E) && t.active && t.effects.push(e);
			})(this, n);
	}
	run() {
		if (!this.active) return this.fn();
		if (!D.includes(this))
			try {
				return (
					D.push((B = this)),
					$.push(z),
					(z = !0),
					(N = 1 << ++P),
					P <= 30
						? (({ deps: e }) => {
								if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= N;
						  })(this)
						: U(this),
					this.fn()
				);
			} finally {
				P <= 30 &&
					((e) => {
						const { deps: t } = e;
						if (t.length) {
							let n = 0;
							for (let r = 0; r < t.length; r++) {
								const i = t[r];
								R(i) && !L(i) ? i.delete(e) : (t[n++] = i), (i.w &= ~N), (i.n &= ~N);
							}
							t.length = n;
						}
					})(this),
					(N = 1 << --P),
					W(),
					D.pop();
				const e = D.length;
				B = e > 0 ? D[e - 1] : void 0;
			}
	}
	stop() {
		this.active && (U(this), this.onStop && this.onStop(), (this.active = !1));
	}
}
function U(e) {
	const { deps: t } = e;
	if (t.length) {
		for (let n = 0; n < t.length; n++) t[n].delete(e);
		t.length = 0;
	}
}
let z = !0;
const $ = [];
function j() {
	$.push(z), (z = !1);
}
function W() {
	const e = $.pop();
	z = void 0 === e || e;
}
function G(e, t, n) {
	if (!Y()) return;
	let r = O.get(e);
	r || O.set(e, (r = new Map()));
	let i = r.get(n);
	i || r.set(n, (i = I())), X(i);
}
function Y() {
	return z && void 0 !== B;
}
function X(e, t) {
	let n = !1;
	P <= 30 ? L(e) || ((e.n |= N), (n = !R(e))) : (n = !e.has(B)), n && (e.add(B), B.deps.push(e));
}
function K(e, t, n, r, i, s) {
	const o = O.get(e);
	if (!o) return;
	let a = [];
	if ("clear" === t) a = [...o.values()];
	else if ("length" === n && g(e))
		o.forEach((e, t) => {
			("length" === t || t >= r) && a.push(e);
		});
	else
		switch ((void 0 !== n && a.push(o.get(n)), t)) {
			case "add":
				g(e) ? C(n) && a.push(o.get("length")) : (a.push(o.get(F)), y(e) && a.push(o.get(H)));
				break;
			case "delete":
				g(e) || (a.push(o.get(F)), y(e) && a.push(o.get(H)));
				break;
			case "set":
				y(e) && a.push(o.get(F));
		}
	if (1 === a.length) a[0] && q(a[0]);
	else {
		const e = [];
		for (const t of a) t && e.push(...t);
		q(I(e));
	}
}
function q(e, t) {
	for (const n of g(e) ? e : [...e]) (n !== B || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run());
}
const Z = d("__proto__,__v_isRef,__isVue"),
	J = new Set(
		Object.getOwnPropertyNames(Symbol)
			.map((e) => Symbol[e])
			.filter(b)
	),
	Q = se(),
	ee = se(!1, !0),
	te = se(!0),
	ne = se(!0, !0),
	re = ie();
function ie() {
	const e = {};
	return (
		["includes", "indexOf", "lastIndexOf"].forEach((t) => {
			e[t] = function (...e) {
				const n = Ge(this);
				for (let t = 0, i = this.length; t < i; t++) G(n, 0, t + "");
				const r = n[t](...e);
				return -1 === r || !1 === r ? n[t](...e.map(Ge)) : r;
			};
		}),
		["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
			e[t] = function (...e) {
				j();
				const n = Ge(this)[t].apply(this, e);
				return W(), n;
			};
		}),
		e
	);
}
function se(e = !1, t = !1) {
	return function (n, r, i) {
		if ("__v_isReactive" === r) return !e;
		if ("__v_isReadonly" === r) return e;
		if ("__v_raw" === r && i === (e ? (t ? De : Ne) : t ? Pe : Oe).get(n)) return n;
		const s = g(n);
		if (!e && s && v(re, r)) return Reflect.get(re, r, i);
		const o = Reflect.get(n, r, i);
		if (b(r) ? J.has(r) : Z(r)) return o;
		if ((e || G(n, 0, r), t)) return o;
		if (Je(o)) {
			return !s || !C(r) ? o.value : o;
		}
		return x(o) ? (e ? Ve(o) : Fe(o)) : o;
	};
}
function oe(e = !1) {
	return function (t, n, r, i) {
		let s = t[n];
		if (!e && !je(r) && ((r = Ge(r)), (s = Ge(s)), !g(t) && Je(s) && !Je(r))) return (s.value = r), !0;
		const o = g(t) && C(n) ? Number(n) < t.length : v(t, n),
			a = Reflect.set(t, n, r, i);
		return t === Ge(i) && (o ? S(r, s) && K(t, "set", n, r) : K(t, "add", n, r)), a;
	};
}
const ae = {
		get: Q,
		set: oe(),
		deleteProperty: function (e, t) {
			const n = v(e, t);
			e[t];
			const r = Reflect.deleteProperty(e, t);
			return r && n && K(e, "delete", t, void 0), r;
		},
		has: function (e, t) {
			const n = Reflect.has(e, t);
			return (b(t) && J.has(t)) || G(e, 0, t), n;
		},
		ownKeys: function (e) {
			return G(e, 0, g(e) ? "length" : F), Reflect.ownKeys(e);
		}
	},
	le = { get: te, set: (e, t) => !0, deleteProperty: (e, t) => !0 },
	ue = f({}, ae, { get: ee, set: oe(!0) }),
	ce = f({}, le, { get: ne }),
	he = (e) => e,
	de = (e) => Reflect.getPrototypeOf(e);
function pe(e, t, n = !1, r = !1) {
	const i = Ge((e = e.__v_raw)),
		s = Ge(t);
	t !== s && !n && G(i, 0, t), !n && G(i, 0, s);
	const { has: o } = de(i),
		a = r ? he : n ? Ke : Xe;
	return o.call(i, t) ? a(e.get(t)) : o.call(i, s) ? a(e.get(s)) : void (e !== i && e.get(t));
}
function fe(e, t = !1) {
	const n = this.__v_raw,
		r = Ge(n),
		i = Ge(e);
	return e !== i && !t && G(r, 0, e), !t && G(r, 0, i), e === i ? n.has(e) : n.has(e) || n.has(i);
}
function me(e, t = !1) {
	return (e = e.__v_raw), !t && G(Ge(e), 0, F), Reflect.get(e, "size", e);
}
function ve(e) {
	e = Ge(e);
	const t = Ge(this);
	return de(t).has.call(t, e) || (t.add(e), K(t, "add", e, e)), this;
}
function ge(e, t) {
	t = Ge(t);
	const n = Ge(this),
		{ has: r, get: i } = de(n);
	let s = r.call(n, e);
	s || ((e = Ge(e)), (s = r.call(n, e)));
	const o = i.call(n, e);
	return n.set(e, t), s ? S(t, o) && K(n, "set", e, t) : K(n, "add", e, t), this;
}
function ye(e) {
	const t = Ge(this),
		{ has: n, get: r } = de(t);
	let i = n.call(t, e);
	i || ((e = Ge(e)), (i = n.call(t, e))), r && r.call(t, e);
	const s = t.delete(e);
	return i && K(t, "delete", e, void 0), s;
}
function be() {
	const e = Ge(this),
		t = 0 !== e.size,
		n = e.clear();
	return t && K(e, "clear", void 0, void 0), n;
}
function xe(e, t) {
	return function (n, r) {
		const i = this,
			s = i.__v_raw,
			o = Ge(s),
			a = t ? he : e ? Ke : Xe;
		return !e && G(o, 0, F), s.forEach((e, t) => n.call(r, a(e), a(t), i));
	};
}
function _e(e, t, n) {
	return function (...r) {
		const i = this.__v_raw,
			s = Ge(i),
			o = y(s),
			a = "entries" === e || (e === Symbol.iterator && o),
			l = "keys" === e && o,
			u = i[e](...r),
			c = n ? he : t ? Ke : Xe;
		return (
			!t && G(s, 0, l ? H : F),
			{
				next() {
					const { value: e, done: t } = u.next();
					return t ? { value: e, done: t } : { value: a ? [c(e[0]), c(e[1])] : c(e), done: t };
				},
				[Symbol.iterator]() {
					return this;
				}
			}
		);
	};
}
function we(e) {
	return function (...t) {
		return "delete" !== e && this;
	};
}
function Ce() {
	const e = {
			get(e) {
				return pe(this, e);
			},
			get size() {
				return me(this);
			},
			has: fe,
			add: ve,
			set: ge,
			delete: ye,
			clear: be,
			forEach: xe(!1, !1)
		},
		t = {
			get(e) {
				return pe(this, e, !1, !0);
			},
			get size() {
				return me(this);
			},
			has: fe,
			add: ve,
			set: ge,
			delete: ye,
			clear: be,
			forEach: xe(!1, !0)
		},
		n = {
			get(e) {
				return pe(this, e, !0);
			},
			get size() {
				return me(this, !0);
			},
			has(e) {
				return fe.call(this, e, !0);
			},
			add: we("add"),
			set: we("set"),
			delete: we("delete"),
			clear: we("clear"),
			forEach: xe(!0, !1)
		},
		r = {
			get(e) {
				return pe(this, e, !0, !0);
			},
			get size() {
				return me(this, !0);
			},
			has(e) {
				return fe.call(this, e, !0);
			},
			add: we("add"),
			set: we("set"),
			delete: we("delete"),
			clear: we("clear"),
			forEach: xe(!0, !0)
		};
	return (
		["keys", "values", "entries", Symbol.iterator].forEach((i) => {
			(e[i] = _e(i, !1, !1)), (n[i] = _e(i, !0, !1)), (t[i] = _e(i, !1, !0)), (r[i] = _e(i, !0, !0));
		}),
		[e, n, t, r]
	);
}
const [Se, Ee, Te, ke] = Ce();
function Ae(e, t) {
	const n = t ? (e ? ke : Te) : e ? Ee : Se;
	return (t, r, i) => ("__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(v(n, r) && r in t ? n : t, r, i));
}
const Me = { get: Ae(!1, !1) },
	Ie = { get: Ae(!1, !0) },
	Re = { get: Ae(!0, !1) },
	Le = { get: Ae(!0, !0) },
	Oe = new WeakMap(),
	Pe = new WeakMap(),
	Ne = new WeakMap(),
	De = new WeakMap();
function Be(e) {
	return e.__v_skip || !Object.isExtensible(e)
		? 0
		: (function (e) {
				switch (e) {
					case "Object":
					case "Array":
						return 1;
					case "Map":
					case "Set":
					case "WeakMap":
					case "WeakSet":
						return 2;
					default:
						return 0;
				}
		  })(((e) => w(e).slice(8, -1))(e));
}
function Fe(e) {
	return e && e.__v_isReadonly ? e : ze(e, !1, ae, Me, Oe);
}
function He(e) {
	return ze(e, !1, ue, Ie, Pe);
}
function Ve(e) {
	return ze(e, !0, le, Re, Ne);
}
function Ue(e) {
	return ze(e, !0, ce, Le, De);
}
function ze(e, t, n, r, i) {
	if (!x(e)) return e;
	if (e.__v_raw && (!t || !e.__v_isReactive)) return e;
	const s = i.get(e);
	if (s) return s;
	const o = Be(e);
	if (0 === o) return e;
	const a = new Proxy(e, 2 === o ? r : n);
	return i.set(e, a), a;
}
function $e(e) {
	return je(e) ? $e(e.__v_raw) : !(!e || !e.__v_isReactive);
}
function je(e) {
	return !(!e || !e.__v_isReadonly);
}
function We(e) {
	return $e(e) || je(e);
}
function Ge(e) {
	const t = e && e.__v_raw;
	return t ? Ge(t) : e;
}
function Ye(e) {
	return (
		((e, t, n) => {
			Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n });
		})(e, "__v_skip", !0),
		e
	);
}
const Xe = (e) => (x(e) ? Fe(e) : e),
	Ke = (e) => (x(e) ? Ve(e) : e);
function qe(e) {
	Y() && ((e = Ge(e)).dep || (e.dep = I()), X(e.dep));
}
function Ze(e, t) {
	(e = Ge(e)).dep && q(e.dep);
}
function Je(e) {
	return Boolean(e && !0 === e.__v_isRef);
}
function Qe(e) {
	return tt(e, !1);
}
function et(e) {
	return tt(e, !0);
}
function tt(e, t) {
	return Je(e) ? e : new nt(e, t);
}
class nt {
	constructor(e, t) {
		(this._shallow = t), (this.dep = void 0), (this.__v_isRef = !0), (this._rawValue = t ? e : Ge(e)), (this._value = t ? e : Xe(e));
	}
	get value() {
		return qe(this), this._value;
	}
	set value(e) {
		(e = this._shallow ? e : Ge(e)), S(e, this._rawValue) && ((this._rawValue = e), (this._value = this._shallow ? e : Xe(e)), Ze(this));
	}
}
function rt(e) {
	Ze(e);
}
function it(e) {
	return Je(e) ? e.value : e;
}
const st = {
	get: (e, t, n) => it(Reflect.get(e, t, n)),
	set: (e, t, n, r) => {
		const i = e[t];
		return Je(i) && !Je(n) ? ((i.value = n), !0) : Reflect.set(e, t, n, r);
	}
};
function ot(e) {
	return $e(e) ? e : new Proxy(e, st);
}
function at(e) {
	const t = g(e) ? new Array(e.length) : {};
	for (const n in e) t[n] = ut(e, n);
	return t;
}
class lt {
	constructor(e, t, n) {
		(this._object = e), (this._key = t), (this._defaultValue = n), (this.__v_isRef = !0);
	}
	get value() {
		const e = this._object[this._key];
		return void 0 === e ? this._defaultValue : e;
	}
	set value(e) {
		this._object[this._key] = e;
	}
}
function ut(e, t, n) {
	const r = e[t];
	return Je(r) ? r : new lt(e, t, n);
}
class ct {
	constructor(e, t, n) {
		(this._setter = t),
			(this.dep = void 0),
			(this._dirty = !0),
			(this.__v_isRef = !0),
			(this.effect = new V(e, () => {
				this._dirty || ((this._dirty = !0), Ze(this));
			})),
			(this.__v_isReadonly = n);
	}
	get value() {
		const e = Ge(this);
		return qe(e), e._dirty && ((e._dirty = !1), (e._value = e.effect.run())), e._value;
	}
	set value(e) {
		this._setter(e);
	}
}
function ht(e, t) {
	let n, r;
	const i = "function" == typeof e;
	i ? ((n = e), (r = p)) : ((n = e.get), (r = e.set));
	return new ct(n, r, i || !r);
}
function dt(e, t) {
	const n = Object.create(null),
		r = e.split(",");
	for (let i = 0; i < r.length; i++) n[r[i]] = !0;
	return t ? (e) => !!n[e.toLowerCase()] : (e) => !!n[e];
}
function pt(e) {
	if (Lt(e)) {
		const t = {};
		for (let n = 0; n < e.length; n++) {
			const r = e[n],
				i = Dt(r) ? vt(r) : pt(r);
			if (i) for (const e in i) t[e] = i[e];
		}
		return t;
	}
	return Dt(e) || Bt(e) ? e : void 0;
}
Promise.resolve();
const ft = /;(?![^(]*\))/g,
	mt = /:(.+)/;
function vt(e) {
	const t = {};
	return (
		e.split(ft).forEach((e) => {
			if (e) {
				const n = e.split(mt);
				n.length > 1 && (t[n[0].trim()] = n[1].trim());
			}
		}),
		t
	);
}
function gt(e) {
	let t = "";
	if (Dt(e)) t = e;
	else if (Lt(e))
		for (let n = 0; n < e.length; n++) {
			const r = gt(e[n]);
			r && (t += r + " ");
		}
	else if (Bt(e)) for (const n in e) e[n] && (t += n + " ");
	return t.trim();
}
function yt(e) {
	if (!e) return null;
	let { class: t, style: n } = e;
	return t && !Dt(t) && (e.class = gt(t)), n && (e.style = pt(n)), e;
}
const bt = (e) => (null == e ? "" : Lt(e) || (Bt(e) && (e.toString === Ht || !Nt(e.toString))) ? JSON.stringify(e, xt, 2) : String(e)),
	xt = (e, t) => (t && t.__v_isRef ? xt(e, t.value) : Ot(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n]) => ((e[`${t} =>`] = n), e), {}) } : Pt(t) ? { [`Set(${t.size})`]: [...t.values()] } : !Bt(t) || Lt(t) || Ut(t) ? t : String(t)),
	_t = {},
	wt = [],
	Ct = () => {},
	St = () => !1,
	Et = /^on[^a-z]/,
	Tt = (e) => Et.test(e),
	kt = (e) => e.startsWith("onUpdate:"),
	At = Object.assign,
	Mt = (e, t) => {
		const n = e.indexOf(t);
		n > -1 && e.splice(n, 1);
	},
	It = Object.prototype.hasOwnProperty,
	Rt = (e, t) => It.call(e, t),
	Lt = Array.isArray,
	Ot = (e) => "[object Map]" === Vt(e),
	Pt = (e) => "[object Set]" === Vt(e),
	Nt = (e) => "function" == typeof e,
	Dt = (e) => "string" == typeof e,
	Bt = (e) => null !== e && "object" == typeof e,
	Ft = (e) => Bt(e) && Nt(e.then) && Nt(e.catch),
	Ht = Object.prototype.toString,
	Vt = (e) => Ht.call(e),
	Ut = (e) => "[object Object]" === Vt(e),
	zt = dt(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
	$t = (e) => {
		const t = Object.create(null);
		return (n) => t[n] || (t[n] = e(n));
	},
	jt = /-(\w)/g,
	Wt = $t((e) => e.replace(jt, (e, t) => (t ? t.toUpperCase() : ""))),
	Gt = /\B([A-Z])/g,
	Yt = $t((e) => e.replace(Gt, "-$1").toLowerCase()),
	Xt = $t((e) => e.charAt(0).toUpperCase() + e.slice(1)),
	Kt = $t((e) => (e ? `on${Xt(e)}` : "")),
	qt = (e, t) => !Object.is(e, t),
	Zt = (e, t) => {
		for (let n = 0; n < e.length; n++) e[n](t);
	},
	Jt = (e, t, n) => {
		Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n });
	},
	Qt = (e) => {
		const t = parseFloat(e);
		return isNaN(t) ? e : t;
	};
let en;
function tn(e, t, ...n) {
	const r = e.vnode.props || _t;
	let i = n;
	const s = t.startsWith("update:"),
		o = s && t.slice(7);
	if (o && o in r) {
		const e = `${"modelValue" === o ? "model" : o}Modifiers`,
			{ number: t, trim: s } = r[e] || _t;
		s ? (i = n.map((e) => e.trim())) : t && (i = n.map(Qt));
	}
	let a,
		l = r[(a = Kt(t))] || r[(a = Kt(Wt(t)))];
	!l && s && (l = r[(a = Kt(Yt(t)))]), l && Ui(l, e, 6, i);
	const u = r[a + "Once"];
	if (u) {
		if (e.emitted) {
			if (e.emitted[a]) return;
		} else e.emitted = {};
		(e.emitted[a] = !0), Ui(u, e, 6, i);
	}
}
function nn(e, t, n = !1) {
	const r = t.emitsCache,
		i = r.get(e);
	if (void 0 !== i) return i;
	const s = e.emits;
	let o = {},
		a = !1;
	if (!Nt(e)) {
		const r = (e) => {
			const n = nn(e, t, !0);
			n && ((a = !0), At(o, n));
		};
		!n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r);
	}
	return s || a ? (Lt(s) ? s.forEach((e) => (o[e] = null)) : At(o, s), r.set(e, o), o) : (r.set(e, null), null);
}
function rn(e, t) {
	return !(!e || !Tt(t)) && ((t = t.slice(2).replace(/Once$/, "")), Rt(e, t[0].toLowerCase() + t.slice(1)) || Rt(e, Yt(t)) || Rt(e, t));
}
let sn = null,
	on = null;
function an(e) {
	const t = sn;
	return (sn = e), (on = (e && e.type.__scopeId) || null), t;
}
function ln(e) {
	on = e;
}
function un() {
	on = null;
}
function cn(e, t = sn, n) {
	if (!t) return e;
	if (e._n) return e;
	const r = (...n) => {
		r._d && Yr(-1);
		const i = an(t),
			s = e(...n);
		return an(i), r._d && Yr(1), s;
	};
	return (r._n = !0), (r._c = !0), (r._d = !0), r;
}
function hn(e) {
	const {
		type: t,
		vnode: n,
		proxy: r,
		withProxy: i,
		props: s,
		propsOptions: [o],
		slots: a,
		attrs: l,
		emit: u,
		render: c,
		renderCache: h,
		data: d,
		setupState: p,
		ctx: f,
		inheritAttrs: m
	} = e;
	let v, g;
	const y = an(e);
	try {
		if (4 & n.shapeFlag) {
			const e = i || r;
			(v = li(c.call(e, e, h, s, p, d, f))), (g = l);
		} else {
			const e = t;
			0, (v = li(e.length > 1 ? e(s, { attrs: l, slots: a, emit: u }) : e(s, null))), (g = t.props ? l : dn(l));
		}
	} catch (x) {
		($r.length = 0), zi(x, e, 1), (v = ri(Ur));
	}
	let b = v;
	if (g && !1 !== m) {
		const e = Object.keys(g),
			{ shapeFlag: t } = b;
		e.length && 7 & t && (o && e.some(kt) && (g = pn(g, o)), (b = si(b, g)));
	}
	return n.dirs && (b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && (b.transition = n.transition), (v = b), an(y), v;
}
const dn = (e) => {
		let t;
		for (const n in e) ("class" === n || "style" === n || Tt(n)) && ((t || (t = {}))[n] = e[n]);
		return t;
	},
	pn = (e, t) => {
		const n = {};
		for (const r in e) (kt(r) && r.slice(9) in t) || (n[r] = e[r]);
		return n;
	};
function fn(e, t, n) {
	const r = Object.keys(t);
	if (r.length !== Object.keys(e).length) return !0;
	for (let i = 0; i < r.length; i++) {
		const s = r[i];
		if (t[s] !== e[s] && !rn(n, s)) return !0;
	}
	return !1;
}
function mn(e, t) {
	if (Ci) {
		let n = Ci.provides;
		const r = Ci.parent && Ci.parent.provides;
		r === n && (n = Ci.provides = Object.create(r)), (n[e] = t);
	} else;
}
function vn(e, t, n = !1) {
	const r = Ci || sn;
	if (r) {
		const i = null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
		if (i && e in i) return i[e];
		if (arguments.length > 1) return n && Nt(t) ? t.call(r.proxy) : t;
	}
}
function gn() {
	const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() };
	return (
		Vn(() => {
			e.isMounted = !0;
		}),
		$n(() => {
			e.isUnmounting = !0;
		}),
		e
	);
}
const yn = [Function, Array],
	bn = {
		name: "BaseTransition",
		props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: yn, onEnter: yn, onAfterEnter: yn, onEnterCancelled: yn, onBeforeLeave: yn, onLeave: yn, onAfterLeave: yn, onLeaveCancelled: yn, onBeforeAppear: yn, onAppear: yn, onAfterAppear: yn, onAppearCancelled: yn },
		setup(e, { slots: t }) {
			const n = Si(),
				r = gn();
			let i;
			return () => {
				const s = t.default && En(t.default(), !0);
				if (!s || !s.length) return;
				const o = Ge(e),
					{ mode: a } = o,
					l = s[0];
				if (r.isLeaving) return wn(l);
				const u = Cn(l);
				if (!u) return wn(l);
				const c = _n(u, o, r, n);
				Sn(u, c);
				const h = n.subTree,
					d = h && Cn(h);
				let p = !1;
				const { getTransitionKey: f } = u.type;
				if (f) {
					const e = f();
					void 0 === i ? (i = e) : e !== i && ((i = e), (p = !0));
				}
				if (d && d.type !== Ur && (!Jr(u, d) || p)) {
					const e = _n(d, o, r, n);
					if ((Sn(d, e), "out-in" === a))
						return (
							(r.isLeaving = !0),
							(e.afterLeave = () => {
								(r.isLeaving = !1), n.update();
							}),
							wn(l)
						);
					"in-out" === a &&
						u.type !== Ur &&
						(e.delayLeave = (e, t, n) => {
							(xn(r, d)[String(d.key)] = d),
								(e._leaveCb = () => {
									t(), (e._leaveCb = void 0), delete c.delayedLeave;
								}),
								(c.delayedLeave = n);
						});
				}
				return l;
			};
		}
	};
function xn(e, t) {
	const { leavingVNodes: n } = e;
	let r = n.get(t.type);
	return r || ((r = Object.create(null)), n.set(t.type, r)), r;
}
function _n(e, t, n, r) {
	const { appear: i, mode: s, persisted: o = !1, onBeforeEnter: a, onEnter: l, onAfterEnter: u, onEnterCancelled: c, onBeforeLeave: h, onLeave: d, onAfterLeave: p, onLeaveCancelled: f, onBeforeAppear: m, onAppear: v, onAfterAppear: g, onAppearCancelled: y } = t,
		b = String(e.key),
		x = xn(n, e),
		_ = (e, t) => {
			e && Ui(e, r, 9, t);
		},
		w = {
			mode: s,
			persisted: o,
			beforeEnter(t) {
				let r = a;
				if (!n.isMounted) {
					if (!i) return;
					r = m || a;
				}
				t._leaveCb && t._leaveCb(!0);
				const s = x[b];
				s && Jr(e, s) && s.el._leaveCb && s.el._leaveCb(), _(r, [t]);
			},
			enter(e) {
				let t = l,
					r = u,
					s = c;
				if (!n.isMounted) {
					if (!i) return;
					(t = v || l), (r = g || u), (s = y || c);
				}
				let o = !1;
				const a = (e._enterCb = (t) => {
					o || ((o = !0), _(t ? s : r, [e]), w.delayedLeave && w.delayedLeave(), (e._enterCb = void 0));
				});
				t ? (t(e, a), t.length <= 1 && a()) : a();
			},
			leave(t, r) {
				const i = String(e.key);
				if ((t._enterCb && t._enterCb(!0), n.isUnmounting)) return r();
				_(h, [t]);
				let s = !1;
				const o = (t._leaveCb = (n) => {
					s || ((s = !0), r(), _(n ? f : p, [t]), (t._leaveCb = void 0), x[i] === e && delete x[i]);
				});
				(x[i] = e), d ? (d(t, o), d.length <= 1 && o()) : o();
			},
			clone: (e) => _n(e, t, n, r)
		};
	return w;
}
function wn(e) {
	if (An(e)) return ((e = si(e)).children = null), e;
}
function Cn(e) {
	return An(e) ? (e.children ? e.children[0] : void 0) : e;
}
function Sn(e, t) {
	6 & e.shapeFlag && e.component ? Sn(e.component.subTree, t) : 128 & e.shapeFlag ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback))) : (e.transition = t);
}
function En(e, t = !1) {
	let n = [],
		r = 0;
	for (let i = 0; i < e.length; i++) {
		const s = e[i];
		s.type === Hr ? (128 & s.patchFlag && r++, (n = n.concat(En(s.children, t)))) : (t || s.type !== Ur) && n.push(s);
	}
	if (r > 1) for (let i = 0; i < n.length; i++) n[i].patchFlag = -2;
	return n;
}
function Tn(e) {
	return Nt(e) ? { setup: e, name: e.name } : e;
}
const kn = (e) => !!e.type.__asyncLoader,
	An = (e) => e.type.__isKeepAlive,
	Mn = {
		name: "KeepAlive",
		__isKeepAlive: !0,
		props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] },
		setup(e, { slots: t }) {
			const n = Si(),
				r = n.ctx;
			if (!r.renderer) return t.default;
			const i = new Map(),
				s = new Set();
			let o = null;
			const a = n.suspense,
				{
					renderer: {
						p: l,
						m: u,
						um: c,
						o: { createElement: h }
					}
				} = r,
				d = h("div");
			function p(e) {
				Nn(e), c(e, n, a);
			}
			function f(e) {
				i.forEach((t, n) => {
					const r = Pi(t.type);
					!r || (e && e(r)) || m(n);
				});
			}
			function m(e) {
				const t = i.get(e);
				o && t.type === o.type ? o && Nn(o) : p(t), i.delete(e), s.delete(e);
			}
			(r.activate = (e, t, n, r, i) => {
				const s = e.component;
				u(e, t, n, 0, a),
					l(s.vnode, e, t, n, s, a, r, e.slotScopeIds, i),
					Sr(() => {
						(s.isDeactivated = !1), s.a && Zt(s.a);
						const t = e.props && e.props.onVnodeMounted;
						t && di(t, s.parent, e);
					}, a);
			}),
				(r.deactivate = (e) => {
					const t = e.component;
					u(e, d, null, 1, a),
						Sr(() => {
							t.da && Zt(t.da);
							const n = e.props && e.props.onVnodeUnmounted;
							n && di(n, t.parent, e), (t.isDeactivated = !0);
						}, a);
				}),
				ds(
					() => [e.include, e.exclude],
					([e, t]) => {
						e && f((t) => In(e, t)), t && f((e) => !In(t, e));
					},
					{ flush: "post", deep: !0 }
				);
			let v = null;
			const g = () => {
				null != v && i.set(v, Dn(n.subTree));
			};
			return (
				Vn(g),
				zn(g),
				$n(() => {
					i.forEach((e) => {
						const { subTree: t, suspense: r } = n,
							i = Dn(t);
						if (e.type !== i.type) p(e);
						else {
							Nn(i);
							const e = i.component.da;
							e && Sr(e, r);
						}
					});
				}),
				() => {
					if (((v = null), !t.default)) return null;
					const n = t.default(),
						r = n[0];
					if (n.length > 1) return (o = null), n;
					if (!(Zr(r) && (4 & r.shapeFlag || 128 & r.shapeFlag))) return (o = null), r;
					let a = Dn(r);
					const l = a.type,
						u = Pi(kn(a) ? a.type.__asyncResolved || {} : l),
						{ include: c, exclude: h, max: d } = e;
					if ((c && (!u || !In(c, u))) || (h && u && In(h, u))) return (o = a), r;
					const p = null == a.key ? l : a.key,
						f = i.get(p);
					return (
						a.el && ((a = si(a)), 128 & r.shapeFlag && (r.ssContent = a)),
						(v = p),
						f ? ((a.el = f.el), (a.component = f.component), a.transition && Sn(a, a.transition), (a.shapeFlag |= 512), s.delete(p), s.add(p)) : (s.add(p), d && s.size > parseInt(d, 10) && m(s.values().next().value)),
						(a.shapeFlag |= 256),
						(o = a),
						r
					);
				}
			);
		}
	};
function In(e, t) {
	return Lt(e) ? e.some((e) => In(e, t)) : Dt(e) ? e.split(",").indexOf(t) > -1 : !!e.test && e.test(t);
}
function Rn(e, t) {
	On(e, "a", t);
}
function Ln(e, t) {
	On(e, "da", t);
}
function On(e, t, n = Ci) {
	const r =
		e.__wdc ||
		(e.__wdc = () => {
			let t = n;
			for (; t; ) {
				if (t.isDeactivated) return;
				t = t.parent;
			}
			return e();
		});
	if ((Bn(t, r, n), n)) {
		let e = n.parent;
		for (; e && e.parent; ) An(e.parent.vnode) && Pn(r, t, n, e), (e = e.parent);
	}
}
function Pn(e, t, n, r) {
	const i = Bn(t, e, r, !0);
	jn(() => {
		Mt(r[t], i);
	}, n);
}
function Nn(e) {
	let t = e.shapeFlag;
	256 & t && (t -= 256), 512 & t && (t -= 512), (e.shapeFlag = t);
}
function Dn(e) {
	return 128 & e.shapeFlag ? e.ssContent : e;
}
function Bn(e, t, n = Ci, r = !1) {
	if (n) {
		const i = n[e] || (n[e] = []),
			s =
				t.__weh ||
				(t.__weh = (...r) => {
					if (n.isUnmounted) return;
					j(), Ei(n);
					const i = Ui(t, n, e, r);
					return Ti(), W(), i;
				});
		return r ? i.unshift(s) : i.push(s), s;
	}
}
const Fn =
		(e) =>
		(t, n = Ci) =>
			(!Ai || "sp" === e) && Bn(e, t, n),
	Hn = Fn("bm"),
	Vn = Fn("m"),
	Un = Fn("bu"),
	zn = Fn("u"),
	$n = Fn("bum"),
	jn = Fn("um"),
	Wn = Fn("sp"),
	Gn = Fn("rtg"),
	Yn = Fn("rtc");
function Xn(e, t = Ci) {
	Bn("ec", e, t);
}
let Kn = !0;
function qn(e) {
	const t = Qn(e),
		n = e.proxy,
		r = e.ctx;
	(Kn = !1), t.beforeCreate && Zn(t.beforeCreate, e, "bc");
	const {
		data: i,
		computed: s,
		methods: o,
		watch: a,
		provide: l,
		inject: u,
		created: c,
		beforeMount: h,
		mounted: d,
		beforeUpdate: p,
		updated: f,
		activated: m,
		deactivated: v,
		beforeDestroy: g,
		beforeUnmount: y,
		destroyed: b,
		unmounted: x,
		render: _,
		renderTracked: w,
		renderTriggered: C,
		errorCaptured: S,
		serverPrefetch: E,
		expose: T,
		inheritAttrs: k,
		components: A,
		directives: M,
		filters: I
	} = t;
	if (
		(u &&
			(function (e, t, n = Ct, r = !1) {
				Lt(e) && (e = rr(e));
				for (const i in e) {
					const n = e[i];
					let s;
					(s = Bt(n) ? ("default" in n ? vn(n.from || i, n.default, !0) : vn(n.from || i)) : vn(n)), Je(s) && r ? Object.defineProperty(t, i, { enumerable: !0, configurable: !0, get: () => s.value, set: (e) => (s.value = e) }) : (t[i] = s);
				}
			})(u, r, null, e.appContext.config.unwrapInjectedRef),
		o)
	)
		for (const L in o) {
			const e = o[L];
			Nt(e) && (r[L] = e.bind(n));
		}
	if (i) {
		const t = i.call(n, n);
		Bt(t) && (e.data = Fe(t));
	}
	if (((Kn = !0), s))
		for (const L in s) {
			const e = s[L],
				t = ht({ get: Nt(e) ? e.bind(n, n) : Nt(e.get) ? e.get.bind(n, n) : Ct, set: !Nt(e) && Nt(e.set) ? e.set.bind(n) : Ct });
			Object.defineProperty(r, L, { enumerable: !0, configurable: !0, get: () => t.value, set: (e) => (t.value = e) });
		}
	if (a) for (const L in a) Jn(a[L], r, n, L);
	if (l) {
		const e = Nt(l) ? l.call(n) : l;
		Reflect.ownKeys(e).forEach((t) => {
			mn(t, e[t]);
		});
	}
	function R(e, t) {
		Lt(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n));
	}
	if ((c && Zn(c, e, "c"), R(Hn, h), R(Vn, d), R(Un, p), R(zn, f), R(Rn, m), R(Ln, v), R(Xn, S), R(Yn, w), R(Gn, C), R($n, y), R(jn, x), R(Wn, E), Lt(T)))
		if (T.length) {
			const t = e.exposed || (e.exposed = {});
			T.forEach((e) => {
				Object.defineProperty(t, e, { get: () => n[e], set: (t) => (n[e] = t) });
			});
		} else e.exposed || (e.exposed = {});
	_ && e.render === Ct && (e.render = _), null != k && (e.inheritAttrs = k), A && (e.components = A), M && (e.directives = M);
}
function Zn(e, t, n) {
	Ui(Lt(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy), t, n);
}
function Jn(e, t, n, r) {
	const i = r.includes(".") ? ms(n, r) : () => n[r];
	if (Dt(e)) {
		const n = t[e];
		Nt(n) && ds(i, n);
	} else if (Nt(e)) ds(i, e.bind(n));
	else if (Bt(e))
		if (Lt(e)) e.forEach((e) => Jn(e, t, n, r));
		else {
			const r = Nt(e.handler) ? e.handler.bind(n) : t[e.handler];
			Nt(r) && ds(i, r, e);
		}
}
function Qn(e) {
	const t = e.type,
		{ mixins: n, extends: r } = t,
		{
			mixins: i,
			optionsCache: s,
			config: { optionMergeStrategies: o }
		} = e.appContext,
		a = s.get(t);
	let l;
	return a ? (l = a) : i.length || n || r ? ((l = {}), i.length && i.forEach((e) => er(l, e, o, !0)), er(l, t, o)) : (l = t), s.set(t, l), l;
}
function er(e, t, n, r = !1) {
	const { mixins: i, extends: s } = t;
	s && er(e, s, n, !0), i && i.forEach((t) => er(e, t, n, !0));
	for (const o in t)
		if (r && "expose" === o);
		else {
			const r = tr[o] || (n && n[o]);
			e[o] = r ? r(e[o], t[o]) : t[o];
		}
	return e;
}
const tr = {
	data: nr,
	props: sr,
	emits: sr,
	methods: sr,
	computed: sr,
	beforeCreate: ir,
	created: ir,
	beforeMount: ir,
	mounted: ir,
	beforeUpdate: ir,
	updated: ir,
	beforeDestroy: ir,
	beforeUnmount: ir,
	destroyed: ir,
	unmounted: ir,
	activated: ir,
	deactivated: ir,
	errorCaptured: ir,
	serverPrefetch: ir,
	components: sr,
	directives: sr,
	watch: function (e, t) {
		if (!e) return t;
		if (!t) return e;
		const n = At(Object.create(null), e);
		for (const r in t) n[r] = ir(e[r], t[r]);
		return n;
	},
	provide: nr,
	inject: function (e, t) {
		return sr(rr(e), rr(t));
	}
};
function nr(e, t) {
	return t
		? e
			? function () {
					return At(Nt(e) ? e.call(this, this) : e, Nt(t) ? t.call(this, this) : t);
			  }
			: t
		: e;
}
function rr(e) {
	if (Lt(e)) {
		const t = {};
		for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
		return t;
	}
	return e;
}
function ir(e, t) {
	return e ? [...new Set([].concat(e, t))] : t;
}
function sr(e, t) {
	return e ? At(At(Object.create(null), e), t) : t;
}
function or(e, t, n, r) {
	const [i, s] = e.propsOptions;
	let o,
		a = !1;
	if (t)
		for (let l in t) {
			if (zt(l)) continue;
			const u = t[l];
			let c;
			i && Rt(i, (c = Wt(l))) ? (s && s.includes(c) ? ((o || (o = {}))[c] = u) : (n[c] = u)) : rn(e.emitsOptions, l) || (l in r && u === r[l]) || ((r[l] = u), (a = !0));
		}
	if (s) {
		const t = Ge(n),
			r = o || _t;
		for (let o = 0; o < s.length; o++) {
			const a = s[o];
			n[a] = ar(i, t, a, r[a], e, !Rt(r, a));
		}
	}
	return a;
}
function ar(e, t, n, r, i, s) {
	const o = e[n];
	if (null != o) {
		const e = Rt(o, "default");
		if (e && void 0 === r) {
			const e = o.default;
			if (o.type !== Function && Nt(e)) {
				const { propsDefaults: s } = i;
				n in s ? (r = s[n]) : (Ei(i), (r = s[n] = e.call(null, t)), Ti());
			} else r = e;
		}
		o[0] && (s && !e ? (r = !1) : !o[1] || ("" !== r && r !== Yt(n)) || (r = !0));
	}
	return r;
}
function lr(e, t, n = !1) {
	const r = t.propsCache,
		i = r.get(e);
	if (i) return i;
	const s = e.props,
		o = {},
		a = [];
	let l = !1;
	if (!Nt(e)) {
		const r = (e) => {
			l = !0;
			const [n, r] = lr(e, t, !0);
			At(o, n), r && a.push(...r);
		};
		!n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r);
	}
	if (!s && !l) return r.set(e, wt), wt;
	if (Lt(s))
		for (let c = 0; c < s.length; c++) {
			const e = Wt(s[c]);
			ur(e) && (o[e] = _t);
		}
	else if (s)
		for (const c in s) {
			const e = Wt(c);
			if (ur(e)) {
				const t = s[c],
					n = (o[e] = Lt(t) || Nt(t) ? { type: t } : t);
				if (n) {
					const t = dr(Boolean, n.type),
						r = dr(String, n.type);
					(n[0] = t > -1), (n[1] = r < 0 || t < r), (t > -1 || Rt(n, "default")) && a.push(e);
				}
			}
		}
	const u = [o, a];
	return r.set(e, u), u;
}
function ur(e) {
	return "$" !== e[0];
}
function cr(e) {
	const t = e && e.toString().match(/^\s*function (\w+)/);
	return t ? t[1] : null === e ? "null" : "";
}
function hr(e, t) {
	return cr(e) === cr(t);
}
function dr(e, t) {
	return Lt(t) ? t.findIndex((t) => hr(t, e)) : Nt(t) && hr(t, e) ? 0 : -1;
}
const pr = (e) => "_" === e[0] || "$stable" === e,
	fr = (e) => (Lt(e) ? e.map(li) : [li(e)]),
	mr = (e, t, n) => {
		const r = cn((...e) => fr(t(...e)), n);
		return (r._c = !1), r;
	},
	vr = (e, t, n) => {
		const r = e._ctx;
		for (const i in e) {
			if (pr(i)) continue;
			const n = e[i];
			if (Nt(n)) t[i] = mr(0, n, r);
			else if (null != n) {
				const e = fr(n);
				t[i] = () => e;
			}
		}
	},
	gr = (e, t) => {
		const n = fr(t);
		e.slots.default = () => n;
	};
function yr(e, t) {
	if (null === sn) return e;
	const n = sn.proxy,
		r = e.dirs || (e.dirs = []);
	for (let i = 0; i < t.length; i++) {
		let [e, s, o, a = _t] = t[i];
		Nt(e) && (e = { mounted: e, updated: e }), e.deep && vs(s), r.push({ dir: e, instance: n, value: s, oldValue: void 0, arg: o, modifiers: a });
	}
	return e;
}
function br(e, t, n, r) {
	const i = e.dirs,
		s = t && t.dirs;
	for (let o = 0; o < i.length; o++) {
		const a = i[o];
		s && (a.oldValue = s[o].value);
		let l = a.dir[r];
		l && (j(), Ui(l, n, 8, [e.el, a, e, t]), W());
	}
}
function xr() {
	return {
		app: null,
		config: { isNativeTag: St, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} },
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap(),
		propsCache: new WeakMap(),
		emitsCache: new WeakMap()
	};
}
let _r = 0;
function wr(e, t) {
	return function (n, r = null) {
		null == r || Bt(r) || (r = null);
		const i = xr(),
			s = new Set();
		let o = !1;
		const a = (i.app = {
			_uid: _r++,
			_component: n,
			_props: r,
			_container: null,
			_context: i,
			_instance: null,
			version: _s,
			get config() {
				return i.config;
			},
			set config(e) {},
			use: (e, ...t) => (s.has(e) || (e && Nt(e.install) ? (s.add(e), e.install(a, ...t)) : Nt(e) && (s.add(e), e(a, ...t))), a),
			mixin: (e) => (i.mixins.includes(e) || i.mixins.push(e), a),
			component: (e, t) => (t ? ((i.components[e] = t), a) : i.components[e]),
			directive: (e, t) => (t ? ((i.directives[e] = t), a) : i.directives[e]),
			mount(s, l, u) {
				if (!o) {
					const c = ri(n, r);
					return (c.appContext = i), l && t ? t(c, s) : e(c, s, u), (o = !0), (a._container = s), (s.__vue_app__ = a), Li(c.component) || c.component.proxy;
				}
			},
			unmount() {
				o && (e(null, a._container), delete a._container.__vue_app__);
			},
			provide: (e, t) => ((i.provides[e] = t), a)
		});
		return a;
	};
}
function Cr(e, t, n, r, i = !1) {
	if (Lt(e)) return void e.forEach((e, s) => Cr(e, t && (Lt(t) ? t[s] : t), n, r, i));
	if (kn(r) && !i) return;
	const s = 4 & r.shapeFlag ? Li(r.component) || r.component.proxy : r.el,
		o = i ? null : s,
		{ i: a, r: l } = e,
		u = t && t.r,
		c = a.refs === _t ? (a.refs = {}) : a.refs,
		h = a.setupState;
	if ((null != u && u !== l && (Dt(u) ? ((c[u] = null), Rt(h, u) && (h[u] = null)) : Je(u) && (u.value = null)), Nt(l))) Vi(l, a, 12, [o, c]);
	else {
		const t = Dt(l),
			r = Je(l);
		if (t || r) {
			const r = () => {
				if (e.f) {
					const n = t ? c[l] : l.value;
					i ? Lt(n) && Mt(n, s) : Lt(n) ? n.includes(s) || n.push(s) : t ? (c[l] = [s]) : ((l.value = [s]), e.k && (c[e.k] = l.value));
				} else t ? ((c[l] = o), Rt(h, l) && (h[l] = o)) : Je(l) && ((l.value = o), e.k && (c[e.k] = o));
			};
			o ? ((r.id = -1), Sr(r, n)) : r();
		}
	}
}
const Sr = function (e, t) {
	t && t.pendingBranch ? (Lt(e) ? t.effects.push(...e) : t.effects.push(e)) : ss(e, Zi, qi, Ji);
};
function Er(e) {
	return (function (e, t) {
		(en || (en = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {})).__VUE__ = !0;
		const { insert: n, remove: r, patchProp: i, createElement: s, createText: o, createComment: a, setText: l, setElementText: u, parentNode: c, nextSibling: h, setScopeId: d = Ct, cloneNode: p, insertStaticContent: f } = e,
			m = (e, t, n, r = null, i = null, s = null, o = !1, a = null, l = !!t.dynamicChildren) => {
				if (e === t) return;
				e && !Jr(e, t) && ((r = Y(e)), H(e, i, s, !0), (e = null)), -2 === t.patchFlag && ((l = !1), (t.dynamicChildren = null));
				const { type: u, ref: c, shapeFlag: h } = t;
				switch (u) {
					case Vr:
						v(e, t, n, r);
						break;
					case Ur:
						g(e, t, n, r);
						break;
					case zr:
						null == e && y(t, n, r, o);
						break;
					case Hr:
						M(e, t, n, r, i, s, o, a, l);
						break;
					default:
						1 & h ? _(e, t, n, r, i, s, o, a, l) : 6 & h ? I(e, t, n, r, i, s, o, a, l) : (64 & h || 128 & h) && u.process(e, t, n, r, i, s, o, a, l, q);
				}
				null != c && i && Cr(c, e && e.ref, s, t || e, !t);
			},
			v = (e, t, r, i) => {
				if (null == e) n((t.el = o(t.children)), r, i);
				else {
					const n = (t.el = e.el);
					t.children !== e.children && l(n, t.children);
				}
			},
			g = (e, t, r, i) => {
				null == e ? n((t.el = a(t.children || "")), r, i) : (t.el = e.el);
			},
			y = (e, t, n, r) => {
				[e.el, e.anchor] = f(e.children, t, n, r);
			},
			b = ({ el: e, anchor: t }, r, i) => {
				let s;
				for (; e && e !== t; ) (s = h(e)), n(e, r, i), (e = s);
				n(t, r, i);
			},
			x = ({ el: e, anchor: t }) => {
				let n;
				for (; e && e !== t; ) (n = h(e)), r(e), (e = n);
				r(t);
			},
			_ = (e, t, n, r, i, s, o, a, l) => {
				(o = o || "svg" === t.type), null == e ? w(t, n, r, i, s, o, a, l) : E(e, t, i, s, o, a, l);
			},
			w = (e, t, r, o, a, l, c, h) => {
				let d, f;
				const { type: m, props: v, shapeFlag: g, transition: y, patchFlag: b, dirs: x } = e;
				if (e.el && void 0 !== p && -1 === b) d = e.el = p(e.el);
				else {
					if (((d = e.el = s(e.type, l, v && v.is, v)), 8 & g ? u(d, e.children) : 16 & g && S(e.children, d, null, o, a, l && "foreignObject" !== m, c, h), x && br(e, null, o, "created"), v)) {
						for (const t in v) "value" === t || zt(t) || i(d, t, null, v[t], l, e.children, o, a, G);
						"value" in v && i(d, "value", null, v.value), (f = v.onVnodeBeforeMount) && di(f, o, e);
					}
					C(d, e, e.scopeId, c, o);
				}
				x && br(e, null, o, "beforeMount");
				const _ = (!a || (a && !a.pendingBranch)) && y && !y.persisted;
				_ && y.beforeEnter(d),
					n(d, t, r),
					((f = v && v.onVnodeMounted) || _ || x) &&
						Sr(() => {
							f && di(f, o, e), _ && y.enter(d), x && br(e, null, o, "mounted");
						}, a);
			},
			C = (e, t, n, r, i) => {
				if ((n && d(e, n), r)) for (let s = 0; s < r.length; s++) d(e, r[s]);
				if (i) {
					if (t === i.subTree) {
						const t = i.vnode;
						C(e, t, t.scopeId, t.slotScopeIds, i.parent);
					}
				}
			},
			S = (e, t, n, r, i, s, o, a, l = 0) => {
				for (let u = l; u < e.length; u++) {
					const l = (e[u] = a ? ui(e[u]) : li(e[u]));
					m(null, l, t, n, r, i, s, o, a);
				}
			},
			E = (e, t, n, r, s, o, a) => {
				const l = (t.el = e.el);
				let { patchFlag: c, dynamicChildren: h, dirs: d } = t;
				c |= 16 & e.patchFlag;
				const p = e.props || _t,
					f = t.props || _t;
				let m;
				n && Tr(n, !1), (m = f.onVnodeBeforeUpdate) && di(m, n, t, e), d && br(t, e, n, "beforeUpdate"), n && Tr(n, !0);
				const v = s && "foreignObject" !== t.type;
				if ((h ? T(e.dynamicChildren, h, l, n, r, v, o) : a || N(e, t, l, null, n, r, v, o, !1), c > 0)) {
					if (16 & c) A(l, t, p, f, n, r, s);
					else if ((2 & c && p.class !== f.class && i(l, "class", null, f.class, s), 4 & c && i(l, "style", p.style, f.style, s), 8 & c)) {
						const o = t.dynamicProps;
						for (let t = 0; t < o.length; t++) {
							const a = o[t],
								u = p[a],
								c = f[a];
							(c === u && "value" !== a) || i(l, a, u, c, s, e.children, n, r, G);
						}
					}
					1 & c && e.children !== t.children && u(l, t.children);
				} else a || null != h || A(l, t, p, f, n, r, s);
				((m = f.onVnodeUpdated) || d) &&
					Sr(() => {
						m && di(m, n, t, e), d && br(t, e, n, "updated");
					}, r);
			},
			T = (e, t, n, r, i, s, o) => {
				for (let a = 0; a < t.length; a++) {
					const l = e[a],
						u = t[a],
						h = l.el && (l.type === Hr || !Jr(l, u) || 70 & l.shapeFlag) ? c(l.el) : n;
					m(l, u, h, null, r, i, s, o, !0);
				}
			},
			A = (e, t, n, r, s, o, a) => {
				if (n !== r) {
					for (const l in r) {
						if (zt(l)) continue;
						const u = r[l],
							c = n[l];
						u !== c && "value" !== l && i(e, l, c, u, a, t.children, s, o, G);
					}
					if (n !== _t) for (const l in n) zt(l) || l in r || i(e, l, n[l], null, a, t.children, s, o, G);
					"value" in r && i(e, "value", n.value, r.value);
				}
			},
			M = (e, t, r, i, s, a, l, u, c) => {
				const h = (t.el = e ? e.el : o("")),
					d = (t.anchor = e ? e.anchor : o(""));
				let { patchFlag: p, dynamicChildren: f, slotScopeIds: m } = t;
				m && (u = u ? u.concat(m) : m), null == e ? (n(h, r, i), n(d, r, i), S(t.children, r, d, s, a, l, u, c)) : p > 0 && 64 & p && f && e.dynamicChildren ? (T(e.dynamicChildren, f, r, s, a, l, u), (null != t.key || (s && t === s.subTree)) && kr(e, t, !0)) : N(e, t, r, d, s, a, l, u, c);
			},
			I = (e, t, n, r, i, s, o, a, l) => {
				(t.slotScopeIds = a), null == e ? (512 & t.shapeFlag ? i.ctx.activate(t, n, r, o, l) : R(t, n, r, i, s, o, l)) : L(e, t, l);
			},
			R = (e, t, n, r, i, s, o) => {
				const a = (e.component = (function (e, t, n) {
					const r = e.type,
						i = (t ? t.appContext : e.appContext) || _i,
						s = {
							uid: wi++,
							vnode: e,
							type: r,
							parent: t,
							appContext: i,
							root: null,
							next: null,
							subTree: null,
							effect: null,
							update: null,
							scope: new k(!0),
							render: null,
							proxy: null,
							exposed: null,
							exposeProxy: null,
							withProxy: null,
							provides: t ? t.provides : Object.create(i.provides),
							accessCache: null,
							renderCache: [],
							components: null,
							directives: null,
							propsOptions: lr(r, i),
							emitsOptions: nn(r, i),
							emit: null,
							emitted: null,
							propsDefaults: _t,
							inheritAttrs: r.inheritAttrs,
							ctx: _t,
							data: _t,
							props: _t,
							attrs: _t,
							slots: _t,
							refs: _t,
							setupState: _t,
							setupContext: null,
							suspense: n,
							suspenseId: n ? n.pendingId : 0,
							asyncDep: null,
							asyncResolved: !1,
							isMounted: !1,
							isUnmounted: !1,
							isDeactivated: !1,
							bc: null,
							c: null,
							bm: null,
							m: null,
							bu: null,
							u: null,
							um: null,
							bum: null,
							da: null,
							a: null,
							rtg: null,
							rtc: null,
							ec: null,
							sp: null
						};
					(s.ctx = { _: s }), (s.root = t ? t.root : s), (s.emit = tn.bind(null, s)), e.ce && e.ce(s);
					return s;
				})(e, r, i));
				if (
					(An(e) && (a.ctx.renderer = q),
					(function (e, t = !1) {
						Ai = t;
						const { props: n, children: r } = e.vnode,
							i = ki(e);
						(function (e, t, n, r = !1) {
							const i = {},
								s = {};
							Jt(s, Qr, 1), (e.propsDefaults = Object.create(null)), or(e, t, i, s);
							for (const o in e.propsOptions[0]) o in i || (i[o] = void 0);
							n ? (e.props = r ? i : He(i)) : e.type.props ? (e.props = i) : (e.props = s), (e.attrs = s);
						})(e, n, i, t),
							((e, t) => {
								if (32 & e.vnode.shapeFlag) {
									const n = t._;
									n ? ((e.slots = Ge(t)), Jt(t, "_", n)) : vr(t, (e.slots = {}));
								} else (e.slots = {}), t && gr(e, t);
								Jt(e.slots, Qr, 1);
							})(e, r);
						const s = i
							? (function (e, t) {
									const n = e.type;
									(e.accessCache = Object.create(null)), (e.proxy = Ye(new Proxy(e.ctx, xi)));
									const { setup: r } = n;
									if (r) {
										const n = (e.setupContext = r.length > 1 ? Ri(e) : null);
										Ei(e), j();
										const i = Vi(r, e, 0, [e.props, n]);
										if ((W(), Ti(), Ft(i))) {
											if ((i.then(Ti, Ti), t))
												return i
													.then((n) => {
														Mi(e, n, t);
													})
													.catch((t) => {
														zi(t, e, 0);
													});
											e.asyncDep = i;
										} else Mi(e, i, t);
									} else Ii(e, t);
							  })(e, t)
							: void 0;
						Ai = !1;
					})(a),
					a.asyncDep)
				) {
					if ((i && i.registerDep(a, O), !e.el)) {
						const e = (a.subTree = ri(Ur));
						g(null, e, t, n);
					}
				} else O(a, e, t, n, i, s, o);
			},
			L = (e, t, n) => {
				const r = (t.component = e.component);
				if (
					(function (e, t, n) {
						const { props: r, children: i, component: s } = e,
							{ props: o, children: a, patchFlag: l } = t,
							u = s.emitsOptions;
						if (t.dirs || t.transition) return !0;
						if (!(n && l >= 0)) return !((!i && !a) || (a && a.$stable)) || (r !== o && (r ? !o || fn(r, o, u) : !!o));
						if (1024 & l) return !0;
						if (16 & l) return r ? fn(r, o, u) : !!o;
						if (8 & l) {
							const e = t.dynamicProps;
							for (let t = 0; t < e.length; t++) {
								const n = e[t];
								if (o[n] !== r[n] && !rn(u, n)) return !0;
							}
						}
						return !1;
					})(e, t, n)
				) {
					if (r.asyncDep && !r.asyncResolved) return void P(r, t, n);
					(r.next = t),
						(function (e) {
							const t = Wi.indexOf(e);
							t > Gi && Wi.splice(t, 1);
						})(r.update),
						r.update();
				} else (t.component = e.component), (t.el = e.el), (r.vnode = t);
			},
			O = (e, t, n, r, i, s, o) => {
				const a = () => {
						if (e.isMounted) {
							let t,
								{ next: n, bu: r, u: a, parent: l, vnode: u } = e,
								h = n;
							Tr(e, !1), n ? ((n.el = u.el), P(e, n, o)) : (n = u), r && Zt(r), (t = n.props && n.props.onVnodeBeforeUpdate) && di(t, l, n, u), Tr(e, !0);
							const d = hn(e),
								p = e.subTree;
							(e.subTree = d),
								m(p, d, c(p.el), Y(p), e, i, s),
								(n.el = d.el),
								null === h &&
									(function ({ vnode: e, parent: t }, n) {
										for (; t && t.subTree === e; ) ((e = t.vnode).el = n), (t = t.parent);
									})(e, d.el),
								a && Sr(a, i),
								(t = n.props && n.props.onVnodeUpdated) && Sr(() => di(t, l, n, u), i);
						} else {
							let o;
							const { el: a, props: l } = t,
								{ bm: u, m: c, parent: h } = e,
								d = kn(t);
							if ((Tr(e, !1), u && Zt(u), !d && (o = l && l.onVnodeBeforeMount) && di(o, h, t), Tr(e, !0), a && J)) {
								const n = () => {
									(e.subTree = hn(e)), J(a, e.subTree, e, i, null);
								};
								d ? t.type.__asyncLoader().then(() => !e.isUnmounted && n()) : n();
							} else {
								const o = (e.subTree = hn(e));
								m(null, o, n, r, e, i, s), (t.el = o.el);
							}
							if ((c && Sr(c, i), !d && (o = l && l.onVnodeMounted))) {
								const e = t;
								Sr(() => di(o, h, e), i);
							}
							256 & t.shapeFlag && e.a && Sr(e.a, i), (e.isMounted = !0), (t = n = r = null);
						}
					},
					l = (e.effect = new V(a, () => rs(e.update), e.scope)),
					u = (e.update = l.run.bind(l));
				(u.id = e.uid), Tr(e, !0), u();
			},
			P = (e, t, n) => {
				t.component = e;
				const r = e.vnode.props;
				(e.vnode = t),
					(e.next = null),
					(function (e, t, n, r) {
						const {
								props: i,
								attrs: s,
								vnode: { patchFlag: o }
							} = e,
							a = Ge(i),
							[l] = e.propsOptions;
						let u = !1;
						if (!(r || o > 0) || 16 & o) {
							let r;
							or(e, t, i, s) && (u = !0);
							for (const s in a) (t && (Rt(t, s) || ((r = Yt(s)) !== s && Rt(t, r)))) || (l ? !n || (void 0 === n[s] && void 0 === n[r]) || (i[s] = ar(l, a, s, void 0, e, !0)) : delete i[s]);
							if (s !== a) for (const e in s) (t && Rt(t, e)) || (delete s[e], (u = !0));
						} else if (8 & o) {
							const n = e.vnode.dynamicProps;
							for (let r = 0; r < n.length; r++) {
								let o = n[r];
								const c = t[o];
								if (l)
									if (Rt(s, o)) c !== s[o] && ((s[o] = c), (u = !0));
									else {
										const t = Wt(o);
										i[t] = ar(l, a, t, c, e, !1);
									}
								else c !== s[o] && ((s[o] = c), (u = !0));
							}
						}
						u && K(e, "set", "$attrs");
					})(e, t.props, r, n),
					((e, t, n) => {
						const { vnode: r, slots: i } = e;
						let s = !0,
							o = _t;
						if (32 & r.shapeFlag) {
							const e = t._;
							e ? (n && 1 === e ? (s = !1) : (At(i, t), n || 1 !== e || delete i._)) : ((s = !t.$stable), vr(t, i)), (o = t);
						} else t && (gr(e, t), (o = { default: 1 }));
						if (s) for (const a in i) pr(a) || a in o || delete i[a];
					})(e, t.children, n),
					j(),
					os(void 0, e.update),
					W();
			},
			N = (e, t, n, r, i, s, o, a, l = !1) => {
				const c = e && e.children,
					h = e ? e.shapeFlag : 0,
					d = t.children,
					{ patchFlag: p, shapeFlag: f } = t;
				if (p > 0) {
					if (128 & p) return void B(c, d, n, r, i, s, o, a, l);
					if (256 & p) return void D(c, d, n, r, i, s, o, a, l);
				}
				8 & f ? (16 & h && G(c, i, s), d !== c && u(n, d)) : 16 & h ? (16 & f ? B(c, d, n, r, i, s, o, a, l) : G(c, i, s, !0)) : (8 & h && u(n, ""), 16 & f && S(d, n, r, i, s, o, a, l));
			},
			D = (e, t, n, r, i, s, o, a, l) => {
				t = t || wt;
				const u = (e = e || wt).length,
					c = t.length,
					h = Math.min(u, c);
				let d;
				for (d = 0; d < h; d++) {
					const r = (t[d] = l ? ui(t[d]) : li(t[d]));
					m(e[d], r, n, null, i, s, o, a, l);
				}
				u > c ? G(e, i, s, !0, !1, h) : S(t, n, r, i, s, o, a, l, h);
			},
			B = (e, t, n, r, i, s, o, a, l) => {
				let u = 0;
				const c = t.length;
				let h = e.length - 1,
					d = c - 1;
				for (; u <= h && u <= d; ) {
					const r = e[u],
						c = (t[u] = l ? ui(t[u]) : li(t[u]));
					if (!Jr(r, c)) break;
					m(r, c, n, null, i, s, o, a, l), u++;
				}
				for (; u <= h && u <= d; ) {
					const r = e[h],
						u = (t[d] = l ? ui(t[d]) : li(t[d]));
					if (!Jr(r, u)) break;
					m(r, u, n, null, i, s, o, a, l), h--, d--;
				}
				if (u > h) {
					if (u <= d) {
						const e = d + 1,
							h = e < c ? t[e].el : r;
						for (; u <= d; ) m(null, (t[u] = l ? ui(t[u]) : li(t[u])), n, h, i, s, o, a, l), u++;
					}
				} else if (u > d) for (; u <= h; ) H(e[u], i, s, !0), u++;
				else {
					const p = u,
						f = u,
						v = new Map();
					for (u = f; u <= d; u++) {
						const e = (t[u] = l ? ui(t[u]) : li(t[u]));
						null != e.key && v.set(e.key, u);
					}
					let g,
						y = 0;
					const b = d - f + 1;
					let x = !1,
						_ = 0;
					const w = new Array(b);
					for (u = 0; u < b; u++) w[u] = 0;
					for (u = p; u <= h; u++) {
						const r = e[u];
						if (y >= b) {
							H(r, i, s, !0);
							continue;
						}
						let c;
						if (null != r.key) c = v.get(r.key);
						else
							for (g = f; g <= d; g++)
								if (0 === w[g - f] && Jr(r, t[g])) {
									c = g;
									break;
								}
						void 0 === c ? H(r, i, s, !0) : ((w[c - f] = u + 1), c >= _ ? (_ = c) : (x = !0), m(r, t[c], n, null, i, s, o, a, l), y++);
					}
					const C = x
						? (function (e) {
								const t = e.slice(),
									n = [0];
								let r, i, s, o, a;
								const l = e.length;
								for (r = 0; r < l; r++) {
									const l = e[r];
									if (0 !== l) {
										if (((i = n[n.length - 1]), e[i] < l)) {
											(t[r] = i), n.push(r);
											continue;
										}
										for (s = 0, o = n.length - 1; s < o; ) (a = (s + o) >> 1), e[n[a]] < l ? (s = a + 1) : (o = a);
										l < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), (n[s] = r));
									}
								}
								(s = n.length), (o = n[s - 1]);
								for (; s-- > 0; ) (n[s] = o), (o = t[o]);
								return n;
						  })(w)
						: wt;
					for (g = C.length - 1, u = b - 1; u >= 0; u--) {
						const e = f + u,
							h = t[e],
							d = e + 1 < c ? t[e + 1].el : r;
						0 === w[u] ? m(null, h, n, d, i, s, o, a, l) : x && (g < 0 || u !== C[g] ? F(h, n, d, 2) : g--);
					}
				}
			},
			F = (e, t, r, i, s = null) => {
				const { el: o, type: a, transition: l, children: u, shapeFlag: c } = e;
				if (6 & c) return void F(e.component.subTree, t, r, i);
				if (128 & c) return void e.suspense.move(t, r, i);
				if (64 & c) return void a.move(e, t, r, q);
				if (a === Hr) {
					n(o, t, r);
					for (let e = 0; e < u.length; e++) F(u[e], t, r, i);
					return void n(e.anchor, t, r);
				}
				if (a === zr) return void b(e, t, r);
				if (2 !== i && 1 & c && l)
					if (0 === i) l.beforeEnter(o), n(o, t, r), Sr(() => l.enter(o), s);
					else {
						const { leave: e, delayLeave: i, afterLeave: s } = l,
							a = () => n(o, t, r),
							u = () => {
								e(o, () => {
									a(), s && s();
								});
							};
						i ? i(o, a, u) : u();
					}
				else n(o, t, r);
			},
			H = (e, t, n, r = !1, i = !1) => {
				const { type: s, props: o, ref: a, children: l, dynamicChildren: u, shapeFlag: c, patchFlag: h, dirs: d } = e;
				if ((null != a && Cr(a, null, n, e, !0), 256 & c)) return void t.ctx.deactivate(e);
				const p = 1 & c && d,
					f = !kn(e);
				let m;
				if ((f && (m = o && o.onVnodeBeforeUnmount) && di(m, t, e), 6 & c)) $(e.component, n, r);
				else {
					if (128 & c) return void e.suspense.unmount(n, r);
					p && br(e, null, t, "beforeUnmount"), 64 & c ? e.type.remove(e, t, n, i, q, r) : u && (s !== Hr || (h > 0 && 64 & h)) ? G(u, t, n, !1, !0) : ((s === Hr && 384 & h) || (!i && 16 & c)) && G(l, t, n), r && U(e);
				}
				((f && (m = o && o.onVnodeUnmounted)) || p) &&
					Sr(() => {
						m && di(m, t, e), p && br(e, null, t, "unmounted");
					}, n);
			},
			U = (e) => {
				const { type: t, el: n, anchor: i, transition: s } = e;
				if (t === Hr) return void z(n, i);
				if (t === zr) return void x(e);
				const o = () => {
					r(n), s && !s.persisted && s.afterLeave && s.afterLeave();
				};
				if (1 & e.shapeFlag && s && !s.persisted) {
					const { leave: t, delayLeave: r } = s,
						i = () => t(n, o);
					r ? r(e.el, o, i) : i();
				} else o();
			},
			z = (e, t) => {
				let n;
				for (; e !== t; ) (n = h(e)), r(e), (e = n);
				r(t);
			},
			$ = (e, t, n) => {
				const { bum: r, scope: i, update: s, subTree: o, um: a } = e;
				r && Zt(r),
					i.stop(),
					s && ((s.active = !1), H(o, e, t, n)),
					a && Sr(a, t),
					Sr(() => {
						e.isUnmounted = !0;
					}, t),
					t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, 0 === t.deps && t.resolve());
			},
			G = (e, t, n, r = !1, i = !1, s = 0) => {
				for (let o = s; o < e.length; o++) H(e[o], t, n, r, i);
			},
			Y = (e) => (6 & e.shapeFlag ? Y(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : h(e.anchor || e.el)),
			X = (e, t, n) => {
				null == e ? t._vnode && H(t._vnode, null, null, !0) : m(t._vnode || null, e, t, null, null, null, n), as(), (t._vnode = e);
			},
			q = { p: m, um: H, m: F, r: U, mt: R, mc: S, pc: N, pbc: T, n: Y, o: e };
		let Z, J;
		t && ([Z, J] = t(q));
		return { render: X, hydrate: Z, createApp: wr(X, Z) };
	})(e);
}
function Tr({ effect: e, update: t }, n) {
	e.allowRecurse = t.allowRecurse = n;
}
function kr(e, t, n = !1) {
	const r = e.children,
		i = t.children;
	if (Lt(r) && Lt(i))
		for (let s = 0; s < r.length; s++) {
			const e = r[s];
			let t = i[s];
			1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && ((t = i[s] = ui(i[s])), (t.el = e.el)), n || kr(e, t));
		}
}
const Ar = (e) => e && (e.disabled || "" === e.disabled),
	Mr = (e) => "undefined" != typeof SVGElement && e instanceof SVGElement,
	Ir = (e, t) => {
		const n = e && e.to;
		if (Dt(n)) {
			if (t) {
				return t(n);
			}
			return null;
		}
		return n;
	};
function Rr(e, t, n, { o: { insert: r }, m: i }, s = 2) {
	0 === s && r(e.targetAnchor, t, n);
	const { el: o, anchor: a, shapeFlag: l, children: u, props: c } = e,
		h = 2 === s;
	if ((h && r(o, t, n), (!h || Ar(c)) && 16 & l)) for (let d = 0; d < u.length; d++) i(u[d], t, n, 2);
	h && r(a, t, n);
}
const Lr = {
	__isTeleport: !0,
	process(e, t, n, r, i, s, o, a, l, u) {
		const {
				mc: c,
				pc: h,
				pbc: d,
				o: { insert: p, querySelector: f, createText: m, createComment: v }
			} = u,
			g = Ar(t.props);
		let { shapeFlag: y, children: b, dynamicChildren: x } = t;
		if (null == e) {
			const e = (t.el = m("")),
				u = (t.anchor = m(""));
			p(e, n, r), p(u, n, r);
			const h = (t.target = Ir(t.props, f)),
				d = (t.targetAnchor = m(""));
			h && (p(d, h), (o = o || Mr(h)));
			const v = (e, t) => {
				16 & y && c(b, e, t, i, s, o, a, l);
			};
			g ? v(n, u) : h && v(h, d);
		} else {
			t.el = e.el;
			const r = (t.anchor = e.anchor),
				c = (t.target = e.target),
				p = (t.targetAnchor = e.targetAnchor),
				m = Ar(e.props),
				v = m ? n : c,
				y = m ? r : p;
			if (((o = o || Mr(c)), x ? (d(e.dynamicChildren, x, v, i, s, o, a), kr(e, t, !0)) : l || h(e, t, v, y, i, s, o, a, !1), g)) m || Rr(t, n, r, u, 1);
			else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
				const e = (t.target = Ir(t.props, f));
				e && Rr(t, e, null, u, 0);
			} else m && Rr(t, c, p, u, 1);
		}
	},
	remove(e, t, n, r, { um: i, o: { remove: s } }, o) {
		const { shapeFlag: a, children: l, anchor: u, targetAnchor: c, target: h, props: d } = e;
		if ((h && s(c), (o || !Ar(d)) && (s(u), 16 & a)))
			for (let p = 0; p < l.length; p++) {
				const e = l[p];
				i(e, t, n, !0, !!e.dynamicChildren);
			}
	},
	move: Rr,
	hydrate: function (e, t, n, r, i, s, { o: { nextSibling: o, parentNode: a, querySelector: l } }, u) {
		const c = (t.target = Ir(t.props, l));
		if (c) {
			const l = c._lpa || c.firstChild;
			16 & t.shapeFlag && (Ar(t.props) ? ((t.anchor = u(o(e), t, a(e), n, r, i, s)), (t.targetAnchor = l)) : ((t.anchor = o(e)), (t.targetAnchor = u(l, t, c, n, r, i, s))), (c._lpa = t.targetAnchor && o(t.targetAnchor)));
		}
		return t.anchor && o(t.anchor);
	}
};
function Or(e, t) {
	return Br("components", e, !0, t) || e;
}
const Pr = Symbol();
function Nr(e) {
	return Dt(e) ? Br("components", e, !1) || e : e || Pr;
}
function Dr(e) {
	return Br("directives", e);
}
function Br(e, t, n = !0, r = !1) {
	const i = sn || Ci;
	if (i) {
		const n = i.type;
		if ("components" === e) {
			const e = Pi(n);
			if (e && (e === t || e === Wt(t) || e === Xt(Wt(t)))) return n;
		}
		const s = Fr(i[e] || n[e], t) || Fr(i.appContext[e], t);
		return !s && r ? n : s;
	}
}
function Fr(e, t) {
	return e && (e[t] || e[Wt(t)] || e[Xt(Wt(t))]);
}
const Hr = Symbol(void 0),
	Vr = Symbol(void 0),
	Ur = Symbol(void 0),
	zr = Symbol(void 0),
	$r = [];
let jr = null;
function Wr(e = !1) {
	$r.push((jr = e ? null : []));
}
let Gr = 1;
function Yr(e) {
	Gr += e;
}
function Xr(e) {
	return (e.dynamicChildren = Gr > 0 ? jr || wt : null), $r.pop(), (jr = $r[$r.length - 1] || null), Gr > 0 && jr && jr.push(e), e;
}
function Kr(e, t, n, r, i, s) {
	return Xr(ni(e, t, n, r, i, s, !0));
}
function qr(e, t, n, r, i) {
	return Xr(ri(e, t, n, r, i, !0));
}
function Zr(e) {
	return !!e && !0 === e.__v_isVNode;
}
function Jr(e, t) {
	return e.type === t.type && e.key === t.key;
}
const Qr = "__vInternal",
	ei = ({ key: e }) => (null != e ? e : null),
	ti = ({ ref: e, ref_key: t, ref_for: n }) => (null != e ? (Dt(e) || Je(e) || Nt(e) ? { i: sn, r: e, k: t, f: !!n } : e) : null);
function ni(e, t = null, n = null, r = 0, i = null, s = e === Hr ? 0 : 1, o = !1, a = !1) {
	const l = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: e,
		props: t,
		key: t && ei(t),
		ref: t && ti(t),
		scopeId: on,
		slotScopeIds: null,
		children: n,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: s,
		patchFlag: r,
		dynamicProps: i,
		dynamicChildren: null,
		appContext: null
	};
	return a ? (ci(l, n), 128 & s && e.normalize(l)) : n && (l.shapeFlag |= Dt(n) ? 8 : 16), Gr > 0 && !o && jr && (l.patchFlag > 0 || 6 & s) && 32 !== l.patchFlag && jr.push(l), l;
}
const ri = function (e, t = null, n = null, r = 0, i = null, s = !1) {
	(e && e !== Pr) || (e = Ur);
	if (Zr(e)) {
		const r = si(e, t, !0);
		return n && ci(r, n), r;
	}
	(o = e), Nt(o) && "__vccOpts" in o && (e = e.__vccOpts);
	var o;
	if (t) {
		t = ii(t);
		let { class: e, style: n } = t;
		e && !Dt(e) && (t.class = gt(e)), Bt(n) && (We(n) && !Lt(n) && (n = At({}, n)), (t.style = pt(n)));
	}
	const a = Dt(e) ? 1 : ((e) => e.__isSuspense)(e) ? 128 : ((e) => e.__isTeleport)(e) ? 64 : Bt(e) ? 4 : Nt(e) ? 2 : 0;
	return ni(e, t, n, r, i, a, s, !0);
};
function ii(e) {
	return e ? (We(e) || Qr in e ? At({}, e) : e) : null;
}
function si(e, t, n = !1) {
	const { props: r, ref: i, patchFlag: s, children: o } = e,
		a = t ? hi(r || {}, t) : r;
	return {
		__v_isVNode: !0,
		__v_skip: !0,
		type: e.type,
		props: a,
		key: a && ei(a),
		ref: t && t.ref ? (n && i ? (Lt(i) ? i.concat(ti(t)) : [i, ti(t)]) : ti(t)) : i,
		scopeId: e.scopeId,
		slotScopeIds: e.slotScopeIds,
		children: o,
		target: e.target,
		targetAnchor: e.targetAnchor,
		staticCount: e.staticCount,
		shapeFlag: e.shapeFlag,
		patchFlag: t && e.type !== Hr ? (-1 === s ? 16 : 16 | s) : s,
		dynamicProps: e.dynamicProps,
		dynamicChildren: e.dynamicChildren,
		appContext: e.appContext,
		dirs: e.dirs,
		transition: e.transition,
		component: e.component,
		suspense: e.suspense,
		ssContent: e.ssContent && si(e.ssContent),
		ssFallback: e.ssFallback && si(e.ssFallback),
		el: e.el,
		anchor: e.anchor
	};
}
function oi(e = " ", t = 0) {
	return ri(Vr, null, e, t);
}
function ai(e = "", t = !1) {
	return t ? (Wr(), qr(Ur, null, e)) : ri(Ur, null, e);
}
function li(e) {
	return null == e || "boolean" == typeof e ? ri(Ur) : Lt(e) ? ri(Hr, null, e.slice()) : "object" == typeof e ? ui(e) : ri(Vr, null, String(e));
}
function ui(e) {
	return null === e.el || e.memo ? e : si(e);
}
function ci(e, t) {
	let n = 0;
	const { shapeFlag: r } = e;
	if (null == t) t = null;
	else if (Lt(t)) n = 16;
	else if ("object" == typeof t) {
		if (65 & r) {
			const n = t.default;
			return void (n && (n._c && (n._d = !1), ci(e, n()), n._c && (n._d = !0)));
		}
		{
			n = 32;
			const r = t._;
			r || Qr in t ? 3 === r && sn && (1 === sn.slots._ ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024))) : (t._ctx = sn);
		}
	} else Nt(t) ? ((t = { default: t, _ctx: sn }), (n = 32)) : ((t = String(t)), 64 & r ? ((n = 16), (t = [oi(t)])) : (n = 8));
	(e.children = t), (e.shapeFlag |= n);
}
function hi(...e) {
	const t = {};
	for (let n = 0; n < e.length; n++) {
		const r = e[n];
		for (const e in r)
			if ("class" === e) t.class !== r.class && (t.class = gt([t.class, r.class]));
			else if ("style" === e) t.style = pt([t.style, r.style]);
			else if (Tt(e)) {
				const n = t[e],
					i = r[e];
				n === i || (Lt(n) && n.includes(i)) || (t[e] = n ? [].concat(n, i) : i);
			} else "" !== e && (t[e] = r[e]);
	}
	return t;
}
function di(e, t, n, r = null) {
	Ui(e, t, 7, [n, r]);
}
function pi(e, t, n, r) {
	let i;
	const s = n && n[r];
	if (Lt(e) || Dt(e)) {
		i = new Array(e.length);
		for (let n = 0, r = e.length; n < r; n++) i[n] = t(e[n], n, void 0, s && s[n]);
	} else if ("number" == typeof e) {
		i = new Array(e);
		for (let n = 0; n < e; n++) i[n] = t(n + 1, n, void 0, s && s[n]);
	} else if (Bt(e))
		if (e[Symbol.iterator]) i = Array.from(e, (e, n) => t(e, n, void 0, s && s[n]));
		else {
			const n = Object.keys(e);
			i = new Array(n.length);
			for (let r = 0, o = n.length; r < o; r++) {
				const o = n[r];
				i[r] = t(e[o], o, r, s && s[r]);
			}
		}
	else i = [];
	return n && (n[r] = i), i;
}
function fi(e, t) {
	for (let n = 0; n < t.length; n++) {
		const r = t[n];
		if (Lt(r)) for (let t = 0; t < r.length; t++) e[r[t].name] = r[t].fn;
		else r && (e[r.name] = r.fn);
	}
	return e;
}
function mi(e, t, n = {}, r, i) {
	if (sn.isCE) return ri("slot", "default" === t ? null : { name: t }, r && r());
	let s = e[t];
	s && s._c && (s._d = !1), Wr();
	const o = s && vi(s(n)),
		a = qr(Hr, { key: n.key || `_${t}` }, o || (r ? r() : []), o && 1 === e._ ? 64 : -2);
	return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a;
}
function vi(e) {
	return e.some((e) => !Zr(e) || (e.type !== Ur && !(e.type === Hr && !vi(e.children)))) ? e : null;
}
function gi(e) {
	const t = {};
	for (const n in e) t[Kt(n)] = e[n];
	return t;
}
const yi = (e) => (e ? (ki(e) ? Li(e) || e.proxy : yi(e.parent)) : null),
	bi = At(Object.create(null), {
		$: (e) => e,
		$el: (e) => e.vnode.el,
		$data: (e) => e.data,
		$props: (e) => e.props,
		$attrs: (e) => e.attrs,
		$slots: (e) => e.slots,
		$refs: (e) => e.refs,
		$parent: (e) => yi(e.parent),
		$root: (e) => yi(e.root),
		$emit: (e) => e.emit,
		$options: (e) => Qn(e),
		$forceUpdate: (e) => () => rs(e.update),
		$nextTick: (e) => ns.bind(e.proxy),
		$watch: (e) => fs.bind(e)
	}),
	xi = {
		get({ _: e }, t) {
			const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l } = e;
			let u;
			if ("$" !== t[0]) {
				const a = o[t];
				if (void 0 !== a)
					switch (a) {
						case 1:
							return r[t];
						case 2:
							return i[t];
						case 4:
							return n[t];
						case 3:
							return s[t];
					}
				else {
					if (r !== _t && Rt(r, t)) return (o[t] = 1), r[t];
					if (i !== _t && Rt(i, t)) return (o[t] = 2), i[t];
					if ((u = e.propsOptions[0]) && Rt(u, t)) return (o[t] = 3), s[t];
					if (n !== _t && Rt(n, t)) return (o[t] = 4), n[t];
					Kn && (o[t] = 0);
				}
			}
			const c = bi[t];
			let h, d;
			return c ? ("$attrs" === t && G(e, 0, t), c(e)) : (h = a.__cssModules) && (h = h[t]) ? h : n !== _t && Rt(n, t) ? ((o[t] = 4), n[t]) : ((d = l.config.globalProperties), Rt(d, t) ? d[t] : void 0);
		},
		set({ _: e }, t, n) {
			const { data: r, setupState: i, ctx: s } = e;
			if (i !== _t && Rt(i, t)) i[t] = n;
			else if (r !== _t && Rt(r, t)) r[t] = n;
			else if (Rt(e.props, t)) return !1;
			return ("$" !== t[0] || !(t.slice(1) in e)) && ((s[t] = n), !0);
		},
		has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: i, propsOptions: s } }, o) {
			let a;
			return !!n[o] || (e !== _t && Rt(e, o)) || (t !== _t && Rt(t, o)) || ((a = s[0]) && Rt(a, o)) || Rt(r, o) || Rt(bi, o) || Rt(i.config.globalProperties, o);
		}
	},
	_i = xr();
let wi = 0;
let Ci = null;
const Si = () => Ci || sn,
	Ei = (e) => {
		(Ci = e), e.scope.on();
	},
	Ti = () => {
		Ci && Ci.scope.off(), (Ci = null);
	};
function ki(e) {
	return 4 & e.vnode.shapeFlag;
}
let Ai = !1;
function Mi(e, t, n) {
	Nt(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : Bt(t) && (e.setupState = ot(t)), Ii(e, n);
}
function Ii(e, t, n) {
	const r = e.type;
	e.render || (e.render = r.render || Ct), Ei(e), j(), qn(e), W(), Ti();
}
function Ri(e) {
	const t = (t) => {
		e.exposed = t || {};
	};
	let n;
	return {
		get attrs() {
			return (
				n ||
				(n = (function (e) {
					return new Proxy(e.attrs, { get: (t, n) => (G(e, 0, "$attrs"), t[n]) });
				})(e))
			);
		},
		slots: e.slots,
		emit: e.emit,
		expose: t
	};
}
function Li(e) {
	if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(ot(Ye(e.exposed)), { get: (t, n) => (n in t ? t[n] : n in bi ? bi[n](e) : void 0) }));
}
const Oi = /(?:^|[-_])(\w)/g;
function Pi(e) {
	return (Nt(e) && e.displayName) || e.name;
}
function Ni(e, t, n = !1) {
	let r = Pi(t);
	if (!r && t.__file) {
		const e = t.__file.match(/([^/\\]+)\.\w+$/);
		e && (r = e[1]);
	}
	if (!r && e && e.parent) {
		const n = (e) => {
			for (const n in e) if (e[n] === t) return n;
		};
		r = n(e.components || e.parent.type.components) || n(e.appContext.components);
	}
	return r ? r.replace(Oi, (e) => e.toUpperCase()).replace(/[-_]/g, "") : n ? "App" : "Anonymous";
}
const Di = [];
function Bi(e, ...t) {
	j();
	const n = Di.length ? Di[Di.length - 1].component : null,
		r = n && n.appContext.config.warnHandler,
		i = (function () {
			let e = Di[Di.length - 1];
			if (!e) return [];
			const t = [];
			for (; e; ) {
				const n = t[0];
				n && n.vnode === e ? n.recurseCount++ : t.push({ vnode: e, recurseCount: 0 });
				const r = e.component && e.component.parent;
				e = r && r.vnode;
			}
			return t;
		})();
	if (r) Vi(r, n, 11, [e + t.join(""), n && n.proxy, i.map(({ vnode: e }) => `at <${Ni(n, e.type)}>`).join("\n"), i]);
	else {
		const n = [`[Vue warn]: ${e}`, ...t];
		i.length &&
			n.push(
				"\n",
				...(function (e) {
					const t = [];
					return (
						e.forEach((e, n) => {
							t.push(
								...(0 === n ? [] : ["\n"]),
								...(function ({ vnode: e, recurseCount: t }) {
									const n = t > 0 ? `... (${t} recursive calls)` : "",
										r = !!e.component && null == e.component.parent,
										i = ` at <${Ni(e.component, e.type, r)}`,
										s = ">" + n;
									return e.props ? [i, ...Fi(e.props), s] : [i + s];
								})(e)
							);
						}),
						t
					);
				})(i)
			),
			console.warn(...n);
	}
	W();
}
function Fi(e) {
	const t = [],
		n = Object.keys(e);
	return (
		n.slice(0, 3).forEach((n) => {
			t.push(...Hi(n, e[n]));
		}),
		n.length > 3 && t.push(" ..."),
		t
	);
}
function Hi(e, t, n) {
	return Dt(t)
		? ((t = JSON.stringify(t)), n ? t : [`${e}=${t}`])
		: "number" == typeof t || "boolean" == typeof t || null == t
		? n
			? t
			: [`${e}=${t}`]
		: Je(t)
		? ((t = Hi(e, Ge(t.value), !0)), n ? t : [`${e}=Ref<`, t, ">"])
		: Nt(t)
		? [`${e}=fn${t.name ? `<${t.name}>` : ""}`]
		: ((t = Ge(t)), n ? t : [`${e}=`, t]);
}
function Vi(e, t, n, r) {
	let i;
	try {
		i = r ? e(...r) : e();
	} catch (s) {
		zi(s, t, n);
	}
	return i;
}
function Ui(e, t, n, r) {
	if (Nt(e)) {
		const i = Vi(e, t, n, r);
		return (
			i &&
				Ft(i) &&
				i.catch((e) => {
					zi(e, t, n);
				}),
			i
		);
	}
	const i = [];
	for (let s = 0; s < e.length; s++) i.push(Ui(e[s], t, n, r));
	return i;
}
function zi(e, t, n, r = !0) {
	t && t.vnode;
	if (t) {
		let r = t.parent;
		const i = t.proxy,
			s = n;
		for (; r; ) {
			const t = r.ec;
			if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, i, s)) return;
			r = r.parent;
		}
		const o = t.appContext.config.errorHandler;
		if (o) return void Vi(o, null, 10, [e, i, s]);
	}
	!(function (e, t, n, r = !0) {
		console.error(e);
	})(e, 0, 0, r);
}
let $i = !1,
	ji = !1;
const Wi = [];
let Gi = 0;
const Yi = [];
let Xi = null,
	Ki = 0;
const qi = [];
let Zi = null,
	Ji = 0;
const Qi = Promise.resolve();
let es = null,
	ts = null;
function ns(e) {
	const t = es || Qi;
	return e ? t.then(this ? e.bind(this) : e) : t;
}
function rs(e) {
	(Wi.length && Wi.includes(e, $i && e.allowRecurse ? Gi + 1 : Gi)) ||
		e === ts ||
		(null == e.id
			? Wi.push(e)
			: Wi.splice(
					(function (e) {
						let t = Gi + 1,
							n = Wi.length;
						for (; t < n; ) {
							const r = (t + n) >>> 1;
							ls(Wi[r]) < e ? (t = r + 1) : (n = r);
						}
						return t;
					})(e.id),
					0,
					e
			  ),
		is());
}
function is() {
	$i || ji || ((ji = !0), (es = Qi.then(us)));
}
function ss(e, t, n, r) {
	Lt(e) ? n.push(...e) : (t && t.includes(e, e.allowRecurse ? r + 1 : r)) || n.push(e), is();
}
function os(e, t = null) {
	if (Yi.length) {
		for (ts = t, Xi = [...new Set(Yi)], Yi.length = 0, Ki = 0; Ki < Xi.length; Ki++) Xi[Ki]();
		(Xi = null), (Ki = 0), (ts = null), os(e, t);
	}
}
function as(e) {
	if (qi.length) {
		const e = [...new Set(qi)];
		if (((qi.length = 0), Zi)) return void Zi.push(...e);
		for (Zi = e, Zi.sort((e, t) => ls(e) - ls(t)), Ji = 0; Ji < Zi.length; Ji++) Zi[Ji]();
		(Zi = null), (Ji = 0);
	}
}
const ls = (e) => (null == e.id ? 1 / 0 : e.id);
function us(e) {
	(ji = !1), ($i = !0), os(e), Wi.sort((e, t) => ls(e) - ls(t));
	try {
		for (Gi = 0; Gi < Wi.length; Gi++) {
			const e = Wi[Gi];
			e && !1 !== e.active && Vi(e, null, 14);
		}
	} finally {
		(Gi = 0), (Wi.length = 0), as(), ($i = !1), (es = null), (Wi.length || Yi.length || qi.length) && us(e);
	}
}
function cs(e, t) {
	return ps(e, null, t);
}
const hs = {};
function ds(e, t, n) {
	return ps(e, t, n);
}
function ps(e, t, { immediate: n, deep: r, flush: i, onTrack: s, onTrigger: o } = _t) {
	const a = Ci;
	let l,
		u,
		c = !1,
		h = !1;
	if (
		(Je(e)
			? ((l = () => e.value), (c = !!e._shallow))
			: $e(e)
			? ((l = () => e), (r = !0))
			: Lt(e)
			? ((h = !0), (c = e.some($e)), (l = () => e.map((e) => (Je(e) ? e.value : $e(e) ? vs(e) : Nt(e) ? Vi(e, a, 2) : void 0))))
			: (l = Nt(e)
					? t
						? () => Vi(e, a, 2)
						: () => {
								if (!a || !a.isUnmounted) return u && u(), Ui(e, a, 3, [d]);
						  }
					: Ct),
		t && r)
	) {
		const e = l;
		l = () => vs(e());
	}
	let d = (e) => {
		u = v.onStop = () => {
			Vi(e, a, 4);
		};
	};
	if (Ai) return (d = Ct), t ? n && Ui(t, a, 3, [l(), h ? [] : void 0, d]) : l(), Ct;
	let p = h ? [] : hs;
	const f = () => {
		if (v.active)
			if (t) {
				const e = v.run();
				(r || c || (h ? e.some((e, t) => qt(e, p[t])) : qt(e, p))) && (u && u(), Ui(t, a, 3, [e, p === hs ? void 0 : p, d]), (p = e));
			} else v.run();
	};
	let m;
	(f.allowRecurse = !!t),
		(m =
			"sync" === i
				? f
				: "post" === i
				? () => Sr(f, a && a.suspense)
				: () => {
						!a || a.isMounted
							? (function (e) {
									ss(e, Xi, Yi, Ki);
							  })(f)
							: f();
				  });
	const v = new V(l, m);
	return (
		t ? (n ? f() : (p = v.run())) : "post" === i ? Sr(v.run.bind(v), a && a.suspense) : v.run(),
		() => {
			v.stop(), a && a.scope && Mt(a.scope.effects, v);
		}
	);
}
function fs(e, t, n) {
	const r = this.proxy,
		i = Dt(e) ? (e.includes(".") ? ms(r, e) : () => r[e]) : e.bind(r, r);
	let s;
	Nt(t) ? (s = t) : ((s = t.handler), (n = t));
	const o = Ci;
	Ei(this);
	const a = ps(i, s.bind(r), n);
	return o ? Ei(o) : Ti(), a;
}
function ms(e, t) {
	const n = t.split(".");
	return () => {
		let t = e;
		for (let e = 0; e < n.length && t; e++) t = t[n[e]];
		return t;
	};
}
function vs(e, t) {
	if (!Bt(e) || e.__v_skip) return e;
	if ((t = t || new Set()).has(e)) return e;
	if ((t.add(e), Je(e))) vs(e.value, t);
	else if (Lt(e)) for (let n = 0; n < e.length; n++) vs(e[n], t);
	else if (Pt(e) || Ot(e))
		e.forEach((e) => {
			vs(e, t);
		});
	else if (Ut(e)) for (const n in e) vs(e[n], t);
	return e;
}
function gs() {
	return bs().slots;
}
function ys() {
	return bs().attrs;
}
function bs() {
	const e = Si();
	return e.setupContext || (e.setupContext = Ri(e));
}
function xs(e, t, n) {
	const r = arguments.length;
	return 2 === r ? (Bt(t) && !Lt(t) ? (Zr(t) ? ri(e, null, [t]) : ri(e, t)) : ri(e, null, t)) : (r > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : 3 === r && Zr(n) && (n = [n]), ri(e, t, n));
}
const _s = "3.2.26";
function ws(e, t) {
	const n = Object.create(null),
		r = e.split(",");
	for (let i = 0; i < r.length; i++) n[r[i]] = !0;
	return t ? (e) => !!n[e.toLowerCase()] : (e) => !!n[e];
}
const Cs = ws("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
function Ss(e) {
	return !!e || "" === e;
}
function Es(e, t) {
	if (e === t) return !0;
	let n = Rs(e),
		r = Rs(t);
	if (n || r) return !(!n || !r) && e.getTime() === t.getTime();
	if (((n = Ms(e)), (r = Ms(t)), n || r))
		return (
			!(!n || !r) &&
			(function (e, t) {
				if (e.length !== t.length) return !1;
				let n = !0;
				for (let r = 0; n && r < e.length; r++) n = Es(e[r], t[r]);
				return n;
			})(e, t)
		);
	if (((n = Ps(e)), (r = Ps(t)), n || r)) {
		if (!n || !r) return !1;
		if (Object.keys(e).length !== Object.keys(t).length) return !1;
		for (const n in e) {
			const r = e.hasOwnProperty(n),
				i = t.hasOwnProperty(n);
			if ((r && !i) || (!r && i) || !Es(e[n], t[n])) return !1;
		}
	}
	return String(e) === String(t);
}
function Ts(e, t) {
	return e.findIndex((e) => Es(e, t));
}
const ks = /^on[^a-z]/,
	As = Object.assign,
	Ms = Array.isArray,
	Is = (e) => "[object Set]" === Ds(e),
	Rs = (e) => e instanceof Date,
	Ls = (e) => "function" == typeof e,
	Os = (e) => "string" == typeof e,
	Ps = (e) => null !== e && "object" == typeof e,
	Ns = Object.prototype.toString,
	Ds = (e) => Ns.call(e),
	Bs = (e) => {
		const t = Object.create(null);
		return (n) => t[n] || (t[n] = e(n));
	},
	Fs = /\B([A-Z])/g,
	Hs = Bs((e) => e.replace(Fs, "-$1").toLowerCase()),
	Vs = Bs((e) => e.charAt(0).toUpperCase() + e.slice(1)),
	Us = (e) => {
		const t = parseFloat(e);
		return isNaN(t) ? e : t;
	},
	zs = "undefined" != typeof document ? document : null,
	$s = new Map(),
	js = {
		insert: (e, t, n) => {
			t.insertBefore(e, n || null);
		},
		remove: (e) => {
			const t = e.parentNode;
			t && t.removeChild(e);
		},
		createElement: (e, t, n, r) => {
			const i = t ? zs.createElementNS("http://www.w3.org/2000/svg", e) : zs.createElement(e, n ? { is: n } : void 0);
			return "select" === e && r && null != r.multiple && i.setAttribute("multiple", r.multiple), i;
		},
		createText: (e) => zs.createTextNode(e),
		createComment: (e) => zs.createComment(e),
		setText: (e, t) => {
			e.nodeValue = t;
		},
		setElementText: (e, t) => {
			e.textContent = t;
		},
		parentNode: (e) => e.parentNode,
		nextSibling: (e) => e.nextSibling,
		querySelector: (e) => zs.querySelector(e),
		setScopeId(e, t) {
			e.setAttribute(t, "");
		},
		cloneNode(e) {
			const t = e.cloneNode(!0);
			return "_value" in e && (t._value = e._value), t;
		},
		insertStaticContent(e, t, n, r) {
			const i = n ? n.previousSibling : t.lastChild;
			let s = $s.get(e);
			if (!s) {
				const t = zs.createElement("template");
				if (((t.innerHTML = r ? `<svg>${e}</svg>` : e), (s = t.content), r)) {
					const e = s.firstChild;
					for (; e.firstChild; ) s.appendChild(e.firstChild);
					s.removeChild(e);
				}
				$s.set(e, s);
			}
			return t.insertBefore(s.cloneNode(!0), n), [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild];
		}
	};
const Ws = /\s*!important$/;
function Gs(e, t, n) {
	if (Ms(n)) n.forEach((n) => Gs(e, t, n));
	else if (t.startsWith("--")) e.setProperty(t, n);
	else {
		const r = (function (e, t) {
			const n = Xs[t];
			if (n) return n;
			let r = Wt(t);
			if ("filter" !== r && r in e) return (Xs[t] = r);
			r = Vs(r);
			for (let i = 0; i < Ys.length; i++) {
				const n = Ys[i] + r;
				if (n in e) return (Xs[t] = n);
			}
			return t;
		})(e, t);
		Ws.test(n) ? e.setProperty(Hs(r), n.replace(Ws, ""), "important") : (e[r] = n);
	}
}
const Ys = ["Webkit", "Moz", "ms"],
	Xs = {};
const Ks = "http://www.w3.org/1999/xlink";
let qs = Date.now,
	Zs = !1;
if ("undefined" != typeof window) {
	qs() > document.createEvent("Event").timeStamp && (qs = () => performance.now());
	const e = navigator.userAgent.match(/firefox\/(\d+)/i);
	Zs = !!(e && Number(e[1]) <= 53);
}
let Js = 0;
const Qs = Promise.resolve(),
	eo = () => {
		Js = 0;
	};
function to(e, t, n, r) {
	e.addEventListener(t, n, r);
}
function no(e, t, n, r, i = null) {
	const s = e._vei || (e._vei = {}),
		o = s[t];
	if (r && o) o.value = r;
	else {
		const [n, a] = (function (e) {
			let t;
			if (ro.test(e)) {
				let n;
				for (t = {}; (n = e.match(ro)); ) (e = e.slice(0, e.length - n[0].length)), (t[n[0].toLowerCase()] = !0);
			}
			return [Hs(e.slice(2)), t];
		})(t);
		if (r) {
			to(
				e,
				n,
				(s[t] = (function (e, t) {
					const n = (e) => {
						const r = e.timeStamp || qs();
						(Zs || r >= n.attached - 1) &&
							Ui(
								(function (e, t) {
									if (Ms(t)) {
										const n = e.stopImmediatePropagation;
										return (
											(e.stopImmediatePropagation = () => {
												n.call(e), (e._stopped = !0);
											}),
											t.map((e) => (t) => !t._stopped && e(t))
										);
									}
									return t;
								})(e, n.value),
								t,
								5,
								[e]
							);
					};
					return (n.value = e), (n.attached = (() => Js || (Qs.then(eo), (Js = qs())))()), n;
				})(r, i)),
				a
			);
		} else
			o &&
				(!(function (e, t, n, r) {
					e.removeEventListener(t, n, r);
				})(e, n, o, a),
				(s[t] = void 0));
	}
}
const ro = /(?:Once|Passive|Capture)$/;
const io = /^on[a-z]/;
function so(e) {
	const t = Si();
	if (!t) return;
	const n = () => oo(t.subTree, e(t.proxy));
	ps(n, null, { flush: "post" }),
		Vn(() => {
			const e = new MutationObserver(n);
			e.observe(t.subTree.el.parentNode, { childList: !0 }), jn(() => e.disconnect());
		});
}
function oo(e, t) {
	if (128 & e.shapeFlag) {
		const n = e.suspense;
		(e = n.activeBranch),
			n.pendingBranch &&
				!n.isHydrating &&
				n.effects.push(() => {
					oo(n.activeBranch, t);
				});
	}
	for (; e.component; ) e = e.component.subTree;
	if (1 & e.shapeFlag && e.el) ao(e.el, t);
	else if (e.type === Hr) e.children.forEach((e) => oo(e, t));
	else if (e.type === zr) {
		let { el: n, anchor: r } = e;
		for (; n && (ao(n, t), n !== r); ) n = n.nextSibling;
	}
}
function ao(e, t) {
	if (1 === e.nodeType) {
		const n = e.style;
		for (const e in t) n.setProperty(`--${e}`, t[e]);
	}
}
const lo = (e, { slots: t }) => xs(bn, fo(e), t);
lo.displayName = "Transition";
const uo = {
		name: String,
		type: String,
		css: { type: Boolean, default: !0 },
		duration: [String, Number, Object],
		enterFromClass: String,
		enterActiveClass: String,
		enterToClass: String,
		appearFromClass: String,
		appearActiveClass: String,
		appearToClass: String,
		leaveFromClass: String,
		leaveActiveClass: String,
		leaveToClass: String
	},
	co = (lo.props = As({}, bn.props, uo)),
	ho = (e, t = []) => {
		Ms(e) ? e.forEach((e) => e(...t)) : e && e(...t);
	},
	po = (e) => !!e && (Ms(e) ? e.some((e) => e.length > 1) : e.length > 1);
function fo(e) {
	const t = {};
	for (const A in e) A in uo || (t[A] = e[A]);
	if (!1 === e.css) return t;
	const {
			name: n = "v",
			type: r,
			duration: i,
			enterFromClass: s = `${n}-enter-from`,
			enterActiveClass: o = `${n}-enter-active`,
			enterToClass: a = `${n}-enter-to`,
			appearFromClass: l = s,
			appearActiveClass: u = o,
			appearToClass: c = a,
			leaveFromClass: h = `${n}-leave-from`,
			leaveActiveClass: d = `${n}-leave-active`,
			leaveToClass: p = `${n}-leave-to`
		} = e,
		f = (function (e) {
			if (null == e) return null;
			if (Ps(e)) return [mo(e.enter), mo(e.leave)];
			{
				const t = mo(e);
				return [t, t];
			}
		})(i),
		m = f && f[0],
		v = f && f[1],
		{ onBeforeEnter: g, onEnter: y, onEnterCancelled: b, onLeave: x, onLeaveCancelled: _, onBeforeAppear: w = g, onAppear: C = y, onAppearCancelled: S = b } = t,
		E = (e, t, n) => {
			go(e, t ? c : a), go(e, t ? u : o), n && n();
		},
		T = (e, t) => {
			go(e, p), go(e, d), t && t();
		},
		k = (e) => (t, n) => {
			const i = e ? C : y,
				o = () => E(t, e, n);
			ho(i, [t, o]),
				yo(() => {
					go(t, e ? l : s), vo(t, e ? c : a), po(i) || xo(t, r, m, o);
				});
		};
	return As(t, {
		onBeforeEnter(e) {
			ho(g, [e]), vo(e, s), vo(e, o);
		},
		onBeforeAppear(e) {
			ho(w, [e]), vo(e, l), vo(e, u);
		},
		onEnter: k(!1),
		onAppear: k(!0),
		onLeave(e, t) {
			const n = () => T(e, t);
			vo(e, h),
				So(),
				vo(e, d),
				yo(() => {
					go(e, h), vo(e, p), po(x) || xo(e, r, v, n);
				}),
				ho(x, [e, n]);
		},
		onEnterCancelled(e) {
			E(e, !1), ho(b, [e]);
		},
		onAppearCancelled(e) {
			E(e, !0), ho(S, [e]);
		},
		onLeaveCancelled(e) {
			T(e), ho(_, [e]);
		}
	});
}
function mo(e) {
	return Us(e);
}
function vo(e, t) {
	t.split(/\s+/).forEach((t) => t && e.classList.add(t)), (e._vtc || (e._vtc = new Set())).add(t);
}
function go(e, t) {
	t.split(/\s+/).forEach((t) => t && e.classList.remove(t));
	const { _vtc: n } = e;
	n && (n.delete(t), n.size || (e._vtc = void 0));
}
function yo(e) {
	requestAnimationFrame(() => {
		requestAnimationFrame(e);
	});
}
let bo = 0;
function xo(e, t, n, r) {
	const i = (e._endId = ++bo),
		s = () => {
			i === e._endId && r();
		};
	if (n) return setTimeout(s, n);
	const { type: o, timeout: a, propCount: l } = _o(e, t);
	if (!o) return r();
	const u = o + "end";
	let c = 0;
	const h = () => {
			e.removeEventListener(u, d), s();
		},
		d = (t) => {
			t.target === e && ++c >= l && h();
		};
	setTimeout(() => {
		c < l && h();
	}, a + 1),
		e.addEventListener(u, d);
}
function _o(e, t) {
	const n = window.getComputedStyle(e),
		r = (e) => (n[e] || "").split(", "),
		i = r("transitionDelay"),
		s = r("transitionDuration"),
		o = wo(i, s),
		a = r("animationDelay"),
		l = r("animationDuration"),
		u = wo(a, l);
	let c = null,
		h = 0,
		d = 0;
	"transition" === t ? o > 0 && ((c = "transition"), (h = o), (d = s.length)) : "animation" === t ? u > 0 && ((c = "animation"), (h = u), (d = l.length)) : ((h = Math.max(o, u)), (c = h > 0 ? (o > u ? "transition" : "animation") : null), (d = c ? ("transition" === c ? s.length : l.length) : 0));
	return { type: c, timeout: h, propCount: d, hasTransform: "transition" === c && /\b(transform|all)(,|$)/.test(n.transitionProperty) };
}
function wo(e, t) {
	for (; e.length < t.length; ) e = e.concat(e);
	return Math.max(...t.map((t, n) => Co(t) + Co(e[n])));
}
function Co(e) {
	return 1e3 * Number(e.slice(0, -1).replace(",", "."));
}
function So() {
	return document.body.offsetHeight;
}
const Eo = new WeakMap(),
	To = new WeakMap(),
	ko = {
		name: "TransitionGroup",
		props: As({}, co, { tag: String, moveClass: String }),
		setup(e, { slots: t }) {
			const n = Si(),
				r = gn();
			let i, s;
			return (
				zn(() => {
					if (!i.length) return;
					const t = e.moveClass || `${e.name || "v"}-move`;
					if (
						!(function (e, t, n) {
							const r = e.cloneNode();
							e._vtc &&
								e._vtc.forEach((e) => {
									e.split(/\s+/).forEach((e) => e && r.classList.remove(e));
								});
							n.split(/\s+/).forEach((e) => e && r.classList.add(e)), (r.style.display = "none");
							const i = 1 === t.nodeType ? t : t.parentNode;
							i.appendChild(r);
							const { hasTransform: s } = _o(r);
							return i.removeChild(r), s;
						})(i[0].el, n.vnode.el, t)
					)
						return;
					i.forEach(Ao), i.forEach(Mo);
					const r = i.filter(Io);
					So(),
						r.forEach((e) => {
							const n = e.el,
								r = n.style;
							vo(n, t), (r.transform = r.webkitTransform = r.transitionDuration = "");
							const i = (n._moveCb = (e) => {
								(e && e.target !== n) || (e && !/transform$/.test(e.propertyName)) || (n.removeEventListener("transitionend", i), (n._moveCb = null), go(n, t));
							});
							n.addEventListener("transitionend", i);
						});
				}),
				() => {
					const o = Ge(e),
						a = fo(o);
					let l = o.tag || Hr;
					(i = s), (s = t.default ? En(t.default()) : []);
					for (let e = 0; e < s.length; e++) {
						const t = s[e];
						null != t.key && Sn(t, _n(t, a, r, n));
					}
					if (i)
						for (let e = 0; e < i.length; e++) {
							const t = i[e];
							Sn(t, _n(t, a, r, n)), Eo.set(t, t.el.getBoundingClientRect());
						}
					return ri(l, null, s);
				}
			);
		}
	};
function Ao(e) {
	const t = e.el;
	t._moveCb && t._moveCb(), t._enterCb && t._enterCb();
}
function Mo(e) {
	To.set(e, e.el.getBoundingClientRect());
}
function Io(e) {
	const t = Eo.get(e),
		n = To.get(e),
		r = t.left - n.left,
		i = t.top - n.top;
	if (r || i) {
		const t = e.el.style;
		return (t.transform = t.webkitTransform = `translate(${r}px,${i}px)`), (t.transitionDuration = "0s"), e;
	}
}
const Ro = (e) => {
	const t = e.props["onUpdate:modelValue"];
	return Ms(t)
		? (e) =>
				((e, t) => {
					for (let n = 0; n < e.length; n++) e[n](t);
				})(t, e)
		: t;
};
function Lo(e) {
	e.target.composing = !0;
}
function Oo(e) {
	const t = e.target;
	t.composing &&
		((t.composing = !1),
		(function (e, t) {
			const n = document.createEvent("HTMLEvents");
			n.initEvent(t, !0, !0), e.dispatchEvent(n);
		})(t, "input"));
}
const Po = {
		created(e, { modifiers: { lazy: t, trim: n, number: r } }, i) {
			e._assign = Ro(i);
			const s = r || (i.props && "number" === i.props.type);
			to(e, t ? "change" : "input", (t) => {
				if (t.target.composing) return;
				let r = e.value;
				n ? (r = r.trim()) : s && (r = Us(r)), e._assign(r);
			}),
				n &&
					to(e, "change", () => {
						e.value = e.value.trim();
					}),
				t || (to(e, "compositionstart", Lo), to(e, "compositionend", Oo), to(e, "change", Oo));
		},
		mounted(e, { value: t }) {
			e.value = null == t ? "" : t;
		},
		beforeUpdate(e, { value: t, modifiers: { lazy: n, trim: r, number: i } }, s) {
			if (((e._assign = Ro(s)), e.composing)) return;
			if (document.activeElement === e) {
				if (n) return;
				if (r && e.value.trim() === t) return;
				if ((i || "number" === e.type) && Us(e.value) === t) return;
			}
			const o = null == t ? "" : t;
			e.value !== o && (e.value = o);
		}
	},
	No = {
		deep: !0,
		created(e, t, n) {
			(e._assign = Ro(n)),
				to(e, "change", () => {
					const t = e._modelValue,
						n = Fo(e),
						r = e.checked,
						i = e._assign;
					if (Ms(t)) {
						const e = Ts(t, n),
							s = -1 !== e;
						if (r && !s) i(t.concat(n));
						else if (!r && s) {
							const n = [...t];
							n.splice(e, 1), i(n);
						}
					} else if (Is(t)) {
						const e = new Set(t);
						r ? e.add(n) : e.delete(n), i(e);
					} else i(Ho(e, r));
				});
		},
		mounted: Do,
		beforeUpdate(e, t, n) {
			(e._assign = Ro(n)), Do(e, t, n);
		}
	};
function Do(e, { value: t, oldValue: n }, r) {
	(e._modelValue = t), Ms(t) ? (e.checked = Ts(t, r.props.value) > -1) : Is(t) ? (e.checked = t.has(r.props.value)) : t !== n && (e.checked = Es(t, Ho(e, !0)));
}
const Bo = {
	created(e, { value: t }, n) {
		(e.checked = Es(t, n.props.value)),
			(e._assign = Ro(n)),
			to(e, "change", () => {
				e._assign(Fo(e));
			});
	},
	beforeUpdate(e, { value: t, oldValue: n }, r) {
		(e._assign = Ro(r)), t !== n && (e.checked = Es(t, r.props.value));
	}
};
function Fo(e) {
	return "_value" in e ? e._value : e.value;
}
function Ho(e, t) {
	const n = t ? "_trueValue" : "_falseValue";
	return n in e ? e[n] : t;
}
const Vo = ["ctrl", "shift", "alt", "meta"],
	Uo = {
		stop: (e) => e.stopPropagation(),
		prevent: (e) => e.preventDefault(),
		self: (e) => e.target !== e.currentTarget,
		ctrl: (e) => !e.ctrlKey,
		shift: (e) => !e.shiftKey,
		alt: (e) => !e.altKey,
		meta: (e) => !e.metaKey,
		left: (e) => "button" in e && 0 !== e.button,
		middle: (e) => "button" in e && 1 !== e.button,
		right: (e) => "button" in e && 2 !== e.button,
		exact: (e, t) => Vo.some((n) => e[`${n}Key`] && !t.includes(n))
	},
	zo =
		(e, t) =>
		(n, ...r) => {
			for (let e = 0; e < t.length; e++) {
				const r = Uo[t[e]];
				if (r && r(n, t)) return;
			}
			return e(n, ...r);
		},
	$o = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" },
	jo = (e, t) => (n) => {
		if (!("key" in n)) return;
		const r = Hs(n.key);
		return t.some((e) => e === r || $o[e] === r) ? e(n) : void 0;
	},
	Wo = {
		beforeMount(e, { value: t }, { transition: n }) {
			(e._vod = "none" === e.style.display ? "" : e.style.display), n && t ? n.beforeEnter(e) : Go(e, t);
		},
		mounted(e, { value: t }, { transition: n }) {
			n && t && n.enter(e);
		},
		updated(e, { value: t, oldValue: n }, { transition: r }) {
			!t != !n &&
				(r
					? t
						? (r.beforeEnter(e), Go(e, !0), r.enter(e))
						: r.leave(e, () => {
								Go(e, !1);
						  })
					: Go(e, t));
		},
		beforeUnmount(e, { value: t }) {
			Go(e, t);
		}
	};
function Go(e, t) {
	e.style.display = t ? e._vod : "none";
}
const Yo = As(
	{
		patchProp: (e, t, n, r, i = !1, s, o, a, l) => {
			"class" === t
				? (function (e, t, n) {
						const r = e._vtc;
						r && (t = (t ? [t, ...r] : [...r]).join(" ")), null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : (e.className = t);
				  })(e, r, i)
				: "style" === t
				? (function (e, t, n) {
						const r = e.style,
							i = Os(n);
						if (n && !i) {
							for (const e in n) Gs(r, e, n[e]);
							if (t && !Os(t)) for (const e in t) null == n[e] && Gs(r, e, "");
						} else {
							const s = r.display;
							i ? t !== n && (r.cssText = n) : t && e.removeAttribute("style"), "_vod" in e && (r.display = s);
						}
				  })(e, n, r)
				: ((e) => ks.test(e))(t)
				? ((e) => e.startsWith("onUpdate:"))(t) || no(e, t, 0, r, o)
				: (
						"." === t[0]
							? ((t = t.slice(1)), 1)
							: "^" === t[0]
							? ((t = t.slice(1)), 0)
							: (function (e, t, n, r) {
									if (r) return "innerHTML" === t || "textContent" === t || !!(t in e && io.test(t) && Ls(n));
									if ("spellcheck" === t || "draggable" === t) return !1;
									if ("form" === t) return !1;
									if ("list" === t && "INPUT" === e.tagName) return !1;
									if ("type" === t && "TEXTAREA" === e.tagName) return !1;
									if (io.test(t) && Os(n)) return !1;
									return t in e;
							  })(e, t, r, i)
				  )
				? (function (e, t, n, r, i, s, o) {
						if ("innerHTML" === t || "textContent" === t) return r && o(r, i, s), void (e[t] = null == n ? "" : n);
						if ("value" === t && "PROGRESS" !== e.tagName && !e.tagName.includes("-")) {
							e._value = n;
							const r = null == n ? "" : n;
							return (e.value === r && "OPTION" !== e.tagName) || (e.value = r), void (null == n && e.removeAttribute(t));
						}
						if ("" === n || null == n) {
							const r = typeof e[t];
							if ("boolean" === r) return void (e[t] = Ss(n));
							if (null == n && "string" === r) return (e[t] = ""), void e.removeAttribute(t);
							if ("number" === r) {
								try {
									e[t] = 0;
								} catch (a) {}
								return void e.removeAttribute(t);
							}
						}
						try {
							e[t] = n;
						} catch (Kj) {}
				  })(e, t, r, s, o, a, l)
				: ("true-value" === t ? (e._trueValue = r) : "false-value" === t && (e._falseValue = r),
				  (function (e, t, n, r, i) {
						if (r && t.startsWith("xlink:")) null == n ? e.removeAttributeNS(Ks, t.slice(6, t.length)) : e.setAttributeNS(Ks, t, n);
						else {
							const r = Cs(t);
							null == n || (r && !Ss(n)) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n);
						}
				  })(e, t, r, i));
		}
	},
	js
);
let Xo;
function Ko() {
	return Xo || (Xo = Er(Yo));
}
const qo = (...e) => {
		Ko().render(...e);
	},
	Zo = (...e) => {
		const t = Ko().createApp(...e),
			{ mount: n } = t;
		return (
			(t.mount = (e) => {
				const r = (function (e) {
					if (Os(e)) {
						return document.querySelector(e);
					}
					return e;
				})(e);
				if (!r) return;
				const i = t._component;
				Ls(i) || i.render || i.template || (i.template = r.innerHTML), (r.innerHTML = "");
				const s = n(r, !1, r instanceof SVGElement);
				return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s;
			}),
			t
		);
	};
var Jo = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Qo(e) {
	return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ea = { exports: {} },
	ta = function (e, t) {
		return function () {
			for (var n = new Array(arguments.length), r = 0; r < n.length; r++) n[r] = arguments[r];
			return e.apply(t, n);
		};
	},
	na = ta,
	ra = Object.prototype.toString;
function ia(e) {
	return "[object Array]" === ra.call(e);
}
function sa(e) {
	return void 0 === e;
}
function oa(e) {
	return null !== e && "object" == typeof e;
}
function aa(e) {
	if ("[object Object]" !== ra.call(e)) return !1;
	var t = Object.getPrototypeOf(e);
	return null === t || t === Object.prototype;
}
function la(e) {
	return "[object Function]" === ra.call(e);
}
function ua(e, t) {
	if (null != e)
		if (("object" != typeof e && (e = [e]), ia(e))) for (var n = 0, r = e.length; n < r; n++) t.call(null, e[n], n, e);
		else for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e);
}
var ca = {
		isArray: ia,
		isArrayBuffer: function (e) {
			return "[object ArrayBuffer]" === ra.call(e);
		},
		isBuffer: function (e) {
			return null !== e && !sa(e) && null !== e.constructor && !sa(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);
		},
		isFormData: function (e) {
			return "undefined" != typeof FormData && e instanceof FormData;
		},
		isArrayBufferView: function (e) {
			return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer;
		},
		isString: function (e) {
			return "string" == typeof e;
		},
		isNumber: function (e) {
			return "number" == typeof e;
		},
		isObject: oa,
		isPlainObject: aa,
		isUndefined: sa,
		isDate: function (e) {
			return "[object Date]" === ra.call(e);
		},
		isFile: function (e) {
			return "[object File]" === ra.call(e);
		},
		isBlob: function (e) {
			return "[object Blob]" === ra.call(e);
		},
		isFunction: la,
		isStream: function (e) {
			return oa(e) && la(e.pipe);
		},
		isURLSearchParams: function (e) {
			return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams;
		},
		isStandardBrowserEnv: function () {
			return ("undefined" == typeof navigator || ("ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product)) && "undefined" != typeof window && "undefined" != typeof document;
		},
		forEach: ua,
		merge: function e() {
			var t = {};
			function n(n, r) {
				aa(t[r]) && aa(n) ? (t[r] = e(t[r], n)) : aa(n) ? (t[r] = e({}, n)) : ia(n) ? (t[r] = n.slice()) : (t[r] = n);
			}
			for (var r = 0, i = arguments.length; r < i; r++) ua(arguments[r], n);
			return t;
		},
		extend: function (e, t, n) {
			return (
				ua(t, function (t, r) {
					e[r] = n && "function" == typeof t ? na(t, n) : t;
				}),
				e
			);
		},
		trim: function (e) {
			return e.replace(/^\s*/, "").replace(/\s*$/, "");
		},
		stripBOM: function (e) {
			return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e;
		}
	},
	ha = ca;
function da(e) {
	return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var pa = function (e, t, n) {
		if (!t) return e;
		var r;
		if (n) r = n(t);
		else if (ha.isURLSearchParams(t)) r = t.toString();
		else {
			var i = [];
			ha.forEach(t, function (e, t) {
				null != e &&
					(ha.isArray(e) ? (t += "[]") : (e = [e]),
					ha.forEach(e, function (e) {
						ha.isDate(e) ? (e = e.toISOString()) : ha.isObject(e) && (e = JSON.stringify(e)), i.push(da(t) + "=" + da(e));
					}));
			}),
				(r = i.join("&"));
		}
		if (r) {
			var s = e.indexOf("#");
			-1 !== s && (e = e.slice(0, s)), (e += (-1 === e.indexOf("?") ? "?" : "&") + r);
		}
		return e;
	},
	fa = ca;
function ma() {
	this.handlers = [];
}
(ma.prototype.use = function (e, t) {
	return this.handlers.push({ fulfilled: e, rejected: t }), this.handlers.length - 1;
}),
	(ma.prototype.eject = function (e) {
		this.handlers[e] && (this.handlers[e] = null);
	}),
	(ma.prototype.forEach = function (e) {
		fa.forEach(this.handlers, function (t) {
			null !== t && e(t);
		});
	});
var va = ma,
	ga = ca,
	ya = function (e) {
		return !(!e || !e.__CANCEL__);
	},
	ba = ca,
	xa = function (e, t, n, r, i) {
		return (
			(e.config = t),
			n && (e.code = n),
			(e.request = r),
			(e.response = i),
			(e.isAxiosError = !0),
			(e.toJSON = function () {
				return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code };
			}),
			e
		);
	},
	_a = function (e, t, n, r, i) {
		var s = new Error(e);
		return xa(s, t, n, r, i);
	},
	wa = _a,
	Ca = ca,
	Sa = Ca.isStandardBrowserEnv()
		? {
				write: function (e, t, n, r, i, s) {
					var o = [];
					o.push(e + "=" + encodeURIComponent(t)), Ca.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), Ca.isString(r) && o.push("path=" + r), Ca.isString(i) && o.push("domain=" + i), !0 === s && o.push("secure"), (document.cookie = o.join("; "));
				},
				read: function (e) {
					var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
					return t ? decodeURIComponent(t[3]) : null;
				},
				remove: function (e) {
					this.write(e, "", Date.now() - 864e5);
				}
		  }
		: {
				write: function () {},
				read: function () {
					return null;
				},
				remove: function () {}
		  },
	Ea = function (e) {
		return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e);
	},
	Ta = function (e, t) {
		return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
	},
	ka = ca,
	Aa = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"],
	Ma = ca,
	Ia = Ma.isStandardBrowserEnv()
		? (function () {
				var e,
					t = /(msie|trident)/i.test(navigator.userAgent),
					n = document.createElement("a");
				function r(e) {
					var r = e;
					return (
						t && (n.setAttribute("href", r), (r = n.href)),
						n.setAttribute("href", r),
						{
							href: n.href,
							protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
							host: n.host,
							search: n.search ? n.search.replace(/^\?/, "") : "",
							hash: n.hash ? n.hash.replace(/^#/, "") : "",
							hostname: n.hostname,
							port: n.port,
							pathname: "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname
						}
					);
				}
				return (
					(e = r(window.location.href)),
					function (t) {
						var n = Ma.isString(t) ? r(t) : t;
						return n.protocol === e.protocol && n.host === e.host;
					}
				);
		  })()
		: function () {
				return !0;
		  },
	Ra = ca,
	La = function (e, t, n) {
		var r = n.config.validateStatus;
		n.status && r && !r(n.status) ? t(wa("Request failed with status code " + n.status, n.config, null, n.request, n)) : e(n);
	},
	Oa = Sa,
	Pa = pa,
	Na = function (e, t) {
		return e && !Ea(t) ? Ta(e, t) : t;
	},
	Da = function (e) {
		var t,
			n,
			r,
			i = {};
		return e
			? (ka.forEach(e.split("\n"), function (e) {
					if (((r = e.indexOf(":")), (t = ka.trim(e.substr(0, r)).toLowerCase()), (n = ka.trim(e.substr(r + 1))), t)) {
						if (i[t] && Aa.indexOf(t) >= 0) return;
						i[t] = "set-cookie" === t ? (i[t] ? i[t] : []).concat([n]) : i[t] ? i[t] + ", " + n : n;
					}
			  }),
			  i)
			: i;
	},
	Ba = Ia,
	Fa = _a,
	Ha = function (e) {
		return new Promise(function (t, n) {
			var r = e.data,
				i = e.headers;
			Ra.isFormData(r) && delete i["Content-Type"];
			var s = new XMLHttpRequest();
			if (e.auth) {
				var o = e.auth.username || "",
					a = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
				i.Authorization = "Basic " + btoa(o + ":" + a);
			}
			var l = Na(e.baseURL, e.url);
			if (
				(s.open(e.method.toUpperCase(), Pa(l, e.params, e.paramsSerializer), !0),
				(s.timeout = e.timeout),
				(s.onreadystatechange = function () {
					if (s && 4 === s.readyState && (0 !== s.status || (s.responseURL && 0 === s.responseURL.indexOf("file:")))) {
						var r = "getAllResponseHeaders" in s ? Da(s.getAllResponseHeaders()) : null,
							i = { data: e.responseType && "text" !== e.responseType ? s.response : s.responseText, status: s.status, statusText: s.statusText, headers: r, config: e, request: s };
						La(t, n, i), (s = null);
					}
				}),
				(s.onabort = function () {
					s && (n(Fa("Request aborted", e, "ECONNABORTED", s)), (s = null));
				}),
				(s.onerror = function () {
					n(Fa("Network Error", e, null, s)), (s = null);
				}),
				(s.ontimeout = function () {
					var t = "timeout of " + e.timeout + "ms exceeded";
					e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(Fa(t, e, "ECONNABORTED", s)), (s = null);
				}),
				Ra.isStandardBrowserEnv())
			) {
				var u = (e.withCredentials || Ba(l)) && e.xsrfCookieName ? Oa.read(e.xsrfCookieName) : void 0;
				u && (i[e.xsrfHeaderName] = u);
			}
			if (
				("setRequestHeader" in s &&
					Ra.forEach(i, function (e, t) {
						void 0 === r && "content-type" === t.toLowerCase() ? delete i[t] : s.setRequestHeader(t, e);
					}),
				Ra.isUndefined(e.withCredentials) || (s.withCredentials = !!e.withCredentials),
				e.responseType)
			)
				try {
					s.responseType = e.responseType;
				} catch (Kj) {
					if ("json" !== e.responseType) throw Kj;
				}
			"function" == typeof e.onDownloadProgress && s.addEventListener("progress", e.onDownloadProgress),
				"function" == typeof e.onUploadProgress && s.upload && s.upload.addEventListener("progress", e.onUploadProgress),
				e.cancelToken &&
					e.cancelToken.promise.then(function (e) {
						s && (s.abort(), n(e), (s = null));
					}),
				r || (r = null),
				s.send(r);
		});
	},
	Va = ca,
	Ua = function (e, t) {
		ba.forEach(e, function (n, r) {
			r !== t && r.toUpperCase() === t.toUpperCase() && ((e[t] = n), delete e[r]);
		});
	},
	za = { "Content-Type": "application/x-www-form-urlencoded" };
function $a(e, t) {
	!Va.isUndefined(e) && Va.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t);
}
var ja,
	Wa = {
		adapter: (("undefined" != typeof XMLHttpRequest || ("undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process))) && (ja = Ha), ja),
		transformRequest: [
			function (e, t) {
				return (
					Ua(t, "Accept"),
					Ua(t, "Content-Type"),
					Va.isFormData(e) || Va.isArrayBuffer(e) || Va.isBuffer(e) || Va.isStream(e) || Va.isFile(e) || Va.isBlob(e)
						? e
						: Va.isArrayBufferView(e)
						? e.buffer
						: Va.isURLSearchParams(e)
						? ($a(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString())
						: Va.isObject(e)
						? ($a(t, "application/json;charset=utf-8"), JSON.stringify(e))
						: e
				);
			}
		],
		transformResponse: [
			function (e) {
				if ("string" == typeof e)
					try {
						e = JSON.parse(e);
					} catch (Kj) {}
				return e;
			}
		],
		timeout: 0,
		xsrfCookieName: "XSRF-TOKEN",
		xsrfHeaderName: "X-XSRF-TOKEN",
		maxContentLength: -1,
		maxBodyLength: -1,
		validateStatus: function (e) {
			return e >= 200 && e < 300;
		}
	};
(Wa.headers = { common: { Accept: "application/json, text/plain, */*" } }),
	Va.forEach(["delete", "get", "head"], function (e) {
		Wa.headers[e] = {};
	}),
	Va.forEach(["post", "put", "patch"], function (e) {
		Wa.headers[e] = Va.merge(za);
	});
var Ga = Wa,
	Ya = ca,
	Xa = function (e, t, n) {
		return (
			ga.forEach(n, function (n) {
				e = n(e, t);
			}),
			e
		);
	},
	Ka = ya,
	qa = Ga;
function Za(e) {
	e.cancelToken && e.cancelToken.throwIfRequested();
}
var Ja = ca,
	Qa = function (e, t) {
		t = t || {};
		var n = {},
			r = ["url", "method", "data"],
			i = ["headers", "auth", "proxy", "params"],
			s = [
				"baseURL",
				"transformRequest",
				"transformResponse",
				"paramsSerializer",
				"timeout",
				"timeoutMessage",
				"withCredentials",
				"adapter",
				"responseType",
				"xsrfCookieName",
				"xsrfHeaderName",
				"onUploadProgress",
				"onDownloadProgress",
				"decompress",
				"maxContentLength",
				"maxBodyLength",
				"maxRedirects",
				"transport",
				"httpAgent",
				"httpsAgent",
				"cancelToken",
				"socketPath",
				"responseEncoding"
			],
			o = ["validateStatus"];
		function a(e, t) {
			return Ja.isPlainObject(e) && Ja.isPlainObject(t) ? Ja.merge(e, t) : Ja.isPlainObject(t) ? Ja.merge({}, t) : Ja.isArray(t) ? t.slice() : t;
		}
		function l(r) {
			Ja.isUndefined(t[r]) ? Ja.isUndefined(e[r]) || (n[r] = a(void 0, e[r])) : (n[r] = a(e[r], t[r]));
		}
		Ja.forEach(r, function (e) {
			Ja.isUndefined(t[e]) || (n[e] = a(void 0, t[e]));
		}),
			Ja.forEach(i, l),
			Ja.forEach(s, function (r) {
				Ja.isUndefined(t[r]) ? Ja.isUndefined(e[r]) || (n[r] = a(void 0, e[r])) : (n[r] = a(void 0, t[r]));
			}),
			Ja.forEach(o, function (r) {
				r in t ? (n[r] = a(e[r], t[r])) : r in e && (n[r] = a(void 0, e[r]));
			});
		var u = r.concat(i).concat(s).concat(o),
			c = Object.keys(e)
				.concat(Object.keys(t))
				.filter(function (e) {
					return -1 === u.indexOf(e);
				});
		return Ja.forEach(c, l), n;
	},
	el = ca,
	tl = pa,
	nl = va,
	rl = function (e) {
		return (
			Za(e),
			(e.headers = e.headers || {}),
			(e.data = Xa(e.data, e.headers, e.transformRequest)),
			(e.headers = Ya.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers)),
			Ya.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (t) {
				delete e.headers[t];
			}),
			(e.adapter || qa.adapter)(e).then(
				function (t) {
					return Za(e), (t.data = Xa(t.data, t.headers, e.transformResponse)), t;
				},
				function (t) {
					return Ka(t) || (Za(e), t && t.response && (t.response.data = Xa(t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t);
				}
			)
		);
	},
	il = Qa;
function sl(e) {
	(this.defaults = e), (this.interceptors = { request: new nl(), response: new nl() });
}
(sl.prototype.request = function (e) {
	"string" == typeof e ? ((e = arguments[1] || {}).url = arguments[0]) : (e = e || {}), (e = il(this.defaults, e)).method ? (e.method = e.method.toLowerCase()) : this.defaults.method ? (e.method = this.defaults.method.toLowerCase()) : (e.method = "get");
	var t = [rl, void 0],
		n = Promise.resolve(e);
	for (
		this.interceptors.request.forEach(function (e) {
			t.unshift(e.fulfilled, e.rejected);
		}),
			this.interceptors.response.forEach(function (e) {
				t.push(e.fulfilled, e.rejected);
			});
		t.length;

	)
		n = n.then(t.shift(), t.shift());
	return n;
}),
	(sl.prototype.getUri = function (e) {
		return (e = il(this.defaults, e)), tl(e.url, e.params, e.paramsSerializer).replace(/^\?/, "");
	}),
	el.forEach(["delete", "get", "head", "options"], function (e) {
		sl.prototype[e] = function (t, n) {
			return this.request(il(n || {}, { method: e, url: t, data: (n || {}).data }));
		};
	}),
	el.forEach(["post", "put", "patch"], function (e) {
		sl.prototype[e] = function (t, n, r) {
			return this.request(il(r || {}, { method: e, url: t, data: n }));
		};
	});
var ol = sl;
function al(e) {
	this.message = e;
}
(al.prototype.toString = function () {
	return "Cancel" + (this.message ? ": " + this.message : "");
}),
	(al.prototype.__CANCEL__ = !0);
var ll = al,
	ul = ll;
function cl(e) {
	if ("function" != typeof e) throw new TypeError("executor must be a function.");
	var t;
	this.promise = new Promise(function (e) {
		t = e;
	});
	var n = this;
	e(function (e) {
		n.reason || ((n.reason = new ul(e)), t(n.reason));
	});
}
(cl.prototype.throwIfRequested = function () {
	if (this.reason) throw this.reason;
}),
	(cl.source = function () {
		var e;
		return {
			token: new cl(function (t) {
				e = t;
			}),
			cancel: e
		};
	});
var hl = cl,
	dl = ca,
	pl = ta,
	fl = ol,
	ml = Qa;
function vl(e) {
	var t = new fl(e),
		n = pl(fl.prototype.request, t);
	return dl.extend(n, fl.prototype, t), dl.extend(n, t), n;
}
var gl = vl(Ga);
(gl.Axios = fl),
	(gl.create = function (e) {
		return vl(ml(gl.defaults, e));
	}),
	(gl.Cancel = ll),
	(gl.CancelToken = hl),
	(gl.isCancel = ya),
	(gl.all = function (e) {
		return Promise.all(e);
	}),
	(gl.spread = function (e) {
		return function (t) {
			return e.apply(null, t);
		};
	}),
	(gl.isAxiosError = function (e) {
		return "object" == typeof e && !0 === e.isAxiosError;
	}),
	(ea.exports = gl),
	(ea.exports.default = gl);
var yl = ea.exports,
	bl = ((e) => ((e[(e.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"), (e[(e.WEBGL = 1)] = "WEBGL"), (e[(e.WEBGL2 = 2)] = "WEBGL2"), e))(bl || {}),
	xl = ((e) => ((e[(e.UNKNOWN = 0)] = "UNKNOWN"), (e[(e.WEBGL = 1)] = "WEBGL"), (e[(e.CANVAS = 2)] = "CANVAS"), e))(xl || {}),
	_l = ((e) => ((e[(e.COLOR = 16384)] = "COLOR"), (e[(e.DEPTH = 256)] = "DEPTH"), (e[(e.STENCIL = 1024)] = "STENCIL"), e))(_l || {}),
	wl = ((e) => (
		(e[(e.NORMAL = 0)] = "NORMAL"),
		(e[(e.ADD = 1)] = "ADD"),
		(e[(e.MULTIPLY = 2)] = "MULTIPLY"),
		(e[(e.SCREEN = 3)] = "SCREEN"),
		(e[(e.OVERLAY = 4)] = "OVERLAY"),
		(e[(e.DARKEN = 5)] = "DARKEN"),
		(e[(e.LIGHTEN = 6)] = "LIGHTEN"),
		(e[(e.COLOR_DODGE = 7)] = "COLOR_DODGE"),
		(e[(e.COLOR_BURN = 8)] = "COLOR_BURN"),
		(e[(e.HARD_LIGHT = 9)] = "HARD_LIGHT"),
		(e[(e.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
		(e[(e.DIFFERENCE = 11)] = "DIFFERENCE"),
		(e[(e.EXCLUSION = 12)] = "EXCLUSION"),
		(e[(e.HUE = 13)] = "HUE"),
		(e[(e.SATURATION = 14)] = "SATURATION"),
		(e[(e.COLOR = 15)] = "COLOR"),
		(e[(e.LUMINOSITY = 16)] = "LUMINOSITY"),
		(e[(e.NORMAL_NPM = 17)] = "NORMAL_NPM"),
		(e[(e.ADD_NPM = 18)] = "ADD_NPM"),
		(e[(e.SCREEN_NPM = 19)] = "SCREEN_NPM"),
		(e[(e.NONE = 20)] = "NONE"),
		(e[(e.SRC_OVER = 0)] = "SRC_OVER"),
		(e[(e.SRC_IN = 21)] = "SRC_IN"),
		(e[(e.SRC_OUT = 22)] = "SRC_OUT"),
		(e[(e.SRC_ATOP = 23)] = "SRC_ATOP"),
		(e[(e.DST_OVER = 24)] = "DST_OVER"),
		(e[(e.DST_IN = 25)] = "DST_IN"),
		(e[(e.DST_OUT = 26)] = "DST_OUT"),
		(e[(e.DST_ATOP = 27)] = "DST_ATOP"),
		(e[(e.ERASE = 26)] = "ERASE"),
		(e[(e.SUBTRACT = 28)] = "SUBTRACT"),
		(e[(e.XOR = 29)] = "XOR"),
		e
	))(wl || {}),
	Cl = ((e) => ((e[(e.POINTS = 0)] = "POINTS"), (e[(e.LINES = 1)] = "LINES"), (e[(e.LINE_LOOP = 2)] = "LINE_LOOP"), (e[(e.LINE_STRIP = 3)] = "LINE_STRIP"), (e[(e.TRIANGLES = 4)] = "TRIANGLES"), (e[(e.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"), (e[(e.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN"), e))(
		Cl || {}
	),
	Sl = ((e) => (
		(e[(e.RGBA = 6408)] = "RGBA"),
		(e[(e.RGB = 6407)] = "RGB"),
		(e[(e.RG = 33319)] = "RG"),
		(e[(e.RED = 6403)] = "RED"),
		(e[(e.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
		(e[(e.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
		(e[(e.RG_INTEGER = 33320)] = "RG_INTEGER"),
		(e[(e.RED_INTEGER = 36244)] = "RED_INTEGER"),
		(e[(e.ALPHA = 6406)] = "ALPHA"),
		(e[(e.LUMINANCE = 6409)] = "LUMINANCE"),
		(e[(e.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
		(e[(e.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
		(e[(e.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
		e
	))(Sl || {}),
	El = ((e) => (
		(e[(e.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
		(e[(e.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
		(e[(e.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
		(e[(e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] = "TEXTURE_CUBE_MAP_POSITIVE_X"),
		(e[(e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] = "TEXTURE_CUBE_MAP_NEGATIVE_X"),
		(e[(e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] = "TEXTURE_CUBE_MAP_POSITIVE_Y"),
		(e[(e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] = "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
		(e[(e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] = "TEXTURE_CUBE_MAP_POSITIVE_Z"),
		(e[(e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
		e
	))(El || {}),
	Tl = ((e) => (
		(e[(e.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
		(e[(e.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
		(e[(e.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
		(e[(e.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
		(e[(e.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
		(e[(e.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
		(e[(e.UNSIGNED_INT_10F_11F_11F_REV = 35899)] = "UNSIGNED_INT_10F_11F_11F_REV"),
		(e[(e.UNSIGNED_INT_2_10_10_10_REV = 33640)] = "UNSIGNED_INT_2_10_10_10_REV"),
		(e[(e.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
		(e[(e.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
		(e[(e.BYTE = 5120)] = "BYTE"),
		(e[(e.SHORT = 5122)] = "SHORT"),
		(e[(e.INT = 5124)] = "INT"),
		(e[(e.FLOAT = 5126)] = "FLOAT"),
		(e[(e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] = "FLOAT_32_UNSIGNED_INT_24_8_REV"),
		(e[(e.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
		e
	))(Tl || {}),
	kl = ((e) => ((e[(e.FLOAT = 0)] = "FLOAT"), (e[(e.INT = 1)] = "INT"), (e[(e.UINT = 2)] = "UINT"), e))(kl || {}),
	Al = ((e) => ((e[(e.NEAREST = 0)] = "NEAREST"), (e[(e.LINEAR = 1)] = "LINEAR"), e))(Al || {}),
	Ml = ((e) => ((e[(e.CLAMP = 33071)] = "CLAMP"), (e[(e.REPEAT = 10497)] = "REPEAT"), (e[(e.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT"), e))(Ml || {}),
	Il = ((e) => ((e[(e.OFF = 0)] = "OFF"), (e[(e.POW2 = 1)] = "POW2"), (e[(e.ON = 2)] = "ON"), (e[(e.ON_MANUAL = 3)] = "ON_MANUAL"), e))(Il || {}),
	Rl = ((e) => ((e[(e.NPM = 0)] = "NPM"), (e[(e.UNPACK = 1)] = "UNPACK"), (e[(e.PMA = 2)] = "PMA"), (e[(e.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"), (e[(e.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"), (e[(e.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA"), e))(Rl || {}),
	Ll = ((e) => ((e[(e.NO = 0)] = "NO"), (e[(e.YES = 1)] = "YES"), (e[(e.AUTO = 2)] = "AUTO"), (e[(e.BLEND = 0)] = "BLEND"), (e[(e.CLEAR = 1)] = "CLEAR"), (e[(e.BLIT = 2)] = "BLIT"), e))(Ll || {}),
	Ol = ((e) => ((e[(e.AUTO = 0)] = "AUTO"), (e[(e.MANUAL = 1)] = "MANUAL"), e))(Ol || {}),
	Pl = ((e) => ((e.LOW = "lowp"), (e.MEDIUM = "mediump"), (e.HIGH = "highp"), e))(Pl || {}),
	Nl = ((e) => ((e[(e.NONE = 0)] = "NONE"), (e[(e.SCISSOR = 1)] = "SCISSOR"), (e[(e.STENCIL = 2)] = "STENCIL"), (e[(e.SPRITE = 3)] = "SPRITE"), (e[(e.COLOR = 4)] = "COLOR"), e))(Nl || {}),
	Dl = ((e) => ((e[(e.RED = 1)] = "RED"), (e[(e.GREEN = 2)] = "GREEN"), (e[(e.BLUE = 4)] = "BLUE"), (e[(e.ALPHA = 8)] = "ALPHA"), e))(Dl || {}),
	Bl = ((e) => ((e[(e.NONE = 0)] = "NONE"), (e[(e.LOW = 2)] = "LOW"), (e[(e.MEDIUM = 4)] = "MEDIUM"), (e[(e.HIGH = 8)] = "HIGH"), e))(Bl || {}),
	Fl = ((e) => ((e[(e.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"), (e[(e.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"), (e[(e.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"), e))(Fl || {});
const Hl = {
		createCanvas: (e, t) => {
			const n = document.createElement("canvas");
			return (n.width = e), (n.height = t), n;
		},
		getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
		getWebGLRenderingContext: () => WebGLRenderingContext,
		getNavigator: () => navigator,
		getBaseUrl: () => {
			var e;
			return null != (e = document.baseURI) ? e : window.location.href;
		},
		getFontFaceSet: () => document.fonts,
		fetch: (e, t) => fetch(e, t),
		parseXML: (e) => new DOMParser().parseFromString(e, "text/xml")
	},
	Vl = { ADAPTER: Hl, RESOLUTION: 1, CREATE_IMAGE_BITMAP: !1, ROUND_PIXELS: !1 };
var Ul = /iPhone/i,
	zl = /iPod/i,
	$l = /iPad/i,
	jl = /\biOS-universal(?:.+)Mac\b/i,
	Wl = /\bAndroid(?:.+)Mobile\b/i,
	Gl = /Android/i,
	Yl = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
	Xl = /Silk/i,
	Kl = /Windows Phone/i,
	ql = /\bWindows(?:.+)ARM\b/i,
	Zl = /BlackBerry/i,
	Jl = /BB10/i,
	Ql = /Opera Mini/i,
	eu = /\b(CriOS|Chrome)(?:.+)Mobile/i,
	tu = /Mobile(?:.+)Firefox\b/i,
	nu = function (e) {
		return void 0 !== e && "MacIntel" === e.platform && "number" == typeof e.maxTouchPoints && e.maxTouchPoints > 1 && "undefined" == typeof MSStream;
	};
function ru(e) {
	var t = { userAgent: "", platform: "", maxTouchPoints: 0 };
	e || "undefined" == typeof navigator
		? "string" == typeof e
			? (t.userAgent = e)
			: e && e.userAgent && (t = { userAgent: e.userAgent, platform: e.platform, maxTouchPoints: e.maxTouchPoints || 0 })
		: (t = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 });
	var n = t.userAgent,
		r = n.split("[FBAN");
	void 0 !== r[1] && (n = r[0]), void 0 !== (r = n.split("Twitter"))[1] && (n = r[0]);
	var i = (function (e) {
			return function (t) {
				return t.test(e);
			};
		})(n),
		s = {
			apple: { phone: i(Ul) && !i(Kl), ipod: i(zl), tablet: !i(Ul) && (i($l) || nu(t)) && !i(Kl), universal: i(jl), device: (i(Ul) || i(zl) || i($l) || i(jl) || nu(t)) && !i(Kl) },
			amazon: { phone: i(Yl), tablet: !i(Yl) && i(Xl), device: i(Yl) || i(Xl) },
			android: { phone: (!i(Kl) && i(Yl)) || (!i(Kl) && i(Wl)), tablet: !i(Kl) && !i(Yl) && !i(Wl) && (i(Xl) || i(Gl)), device: (!i(Kl) && (i(Yl) || i(Xl) || i(Wl) || i(Gl))) || i(/\bokhttp\b/i) },
			windows: { phone: i(Kl), tablet: i(ql), device: i(Kl) || i(ql) },
			other: { blackberry: i(Zl), blackberry10: i(Jl), opera: i(Ql), firefox: i(tu), chrome: i(eu), device: i(Zl) || i(Jl) || i(Ql) || i(tu) || i(eu) },
			any: !1,
			phone: !1,
			tablet: !1
		};
	return (s.any = s.apple.device || s.android.device || s.windows.device || s.other.device), (s.phone = s.apple.phone || s.android.phone || s.windows.phone), (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet), s;
}
const iu = (null != (e = ru.default) ? e : ru)(globalThis.navigator),
	su = {
		ADAPTER: {
			createCanvas: (e, t) => {
				const n = document.createElement("canvas");
				return (n.width = e), (n.height = t), n;
			},
			getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
			getWebGLRenderingContext: () => WebGLRenderingContext,
			getNavigator: () => navigator,
			getBaseUrl: () => {
				var e;
				return null != (e = document.baseURI) ? e : window.location.href;
			},
			getFontFaceSet: () => document.fonts,
			fetch: (e, t) => fetch(e, t),
			parseXML: (e) => new DOMParser().parseFromString(e, "text/xml")
		},
		RESOLUTION: 1,
		CREATE_IMAGE_BITMAP: !1,
		ROUND_PIXELS: !1
	},
	ou = (null != (t = ru.default) ? t : ru)(globalThis.navigator);
(su.RETINA_PREFIX = /@([0-9\.]+)x/), (su.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1);
var au = { exports: {} };
!(function (e) {
	var t = Object.prototype.hasOwnProperty,
		n = "~";
	function r() {}
	function i(e, t, n) {
		(this.fn = e), (this.context = t), (this.once = n || !1);
	}
	function s(e, t, r, s, o) {
		if ("function" != typeof r) throw new TypeError("The listener must be a function");
		var a = new i(r, s || e, o),
			l = n ? n + t : t;
		return e._events[l] ? (e._events[l].fn ? (e._events[l] = [e._events[l], a]) : e._events[l].push(a)) : ((e._events[l] = a), e._eventsCount++), e;
	}
	function o(e, t) {
		0 == --e._eventsCount ? (e._events = new r()) : delete e._events[t];
	}
	function a() {
		(this._events = new r()), (this._eventsCount = 0);
	}
	Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
		(a.prototype.eventNames = function () {
			var e,
				r,
				i = [];
			if (0 === this._eventsCount) return i;
			for (r in (e = this._events)) t.call(e, r) && i.push(n ? r.slice(1) : r);
			return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i;
		}),
		(a.prototype.listeners = function (e) {
			var t = n ? n + e : e,
				r = this._events[t];
			if (!r) return [];
			if (r.fn) return [r.fn];
			for (var i = 0, s = r.length, o = new Array(s); i < s; i++) o[i] = r[i].fn;
			return o;
		}),
		(a.prototype.listenerCount = function (e) {
			var t = n ? n + e : e,
				r = this._events[t];
			return r ? (r.fn ? 1 : r.length) : 0;
		}),
		(a.prototype.emit = function (e, t, r, i, s, o) {
			var a = n ? n + e : e;
			if (!this._events[a]) return !1;
			var l,
				u,
				c = this._events[a],
				h = arguments.length;
			if (c.fn) {
				switch ((c.once && this.removeListener(e, c.fn, void 0, !0), h)) {
					case 1:
						return c.fn.call(c.context), !0;
					case 2:
						return c.fn.call(c.context, t), !0;
					case 3:
						return c.fn.call(c.context, t, r), !0;
					case 4:
						return c.fn.call(c.context, t, r, i), !0;
					case 5:
						return c.fn.call(c.context, t, r, i, s), !0;
					case 6:
						return c.fn.call(c.context, t, r, i, s, o), !0;
				}
				for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
				c.fn.apply(c.context, l);
			} else {
				var d,
					p = c.length;
				for (u = 0; u < p; u++)
					switch ((c[u].once && this.removeListener(e, c[u].fn, void 0, !0), h)) {
						case 1:
							c[u].fn.call(c[u].context);
							break;
						case 2:
							c[u].fn.call(c[u].context, t);
							break;
						case 3:
							c[u].fn.call(c[u].context, t, r);
							break;
						case 4:
							c[u].fn.call(c[u].context, t, r, i);
							break;
						default:
							if (!l) for (d = 1, l = new Array(h - 1); d < h; d++) l[d - 1] = arguments[d];
							c[u].fn.apply(c[u].context, l);
					}
			}
			return !0;
		}),
		(a.prototype.on = function (e, t, n) {
			return s(this, e, t, n, !1);
		}),
		(a.prototype.once = function (e, t, n) {
			return s(this, e, t, n, !0);
		}),
		(a.prototype.removeListener = function (e, t, r, i) {
			var s = n ? n + e : e;
			if (!this._events[s]) return this;
			if (!t) return o(this, s), this;
			var a = this._events[s];
			if (a.fn) a.fn !== t || (i && !a.once) || (r && a.context !== r) || o(this, s);
			else {
				for (var l = 0, u = [], c = a.length; l < c; l++) (a[l].fn !== t || (i && !a[l].once) || (r && a[l].context !== r)) && u.push(a[l]);
				u.length ? (this._events[s] = 1 === u.length ? u[0] : u) : o(this, s);
			}
			return this;
		}),
		(a.prototype.removeAllListeners = function (e) {
			var t;
			return e ? ((t = n ? n + e : e), this._events[t] && o(this, t)) : ((this._events = new r()), (this._eventsCount = 0)), this;
		}),
		(a.prototype.off = a.prototype.removeListener),
		(a.prototype.addListener = a.prototype.on),
		(a.prefixed = n),
		(a.EventEmitter = a),
		(e.exports = a);
})(au);
var lu = au.exports,
	uu = { exports: {} };
function cu(e, t, n) {
	n = n || 2;
	var r,
		i,
		s,
		o,
		a,
		l,
		u,
		c = t && t.length,
		h = c ? t[0] * n : e.length,
		d = hu(e, 0, h, n, !0),
		p = [];
	if (!d || d.next === d.prev) return p;
	if (
		(c &&
			(d = (function (e, t, n, r) {
				var i,
					s,
					o,
					a = [];
				for (i = 0, s = t.length; i < s; i++) (o = hu(e, t[i] * r, i < s - 1 ? t[i + 1] * r : e.length, r, !1)) === o.next && (o.steiner = !0), a.push(wu(o));
				for (a.sort(yu), i = 0; i < a.length; i++) n = bu(a[i], n);
				return n;
			})(e, t, d, n)),
		e.length > 80 * n)
	) {
		(r = s = e[0]), (i = o = e[1]);
		for (var f = n; f < h; f += n) (a = e[f]) < r && (r = a), (l = e[f + 1]) < i && (i = l), a > s && (s = a), l > o && (o = l);
		u = 0 !== (u = Math.max(s - r, o - i)) ? 32767 / u : 0;
	}
	return pu(d, p, n, r, i, u, 0), p;
}
function hu(e, t, n, r, i) {
	var s, o;
	if (i === Nu(e, t, n, r) > 0) for (s = t; s < n; s += r) o = Lu(s, e[s], e[s + 1], o);
	else for (s = n - r; s >= t; s -= r) o = Lu(s, e[s], e[s + 1], o);
	return o && Tu(o, o.next) && (Ou(o), (o = o.next)), o;
}
function du(e, t) {
	if (!e) return e;
	t || (t = e);
	var n,
		r = e;
	do {
		if (((n = !1), r.steiner || (!Tu(r, r.next) && 0 !== Eu(r.prev, r, r.next)))) r = r.next;
		else {
			if ((Ou(r), (r = t = r.prev) === r.next)) break;
			n = !0;
		}
	} while (n || r !== t);
	return t;
}
function pu(e, t, n, r, i, s, o) {
	if (e) {
		!o &&
			s &&
			(function (e, t, n, r) {
				var i = e;
				do {
					0 === i.z && (i.z = _u(i.x, i.y, t, n, r)), (i.prevZ = i.prev), (i.nextZ = i.next), (i = i.next);
				} while (i !== e);
				(i.prevZ.nextZ = null),
					(i.prevZ = null),
					(function (e) {
						var t,
							n,
							r,
							i,
							s,
							o,
							a,
							l,
							u = 1;
						do {
							for (n = e, e = null, s = null, o = 0; n; ) {
								for (o++, r = n, a = 0, t = 0; t < u && (a++, (r = r.nextZ)); t++);
								for (l = u; a > 0 || (l > 0 && r); ) 0 !== a && (0 === l || !r || n.z <= r.z) ? ((i = n), (n = n.nextZ), a--) : ((i = r), (r = r.nextZ), l--), s ? (s.nextZ = i) : (e = i), (i.prevZ = s), (s = i);
								n = r;
							}
							(s.nextZ = null), (u *= 2);
						} while (o > 1);
					})(i);
			})(e, r, i, s);
		for (var a, l, u = e; e.prev !== e.next; )
			if (((a = e.prev), (l = e.next), s ? mu(e, r, i, s) : fu(e))) t.push((a.i / n) | 0), t.push((e.i / n) | 0), t.push((l.i / n) | 0), Ou(e), (e = l.next), (u = l.next);
			else if ((e = l) === u) {
				o ? (1 === o ? pu((e = vu(du(e), t, n)), t, n, r, i, s, 2) : 2 === o && gu(e, t, n, r, i, s)) : pu(du(e), t, n, r, i, s, 1);
				break;
			}
	}
}
function fu(e) {
	var t = e.prev,
		n = e,
		r = e.next;
	if (Eu(t, n, r) >= 0) return !1;
	for (var i = t.x, s = n.x, o = r.x, a = t.y, l = n.y, u = r.y, c = i < s ? (i < o ? i : o) : s < o ? s : o, h = a < l ? (a < u ? a : u) : l < u ? l : u, d = i > s ? (i > o ? i : o) : s > o ? s : o, p = a > l ? (a > u ? a : u) : l > u ? l : u, f = r.next; f !== t; ) {
		if (f.x >= c && f.x <= d && f.y >= h && f.y <= p && Cu(i, a, s, l, o, u, f.x, f.y) && Eu(f.prev, f, f.next) >= 0) return !1;
		f = f.next;
	}
	return !0;
}
function mu(e, t, n, r) {
	var i = e.prev,
		s = e,
		o = e.next;
	if (Eu(i, s, o) >= 0) return !1;
	for (
		var a = i.x,
			l = s.x,
			u = o.x,
			c = i.y,
			h = s.y,
			d = o.y,
			p = a < l ? (a < u ? a : u) : l < u ? l : u,
			f = c < h ? (c < d ? c : d) : h < d ? h : d,
			m = a > l ? (a > u ? a : u) : l > u ? l : u,
			v = c > h ? (c > d ? c : d) : h > d ? h : d,
			g = _u(p, f, t, n, r),
			y = _u(m, v, t, n, r),
			b = e.prevZ,
			x = e.nextZ;
		b && b.z >= g && x && x.z <= y;

	) {
		if (b.x >= p && b.x <= m && b.y >= f && b.y <= v && b !== i && b !== o && Cu(a, c, l, h, u, d, b.x, b.y) && Eu(b.prev, b, b.next) >= 0) return !1;
		if (((b = b.prevZ), x.x >= p && x.x <= m && x.y >= f && x.y <= v && x !== i && x !== o && Cu(a, c, l, h, u, d, x.x, x.y) && Eu(x.prev, x, x.next) >= 0)) return !1;
		x = x.nextZ;
	}
	for (; b && b.z >= g; ) {
		if (b.x >= p && b.x <= m && b.y >= f && b.y <= v && b !== i && b !== o && Cu(a, c, l, h, u, d, b.x, b.y) && Eu(b.prev, b, b.next) >= 0) return !1;
		b = b.prevZ;
	}
	for (; x && x.z <= y; ) {
		if (x.x >= p && x.x <= m && x.y >= f && x.y <= v && x !== i && x !== o && Cu(a, c, l, h, u, d, x.x, x.y) && Eu(x.prev, x, x.next) >= 0) return !1;
		x = x.nextZ;
	}
	return !0;
}
function vu(e, t, n) {
	var r = e;
	do {
		var i = r.prev,
			s = r.next.next;
		!Tu(i, s) && ku(i, r, r.next, s) && Iu(i, s) && Iu(s, i) && (t.push((i.i / n) | 0), t.push((r.i / n) | 0), t.push((s.i / n) | 0), Ou(r), Ou(r.next), (r = e = s)), (r = r.next);
	} while (r !== e);
	return du(r);
}
function gu(e, t, n, r, i, s) {
	var o = e;
	do {
		for (var a = o.next.next; a !== o.prev; ) {
			if (o.i !== a.i && Su(o, a)) {
				var l = Ru(o, a);
				return (o = du(o, o.next)), (l = du(l, l.next)), pu(o, t, n, r, i, s, 0), void pu(l, t, n, r, i, s, 0);
			}
			a = a.next;
		}
		o = o.next;
	} while (o !== e);
}
function yu(e, t) {
	return e.x - t.x;
}
function bu(e, t) {
	var n = (function (e, t) {
		var n,
			r = t,
			i = e.x,
			s = e.y,
			o = -1 / 0;
		do {
			if (s <= r.y && s >= r.next.y && r.next.y !== r.y) {
				var a = r.x + ((s - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
				if (a <= i && a > o && ((o = a), (n = r.x < r.next.x ? r : r.next), a === i)) return n;
			}
			r = r.next;
		} while (r !== t);
		if (!n) return null;
		var l,
			u = n,
			c = n.x,
			h = n.y,
			d = 1 / 0;
		r = n;
		do {
			i >= r.x && r.x >= c && i !== r.x && Cu(s < h ? i : o, s, c, h, s < h ? o : i, s, r.x, r.y) && ((l = Math.abs(s - r.y) / (i - r.x)), Iu(r, e) && (l < d || (l === d && (r.x > n.x || (r.x === n.x && xu(n, r))))) && ((n = r), (d = l))), (r = r.next);
		} while (r !== u);
		return n;
	})(e, t);
	if (!n) return t;
	var r = Ru(n, e);
	return du(r, r.next), du(n, n.next);
}
function xu(e, t) {
	return Eu(e.prev, e, t.prev) < 0 && Eu(t.next, e, e.next) < 0;
}
function _u(e, t, n, r, i) {
	return (
		(e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = ((e - n) * i) | 0) | (e << 8))) | (e << 4))) | (e << 2))) | (e << 1))) |
		((t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = ((t - r) * i) | 0) | (t << 8))) | (t << 4))) | (t << 2))) | (t << 1))) << 1)
	);
}
function wu(e) {
	var t = e,
		n = e;
	do {
		(t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
	} while (t !== e);
	return n;
}
function Cu(e, t, n, r, i, s, o, a) {
	return (i - o) * (t - a) >= (e - o) * (s - a) && (e - o) * (r - a) >= (n - o) * (t - a) && (n - o) * (s - a) >= (i - o) * (r - a);
}
function Su(e, t) {
	return (
		e.next.i !== t.i &&
		e.prev.i !== t.i &&
		!(function (e, t) {
			var n = e;
			do {
				if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && ku(n, n.next, e, t)) return !0;
				n = n.next;
			} while (n !== e);
			return !1;
		})(e, t) &&
		((Iu(e, t) &&
			Iu(t, e) &&
			(function (e, t) {
				var n = e,
					r = !1,
					i = (e.x + t.x) / 2,
					s = (e.y + t.y) / 2;
				do {
					n.y > s != n.next.y > s && n.next.y !== n.y && i < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x && (r = !r), (n = n.next);
				} while (n !== e);
				return r;
			})(e, t) &&
			(Eu(e.prev, e, t.prev) || Eu(e, t.prev, t))) ||
			(Tu(e, t) && Eu(e.prev, e, e.next) > 0 && Eu(t.prev, t, t.next) > 0))
	);
}
function Eu(e, t, n) {
	return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
}
function Tu(e, t) {
	return e.x === t.x && e.y === t.y;
}
function ku(e, t, n, r) {
	var i = Mu(Eu(e, t, n)),
		s = Mu(Eu(e, t, r)),
		o = Mu(Eu(n, r, e)),
		a = Mu(Eu(n, r, t));
	return (i !== s && o !== a) || !(0 !== i || !Au(e, n, t)) || !(0 !== s || !Au(e, r, t)) || !(0 !== o || !Au(n, e, r)) || !(0 !== a || !Au(n, t, r));
}
function Au(e, t, n) {
	return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);
}
function Mu(e) {
	return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function Iu(e, t) {
	return Eu(e.prev, e, e.next) < 0 ? Eu(e, t, e.next) >= 0 && Eu(e, e.prev, t) >= 0 : Eu(e, t, e.prev) < 0 || Eu(e, e.next, t) < 0;
}
function Ru(e, t) {
	var n = new Pu(e.i, e.x, e.y),
		r = new Pu(t.i, t.x, t.y),
		i = e.next,
		s = t.prev;
	return (e.next = t), (t.prev = e), (n.next = i), (i.prev = n), (r.next = n), (n.prev = r), (s.next = r), (r.prev = s), r;
}
function Lu(e, t, n, r) {
	var i = new Pu(e, t, n);
	return r ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i)) : ((i.prev = i), (i.next = i)), i;
}
function Ou(e) {
	(e.next.prev = e.prev), (e.prev.next = e.next), e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function Pu(e, t, n) {
	(this.i = e), (this.x = t), (this.y = n), (this.prev = null), (this.next = null), (this.z = 0), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
}
function Nu(e, t, n, r) {
	for (var i = 0, s = t, o = n - r; s < n; s += r) (i += (e[o] - e[s]) * (e[s + 1] + e[o + 1])), (o = s);
	return i;
}
(uu.exports = cu),
	(uu.exports.default = cu),
	(cu.deviation = function (e, t, n, r) {
		var i = t && t.length,
			s = i ? t[0] * n : e.length,
			o = Math.abs(Nu(e, 0, s, n));
		if (i)
			for (var a = 0, l = t.length; a < l; a++) {
				var u = t[a] * n,
					c = a < l - 1 ? t[a + 1] * n : e.length;
				o -= Math.abs(Nu(e, u, c, n));
			}
		var h = 0;
		for (a = 0; a < r.length; a += 3) {
			var d = r[a] * n,
				p = r[a + 1] * n,
				f = r[a + 2] * n;
			h += Math.abs((e[d] - e[f]) * (e[p + 1] - e[d + 1]) - (e[d] - e[p]) * (e[f + 1] - e[d + 1]));
		}
		return 0 === o && 0 === h ? 0 : Math.abs((h - o) / o);
	}),
	(cu.flatten = function (e) {
		for (var t = e[0][0].length, n = { vertices: [], holes: [], dimensions: t }, r = 0, i = 0; i < e.length; i++) {
			for (var s = 0; s < e[i].length; s++) for (var o = 0; o < t; o++) n.vertices.push(e[i][s][o]);
			i > 0 && ((r += e[i - 1].length), n.holes.push(r));
		}
		return n;
	});
var Du,
	Bu,
	Fu = uu.exports,
	Hu = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(Du = Hu),
	(Bu = Hu.exports),
	(function (e) {
		var t = Bu && !Bu.nodeType && Bu,
			n = Du && !Du.nodeType && Du,
			r = "object" == typeof Jo && Jo;
		(r.global !== r && r.window !== r && r.self !== r) || (e = r);
		var i,
			s,
			o = 2147483647,
			a = 36,
			l = /^xn--/,
			u = /[^\x20-\x7E]/,
			c = /[\x2E\u3002\uFF0E\uFF61]/g,
			h = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" },
			d = Math.floor,
			p = String.fromCharCode;
		function f(e) {
			throw RangeError(h[e]);
		}
		function m(e, t) {
			for (var n = e.length, r = []; n--; ) r[n] = t(e[n]);
			return r;
		}
		function v(e, t) {
			var n = e.split("@"),
				r = "";
			return n.length > 1 && ((r = n[0] + "@"), (e = n[1])), r + m((e = e.replace(c, ".")).split("."), t).join(".");
		}
		function g(e) {
			for (var t, n, r = [], i = 0, s = e.length; i < s; ) (t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < s ? (56320 == (64512 & (n = e.charCodeAt(i++))) ? r.push(((1023 & t) << 10) + (1023 & n) + 65536) : (r.push(t), i--)) : r.push(t);
			return r;
		}
		function y(e) {
			return m(e, function (e) {
				var t = "";
				return e > 65535 && ((t += p((((e -= 65536) >>> 10) & 1023) | 55296)), (e = 56320 | (1023 & e))), (t += p(e));
			}).join("");
		}
		function b(e, t) {
			return e + 22 + 75 * (e < 26) - ((0 != t) << 5);
		}
		function x(e, t, n) {
			var r = 0;
			for (e = n ? d(e / 700) : e >> 1, e += d(e / t); e > 455; r += a) e = d(e / 35);
			return d(r + (36 * e) / (e + 38));
		}
		function _(e) {
			var t,
				n,
				r,
				i,
				s,
				l,
				u,
				c,
				h,
				p,
				m,
				v = [],
				g = e.length,
				b = 0,
				_ = 128,
				w = 72;
			for ((n = e.lastIndexOf("-")) < 0 && (n = 0), r = 0; r < n; ++r) e.charCodeAt(r) >= 128 && f("not-basic"), v.push(e.charCodeAt(r));
			for (i = n > 0 ? n + 1 : 0; i < g; ) {
				for (s = b, l = 1, u = a; i >= g && f("invalid-input"), ((c = (m = e.charCodeAt(i++)) - 48 < 10 ? m - 22 : m - 65 < 26 ? m - 65 : m - 97 < 26 ? m - 97 : a) >= a || c > d((o - b) / l)) && f("overflow"), (b += c * l), !(c < (h = u <= w ? 1 : u >= w + 26 ? 26 : u - w)); u += a)
					l > d(o / (p = a - h)) && f("overflow"), (l *= p);
				(w = x(b - s, (t = v.length + 1), 0 == s)), d(b / t) > o - _ && f("overflow"), (_ += d(b / t)), (b %= t), v.splice(b++, 0, _);
			}
			return y(v);
		}
		function w(e) {
			var t,
				n,
				r,
				i,
				s,
				l,
				u,
				c,
				h,
				m,
				v,
				y,
				_,
				w,
				C,
				S = [];
			for (y = (e = g(e)).length, t = 128, n = 0, s = 72, l = 0; l < y; ++l) (v = e[l]) < 128 && S.push(p(v));
			for (r = i = S.length, i && S.push("-"); r < y; ) {
				for (u = o, l = 0; l < y; ++l) (v = e[l]) >= t && v < u && (u = v);
				for (u - t > d((o - n) / (_ = r + 1)) && f("overflow"), n += (u - t) * _, t = u, l = 0; l < y; ++l)
					if (((v = e[l]) < t && ++n > o && f("overflow"), v == t)) {
						for (c = n, h = a; !(c < (m = h <= s ? 1 : h >= s + 26 ? 26 : h - s)); h += a) (C = c - m), (w = a - m), S.push(p(b(m + (C % w), 0))), (c = d(C / w));
						S.push(p(b(c, 0))), (s = x(n, _, r == i)), (n = 0), ++r;
					}
				++n, ++t;
			}
			return S.join("");
		}
		if (
			((i = {
				version: "1.3.2",
				ucs2: { decode: g, encode: y },
				decode: _,
				encode: w,
				toASCII: function (e) {
					return v(e, function (e) {
						return u.test(e) ? "xn--" + w(e) : e;
					});
				},
				toUnicode: function (e) {
					return v(e, function (e) {
						return l.test(e) ? _(e.slice(4).toLowerCase()) : e;
					});
				}
			}),
			t && n)
		)
			if (Du.exports == t) n.exports = i;
			else for (s in i) i.hasOwnProperty(s) && (t[s] = i[s]);
		else e.punycode = i;
	})(Jo);
var Vu = {};
function Uu(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t);
}
var zu = function (e) {
	switch (typeof e) {
		case "string":
			return e;
		case "boolean":
			return e ? "true" : "false";
		case "number":
			return isFinite(e) ? e : "";
		default:
			return "";
	}
};
(Vu.decode = Vu.parse =
	function (e, t, n, r) {
		(t = t || "&"), (n = n || "=");
		var i = {};
		if ("string" != typeof e || 0 === e.length) return i;
		var s = /\+/g;
		e = e.split(t);
		var o = 1e3;
		r && "number" == typeof r.maxKeys && (o = r.maxKeys);
		var a = e.length;
		o > 0 && a > o && (a = o);
		for (var l = 0; l < a; ++l) {
			var u,
				c,
				h,
				d,
				p = e[l].replace(s, "%20"),
				f = p.indexOf(n);
			f >= 0 ? ((u = p.substr(0, f)), (c = p.substr(f + 1))) : ((u = p), (c = "")), (h = decodeURIComponent(u)), (d = decodeURIComponent(c)), Uu(i, h) ? (Array.isArray(i[h]) ? i[h].push(d) : (i[h] = [i[h], d])) : (i[h] = d);
		}
		return i;
	}),
	(Vu.encode = Vu.stringify =
		function (e, t, n, r) {
			return (
				(t = t || "&"),
				(n = n || "="),
				null === e && (e = void 0),
				"object" == typeof e
					? Object.keys(e)
							.map(function (r) {
								var i = encodeURIComponent(zu(r)) + n;
								return Array.isArray(e[r])
									? e[r]
											.map(function (e) {
												return i + encodeURIComponent(zu(e));
											})
											.join(t)
									: i + encodeURIComponent(zu(e[r]));
							})
							.join(t)
					: r
					? encodeURIComponent(zu(r)) + n + encodeURIComponent(zu(e))
					: ""
			);
		});
var $u = Hu.exports,
	ju = {
		isString: function (e) {
			return "string" == typeof e;
		},
		isObject: function (e) {
			return "object" == typeof e && null !== e;
		},
		isNull: function (e) {
			return null === e;
		},
		isNullOrUndefined: function (e) {
			return null == e;
		}
	},
	Wu = lc,
	Gu = function (e, t) {
		return lc(e, !1, !0).resolve(t);
	},
	Yu = function (e) {
		ju.isString(e) && (e = lc(e));
		return e instanceof Xu ? e.format() : Xu.prototype.format.call(e);
	};
function Xu() {
	(this.protocol = null), (this.slashes = null), (this.auth = null), (this.host = null), (this.port = null), (this.hostname = null), (this.hash = null), (this.search = null), (this.query = null), (this.pathname = null), (this.path = null), (this.href = null);
}
var Ku = /^([a-z0-9.+-]+:)/i,
	qu = /:[0-9]*$/,
	Zu = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	Ju = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
	Qu = ["'"].concat(Ju),
	ec = ["%", "/", "?", ";", "#"].concat(Qu),
	tc = ["/", "?", "#"],
	nc = /^[+a-z0-9A-Z_-]{0,63}$/,
	rc = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	ic = { javascript: !0, "javascript:": !0 },
	sc = { javascript: !0, "javascript:": !0 },
	oc = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 },
	ac = Vu;
function lc(e, t, n) {
	if (e && ju.isObject(e) && e instanceof Xu) return e;
	var r = new Xu();
	return r.parse(e, t, n), r;
}
(Xu.prototype.parse = function (e, t, n) {
	if (!ju.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
	var r = e.indexOf("?"),
		i = -1 !== r && r < e.indexOf("#") ? "?" : "#",
		s = e.split(i);
	s[0] = s[0].replace(/\\/g, "/");
	var o = (e = s.join(i));
	if (((o = o.trim()), !n && 1 === e.split("#").length)) {
		var a = Zu.exec(o);
		if (a) return (this.path = o), (this.href = o), (this.pathname = a[1]), a[2] ? ((this.search = a[2]), (this.query = t ? ac.parse(this.search.substr(1)) : this.search.substr(1))) : t && ((this.search = ""), (this.query = {})), this;
	}
	var l = Ku.exec(o);
	if (l) {
		var u = (l = l[0]).toLowerCase();
		(this.protocol = u), (o = o.substr(l.length));
	}
	if (n || l || o.match(/^\/\/[^@\/]+@[^@\/]+/)) {
		var c = "//" === o.substr(0, 2);
		!c || (l && sc[l]) || ((o = o.substr(2)), (this.slashes = !0));
	}
	if (!sc[l] && (c || (l && !oc[l]))) {
		for (var h, d, p = -1, f = 0; f < tc.length; f++) {
			-1 !== (m = o.indexOf(tc[f])) && (-1 === p || m < p) && (p = m);
		}
		-1 !== (d = -1 === p ? o.lastIndexOf("@") : o.lastIndexOf("@", p)) && ((h = o.slice(0, d)), (o = o.slice(d + 1)), (this.auth = decodeURIComponent(h))), (p = -1);
		for (f = 0; f < ec.length; f++) {
			var m;
			-1 !== (m = o.indexOf(ec[f])) && (-1 === p || m < p) && (p = m);
		}
		-1 === p && (p = o.length), (this.host = o.slice(0, p)), (o = o.slice(p)), this.parseHost(), (this.hostname = this.hostname || "");
		var v = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
		if (!v)
			for (var g = this.hostname.split(/\./), y = ((f = 0), g.length); f < y; f++) {
				var b = g[f];
				if (b && !b.match(nc)) {
					for (var x = "", _ = 0, w = b.length; _ < w; _++) b.charCodeAt(_) > 127 ? (x += "x") : (x += b[_]);
					if (!x.match(nc)) {
						var C = g.slice(0, f),
							S = g.slice(f + 1),
							E = b.match(rc);
						E && (C.push(E[1]), S.unshift(E[2])), S.length && (o = "/" + S.join(".") + o), (this.hostname = C.join("."));
						break;
					}
				}
			}
		this.hostname.length > 255 ? (this.hostname = "") : (this.hostname = this.hostname.toLowerCase()), v || (this.hostname = $u.toASCII(this.hostname));
		var T = this.port ? ":" + this.port : "",
			k = this.hostname || "";
		(this.host = k + T), (this.href += this.host), v && ((this.hostname = this.hostname.substr(1, this.hostname.length - 2)), "/" !== o[0] && (o = "/" + o));
	}
	if (!ic[u])
		for (f = 0, y = Qu.length; f < y; f++) {
			var A = Qu[f];
			if (-1 !== o.indexOf(A)) {
				var M = encodeURIComponent(A);
				M === A && (M = escape(A)), (o = o.split(A).join(M));
			}
		}
	var I = o.indexOf("#");
	-1 !== I && ((this.hash = o.substr(I)), (o = o.slice(0, I)));
	var R = o.indexOf("?");
	if (
		(-1 !== R ? ((this.search = o.substr(R)), (this.query = o.substr(R + 1)), t && (this.query = ac.parse(this.query)), (o = o.slice(0, R))) : t && ((this.search = ""), (this.query = {})),
		o && (this.pathname = o),
		oc[u] && this.hostname && !this.pathname && (this.pathname = "/"),
		this.pathname || this.search)
	) {
		T = this.pathname || "";
		var L = this.search || "";
		this.path = T + L;
	}
	return (this.href = this.format()), this;
}),
	(Xu.prototype.format = function () {
		var e = this.auth || "";
		e && ((e = (e = encodeURIComponent(e)).replace(/%3A/i, ":")), (e += "@"));
		var t = this.protocol || "",
			n = this.pathname || "",
			r = this.hash || "",
			i = !1,
			s = "";
		this.host ? (i = e + this.host) : this.hostname && ((i = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]")), this.port && (i += ":" + this.port)), this.query && ju.isObject(this.query) && Object.keys(this.query).length && (s = ac.stringify(this.query));
		var o = this.search || (s && "?" + s) || "";
		return (
			t && ":" !== t.substr(-1) && (t += ":"),
			this.slashes || ((!t || oc[t]) && !1 !== i) ? ((i = "//" + (i || "")), n && "/" !== n.charAt(0) && (n = "/" + n)) : i || (i = ""),
			r && "#" !== r.charAt(0) && (r = "#" + r),
			o && "?" !== o.charAt(0) && (o = "?" + o),
			t +
				i +
				(n = n.replace(/[?#]/g, function (e) {
					return encodeURIComponent(e);
				})) +
				(o = o.replace("#", "%23")) +
				r
		);
	}),
	(Xu.prototype.resolve = function (e) {
		return this.resolveObject(lc(e, !1, !0)).format();
	}),
	(Xu.prototype.resolveObject = function (e) {
		if (ju.isString(e)) {
			var t = new Xu();
			t.parse(e, !1, !0), (e = t);
		}
		for (var n = new Xu(), r = Object.keys(this), i = 0; i < r.length; i++) {
			var s = r[i];
			n[s] = this[s];
		}
		if (((n.hash = e.hash), "" === e.href)) return (n.href = n.format()), n;
		if (e.slashes && !e.protocol) {
			for (var o = Object.keys(e), a = 0; a < o.length; a++) {
				var l = o[a];
				"protocol" !== l && (n[l] = e[l]);
			}
			return oc[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"), (n.href = n.format()), n;
		}
		if (e.protocol && e.protocol !== n.protocol) {
			if (!oc[e.protocol]) {
				for (var u = Object.keys(e), c = 0; c < u.length; c++) {
					var h = u[c];
					n[h] = e[h];
				}
				return (n.href = n.format()), n;
			}
			if (((n.protocol = e.protocol), e.host || sc[e.protocol])) n.pathname = e.pathname;
			else {
				for (var d = (e.pathname || "").split("/"); d.length && !(e.host = d.shift()); );
				e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== d[0] && d.unshift(""), d.length < 2 && d.unshift(""), (n.pathname = d.join("/"));
			}
			if (((n.search = e.search), (n.query = e.query), (n.host = e.host || ""), (n.auth = e.auth), (n.hostname = e.hostname || e.host), (n.port = e.port), n.pathname || n.search)) {
				var p = n.pathname || "",
					f = n.search || "";
				n.path = p + f;
			}
			return (n.slashes = n.slashes || e.slashes), (n.href = n.format()), n;
		}
		var m = n.pathname && "/" === n.pathname.charAt(0),
			v = e.host || (e.pathname && "/" === e.pathname.charAt(0)),
			g = v || m || (n.host && e.pathname),
			y = g,
			b = (n.pathname && n.pathname.split("/")) || [],
			x = ((d = (e.pathname && e.pathname.split("/")) || []), n.protocol && !oc[n.protocol]);
		if (
			(x &&
				((n.hostname = ""),
				(n.port = null),
				n.host && ("" === b[0] ? (b[0] = n.host) : b.unshift(n.host)),
				(n.host = ""),
				e.protocol && ((e.hostname = null), (e.port = null), e.host && ("" === d[0] ? (d[0] = e.host) : d.unshift(e.host)), (e.host = null)),
				(g = g && ("" === d[0] || "" === b[0]))),
			v)
		)
			(n.host = e.host || "" === e.host ? e.host : n.host), (n.hostname = e.hostname || "" === e.hostname ? e.hostname : n.hostname), (n.search = e.search), (n.query = e.query), (b = d);
		else if (d.length) b || (b = []), b.pop(), (b = b.concat(d)), (n.search = e.search), (n.query = e.query);
		else if (!ju.isNullOrUndefined(e.search)) {
			if (x) (n.hostname = n.host = b.shift()), (E = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && ((n.auth = E.shift()), (n.host = n.hostname = E.shift()));
			return (n.search = e.search), (n.query = e.query), (ju.isNull(n.pathname) && ju.isNull(n.search)) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), (n.href = n.format()), n;
		}
		if (!b.length) return (n.pathname = null), n.search ? (n.path = "/" + n.search) : (n.path = null), (n.href = n.format()), n;
		for (var _ = b.slice(-1)[0], w = ((n.host || e.host || b.length > 1) && ("." === _ || ".." === _)) || "" === _, C = 0, S = b.length; S >= 0; S--) "." === (_ = b[S]) ? b.splice(S, 1) : ".." === _ ? (b.splice(S, 1), C++) : C && (b.splice(S, 1), C--);
		if (!g && !y) for (; C--; C) b.unshift("..");
		!g || "" === b[0] || (b[0] && "/" === b[0].charAt(0)) || b.unshift(""), w && "/" !== b.join("/").substr(-1) && b.push("");
		var E,
			T = "" === b[0] || (b[0] && "/" === b[0].charAt(0));
		x && ((n.hostname = n.host = T ? "" : b.length ? b.shift() : ""), (E = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && ((n.auth = E.shift()), (n.host = n.hostname = E.shift())));
		return (
			(g = g || (n.host && b.length)) && !T && b.unshift(""),
			b.length ? (n.pathname = b.join("/")) : ((n.pathname = null), (n.path = null)),
			(ju.isNull(n.pathname) && ju.isNull(n.search)) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
			(n.auth = e.auth || n.auth),
			(n.slashes = n.slashes || e.slashes),
			(n.href = n.format()),
			n
		);
	}),
	(Xu.prototype.parseHost = function () {
		var e = this.host,
			t = qu.exec(e);
		t && (":" !== (t = t[0]) && (this.port = t.substr(1)), (e = e.substr(0, e.length - t.length))), e && (this.hostname = e);
	});
const uc = { parse: Wu, format: Yu, resolve: Gu };
function cc(e) {
	if ("string" != typeof e) throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`);
}
function hc(e) {
	return e.split("?")[0].split("#")[0];
}
const dc = {
		toPosix(e) {
			return (t = "\\"), (n = "/"), e.replace(new RegExp(t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), n);
			var t, n;
		},
		isUrl(e) {
			return /^https?:/.test(this.toPosix(e));
		},
		isDataUrl: (e) => /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e),
		hasProtocol(e) {
			return /^[^/:]+:\//.test(this.toPosix(e));
		},
		getProtocol(e) {
			cc(e), (e = this.toPosix(e));
			let t = "";
			const n = /^file:\/\/\//.exec(e),
				r = /^[^/:]+:\/\//.exec(e),
				i = /^[^/:]+:\//.exec(e);
			if (n || r || i) {
				const s = (null == n ? void 0 : n[0]) || (null == r ? void 0 : r[0]) || (null == i ? void 0 : i[0]);
				(t = s), (e = e.slice(s.length));
			}
			return t;
		},
		toAbsolute(e, t, n) {
			if (this.isDataUrl(e)) return e;
			const r = hc(this.toPosix(null != t ? t : su.ADAPTER.getBaseUrl())),
				i = hc(this.toPosix(null != n ? n : this.rootname(r)));
			if ((cc(e), (e = this.toPosix(e)).startsWith("/"))) return dc.join(i, e.slice(1));
			return this.isAbsolute(e) ? e : this.join(r, e);
		},
		normalize(e) {
			if ((cc((e = this.toPosix(e))), 0 === e.length)) return ".";
			let t = "";
			const n = e.startsWith("/");
			this.hasProtocol(e) && ((t = this.rootname(e)), (e = e.slice(t.length)));
			const r = e.endsWith("/");
			return (
				(e = (function (e, t) {
					let n = "",
						r = 0,
						i = -1,
						s = 0,
						o = -1;
					for (let a = 0; a <= e.length; ++a) {
						if (a < e.length) o = e.charCodeAt(a);
						else {
							if (47 === o) break;
							o = 47;
						}
						if (47 === o) {
							if (i === a - 1 || 1 === s);
							else if (i !== a - 1 && 2 === s) {
								if (n.length < 2 || 2 !== r || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2))
									if (n.length > 2) {
										const e = n.lastIndexOf("/");
										if (e !== n.length - 1) {
											-1 === e ? ((n = ""), (r = 0)) : ((n = n.slice(0, e)), (r = n.length - 1 - n.lastIndexOf("/"))), (i = a), (s = 0);
											continue;
										}
									} else if (2 === n.length || 1 === n.length) {
										(n = ""), (r = 0), (i = a), (s = 0);
										continue;
									}
								t && (n.length > 0 ? (n += "/..") : (n = ".."), (r = 2));
							} else n.length > 0 ? (n += `/${e.slice(i + 1, a)}`) : (n = e.slice(i + 1, a)), (r = a - i - 1);
							(i = a), (s = 0);
						} else 46 === o && -1 !== s ? ++s : (s = -1);
					}
					return n;
				})(e, !1)).length > 0 &&
					r &&
					(e += "/"),
				n ? `/${e}` : t + e
			);
		},
		isAbsolute(e) {
			return cc(e), (e = this.toPosix(e)), !!this.hasProtocol(e) || e.startsWith("/");
		},
		join(...e) {
			var t;
			if (0 === e.length) return ".";
			let n;
			for (let r = 0; r < e.length; ++r) {
				const i = e[r];
				if ((cc(i), i.length > 0))
					if (void 0 === n) n = i;
					else {
						const s = null != (t = e[r - 1]) ? t : "";
						this.extname(s) ? (n += `/../${i}`) : (n += `/${i}`);
					}
			}
			return void 0 === n ? "." : this.normalize(n);
		},
		dirname(e) {
			if ((cc(e), 0 === e.length)) return ".";
			let t = (e = this.toPosix(e)).charCodeAt(0);
			const n = 47 === t;
			let r = -1,
				i = !0;
			const s = this.getProtocol(e),
				o = e;
			for (let a = (e = e.slice(s.length)).length - 1; a >= 1; --a)
				if (((t = e.charCodeAt(a)), 47 === t)) {
					if (!i) {
						r = a;
						break;
					}
				} else i = !1;
			return -1 === r ? (n ? "/" : this.isUrl(o) ? s + e : s) : n && 1 === r ? "//" : s + e.slice(0, r);
		},
		rootname(e) {
			cc(e);
			let t = "";
			if (((t = (e = this.toPosix(e)).startsWith("/") ? "/" : this.getProtocol(e)), this.isUrl(e))) {
				const n = e.indexOf("/", t.length);
				(t = -1 !== n ? e.slice(0, n) : e), t.endsWith("/") || (t += "/");
			}
			return t;
		},
		basename(e, t) {
			cc(e), t && cc(t), (e = hc(this.toPosix(e)));
			let n,
				r = 0,
				i = -1,
				s = !0;
			if (void 0 !== t && t.length > 0 && t.length <= e.length) {
				if (t.length === e.length && t === e) return "";
				let o = t.length - 1,
					a = -1;
				for (n = e.length - 1; n >= 0; --n) {
					const l = e.charCodeAt(n);
					if (47 === l) {
						if (!s) {
							r = n + 1;
							break;
						}
					} else -1 === a && ((s = !1), (a = n + 1)), o >= 0 && (l === t.charCodeAt(o) ? -1 == --o && (i = n) : ((o = -1), (i = a)));
				}
				return r === i ? (i = a) : -1 === i && (i = e.length), e.slice(r, i);
			}
			for (n = e.length - 1; n >= 0; --n)
				if (47 === e.charCodeAt(n)) {
					if (!s) {
						r = n + 1;
						break;
					}
				} else -1 === i && ((s = !1), (i = n + 1));
			return -1 === i ? "" : e.slice(r, i);
		},
		extname(e) {
			cc(e);
			let t = -1,
				n = 0,
				r = -1,
				i = !0,
				s = 0;
			for (let o = (e = hc(this.toPosix(e))).length - 1; o >= 0; --o) {
				const a = e.charCodeAt(o);
				if (47 !== a) -1 === r && ((i = !1), (r = o + 1)), 46 === a ? (-1 === t ? (t = o) : 1 !== s && (s = 1)) : -1 !== t && (s = -1);
				else if (!i) {
					n = o + 1;
					break;
				}
			}
			return -1 === t || -1 === r || 0 === s || (1 === s && t === r - 1 && t === n + 1) ? "" : e.slice(t, r);
		},
		parse(e) {
			cc(e);
			const t = { root: "", dir: "", base: "", ext: "", name: "" };
			if (0 === e.length) return t;
			let n = (e = hc(this.toPosix(e))).charCodeAt(0);
			const r = this.isAbsolute(e);
			let i;
			(t.root = this.rootname(e)), (i = r || this.hasProtocol(e) ? 1 : 0);
			let s = -1,
				o = 0,
				a = -1,
				l = !0,
				u = e.length - 1,
				c = 0;
			for (; u >= i; --u)
				if (((n = e.charCodeAt(u)), 47 !== n)) -1 === a && ((l = !1), (a = u + 1)), 46 === n ? (-1 === s ? (s = u) : 1 !== c && (c = 1)) : -1 !== s && (c = -1);
				else if (!l) {
					o = u + 1;
					break;
				}
			return (
				-1 === s || -1 === a || 0 === c || (1 === c && s === a - 1 && s === o + 1)
					? -1 !== a && (t.base = t.name = 0 === o && r ? e.slice(1, a) : e.slice(o, a))
					: (0 === o && r ? ((t.name = e.slice(1, s)), (t.base = e.slice(1, a))) : ((t.name = e.slice(o, s)), (t.base = e.slice(o, a))), (t.ext = e.slice(s, a))),
				(t.dir = this.dirname(e)),
				t
			);
		},
		sep: "/",
		delimiter: ":"
	},
	pc = {};
function fc(e, t, n = 3) {
	if (pc[t]) return;
	let r = new Error().stack;
	void 0 === r
		? console.warn("PixiJS Deprecation Warning: ", `${t}\nDeprecated since v${e}`)
		: ((r = r.split("\n").splice(n).join("\n")),
		  console.groupCollapsed
				? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}\nDeprecated since v${e}`), console.warn(r), console.groupEnd())
				: (console.warn("PixiJS Deprecation Warning: ", `${t}\nDeprecated since v${e}`), console.warn(r))),
		(pc[t] = !0);
}
let mc;
function vc() {
	return (
		void 0 === mc &&
			(mc = (function () {
				var e;
				const t = { stencil: !0, failIfMajorPerformanceCaveat: su.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
				try {
					if (!su.ADAPTER.getWebGLRenderingContext()) return !1;
					const n = su.ADAPTER.createCanvas();
					let r = n.getContext("webgl", t) || n.getContext("experimental-webgl", t);
					const i = !!(null == (e = null == r ? void 0 : r.getContextAttributes()) ? void 0 : e.stencil);
					if (r) {
						const e = r.getExtension("WEBGL_lose_context");
						e && e.loseContext();
					}
					return (r = null), i;
				} catch (Kj) {
					return !1;
				}
			})()),
		mc
	);
}
var gc = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
	yc = function (e) {
		return "string" == typeof e ? e.length > 0 : "number" == typeof e;
	},
	bc = function (e, t, n) {
		return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * e) / n + 0;
	},
	xc = function (e, t, n) {
		return void 0 === t && (t = 0), void 0 === n && (n = 1), e > n ? n : e > t ? e : t;
	},
	_c = function (e) {
		return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360;
	},
	wc = function (e) {
		return { r: xc(e.r, 0, 255), g: xc(e.g, 0, 255), b: xc(e.b, 0, 255), a: xc(e.a) };
	},
	Cc = function (e) {
		return { r: bc(e.r), g: bc(e.g), b: bc(e.b), a: bc(e.a, 3) };
	},
	Sc = /^#([0-9a-f]{3,8})$/i,
	Ec = function (e) {
		var t = e.toString(16);
		return t.length < 2 ? "0" + t : t;
	},
	Tc = function (e) {
		var t = e.r,
			n = e.g,
			r = e.b,
			i = e.a,
			s = Math.max(t, n, r),
			o = s - Math.min(t, n, r),
			a = o ? (s === t ? (n - r) / o : s === n ? 2 + (r - t) / o : 4 + (t - n) / o) : 0;
		return { h: 60 * (a < 0 ? a + 6 : a), s: s ? (o / s) * 100 : 0, v: (s / 255) * 100, a: i };
	},
	kc = function (e) {
		var t = e.h,
			n = e.s,
			r = e.v,
			i = e.a;
		(t = (t / 360) * 6), (n /= 100), (r /= 100);
		var s = Math.floor(t),
			o = r * (1 - n),
			a = r * (1 - (t - s) * n),
			l = r * (1 - (1 - t + s) * n),
			u = s % 6;
		return { r: 255 * [r, a, o, o, l, r][u], g: 255 * [l, r, r, a, o, o][u], b: 255 * [o, o, l, r, r, a][u], a: i };
	},
	Ac = function (e) {
		return { h: _c(e.h), s: xc(e.s, 0, 100), l: xc(e.l, 0, 100), a: xc(e.a) };
	},
	Mc = function (e) {
		return { h: bc(e.h), s: bc(e.s), l: bc(e.l), a: bc(e.a, 3) };
	},
	Ic = function (e) {
		return kc(((n = (t = e).s), { h: t.h, s: (n *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? ((2 * n) / (r + n)) * 100 : 0, v: r + n, a: t.a }));
		var t, n, r;
	},
	Rc = function (e) {
		return { h: (t = Tc(e)).h, s: (i = ((200 - (n = t.s)) * (r = t.v)) / 100) > 0 && i < 200 ? ((n * r) / 100 / (i <= 100 ? i : 200 - i)) * 100 : 0, l: i / 2, a: t.a };
		var t, n, r, i;
	},
	Lc = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
	Oc = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
	Pc = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
	Nc = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
	Dc = {
		string: [
			[
				function (e) {
					var t = Sc.exec(e);
					return t
						? (e = t[1]).length <= 4
							? { r: parseInt(e[0] + e[0], 16), g: parseInt(e[1] + e[1], 16), b: parseInt(e[2] + e[2], 16), a: 4 === e.length ? bc(parseInt(e[3] + e[3], 16) / 255, 2) : 1 }
							: 6 === e.length || 8 === e.length
							? { r: parseInt(e.substr(0, 2), 16), g: parseInt(e.substr(2, 2), 16), b: parseInt(e.substr(4, 2), 16), a: 8 === e.length ? bc(parseInt(e.substr(6, 2), 16) / 255, 2) : 1 }
							: null
						: null;
				},
				"hex"
			],
			[
				function (e) {
					var t = Pc.exec(e) || Nc.exec(e);
					return t ? (t[2] !== t[4] || t[4] !== t[6] ? null : wc({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1) })) : null;
				},
				"rgb"
			],
			[
				function (e) {
					var t = Lc.exec(e) || Oc.exec(e);
					if (!t) return null;
					var n,
						r,
						i = Ac({ h: ((n = t[1]), (r = t[2]), void 0 === r && (r = "deg"), Number(n) * (gc[r] || 1)), s: Number(t[3]), l: Number(t[4]), a: void 0 === t[5] ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
					return Ic(i);
				},
				"hsl"
			]
		],
		object: [
			[
				function (e) {
					var t = e.r,
						n = e.g,
						r = e.b,
						i = e.a,
						s = void 0 === i ? 1 : i;
					return yc(t) && yc(n) && yc(r) ? wc({ r: Number(t), g: Number(n), b: Number(r), a: Number(s) }) : null;
				},
				"rgb"
			],
			[
				function (e) {
					var t = e.h,
						n = e.s,
						r = e.l,
						i = e.a,
						s = void 0 === i ? 1 : i;
					if (!yc(t) || !yc(n) || !yc(r)) return null;
					var o = Ac({ h: Number(t), s: Number(n), l: Number(r), a: Number(s) });
					return Ic(o);
				},
				"hsl"
			],
			[
				function (e) {
					var t = e.h,
						n = e.s,
						r = e.v,
						i = e.a,
						s = void 0 === i ? 1 : i;
					if (!yc(t) || !yc(n) || !yc(r)) return null;
					var o,
						a = ((o = { h: Number(t), s: Number(n), v: Number(r), a: Number(s) }), { h: _c(o.h), s: xc(o.s, 0, 100), v: xc(o.v, 0, 100), a: xc(o.a) });
					return kc(a);
				},
				"hsv"
			]
		]
	},
	Bc = function (e, t) {
		for (var n = 0; n < t.length; n++) {
			var r = t[n][0](e);
			if (r) return [r, t[n][1]];
		}
		return [null, void 0];
	},
	Fc = function (e, t) {
		var n = Rc(e);
		return { h: n.h, s: xc(n.s + 100 * t, 0, 100), l: n.l, a: n.a };
	},
	Hc = function (e) {
		return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255;
	},
	Vc = function (e, t) {
		var n = Rc(e);
		return { h: n.h, s: n.s, l: xc(n.l + 100 * t, 0, 100), a: n.a };
	},
	Uc = (function () {
		function e(e) {
			(this.parsed = (function (e) {
				return "string" == typeof e ? Bc(e.trim(), Dc.string) : "object" == typeof e && null !== e ? Bc(e, Dc.object) : [null, void 0];
			})(e)[0]),
				(this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
		}
		return (
			(e.prototype.isValid = function () {
				return null !== this.parsed;
			}),
			(e.prototype.brightness = function () {
				return bc(Hc(this.rgba), 2);
			}),
			(e.prototype.isDark = function () {
				return Hc(this.rgba) < 0.5;
			}),
			(e.prototype.isLight = function () {
				return Hc(this.rgba) >= 0.5;
			}),
			(e.prototype.toHex = function () {
				return (t = (e = Cc(this.rgba)).r), (n = e.g), (r = e.b), (s = (i = e.a) < 1 ? Ec(bc(255 * i)) : ""), "#" + Ec(t) + Ec(n) + Ec(r) + s;
				var e, t, n, r, i, s;
			}),
			(e.prototype.toRgb = function () {
				return Cc(this.rgba);
			}),
			(e.prototype.toRgbString = function () {
				return (t = (e = Cc(this.rgba)).r), (n = e.g), (r = e.b), (i = e.a) < 1 ? "rgba(" + t + ", " + n + ", " + r + ", " + i + ")" : "rgb(" + t + ", " + n + ", " + r + ")";
				var e, t, n, r, i;
			}),
			(e.prototype.toHsl = function () {
				return Mc(Rc(this.rgba));
			}),
			(e.prototype.toHslString = function () {
				return (t = (e = Mc(Rc(this.rgba))).h), (n = e.s), (r = e.l), (i = e.a) < 1 ? "hsla(" + t + ", " + n + "%, " + r + "%, " + i + ")" : "hsl(" + t + ", " + n + "%, " + r + "%)";
				var e, t, n, r, i;
			}),
			(e.prototype.toHsv = function () {
				return (e = Tc(this.rgba)), { h: bc(e.h), s: bc(e.s), v: bc(e.v), a: bc(e.a, 3) };
				var e;
			}),
			(e.prototype.invert = function () {
				return zc({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
				var e;
			}),
			(e.prototype.saturate = function (e) {
				return void 0 === e && (e = 0.1), zc(Fc(this.rgba, e));
			}),
			(e.prototype.desaturate = function (e) {
				return void 0 === e && (e = 0.1), zc(Fc(this.rgba, -e));
			}),
			(e.prototype.grayscale = function () {
				return zc(Fc(this.rgba, -1));
			}),
			(e.prototype.lighten = function (e) {
				return void 0 === e && (e = 0.1), zc(Vc(this.rgba, e));
			}),
			(e.prototype.darken = function (e) {
				return void 0 === e && (e = 0.1), zc(Vc(this.rgba, -e));
			}),
			(e.prototype.rotate = function (e) {
				return void 0 === e && (e = 15), this.hue(this.hue() + e);
			}),
			(e.prototype.alpha = function (e) {
				return "number" == typeof e ? zc({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : bc(this.rgba.a, 3);
				var t;
			}),
			(e.prototype.hue = function (e) {
				var t = Rc(this.rgba);
				return "number" == typeof e ? zc({ h: e, s: t.s, l: t.l, a: t.a }) : bc(t.h);
			}),
			(e.prototype.isEqual = function (e) {
				return this.toHex() === zc(e).toHex();
			}),
			e
		);
	})(),
	zc = function (e) {
		return e instanceof Uc ? e : new Uc(e);
	},
	$c = [];
[
	function (e, t) {
		var n = {
				white: "#ffffff",
				bisque: "#ffe4c4",
				blue: "#0000ff",
				cadetblue: "#5f9ea0",
				chartreuse: "#7fff00",
				chocolate: "#d2691e",
				coral: "#ff7f50",
				antiquewhite: "#faebd7",
				aqua: "#00ffff",
				azure: "#f0ffff",
				whitesmoke: "#f5f5f5",
				papayawhip: "#ffefd5",
				plum: "#dda0dd",
				blanchedalmond: "#ffebcd",
				black: "#000000",
				gold: "#ffd700",
				goldenrod: "#daa520",
				gainsboro: "#dcdcdc",
				cornsilk: "#fff8dc",
				cornflowerblue: "#6495ed",
				burlywood: "#deb887",
				aquamarine: "#7fffd4",
				beige: "#f5f5dc",
				crimson: "#dc143c",
				cyan: "#00ffff",
				darkblue: "#00008b",
				darkcyan: "#008b8b",
				darkgoldenrod: "#b8860b",
				darkkhaki: "#bdb76b",
				darkgray: "#a9a9a9",
				darkgreen: "#006400",
				darkgrey: "#a9a9a9",
				peachpuff: "#ffdab9",
				darkmagenta: "#8b008b",
				darkred: "#8b0000",
				darkorchid: "#9932cc",
				darkorange: "#ff8c00",
				darkslateblue: "#483d8b",
				gray: "#808080",
				darkslategray: "#2f4f4f",
				darkslategrey: "#2f4f4f",
				deeppink: "#ff1493",
				deepskyblue: "#00bfff",
				wheat: "#f5deb3",
				firebrick: "#b22222",
				floralwhite: "#fffaf0",
				ghostwhite: "#f8f8ff",
				darkviolet: "#9400d3",
				magenta: "#ff00ff",
				green: "#008000",
				dodgerblue: "#1e90ff",
				grey: "#808080",
				honeydew: "#f0fff0",
				hotpink: "#ff69b4",
				blueviolet: "#8a2be2",
				forestgreen: "#228b22",
				lawngreen: "#7cfc00",
				indianred: "#cd5c5c",
				indigo: "#4b0082",
				fuchsia: "#ff00ff",
				brown: "#a52a2a",
				maroon: "#800000",
				mediumblue: "#0000cd",
				lightcoral: "#f08080",
				darkturquoise: "#00ced1",
				lightcyan: "#e0ffff",
				ivory: "#fffff0",
				lightyellow: "#ffffe0",
				lightsalmon: "#ffa07a",
				lightseagreen: "#20b2aa",
				linen: "#faf0e6",
				mediumaquamarine: "#66cdaa",
				lemonchiffon: "#fffacd",
				lime: "#00ff00",
				khaki: "#f0e68c",
				mediumseagreen: "#3cb371",
				limegreen: "#32cd32",
				mediumspringgreen: "#00fa9a",
				lightskyblue: "#87cefa",
				lightblue: "#add8e6",
				midnightblue: "#191970",
				lightpink: "#ffb6c1",
				mistyrose: "#ffe4e1",
				moccasin: "#ffe4b5",
				mintcream: "#f5fffa",
				lightslategray: "#778899",
				lightslategrey: "#778899",
				navajowhite: "#ffdead",
				navy: "#000080",
				mediumvioletred: "#c71585",
				powderblue: "#b0e0e6",
				palegoldenrod: "#eee8aa",
				oldlace: "#fdf5e6",
				paleturquoise: "#afeeee",
				mediumturquoise: "#48d1cc",
				mediumorchid: "#ba55d3",
				rebeccapurple: "#663399",
				lightsteelblue: "#b0c4de",
				mediumslateblue: "#7b68ee",
				thistle: "#d8bfd8",
				tan: "#d2b48c",
				orchid: "#da70d6",
				mediumpurple: "#9370db",
				purple: "#800080",
				pink: "#ffc0cb",
				skyblue: "#87ceeb",
				springgreen: "#00ff7f",
				palegreen: "#98fb98",
				red: "#ff0000",
				yellow: "#ffff00",
				slateblue: "#6a5acd",
				lavenderblush: "#fff0f5",
				peru: "#cd853f",
				palevioletred: "#db7093",
				violet: "#ee82ee",
				teal: "#008080",
				slategray: "#708090",
				slategrey: "#708090",
				aliceblue: "#f0f8ff",
				darkseagreen: "#8fbc8f",
				darkolivegreen: "#556b2f",
				greenyellow: "#adff2f",
				seagreen: "#2e8b57",
				seashell: "#fff5ee",
				tomato: "#ff6347",
				silver: "#c0c0c0",
				sienna: "#a0522d",
				lavender: "#e6e6fa",
				lightgreen: "#90ee90",
				orange: "#ffa500",
				orangered: "#ff4500",
				steelblue: "#4682b4",
				royalblue: "#4169e1",
				turquoise: "#40e0d0",
				yellowgreen: "#9acd32",
				salmon: "#fa8072",
				saddlebrown: "#8b4513",
				sandybrown: "#f4a460",
				rosybrown: "#bc8f8f",
				darksalmon: "#e9967a",
				lightgoldenrodyellow: "#fafad2",
				snow: "#fffafa",
				lightgrey: "#d3d3d3",
				lightgray: "#d3d3d3",
				dimgray: "#696969",
				dimgrey: "#696969",
				olivedrab: "#6b8e23",
				olive: "#808000"
			},
			r = {};
		for (var i in n) r[n[i]] = i;
		var s = {};
		(e.prototype.toName = function (t) {
			if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
			var i,
				o,
				a = r[this.toHex()];
			if (a) return a;
			if (null == t ? void 0 : t.closest) {
				var l = this.toRgb(),
					u = 1 / 0,
					c = "black";
				if (!s.length) for (var h in n) s[h] = new e(n[h]).toRgb();
				for (var d in n) {
					var p = ((i = l), (o = s[d]), Math.pow(i.r - o.r, 2) + Math.pow(i.g - o.g, 2) + Math.pow(i.b - o.b, 2));
					p < u && ((u = p), (c = d));
				}
				return c;
			}
		}),
			t.string.push([
				function (t) {
					var r = t.toLowerCase(),
						i = "transparent" === r ? "#0000" : n[r];
					return i ? new e(i).toRgb() : null;
				},
				"name"
			]);
	}
].forEach(function (e) {
	$c.indexOf(e) < 0 && (e(Uc, Dc), $c.push(e));
});
const jc = class {
	constructor(e = 16777215) {
		(this._value = null), (this._components = new Float32Array(4)), this._components.fill(1), (this._int = 16777215), (this.value = e);
	}
	get red() {
		return this._components[0];
	}
	get green() {
		return this._components[1];
	}
	get blue() {
		return this._components[2];
	}
	get alpha() {
		return this._components[3];
	}
	setValue(e) {
		return (this.value = e), this;
	}
	set value(e) {
		if (e instanceof jc) (this._value = this.cloneSource(e._value)), (this._int = e._int), this._components.set(e._components);
		else {
			if (null === e) throw new Error("Cannot set PIXI.Color#value to null");
			(null !== this._value && this.isSourceEqual(this._value, e)) || (this.normalize(e), (this._value = this.cloneSource(e)));
		}
	}
	get value() {
		return this._value;
	}
	cloneSource(e) {
		return "string" == typeof e || "number" == typeof e || e instanceof Number || null === e ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : "object" == typeof e && null !== e ? u({}, e) : e;
	}
	isSourceEqual(e, t) {
		const n = typeof e;
		if (n !== typeof t) return !1;
		if ("number" === n || "string" === n || e instanceof Number) return e === t;
		if ((Array.isArray(e) && Array.isArray(t)) || (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))) return e.length === t.length && e.every((e, n) => e === t[n]);
		if (null !== e && null !== t) {
			const n = Object.keys(e),
				r = Object.keys(t);
			return n.length === r.length && n.every((n) => e[n] === t[n]);
		}
		return e === t;
	}
	toRgba() {
		const [e, t, n, r] = this._components;
		return { r: e, g: t, b: n, a: r };
	}
	toRgb() {
		const [e, t, n] = this._components;
		return { r: e, g: t, b: n };
	}
	toRgbaString() {
		const [e, t, n] = this.toUint8RgbArray();
		return `rgba(${e},${t},${n},${this.alpha})`;
	}
	toUint8RgbArray(e) {
		const [t, n, r] = this._components;
		return ((e = null != e ? e : [])[0] = Math.round(255 * t)), (e[1] = Math.round(255 * n)), (e[2] = Math.round(255 * r)), e;
	}
	toRgbArray(e) {
		e = null != e ? e : [];
		const [t, n, r] = this._components;
		return (e[0] = t), (e[1] = n), (e[2] = r), e;
	}
	toNumber() {
		return this._int;
	}
	toLittleEndianNumber() {
		const e = this._int;
		return (e >> 16) + (65280 & e) + ((255 & e) << 16);
	}
	multiply(e) {
		const [t, n, r, i] = jc.temp.setValue(e)._components;
		return (this._components[0] *= t), (this._components[1] *= n), (this._components[2] *= r), (this._components[3] *= i), this.refreshInt(), (this._value = null), this;
	}
	premultiply(e, t = !0) {
		return t && ((this._components[0] *= e), (this._components[1] *= e), (this._components[2] *= e)), (this._components[3] = e), this.refreshInt(), (this._value = null), this;
	}
	toPremultiplied(e, t = !0) {
		if (1 === e) return (255 << 24) + this._int;
		if (0 === e) return t ? 0 : this._int;
		let n = (this._int >> 16) & 255,
			r = (this._int >> 8) & 255,
			i = 255 & this._int;
		return t && ((n = (n * e + 0.5) | 0), (r = (r * e + 0.5) | 0), (i = (i * e + 0.5) | 0)), ((255 * e) << 24) + (n << 16) + (r << 8) + i;
	}
	toHex() {
		const e = this._int.toString(16);
		return `#${"000000".substring(0, 6 - e.length) + e}`;
	}
	toHexa() {
		const e = Math.round(255 * this._components[3]).toString(16);
		return this.toHex() + "00".substring(0, 2 - e.length) + e;
	}
	setAlpha(e) {
		return (this._components[3] = this._clamp(e)), this;
	}
	round(e) {
		const [t, n, r] = this._components;
		return (this._components[0] = Math.round(t * e) / e), (this._components[1] = Math.round(n * e) / e), (this._components[2] = Math.round(r * e) / e), this.refreshInt(), (this._value = null), this;
	}
	toArray(e) {
		e = null != e ? e : [];
		const [t, n, r, i] = this._components;
		return (e[0] = t), (e[1] = n), (e[2] = r), (e[3] = i), e;
	}
	normalize(e) {
		let t, n, r, i;
		if (("number" == typeof e || e instanceof Number) && e >= 0 && e <= 16777215) {
			(t = ((e >> 16) & 255) / 255), (n = ((e >> 8) & 255) / 255), (r = (255 & e) / 255), (i = 1);
		} else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) (e = this._clamp(e)), ([t, n, r, i = 1] = e);
		else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) (e = this._clamp(e, 0, 255)), ([t, n, r, i = 255] = e), (t /= 255), (n /= 255), (r /= 255), (i /= 255);
		else if ("string" == typeof e || "object" == typeof e) {
			if ("string" == typeof e) {
				const t = jc.HEX_PATTERN.exec(e);
				t && (e = `#${t[2]}`);
			}
			const s = zc(e);
			s.isValid() && (({ r: t, g: n, b: r, a: i } = s.rgba), (t /= 255), (n /= 255), (r /= 255));
		}
		if (void 0 === t) throw new Error(`Unable to convert color ${e}`);
		(this._components[0] = t), (this._components[1] = n), (this._components[2] = r), (this._components[3] = i), this.refreshInt();
	}
	refreshInt() {
		this._clamp(this._components);
		const [e, t, n] = this._components;
		this._int = ((255 * e) << 16) + ((255 * t) << 8) + ((255 * n) | 0);
	}
	_clamp(e, t = 0, n = 1) {
		return "number" == typeof e
			? Math.min(Math.max(e, t), n)
			: (e.forEach((r, i) => {
					e[i] = Math.min(Math.max(r, t), n);
			  }),
			  e);
	}
};
let Wc = jc;
function Gc(e) {
	return fc("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), Wc.shared.setValue(e).toHex();
}
function Yc(e) {
	return fc("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), Wc.shared.setValue(e).toNumber();
}
(Wc.shared = new jc()), (Wc.temp = new jc()), (Wc.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i);
const Xc = (function () {
	const e = [],
		t = [];
	for (let r = 0; r < 32; r++) (e[r] = r), (t[r] = r);
	(e[wl.NORMAL_NPM] = wl.NORMAL), (e[wl.ADD_NPM] = wl.ADD), (e[wl.SCREEN_NPM] = wl.SCREEN), (t[wl.NORMAL] = wl.NORMAL_NPM), (t[wl.ADD] = wl.ADD_NPM), (t[wl.SCREEN] = wl.SCREEN_NPM);
	const n = [];
	return n.push(t), n.push(e), n;
})();
function Kc(e, t) {
	return Xc[t ? 1 : 0][e];
}
const qc = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function Zc(e, t = null) {
	const n = 6 * e;
	if ((t = t || new Uint16Array(n)).length !== n) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${n}`);
	for (let r = 0, i = 0; r < n; r += 6, i += 4) (t[r + 0] = i + 0), (t[r + 1] = i + 1), (t[r + 2] = i + 2), (t[r + 3] = i + 0), (t[r + 4] = i + 2), (t[r + 5] = i + 3);
	return t;
}
function Jc(e) {
	if (4 === e.BYTES_PER_ELEMENT) return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
	if (2 === e.BYTES_PER_ELEMENT) {
		if (e instanceof Uint16Array) return "Uint16Array";
	} else if (1 === e.BYTES_PER_ELEMENT && e instanceof Uint8Array) return "Uint8Array";
	return null;
}
const Qc = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array };
function eh(e) {
	return (e += 0 === e ? 1 : 0), --e, (e |= e >>> 1), (e |= e >>> 2), (e |= e >>> 4), (e |= e >>> 8), (e |= e >>> 16) + 1;
}
function th(e) {
	return !(e & (e - 1) || !e);
}
function nh(e) {
	let t = (e > 65535 ? 1 : 0) << 4,
		n = ((e >>>= t) > 255 ? 1 : 0) << 3;
	return (t |= n), (n = ((e >>>= n) > 15 ? 1 : 0) << 2), (t |= n), (n = ((e >>>= n) > 3 ? 1 : 0) << 1), (t |= n), t | ((e >>>= n) >> 1);
}
function rh(e, t, n) {
	const r = e.length;
	let i;
	if (t >= r || 0 === n) return;
	const s = r - (n = t + n > r ? r - t : n);
	for (i = t; i < s; ++i) e[i] = e[i + n];
	e.length = s;
}
function ih(e) {
	return 0 === e ? 0 : e < 0 ? -1 : 1;
}
let sh = 0;
function oh() {
	return ++sh;
}
const ah = class {
	constructor(e, t, n, r) {
		(this.left = e), (this.top = t), (this.right = n), (this.bottom = r);
	}
	get width() {
		return this.right - this.left;
	}
	get height() {
		return this.bottom - this.top;
	}
	isEmpty() {
		return this.left === this.right || this.top === this.bottom;
	}
};
let lh = ah;
lh.EMPTY = new ah(0, 0, 0, 0);
const uh = {},
	ch = Object.create(null),
	hh = Object.create(null);
class dh {
	constructor(e, t, n) {
		(this._canvas = su.ADAPTER.createCanvas()), (this._context = this._canvas.getContext("2d")), (this.resolution = n || su.RESOLUTION), this.resize(e, t);
	}
	clear() {
		this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
	}
	resize(e, t) {
		this._checkDestroyed(), (this._canvas.width = Math.round(e * this.resolution)), (this._canvas.height = Math.round(t * this.resolution));
	}
	destroy() {
		(this._context = null), (this._canvas = null);
	}
	get width() {
		return this._checkDestroyed(), this._canvas.width;
	}
	set width(e) {
		this._checkDestroyed(), (this._canvas.width = Math.round(e));
	}
	get height() {
		return this._checkDestroyed(), this._canvas.height;
	}
	set height(e) {
		this._checkDestroyed(), (this._canvas.height = Math.round(e));
	}
	get canvas() {
		return this._checkDestroyed(), this._canvas;
	}
	get context() {
		return this._checkDestroyed(), this._context;
	}
	_checkDestroyed() {
		if (null === this._canvas) throw new TypeError("The CanvasRenderTarget has already been destroyed");
	}
}
function ph(e, t, n) {
	for (let r = 0, i = 4 * n * t; r < t; ++r, i += 4) if (0 !== e[i + 3]) return !1;
	return !0;
}
function fh(e, t, n, r, i) {
	const s = 4 * t;
	for (let o = r, a = r * s + 4 * n; o <= i; ++o, a += s) if (0 !== e[a + 3]) return !1;
	return !0;
}
function mh(e) {
	const { width: t, height: n } = e,
		r = e.getContext("2d", { willReadFrequently: !0 });
	if (null === r) throw new TypeError("Failed to get canvas 2D context");
	const i = r.getImageData(0, 0, t, n).data;
	let s = 0,
		o = 0,
		a = t - 1,
		l = n - 1;
	for (; o < n && ph(i, t, o); ) ++o;
	if (o === n) return lh.EMPTY;
	for (; ph(i, t, l); ) --l;
	for (; fh(i, t, s, o, l); ) ++s;
	for (; fh(i, t, a, o, l); ) --a;
	return ++a, ++l, new lh(s, o, a, l);
}
function vh(e) {
	const t = mh(e),
		{ width: n, height: r } = t;
	let i = null;
	if (!t.isEmpty()) {
		const s = e.getContext("2d");
		if (null === s) throw new TypeError("Failed to get canvas 2D context");
		i = s.getImageData(t.left, t.top, n, r);
	}
	return { width: n, height: r, data: i };
}
let gh;
function yh(e, t = globalThis.location) {
	if (e.startsWith("data:")) return "";
	(t = t || globalThis.location), gh || (gh = document.createElement("a")), (gh.href = e);
	const n = uc.parse(gh.href),
		r = (!n.port && "" === t.port) || n.port === t.port;
	return n.hostname === t.hostname && r && n.protocol === t.protocol ? "" : "anonymous";
}
function bh(e, t = 1) {
	var n;
	const r = null == (n = su.RETINA_PREFIX) ? void 0 : n.exec(e);
	return r ? parseFloat(r[1]) : t;
}
var xh = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				isMobile: ou,
				EventEmitter: lu,
				earcut: Fu,
				url: uc,
				path: dc,
				sayHello: function () {
					fc("7.0.0", 'sayHello is deprecated, please use Renderer\'s "hello" option');
				},
				skipHello: function () {
					fc("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello");
				},
				isWebGLSupported: vc,
				hex2rgb: function (e, t = []) {
					return fc("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), Wc.shared.setValue(e).toRgbArray(t);
				},
				hex2string: Gc,
				rgb2hex: Yc,
				string2hex: function (e) {
					return fc("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), Wc.shared.setValue(e).toNumber();
				},
				correctBlendMode: Kc,
				premultiplyBlendMode: Xc,
				premultiplyRgba: function (e, t, n, r = !0) {
					return (
						fc("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"),
						Wc.shared
							.setValue(e)
							.premultiply(t, r)
							.toArray(null != n ? n : new Float32Array(4))
					);
				},
				premultiplyTint: function (e, t) {
					return fc("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), Wc.shared.setValue(e).toPremultiplied(t);
				},
				premultiplyTintToRgba: function (e, t, n, r = !0) {
					return (
						fc("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"),
						Wc.shared
							.setValue(e)
							.premultiply(t, r)
							.toArray(null != n ? n : new Float32Array(4))
					);
				},
				DATA_URI: qc,
				createIndicesForQuads: Zc,
				getBufferType: Jc,
				interleaveTypedArrays: function (e, t) {
					let n = 0,
						r = 0;
					const i = {};
					for (let l = 0; l < e.length; l++) (r += t[l]), (n += e[l].length);
					const s = new ArrayBuffer(4 * n);
					let o = null,
						a = 0;
					for (let l = 0; l < e.length; l++) {
						const n = t[l],
							u = e[l],
							c = Jc(u);
						i[c] || (i[c] = new Qc[c](s)), (o = i[c]);
						for (let e = 0; e < u.length; e++) {
							o[((e / n) | 0) * r + a + (e % n)] = u[e];
						}
						a += n;
					}
					return new Float32Array(s);
				},
				isPow2: th,
				log2: nh,
				nextPow2: eh,
				removeItems: rh,
				sign: ih,
				uid: oh,
				deprecation: fc,
				BoundingBox: lh,
				BaseTextureCache: hh,
				ProgramCache: uh,
				TextureCache: ch,
				clearTextureCache: function () {
					let e;
					for (e in ch) delete ch[e];
					for (e in hh) delete hh[e];
				},
				destroyTextureCache: function () {
					let e;
					for (e in ch) ch[e].destroy();
					for (e in hh) hh[e].destroy();
				},
				CanvasRenderTarget: dh,
				getCanvasBoundingBox: mh,
				trimCanvas: vh,
				decomposeDataUri: function (e) {
					const t = qc.exec(e);
					if (t) return { mediaType: t[1] ? t[1].toLowerCase() : void 0, subType: t[2] ? t[2].toLowerCase() : void 0, charset: t[3] ? t[3].toLowerCase() : void 0, encoding: t[4] ? t[4].toLowerCase() : void 0, data: t[5] };
				},
				determineCrossOrigin: yh,
				getResolutionOfUrl: bh
			},
			Symbol.toStringTag,
			{ value: "Module" }
		)
	),
	_h = ((e) => (
		(e.Renderer = "renderer"),
		(e.Application = "application"),
		(e.RendererSystem = "renderer-webgl-system"),
		(e.RendererPlugin = "renderer-webgl-plugin"),
		(e.CanvasRendererSystem = "renderer-canvas-system"),
		(e.CanvasRendererPlugin = "renderer-canvas-plugin"),
		(e.Asset = "asset"),
		(e.LoadParser = "load-parser"),
		(e.ResolveParser = "resolve-parser"),
		(e.CacheParser = "cache-parser"),
		(e.DetectionParser = "detection-parser"),
		e
	))(_h || {});
const wh = (e) => {
		if ("function" == typeof e || ("object" == typeof e && e.extension)) {
			if (!e.extension) throw new Error("Extension class must have an extension object");
			const t = "object" != typeof e.extension ? { type: e.extension } : e.extension;
			e = c(u({}, t), { ref: e });
		}
		if ("object" != typeof e) throw new Error("Invalid extension type");
		return "string" == typeof (e = u({}, e)).type && (e.type = [e.type]), e;
	},
	Ch = (e, t) => {
		var n;
		return null != (n = wh(e).priority) ? n : t;
	},
	Sh = {
		_addHandlers: {},
		_removeHandlers: {},
		_queue: {},
		remove(...e) {
			return (
				e.map(wh).forEach((e) => {
					e.type.forEach((t) => {
						var n, r;
						return null == (r = (n = this._removeHandlers)[t]) ? void 0 : r.call(n, e);
					});
				}),
				this
			);
		},
		add(...e) {
			return (
				e.map(wh).forEach((e) => {
					e.type.forEach((t) => {
						const n = this._addHandlers,
							r = this._queue;
						n[t] ? n[t](e) : ((r[t] = r[t] || []), r[t].push(e));
					});
				}),
				this
			);
		},
		handle(e, t, n) {
			const r = this._addHandlers,
				i = this._removeHandlers;
			if (r[e] || i[e]) throw new Error(`Extension type ${e} already has a handler`);
			(r[e] = t), (i[e] = n);
			const s = this._queue;
			return s[e] && (s[e].forEach((e) => t(e)), delete s[e]), this;
		},
		handleByMap(e, t) {
			return this.handle(
				e,
				(e) => {
					t[e.name] = e.ref;
				},
				(e) => {
					delete t[e.name];
				}
			);
		},
		handleByList(e, t, n = -1) {
			return this.handle(
				e,
				(e) => {
					t.includes(e.ref) || (t.push(e.ref), t.sort((e, t) => Ch(t, n) - Ch(e, n)));
				},
				(e) => {
					const n = t.indexOf(e.ref);
					-1 !== n && t.splice(n, 1);
				}
			);
		}
	};
class Eh {
	constructor(e) {
		"number" == typeof e ? (this.rawBinaryData = new ArrayBuffer(e)) : e instanceof Uint8Array ? (this.rawBinaryData = e.buffer) : (this.rawBinaryData = e), (this.uint32View = new Uint32Array(this.rawBinaryData)), (this.float32View = new Float32Array(this.rawBinaryData));
	}
	get int8View() {
		return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
	}
	get uint8View() {
		return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
	}
	get int16View() {
		return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
	}
	get uint16View() {
		return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
	}
	get int32View() {
		return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
	}
	view(e) {
		return this[`${e}View`];
	}
	destroy() {
		(this.rawBinaryData = null), (this._int8View = null), (this._uint8View = null), (this._int16View = null), (this._uint16View = null), (this._int32View = null), (this.uint32View = null), (this.float32View = null);
	}
	static sizeOf(e) {
		switch (e) {
			case "int8":
			case "uint8":
				return 1;
			case "int16":
			case "uint16":
				return 2;
			case "int32":
			case "uint32":
			case "float32":
				return 4;
			default:
				throw new Error(`${e} isn't a valid view type`);
		}
	}
}
const Th = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
function kh(e) {
	let t = "";
	for (let n = 0; n < e; ++n) n > 0 && (t += "\nelse "), n < e - 1 && (t += `if(test == ${n}.0){}`);
	return t;
}
function Ah(e, t) {
	if (0 === e) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
	const n = t.createShader(t.FRAGMENT_SHADER);
	for (;;) {
		const r = Th.replace(/%forloop%/gi, kh(e));
		if ((t.shaderSource(n, r), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS))) break;
		e = (e / 2) | 0;
	}
	return e;
}
class Mh {
	constructor() {
		(this.data = 0), (this.blendMode = wl.NORMAL), (this.polygonOffset = 0), (this.blend = !0), (this.depthMask = !0);
	}
	get blend() {
		return !!(1 & this.data);
	}
	set blend(e) {
		!!(1 & this.data) !== e && (this.data ^= 1);
	}
	get offsets() {
		return !!(2 & this.data);
	}
	set offsets(e) {
		!!(2 & this.data) !== e && (this.data ^= 2);
	}
	get culling() {
		return !!(4 & this.data);
	}
	set culling(e) {
		!!(4 & this.data) !== e && (this.data ^= 4);
	}
	get depthTest() {
		return !!(8 & this.data);
	}
	set depthTest(e) {
		!!(8 & this.data) !== e && (this.data ^= 8);
	}
	get depthMask() {
		return !!(32 & this.data);
	}
	set depthMask(e) {
		!!(32 & this.data) !== e && (this.data ^= 32);
	}
	get clockwiseFrontFace() {
		return !!(16 & this.data);
	}
	set clockwiseFrontFace(e) {
		!!(16 & this.data) !== e && (this.data ^= 16);
	}
	get blendMode() {
		return this._blendMode;
	}
	set blendMode(e) {
		(this.blend = e !== wl.NONE), (this._blendMode = e);
	}
	get polygonOffset() {
		return this._polygonOffset;
	}
	set polygonOffset(e) {
		(this.offsets = !!e), (this._polygonOffset = e);
	}
	toString() {
		return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
	}
	static for2d() {
		const e = new Mh();
		return (e.depthTest = !1), (e.blend = !0), e;
	}
}
const Ih = [];
function Rh(e, t) {
	if (!e) return null;
	let n = "";
	if ("string" == typeof e) {
		const t = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
		t && (n = t[1].toLowerCase());
	}
	for (let r = Ih.length - 1; r >= 0; --r) {
		const i = Ih[r];
		if (i.test && i.test(e, n)) return new i(e, t);
	}
	throw new Error("Unrecognized source type to auto-detect Resource");
}
class Lh {
	constructor(e) {
		(this.items = []), (this._name = e), (this._aliasCount = 0);
	}
	emit(e, t, n, r, i, s, o, a) {
		if (arguments.length > 8) throw new Error("max arguments reached");
		const { name: l, items: u } = this;
		this._aliasCount++;
		for (let c = 0, h = u.length; c < h; c++) u[c][l](e, t, n, r, i, s, o, a);
		return u === this.items && this._aliasCount--, this;
	}
	ensureNonAliasedItems() {
		this._aliasCount > 0 && this.items.length > 1 && ((this._aliasCount = 0), (this.items = this.items.slice(0)));
	}
	add(e) {
		return e[this._name] && (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)), this;
	}
	remove(e) {
		const t = this.items.indexOf(e);
		return -1 !== t && (this.ensureNonAliasedItems(), this.items.splice(t, 1)), this;
	}
	contains(e) {
		return this.items.includes(e);
	}
	removeAll() {
		return this.ensureNonAliasedItems(), (this.items.length = 0), this;
	}
	destroy() {
		this.removeAll(), (this.items = null), (this._name = null);
	}
	get empty() {
		return 0 === this.items.length;
	}
	get name() {
		return this._name;
	}
}
Object.defineProperties(Lh.prototype, { dispatch: { value: Lh.prototype.emit }, run: { value: Lh.prototype.emit } });
class Oh {
	constructor(e = 0, t = 0) {
		(this._width = e), (this._height = t), (this.destroyed = !1), (this.internal = !1), (this.onResize = new Lh("setRealSize")), (this.onUpdate = new Lh("update")), (this.onError = new Lh("onError"));
	}
	bind(e) {
		this.onResize.add(e), this.onUpdate.add(e), this.onError.add(e), (this._width || this._height) && this.onResize.emit(this._width, this._height);
	}
	unbind(e) {
		this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e);
	}
	resize(e, t) {
		(e === this._width && t === this._height) || ((this._width = e), (this._height = t), this.onResize.emit(e, t));
	}
	get valid() {
		return !!this._width && !!this._height;
	}
	update() {
		this.destroyed || this.onUpdate.emit();
	}
	load() {
		return Promise.resolve(this);
	}
	get width() {
		return this._width;
	}
	get height() {
		return this._height;
	}
	style(e, t, n) {
		return !1;
	}
	dispose() {}
	destroy() {
		this.destroyed || ((this.destroyed = !0), this.dispose(), this.onError.removeAll(), (this.onError = null), this.onResize.removeAll(), (this.onResize = null), this.onUpdate.removeAll(), (this.onUpdate = null));
	}
	static test(e, t) {
		return !1;
	}
}
class Ph extends Oh {
	constructor(e, t) {
		const { width: n, height: r } = t || {};
		if (!n || !r) throw new Error("BufferResource width or height invalid");
		super(n, r), (this.data = e);
	}
	upload(e, t, n) {
		const r = e.gl;
		r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === Rl.UNPACK);
		const i = t.realWidth,
			s = t.realHeight;
		return n.width === i && n.height === s ? r.texSubImage2D(t.target, 0, 0, 0, i, s, t.format, n.type, this.data) : ((n.width = i), (n.height = s), r.texImage2D(t.target, 0, n.internalFormat, i, s, 0, t.format, n.type, this.data)), !0;
	}
	dispose() {
		this.data = null;
	}
	static test(e) {
		return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
	}
}
const Nh = { scaleMode: Al.NEAREST, format: Sl.RGBA, alphaMode: Rl.NPM },
	Dh = class extends lu {
		constructor(e = null, t = null) {
			super(), (t = Object.assign({}, Dh.defaultOptions, t));
			const { alphaMode: n, mipmap: r, anisotropicLevel: i, scaleMode: s, width: o, height: a, wrapMode: l, format: u, type: c, target: h, resolution: d, resourceOptions: p } = t;
			!e || e instanceof Oh || ((e = Rh(e, p)).internal = !0),
				(this.resolution = d || Vl.RESOLUTION),
				(this.width = Math.round((o || 0) * this.resolution) / this.resolution),
				(this.height = Math.round((a || 0) * this.resolution) / this.resolution),
				(this._mipmap = r),
				(this.anisotropicLevel = i),
				(this._wrapMode = l),
				(this._scaleMode = s),
				(this.format = u),
				(this.type = c),
				(this.target = h),
				(this.alphaMode = n),
				(this.uid = oh()),
				(this.touched = 0),
				(this.isPowerOfTwo = !1),
				this._refreshPOT(),
				(this._glTextures = {}),
				(this.dirtyId = 0),
				(this.dirtyStyleId = 0),
				(this.cacheId = null),
				(this.valid = o > 0 && a > 0),
				(this.textureCacheIds = []),
				(this.destroyed = !1),
				(this.resource = null),
				(this._batchEnabled = 0),
				(this._batchLocation = 0),
				(this.parentTextureArray = null),
				this.setResource(e);
		}
		get realWidth() {
			return Math.round(this.width * this.resolution);
		}
		get realHeight() {
			return Math.round(this.height * this.resolution);
		}
		get mipmap() {
			return this._mipmap;
		}
		set mipmap(e) {
			this._mipmap !== e && ((this._mipmap = e), this.dirtyStyleId++);
		}
		get scaleMode() {
			return this._scaleMode;
		}
		set scaleMode(e) {
			this._scaleMode !== e && ((this._scaleMode = e), this.dirtyStyleId++);
		}
		get wrapMode() {
			return this._wrapMode;
		}
		set wrapMode(e) {
			this._wrapMode !== e && ((this._wrapMode = e), this.dirtyStyleId++);
		}
		setStyle(e, t) {
			let n;
			return void 0 !== e && e !== this.scaleMode && ((this.scaleMode = e), (n = !0)), void 0 !== t && t !== this.mipmap && ((this.mipmap = t), (n = !0)), n && this.dirtyStyleId++, this;
		}
		setSize(e, t, n) {
			return (n = n || this.resolution), this.setRealSize(e * n, t * n, n);
		}
		setRealSize(e, t, n) {
			return (this.resolution = n || this.resolution), (this.width = Math.round(e) / this.resolution), (this.height = Math.round(t) / this.resolution), this._refreshPOT(), this.update(), this;
		}
		_refreshPOT() {
			this.isPowerOfTwo = th(this.realWidth) && th(this.realHeight);
		}
		setResolution(e) {
			const t = this.resolution;
			return t === e || ((this.resolution = e), this.valid && ((this.width = Math.round(this.width * t) / e), (this.height = Math.round(this.height * t) / e), this.emit("update", this)), this._refreshPOT()), this;
		}
		setResource(e) {
			if (this.resource === e) return this;
			if (this.resource) throw new Error("Resource can be set only once");
			return e.bind(this), (this.resource = e), this;
		}
		update() {
			this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && ((this.valid = !0), this.emit("loaded", this), this.emit("update", this));
		}
		onError(e) {
			this.emit("error", this, e);
		}
		destroy() {
			this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), (this.resource = null)),
				this.cacheId && (delete hh[this.cacheId], delete ch[this.cacheId], (this.cacheId = null)),
				this.dispose(),
				Dh.removeFromCache(this),
				(this.textureCacheIds = null),
				(this.destroyed = !0);
		}
		dispose() {
			this.emit("dispose", this);
		}
		castToBaseTexture() {
			return this;
		}
		static from(e, t, n = Vl.STRICT_TEXTURE_CACHE) {
			const r = "string" == typeof e;
			let i = null;
			if (r) i = e;
			else {
				if (!e._pixiId) {
					const n = (null == t ? void 0 : t.pixiIdPrefix) || "pixiid";
					e._pixiId = `${n}_${oh()}`;
				}
				i = e._pixiId;
			}
			let s = hh[i];
			if (r && n && !s) throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);
			return s || ((s = new Dh(e, t)), (s.cacheId = i), Dh.addToCache(s, i)), s;
		}
		static fromBuffer(e, t, n, r) {
			e = e || new Float32Array(t * n * 4);
			const i = new Ph(e, { width: t, height: n }),
				s = e instanceof Float32Array ? Tl.FLOAT : Tl.UNSIGNED_BYTE;
			return new Dh(i, Object.assign({}, Nh, { type: s }, r));
		}
		static addToCache(e, t) {
			t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), hh[t] && hh[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`), (hh[t] = e));
		}
		static removeFromCache(e) {
			if ("string" == typeof e) {
				const t = hh[e];
				if (t) {
					const n = t.textureCacheIds.indexOf(e);
					return n > -1 && t.textureCacheIds.splice(n, 1), delete hh[e], t;
				}
			} else if (null == e ? void 0 : e.textureCacheIds) {
				for (let t = 0; t < e.textureCacheIds.length; ++t) delete hh[e.textureCacheIds[t]];
				return (e.textureCacheIds.length = 0), e;
			}
			return null;
		}
	};
let Bh = Dh;
(Bh.defaultOptions = { mipmap: Il.POW2, anisotropicLevel: 0, scaleMode: Al.LINEAR, wrapMode: Ml.CLAMP, alphaMode: Rl.UNPACK, target: El.TEXTURE_2D, format: Sl.RGBA, type: Tl.UNSIGNED_BYTE }), (Bh._globalBatch = 0);
class Fh {
	constructor() {
		(this.texArray = null), (this.blend = 0), (this.type = Cl.TRIANGLES), (this.start = 0), (this.size = 0), (this.data = null);
	}
}
let Hh = 0;
class Vh {
	constructor(e, t = !0, n = !1) {
		(this.data = e || new Float32Array(1)), (this._glBuffers = {}), (this._updateID = 0), (this.index = n), (this.static = t), (this.id = Hh++), (this.disposeRunner = new Lh("disposeBuffer"));
	}
	update(e) {
		e instanceof Array && (e = new Float32Array(e)), (this.data = e || this.data), this._updateID++;
	}
	dispose() {
		this.disposeRunner.emit(this, !1);
	}
	destroy() {
		this.dispose(), (this.data = null);
	}
	set index(e) {
		this.type = e ? Fl.ELEMENT_ARRAY_BUFFER : Fl.ARRAY_BUFFER;
	}
	get index() {
		return this.type === Fl.ELEMENT_ARRAY_BUFFER;
	}
	static from(e) {
		return e instanceof Array && (e = new Float32Array(e)), new Vh(e);
	}
}
class Uh {
	constructor(e, t = 0, n = !1, r = Tl.FLOAT, i, s, o, a = 1) {
		(this.buffer = e), (this.size = t), (this.normalized = n), (this.type = r), (this.stride = i), (this.start = s), (this.instance = o), (this.divisor = a);
	}
	destroy() {
		this.buffer = null;
	}
	static from(e, t, n, r, i) {
		return new Uh(e, t, n, r, i);
	}
}
const zh = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array };
const $h = { 5126: 4, 5123: 2, 5121: 1 };
let jh = 0;
const Wh = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array, Uint16Array: Uint16Array };
class Gh {
	constructor(e = [], t = {}) {
		(this.buffers = e), (this.indexBuffer = null), (this.attributes = t), (this.glVertexArrayObjects = {}), (this.id = jh++), (this.instanced = !1), (this.instanceCount = 1), (this.disposeRunner = new Lh("disposeGeometry")), (this.refCount = 0);
	}
	addAttribute(e, t, n = 0, r = !1, i, s, o, a = !1) {
		if (!t) throw new Error("You must pass a buffer when creating an attribute");
		t instanceof Vh || (t instanceof Array && (t = new Float32Array(t)), (t = new Vh(t)));
		const l = e.split("|");
		if (l.length > 1) {
			for (let e = 0; e < l.length; e++) this.addAttribute(l[e], t, n, r, i);
			return this;
		}
		let u = this.buffers.indexOf(t);
		return -1 === u && (this.buffers.push(t), (u = this.buffers.length - 1)), (this.attributes[e] = new Uh(u, n, r, i, s, o, a)), (this.instanced = this.instanced || a), this;
	}
	getAttribute(e) {
		return this.attributes[e];
	}
	getBuffer(e) {
		return this.buffers[this.getAttribute(e).buffer];
	}
	addIndex(e) {
		return e instanceof Vh || (e instanceof Array && (e = new Uint16Array(e)), (e = new Vh(e))), (e.type = Fl.ELEMENT_ARRAY_BUFFER), (this.indexBuffer = e), this.buffers.includes(e) || this.buffers.push(e), this;
	}
	getIndex() {
		return this.indexBuffer;
	}
	interleave() {
		if (1 === this.buffers.length || (2 === this.buffers.length && this.indexBuffer)) return this;
		const e = [],
			t = [],
			n = new Vh();
		let r;
		for (r in this.attributes) {
			const n = this.attributes[r],
				i = this.buffers[n.buffer];
			e.push(i.data), t.push((n.size * $h[n.type]) / 4), (n.buffer = 0);
		}
		for (
			n.data = (function (e, t) {
				let n = 0,
					r = 0;
				const i = {};
				for (let l = 0; l < e.length; l++) (r += t[l]), (n += e[l].length);
				const s = new ArrayBuffer(4 * n);
				let o = null,
					a = 0;
				for (let l = 0; l < e.length; l++) {
					const n = t[l],
						u = e[l],
						c = Jc(u);
					i[c] || (i[c] = new zh[c](s)), (o = i[c]);
					for (let e = 0; e < u.length; e++) o[((e / n) | 0) * r + a + (e % n)] = u[e];
					a += n;
				}
				return new Float32Array(s);
			})(e, t),
				r = 0;
			r < this.buffers.length;
			r++
		)
			this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
		return (this.buffers = [n]), this.indexBuffer && this.buffers.push(this.indexBuffer), this;
	}
	getSize() {
		for (const e in this.attributes) {
			const t = this.attributes[e];
			return this.buffers[t.buffer].data.length / (t.stride / 4 || t.size);
		}
		return 0;
	}
	dispose() {
		this.disposeRunner.emit(this, !1);
	}
	destroy() {
		this.dispose(), (this.buffers = null), (this.indexBuffer = null), (this.attributes = null);
	}
	clone() {
		const e = new Gh();
		for (let t = 0; t < this.buffers.length; t++) e.buffers[t] = new Vh(this.buffers[t].data.slice(0));
		for (const t in this.attributes) {
			const n = this.attributes[t];
			e.attributes[t] = new Uh(n.buffer, n.size, n.normalized, n.type, n.stride, n.start, n.instance);
		}
		return this.indexBuffer && ((e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)]), (e.indexBuffer.type = Fl.ELEMENT_ARRAY_BUFFER)), e;
	}
	static merge(e) {
		const t = new Gh(),
			n = [],
			r = [],
			i = [];
		let s;
		for (let o = 0; o < e.length; o++) {
			s = e[o];
			for (let e = 0; e < s.buffers.length; e++) (r[e] = r[e] || 0), (r[e] += s.buffers[e].data.length), (i[e] = 0);
		}
		for (let o = 0; o < s.buffers.length; o++) (n[o] = new Wh[Jc(s.buffers[o].data)](r[o])), (t.buffers[o] = new Vh(n[o]));
		for (let o = 0; o < e.length; o++) {
			s = e[o];
			for (let e = 0; e < s.buffers.length; e++) n[e].set(s.buffers[e].data, i[e]), (i[e] += s.buffers[e].data.length);
		}
		if (((t.attributes = s.attributes), s.indexBuffer)) {
			(t.indexBuffer = t.buffers[s.buffers.indexOf(s.indexBuffer)]), (t.indexBuffer.type = Fl.ELEMENT_ARRAY_BUFFER);
			let n = 0,
				r = 0,
				i = 0,
				o = 0;
			for (let e = 0; e < s.buffers.length; e++)
				if (s.buffers[e] !== s.indexBuffer) {
					o = e;
					break;
				}
			for (const e in s.attributes) {
				const t = s.attributes[e];
				(0 | t.buffer) === o && (r += (t.size * $h[t.type]) / 4);
			}
			for (let s = 0; s < e.length; s++) {
				const a = e[s].indexBuffer.data;
				for (let e = 0; e < a.length; e++) t.indexBuffer.data[e + i] += n;
				(n += e[s].buffers[o].data.length / r), (i += a.length);
			}
		}
		return t;
	}
}
class Yh extends Gh {
	constructor(e = !1) {
		super(),
			(this._buffer = new Vh(null, e, !1)),
			(this._indexBuffer = new Vh(null, e, !0)),
			this.addAttribute("aVertexPosition", this._buffer, 2, !1, Tl.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Tl.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Tl.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Tl.FLOAT).addIndex(this._indexBuffer);
	}
}
const Xh = 2 * Math.PI,
	Kh = 180 / Math.PI,
	qh = Math.PI / 180;
var Zh = ((e) => ((e[(e.POLY = 0)] = "POLY"), (e[(e.RECT = 1)] = "RECT"), (e[(e.CIRC = 2)] = "CIRC"), (e[(e.ELIP = 3)] = "ELIP"), (e[(e.RREC = 4)] = "RREC"), e))(Zh || {});
class Jh {
	constructor(e = 0, t = 0) {
		(this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
	}
	clone() {
		return new Jh(this.x, this.y);
	}
	copyFrom(e) {
		return this.set(e.x, e.y), this;
	}
	copyTo(e) {
		return e.set(this.x, this.y), e;
	}
	equals(e) {
		return e.x === this.x && e.y === this.y;
	}
	set(e = 0, t = e) {
		return (this.x = e), (this.y = t), this;
	}
	toString() {
		return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
	}
}
const Qh = [new Jh(), new Jh(), new Jh(), new Jh()];
class ed {
	constructor(e = 0, t = 0, n = 0, r = 0) {
		(this.x = Number(e)), (this.y = Number(t)), (this.width = Number(n)), (this.height = Number(r)), (this.type = Zh.RECT);
	}
	get left() {
		return this.x;
	}
	get right() {
		return this.x + this.width;
	}
	get top() {
		return this.y;
	}
	get bottom() {
		return this.y + this.height;
	}
	static get EMPTY() {
		return new ed(0, 0, 0, 0);
	}
	clone() {
		return new ed(this.x, this.y, this.width, this.height);
	}
	copyFrom(e) {
		return (this.x = e.x), (this.y = e.y), (this.width = e.width), (this.height = e.height), this;
	}
	copyTo(e) {
		return (e.x = this.x), (e.y = this.y), (e.width = this.width), (e.height = this.height), e;
	}
	contains(e, t) {
		return !(this.width <= 0 || this.height <= 0) && e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
	}
	intersects(e, t) {
		if (!t) {
			const t = this.x < e.x ? e.x : this.x;
			if ((this.right > e.right ? e.right : this.right) <= t) return !1;
			const n = this.y < e.y ? e.y : this.y;
			return (this.bottom > e.bottom ? e.bottom : this.bottom) > n;
		}
		const n = this.left,
			r = this.right,
			i = this.top,
			s = this.bottom;
		if (r <= n || s <= i) return !1;
		const o = Qh[0].set(e.left, e.top),
			a = Qh[1].set(e.left, e.bottom),
			l = Qh[2].set(e.right, e.top),
			u = Qh[3].set(e.right, e.bottom);
		if (l.x <= o.x || a.y <= o.y) return !1;
		const c = Math.sign(t.a * t.d - t.b * t.c);
		if (0 === c) return !1;
		if ((t.apply(o, o), t.apply(a, a), t.apply(l, l), t.apply(u, u), Math.max(o.x, a.x, l.x, u.x) <= n || Math.min(o.x, a.x, l.x, u.x) >= r || Math.max(o.y, a.y, l.y, u.y) <= i || Math.min(o.y, a.y, l.y, u.y) >= s)) return !1;
		const h = c * (a.y - o.y),
			d = c * (o.x - a.x),
			p = h * n + d * i,
			f = h * r + d * i,
			m = h * n + d * s,
			v = h * r + d * s;
		if (Math.max(p, f, m, v) <= h * o.x + d * o.y || Math.min(p, f, m, v) >= h * u.x + d * u.y) return !1;
		const g = c * (o.y - l.y),
			y = c * (l.x - o.x),
			b = g * n + y * i,
			x = g * r + y * i,
			_ = g * n + y * s,
			w = g * r + y * s;
		return !(Math.max(b, x, _, w) <= g * o.x + y * o.y || Math.min(b, x, _, w) >= g * u.x + y * u.y);
	}
	pad(e = 0, t = e) {
		return (this.x -= e), (this.y -= t), (this.width += 2 * e), (this.height += 2 * t), this;
	}
	fit(e) {
		const t = Math.max(this.x, e.x),
			n = Math.min(this.x + this.width, e.x + e.width),
			r = Math.max(this.y, e.y),
			i = Math.min(this.y + this.height, e.y + e.height);
		return (this.x = t), (this.width = Math.max(n - t, 0)), (this.y = r), (this.height = Math.max(i - r, 0)), this;
	}
	ceil(e = 1, t = 0.001) {
		const n = Math.ceil((this.x + this.width - t) * e) / e,
			r = Math.ceil((this.y + this.height - t) * e) / e;
		return (this.x = Math.floor((this.x + t) * e) / e), (this.y = Math.floor((this.y + t) * e) / e), (this.width = n - this.x), (this.height = r - this.y), this;
	}
	enlarge(e) {
		const t = Math.min(this.x, e.x),
			n = Math.max(this.x + this.width, e.x + e.width),
			r = Math.min(this.y, e.y),
			i = Math.max(this.y + this.height, e.y + e.height);
		return (this.x = t), (this.width = n - t), (this.y = r), (this.height = i - r), this;
	}
	toString() {
		return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
	}
}
class td {
	constructor(e = 0, t = 0, n = 0) {
		(this.x = e), (this.y = t), (this.radius = n), (this.type = Zh.CIRC);
	}
	clone() {
		return new td(this.x, this.y, this.radius);
	}
	contains(e, t) {
		if (this.radius <= 0) return !1;
		const n = this.radius * this.radius;
		let r = this.x - e,
			i = this.y - t;
		return (r *= r), (i *= i), r + i <= n;
	}
	getBounds() {
		return new ed(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
	}
	toString() {
		return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
	}
}
class nd {
	constructor(e = 0, t = 0, n = 0, r = 0) {
		(this.x = e), (this.y = t), (this.width = n), (this.height = r), (this.type = Zh.ELIP);
	}
	clone() {
		return new nd(this.x, this.y, this.width, this.height);
	}
	contains(e, t) {
		if (this.width <= 0 || this.height <= 0) return !1;
		let n = (e - this.x) / this.width,
			r = (t - this.y) / this.height;
		return (n *= n), (r *= r), n + r <= 1;
	}
	getBounds() {
		return new ed(this.x - this.width, this.y - this.height, this.width, this.height);
	}
	toString() {
		return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
	}
}
class rd {
	constructor(...e) {
		let t = Array.isArray(e[0]) ? e[0] : e;
		if ("number" != typeof t[0]) {
			const e = [];
			for (let n = 0, r = t.length; n < r; n++) e.push(t[n].x, t[n].y);
			t = e;
		}
		(this.points = t), (this.type = Zh.POLY), (this.closeStroke = !0);
	}
	clone() {
		const e = this.points.slice(),
			t = new rd(e);
		return (t.closeStroke = this.closeStroke), t;
	}
	contains(e, t) {
		let n = !1;
		const r = this.points.length / 2;
		for (let i = 0, s = r - 1; i < r; s = i++) {
			const r = this.points[2 * i],
				o = this.points[2 * i + 1],
				a = this.points[2 * s],
				l = this.points[2 * s + 1];
			o > t != l > t && e < ((t - o) / (l - o)) * (a - r) + r && (n = !n);
		}
		return n;
	}
	toString() {
		return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
	}
}
class id {
	constructor(e = 0, t = 0, n = 0, r = 0, i = 20) {
		(this.x = e), (this.y = t), (this.width = n), (this.height = r), (this.radius = i), (this.type = Zh.RREC);
	}
	clone() {
		return new id(this.x, this.y, this.width, this.height, this.radius);
	}
	contains(e, t) {
		if (this.width <= 0 || this.height <= 0) return !1;
		if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
			const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
			if ((t >= this.y + n && t <= this.y + this.height - n) || (e >= this.x + n && e <= this.x + this.width - n)) return !0;
			let r = e - (this.x + n),
				i = t - (this.y + n);
			const s = n * n;
			if (r * r + i * i <= s) return !0;
			if (((r = e - (this.x + this.width - n)), r * r + i * i <= s)) return !0;
			if (((i = t - (this.y + this.height - n)), r * r + i * i <= s)) return !0;
			if (((r = e - (this.x + n)), r * r + i * i <= s)) return !0;
		}
		return !1;
	}
	toString() {
		return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
	}
}
class sd {
	constructor(e = 1, t = 0, n = 0, r = 1, i = 0, s = 0) {
		(this.array = null), (this.a = e), (this.b = t), (this.c = n), (this.d = r), (this.tx = i), (this.ty = s);
	}
	fromArray(e) {
		(this.a = e[0]), (this.b = e[1]), (this.c = e[3]), (this.d = e[4]), (this.tx = e[2]), (this.ty = e[5]);
	}
	set(e, t, n, r, i, s) {
		return (this.a = e), (this.b = t), (this.c = n), (this.d = r), (this.tx = i), (this.ty = s), this;
	}
	toArray(e, t) {
		this.array || (this.array = new Float32Array(9));
		const n = t || this.array;
		return (
			e ? ((n[0] = this.a), (n[1] = this.b), (n[2] = 0), (n[3] = this.c), (n[4] = this.d), (n[5] = 0), (n[6] = this.tx), (n[7] = this.ty), (n[8] = 1)) : ((n[0] = this.a), (n[1] = this.c), (n[2] = this.tx), (n[3] = this.b), (n[4] = this.d), (n[5] = this.ty), (n[6] = 0), (n[7] = 0), (n[8] = 1)),
			n
		);
	}
	apply(e, t) {
		t = t || new Jh();
		const n = e.x,
			r = e.y;
		return (t.x = this.a * n + this.c * r + this.tx), (t.y = this.b * n + this.d * r + this.ty), t;
	}
	applyInverse(e, t) {
		t = t || new Jh();
		const n = 1 / (this.a * this.d + this.c * -this.b),
			r = e.x,
			i = e.y;
		return (t.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n), (t.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n), t;
	}
	translate(e, t) {
		return (this.tx += e), (this.ty += t), this;
	}
	scale(e, t) {
		return (this.a *= e), (this.d *= t), (this.c *= e), (this.b *= t), (this.tx *= e), (this.ty *= t), this;
	}
	rotate(e) {
		const t = Math.cos(e),
			n = Math.sin(e),
			r = this.a,
			i = this.c,
			s = this.tx;
		return (this.a = r * t - this.b * n), (this.b = r * n + this.b * t), (this.c = i * t - this.d * n), (this.d = i * n + this.d * t), (this.tx = s * t - this.ty * n), (this.ty = s * n + this.ty * t), this;
	}
	append(e) {
		const t = this.a,
			n = this.b,
			r = this.c,
			i = this.d;
		return (this.a = e.a * t + e.b * r), (this.b = e.a * n + e.b * i), (this.c = e.c * t + e.d * r), (this.d = e.c * n + e.d * i), (this.tx = e.tx * t + e.ty * r + this.tx), (this.ty = e.tx * n + e.ty * i + this.ty), this;
	}
	setTransform(e, t, n, r, i, s, o, a, l) {
		return (this.a = Math.cos(o + l) * i), (this.b = Math.sin(o + l) * i), (this.c = -Math.sin(o - a) * s), (this.d = Math.cos(o - a) * s), (this.tx = e - (n * this.a + r * this.c)), (this.ty = t - (n * this.b + r * this.d)), this;
	}
	prepend(e) {
		const t = this.tx;
		if (1 !== e.a || 0 !== e.b || 0 !== e.c || 1 !== e.d) {
			const t = this.a,
				n = this.c;
			(this.a = t * e.a + this.b * e.c), (this.b = t * e.b + this.b * e.d), (this.c = n * e.a + this.d * e.c), (this.d = n * e.b + this.d * e.d);
		}
		return (this.tx = t * e.a + this.ty * e.c + e.tx), (this.ty = t * e.b + this.ty * e.d + e.ty), this;
	}
	decompose(e) {
		const t = this.a,
			n = this.b,
			r = this.c,
			i = this.d,
			s = e.pivot,
			o = -Math.atan2(-r, i),
			a = Math.atan2(n, t),
			l = Math.abs(o + a);
		return (
			l < 1e-5 || Math.abs(Xh - l) < 1e-5 ? ((e.rotation = a), (e.skew.x = e.skew.y = 0)) : ((e.rotation = 0), (e.skew.x = o), (e.skew.y = a)),
			(e.scale.x = Math.sqrt(t * t + n * n)),
			(e.scale.y = Math.sqrt(r * r + i * i)),
			(e.position.x = this.tx + (s.x * t + s.y * r)),
			(e.position.y = this.ty + (s.x * n + s.y * i)),
			e
		);
	}
	invert() {
		const e = this.a,
			t = this.b,
			n = this.c,
			r = this.d,
			i = this.tx,
			s = e * r - t * n;
		return (this.a = r / s), (this.b = -t / s), (this.c = -n / s), (this.d = e / s), (this.tx = (n * this.ty - r * i) / s), (this.ty = -(e * this.ty - t * i) / s), this;
	}
	identity() {
		return (this.a = 1), (this.b = 0), (this.c = 0), (this.d = 1), (this.tx = 0), (this.ty = 0), this;
	}
	clone() {
		const e = new sd();
		return (e.a = this.a), (e.b = this.b), (e.c = this.c), (e.d = this.d), (e.tx = this.tx), (e.ty = this.ty), e;
	}
	copyTo(e) {
		return (e.a = this.a), (e.b = this.b), (e.c = this.c), (e.d = this.d), (e.tx = this.tx), (e.ty = this.ty), e;
	}
	copyFrom(e) {
		return (this.a = e.a), (this.b = e.b), (this.c = e.c), (this.d = e.d), (this.tx = e.tx), (this.ty = e.ty), this;
	}
	toString() {
		return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
	}
	static get IDENTITY() {
		return new sd();
	}
	static get TEMP_MATRIX() {
		return new sd();
	}
}
const od = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
	ad = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
	ld = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
	ud = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
	cd = [],
	hd = [],
	dd = Math.sign;
!(function () {
	for (let e = 0; e < 16; e++) {
		const t = [];
		cd.push(t);
		for (let n = 0; n < 16; n++) {
			const r = dd(od[e] * od[n] + ld[e] * ad[n]),
				i = dd(ad[e] * od[n] + ud[e] * ad[n]),
				s = dd(od[e] * ld[n] + ld[e] * ud[n]),
				o = dd(ad[e] * ld[n] + ud[e] * ud[n]);
			for (let e = 0; e < 16; e++)
				if (od[e] === r && ad[e] === i && ld[e] === s && ud[e] === o) {
					t.push(e);
					break;
				}
		}
	}
	for (let e = 0; e < 16; e++) {
		const t = new sd();
		t.set(od[e], ad[e], ld[e], ud[e], 0, 0), hd.push(t);
	}
})();
const pd = {
	E: 0,
	SE: 1,
	S: 2,
	SW: 3,
	W: 4,
	NW: 5,
	N: 6,
	NE: 7,
	MIRROR_VERTICAL: 8,
	MAIN_DIAGONAL: 10,
	MIRROR_HORIZONTAL: 12,
	REVERSE_DIAGONAL: 14,
	uX: (e) => od[e],
	uY: (e) => ad[e],
	vX: (e) => ld[e],
	vY: (e) => ud[e],
	inv: (e) => (8 & e ? 15 & e : 7 & -e),
	add: (e, t) => cd[e][t],
	sub: (e, t) => cd[e][pd.inv(t)],
	rotate180: (e) => 4 ^ e,
	isVertical: (e) => 2 == (3 & e),
	byDirection: (e, t) => (2 * Math.abs(e) <= Math.abs(t) ? (t >= 0 ? pd.S : pd.N) : 2 * Math.abs(t) <= Math.abs(e) ? (e > 0 ? pd.E : pd.W) : t > 0 ? (e > 0 ? pd.SE : pd.SW) : e > 0 ? pd.NE : pd.NW),
	matrixAppendRotationInv: (e, t, n = 0, r = 0) => {
		const i = hd[pd.inv(t)];
		(i.tx = n), (i.ty = r), e.append(i);
	}
};
class fd {
	constructor(e, t, n = 0, r = 0) {
		(this._x = n), (this._y = r), (this.cb = e), (this.scope = t);
	}
	clone(e = this.cb, t = this.scope) {
		return new fd(e, t, this._x, this._y);
	}
	set(e = 0, t = e) {
		return (this._x === e && this._y === t) || ((this._x = e), (this._y = t), this.cb.call(this.scope)), this;
	}
	copyFrom(e) {
		return (this._x === e.x && this._y === e.y) || ((this._x = e.x), (this._y = e.y), this.cb.call(this.scope)), this;
	}
	copyTo(e) {
		return e.set(this._x, this._y), e;
	}
	equals(e) {
		return e.x === this._x && e.y === this._y;
	}
	toString() {
		return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`;
	}
	get x() {
		return this._x;
	}
	set x(e) {
		this._x !== e && ((this._x = e), this.cb.call(this.scope));
	}
	get y() {
		return this._y;
	}
	set y(e) {
		this._y !== e && ((this._y = e), this.cb.call(this.scope));
	}
}
const md = class {
	constructor() {
		(this.worldTransform = new sd()),
			(this.localTransform = new sd()),
			(this.position = new fd(this.onChange, this, 0, 0)),
			(this.scale = new fd(this.onChange, this, 1, 1)),
			(this.pivot = new fd(this.onChange, this, 0, 0)),
			(this.skew = new fd(this.updateSkew, this, 0, 0)),
			(this._rotation = 0),
			(this._cx = 1),
			(this._sx = 0),
			(this._cy = 0),
			(this._sy = 1),
			(this._localID = 0),
			(this._currentLocalID = 0),
			(this._worldID = 0),
			(this._parentID = 0);
	}
	onChange() {
		this._localID++;
	}
	updateSkew() {
		(this._cx = Math.cos(this._rotation + this.skew.y)), (this._sx = Math.sin(this._rotation + this.skew.y)), (this._cy = -Math.sin(this._rotation - this.skew.x)), (this._sy = Math.cos(this._rotation - this.skew.x)), this._localID++;
	}
	toString() {
		return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
	}
	updateLocalTransform() {
		const e = this.localTransform;
		this._localID !== this._currentLocalID &&
			((e.a = this._cx * this.scale.x),
			(e.b = this._sx * this.scale.x),
			(e.c = this._cy * this.scale.y),
			(e.d = this._sy * this.scale.y),
			(e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
			(e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
			(this._currentLocalID = this._localID),
			(this._parentID = -1));
	}
	updateTransform(e) {
		const t = this.localTransform;
		if (
			(this._localID !== this._currentLocalID &&
				((t.a = this._cx * this.scale.x),
				(t.b = this._sx * this.scale.x),
				(t.c = this._cy * this.scale.y),
				(t.d = this._sy * this.scale.y),
				(t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
				(t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
				(this._currentLocalID = this._localID),
				(this._parentID = -1)),
			this._parentID !== e._worldID)
		) {
			const n = e.worldTransform,
				r = this.worldTransform;
			(r.a = t.a * n.a + t.b * n.c), (r.b = t.a * n.b + t.b * n.d), (r.c = t.c * n.a + t.d * n.c), (r.d = t.c * n.b + t.d * n.d), (r.tx = t.tx * n.a + t.ty * n.c + n.tx), (r.ty = t.tx * n.b + t.ty * n.d + n.ty), (this._parentID = e._worldID), this._worldID++;
		}
	}
	setFromMatrix(e) {
		e.decompose(this), this._localID++;
	}
	get rotation() {
		return this._rotation;
	}
	set rotation(e) {
		this._rotation !== e && ((this._rotation = e), this.updateSkew());
	}
};
let vd = md;
vd.IDENTITY = new md();
function gd(e, t, n) {
	const r = e.createShader(t);
	return e.shaderSource(r, n), e.compileShader(r), r;
}
function yd(e) {
	const t = new Array(e);
	for (let n = 0; n < t.length; n++) t[n] = !1;
	return t;
}
function bd(e, t) {
	switch (e) {
		case "float":
			return 0;
		case "vec2":
			return new Float32Array(2 * t);
		case "vec3":
			return new Float32Array(3 * t);
		case "vec4":
			return new Float32Array(4 * t);
		case "int":
		case "uint":
		case "sampler2D":
		case "sampler2DArray":
			return 0;
		case "ivec2":
			return new Int32Array(2 * t);
		case "ivec3":
			return new Int32Array(3 * t);
		case "ivec4":
			return new Int32Array(4 * t);
		case "uvec2":
			return new Uint32Array(2 * t);
		case "uvec3":
			return new Uint32Array(3 * t);
		case "uvec4":
			return new Uint32Array(4 * t);
		case "bool":
			return !1;
		case "bvec2":
			return yd(2 * t);
		case "bvec3":
			return yd(3 * t);
		case "bvec4":
			return yd(4 * t);
		case "mat2":
			return new Float32Array([1, 0, 0, 1]);
		case "mat3":
			return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
		case "mat4":
			return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
	}
	return null;
}
const xd = [
		{
			test: (e) => "float" === e.type && 1 === e.size && !e.isArray,
			code: (e) =>
				`\n                        if(uv["${e}"] !== ud["${e}"].value)\n                        {\n                                ud["${e}"].value = uv["${e}"]\n                                gl.uniform1f(ud["${e}"].location, uv["${e}"])\n                        }\n                        `
		},
		{
			test: (e, t) => !(("sampler2D" !== e.type && "samplerCube" !== e.type && "sampler2DArray" !== e.type) || 1 !== e.size || e.isArray || (null != t && void 0 === t.castToBaseTexture)),
			code: (e) =>
				`t = syncData.textureCount++;\n\n                        renderer.texture.bind(uv["${e}"], t);\n\n                        if(ud["${e}"].value !== t)\n                        {\n                                ud["${e}"].value = t;\n                                gl.uniform1i(ud["${e}"].location, t);\n; // eslint-disable-line max-len\n                        }`
		},
		{
			test: (e, t) => "mat3" === e.type && 1 === e.size && !e.isArray && void 0 !== t.a,
			code: (e) => `\n                        gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));\n                        `,
			codeUbo: (e) =>
				`\n                                var ${e}_matrix = uv.${e}.toArray(true);\n\n                                data[offset] = ${e}_matrix[0];\n                                data[offset+1] = ${e}_matrix[1];\n                                data[offset+2] = ${e}_matrix[2];\n                \n                                data[offset + 4] = ${e}_matrix[3];\n                                data[offset + 5] = ${e}_matrix[4];\n                                data[offset + 6] = ${e}_matrix[5];\n                \n                                data[offset + 8] = ${e}_matrix[6];\n                                data[offset + 9] = ${e}_matrix[7];\n                                data[offset + 10] = ${e}_matrix[8];\n                        `
		},
		{
			test: (e, t) => "vec2" === e.type && 1 === e.size && !e.isArray && void 0 !== t.x,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v.x || cv[1] !== v.y)\n                                {\n                                        cv[0] = v.x;\n                                        cv[1] = v.y;\n                                        gl.uniform2f(ud["${e}"].location, v.x, v.y);\n                                }`,
			codeUbo: (e) => `\n                                v = uv.${e};\n\n                                data[offset] = v.x;\n                                data[offset+1] = v.y;\n                        `
		},
		{
			test: (e) => "vec2" === e.type && 1 === e.size && !e.isArray,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v[0] || cv[1] !== v[1])\n                                {\n                                        cv[0] = v[0];\n                                        cv[1] = v[1];\n                                        gl.uniform2f(ud["${e}"].location, v[0], v[1]);\n                                }\n                        `
		},
		{
			test: (e, t) => "vec4" === e.type && 1 === e.size && !e.isArray && void 0 !== t.width,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                                {\n                                        cv[0] = v.x;\n                                        cv[1] = v.y;\n                                        cv[2] = v.width;\n                                        cv[3] = v.height;\n                                        gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)\n                                }`,
			codeUbo: (e) =>
				`\n                                        v = uv.${e};\n\n                                        data[offset] = v.x;\n                                        data[offset+1] = v.y;\n                                        data[offset+2] = v.width;\n                                        data[offset+3] = v.height;\n                                `
		},
		{
			test: (e, t) => "vec4" === e.type && 1 === e.size && !e.isArray && void 0 !== t.red,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                                {\n                                        cv[0] = v.red;\n                                        cv[1] = v.green;\n                                        cv[2] = v.blue;\n                                        cv[3] = v.alpha;\n                                        gl.uniform4f(ud["${e}"].location, v.red, v.green, v.blue, v.alpha)\n                                }`,
			codeUbo: (e) =>
				`\n                                        v = uv.${e};\n\n                                        data[offset] = v.red;\n                                        data[offset+1] = v.green;\n                                        data[offset+2] = v.blue;\n                                        data[offset+3] = v.alpha;\n                                `
		},
		{
			test: (e, t) => "vec3" === e.type && 1 === e.size && !e.isArray && void 0 !== t.red,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                                {\n                                        cv[0] = v.red;\n                                        cv[1] = v.green;\n                                        cv[2] = v.blue;\n        \n                                        gl.uniform3f(ud["${e}"].location, v.red, v.green, v.blue)\n                                }`,
			codeUbo: (e) =>
				`\n                                        v = uv.${e};\n\n                                        data[offset] = v.red;\n                                        data[offset+1] = v.green;\n                                        data[offset+2] = v.blue;\n                                `
		},
		{
			test: (e) => "vec4" === e.type && 1 === e.size && !e.isArray,
			code: (e) =>
				`\n                                cv = ud["${e}"].value;\n                                v = uv["${e}"];\n\n                                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                                {\n                                        cv[0] = v[0];\n                                        cv[1] = v[1];\n                                        cv[2] = v[2];\n                                        cv[3] = v[3];\n\n                                        gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])\n                                }`
		}
	],
	_d = {
		float: "\n        if (cv !== v)\n        {\n                cu.value = v;\n                gl.uniform1f(location, v);\n        }",
		vec2: "\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n\n                gl.uniform2f(location, v[0], v[1])\n        }",
		vec3: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n\n                gl.uniform3f(location, v[0], v[1], v[2])\n        }",
		vec4: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n                cv[3] = v[3];\n\n                gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }",
		int: "\n        if (cv !== v)\n        {\n                cu.value = v;\n\n                gl.uniform1i(location, v);\n        }",
		ivec2: "\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n\n                gl.uniform2i(location, v[0], v[1]);\n        }",
		ivec3: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n\n                gl.uniform3i(location, v[0], v[1], v[2]);\n        }",
		ivec4: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n                cv[3] = v[3];\n\n                gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }",
		uint: "\n        if (cv !== v)\n        {\n                cu.value = v;\n\n                gl.uniform1ui(location, v);\n        }",
		uvec2: "\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n\n                gl.uniform2ui(location, v[0], v[1]);\n        }",
		uvec3: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n\n                gl.uniform3ui(location, v[0], v[1], v[2]);\n        }",
		uvec4: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n                cv[3] = v[3];\n\n                gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }",
		bool: "\n        if (cv !== v)\n        {\n                cu.value = v;\n                gl.uniform1i(location, v);\n        }",
		bvec2: "\n        if (cv[0] != v[0] || cv[1] != v[1])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n\n                gl.uniform2i(location, v[0], v[1]);\n        }",
		bvec3: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n\n                gl.uniform3i(location, v[0], v[1], v[2]);\n        }",
		bvec4: "\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n                cv[0] = v[0];\n                cv[1] = v[1];\n                cv[2] = v[2];\n                cv[3] = v[3];\n\n                gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }",
		mat2: "gl.uniformMatrix2fv(location, false, v)",
		mat3: "gl.uniformMatrix3fv(location, false, v)",
		mat4: "gl.uniformMatrix4fv(location, false, v)",
		sampler2D: "\n        if (cv !== v)\n        {\n                cu.value = v;\n\n                gl.uniform1i(location, v);\n        }",
		samplerCube: "\n        if (cv !== v)\n        {\n                cu.value = v;\n\n                gl.uniform1i(location, v);\n        }",
		sampler2DArray: "\n        if (cv !== v)\n        {\n                cu.value = v;\n\n                gl.uniform1i(location, v);\n        }"
	},
	wd = {
		float: "gl.uniform1fv(location, v)",
		vec2: "gl.uniform2fv(location, v)",
		vec3: "gl.uniform3fv(location, v)",
		vec4: "gl.uniform4fv(location, v)",
		mat4: "gl.uniformMatrix4fv(location, false, v)",
		mat3: "gl.uniformMatrix3fv(location, false, v)",
		mat2: "gl.uniformMatrix2fv(location, false, v)",
		int: "gl.uniform1iv(location, v)",
		ivec2: "gl.uniform2iv(location, v)",
		ivec3: "gl.uniform3iv(location, v)",
		ivec4: "gl.uniform4iv(location, v)",
		uint: "gl.uniform1uiv(location, v)",
		uvec2: "gl.uniform2uiv(location, v)",
		uvec3: "gl.uniform3uiv(location, v)",
		uvec4: "gl.uniform4uiv(location, v)",
		bool: "gl.uniform1iv(location, v)",
		bvec2: "gl.uniform2iv(location, v)",
		bvec3: "gl.uniform3iv(location, v)",
		bvec4: "gl.uniform4iv(location, v)",
		sampler2D: "gl.uniform1iv(location, v)",
		samplerCube: "gl.uniform1iv(location, v)",
		sampler2DArray: "gl.uniform1iv(location, v)"
	};
const Cd = {};
let Sd,
	Ed = Cd;
function Td() {
	if (Ed === Cd || (null == Ed ? void 0 : Ed.isContextLost())) {
		const e = Vl.ADAPTER.createCanvas();
		let t;
		Vl.PREFER_ENV >= bl.WEBGL2 && (t = e.getContext("webgl2", {})), t || ((t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {})), t ? t.getExtension("WEBGL_draw_buffers") : (t = null)), (Ed = t);
	}
	return Ed;
}
function kd(e, t) {
	const n = e
			.getShaderSource(t)
			.split("\n")
			.map((e, t) => `${t}: ${e}`),
		r = e.getShaderInfoLog(t),
		i = r.split("\n"),
		s = {},
		o = i.map((e) => parseFloat(e.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((e) => !(!e || s[e]) && ((s[e] = !0), !0)),
		a = [""];
	o.forEach((e) => {
		(n[e - 1] = `%c${n[e - 1]}%c`), a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
	});
	const l = n.join("\n");
	(a[0] = l), console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd();
}
const Ad = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
function Md(e) {
	return Ad[e];
}
let Id = null;
const Rd = {
	FLOAT: "float",
	FLOAT_VEC2: "vec2",
	FLOAT_VEC3: "vec3",
	FLOAT_VEC4: "vec4",
	INT: "int",
	INT_VEC2: "ivec2",
	INT_VEC3: "ivec3",
	INT_VEC4: "ivec4",
	UNSIGNED_INT: "uint",
	UNSIGNED_INT_VEC2: "uvec2",
	UNSIGNED_INT_VEC3: "uvec3",
	UNSIGNED_INT_VEC4: "uvec4",
	BOOL: "bool",
	BOOL_VEC2: "bvec2",
	BOOL_VEC3: "bvec3",
	BOOL_VEC4: "bvec4",
	FLOAT_MAT2: "mat2",
	FLOAT_MAT3: "mat3",
	FLOAT_MAT4: "mat4",
	SAMPLER_2D: "sampler2D",
	INT_SAMPLER_2D: "sampler2D",
	UNSIGNED_INT_SAMPLER_2D: "sampler2D",
	SAMPLER_CUBE: "samplerCube",
	INT_SAMPLER_CUBE: "samplerCube",
	UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
	SAMPLER_2D_ARRAY: "sampler2DArray",
	INT_SAMPLER_2D_ARRAY: "sampler2DArray",
	UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function Ld(e, t) {
	if (!Id) {
		const t = Object.keys(Rd);
		Id = {};
		for (let n = 0; n < t.length; ++n) {
			const r = t[n];
			Id[e[r]] = Rd[r];
		}
	}
	return Id[t];
}
function Od(e, t, n) {
	if ("precision" !== e.substring(0, 9)) {
		let r = t;
		return t === Pl.HIGH && n !== Pl.HIGH && (r = Pl.MEDIUM), `precision ${r} float;\n${e}`;
	}
	return n !== Pl.HIGH && "precision highp" === e.substring(0, 15) ? e.replace("precision highp", "precision mediump") : e;
}
let Pd;
function Nd() {
	if ("boolean" == typeof Pd) return Pd;
	try {
		const e = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
		Pd = !0 === e({ a: "b" }, "a", "b");
	} catch (Kj) {
		Pd = !1;
	}
	return Pd;
}
let Dd = 0;
const Bd = {},
	Fd = class {
		constructor(e, t, n = "pixi-shader", r = {}) {
			(this.extra = {}),
				(this.id = Dd++),
				(this.vertexSrc = e || Fd.defaultVertexSrc),
				(this.fragmentSrc = t || Fd.defaultFragmentSrc),
				(this.vertexSrc = this.vertexSrc.trim()),
				(this.fragmentSrc = this.fragmentSrc.trim()),
				(this.extra = r),
				"#version" !== this.vertexSrc.substring(0, 8) &&
					((n = n.replace(/\s+/g, "-")),
					Bd[n] ? (Bd[n]++, (n += `-${Bd[n]}`)) : (Bd[n] = 1),
					(this.vertexSrc = `#define SHADER_NAME ${n}\n${this.vertexSrc}`),
					(this.fragmentSrc = `#define SHADER_NAME ${n}\n${this.fragmentSrc}`),
					(this.vertexSrc = Od(this.vertexSrc, Fd.defaultVertexPrecision, Pl.HIGH)),
					(this.fragmentSrc = Od(
						this.fragmentSrc,
						Fd.defaultFragmentPrecision,
						(function () {
							if (!Sd) {
								Sd = Pl.MEDIUM;
								const e = Td();
								if (e && e.getShaderPrecisionFormat) {
									const t = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT);
									Sd = t.precision ? Pl.HIGH : Pl.MEDIUM;
								}
							}
							return Sd;
						})()
					))),
				(this.glPrograms = {}),
				(this.syncUniforms = null);
		}
		static get defaultVertexSrc() {
			return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n     gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n     vTextureCoord = aTextureCoord;\n}\n";
		}
		static get defaultFragmentSrc() {
			return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n     gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
		}
		static from(e, t, n) {
			const r = e + t;
			let i = uh[r];
			return i || (uh[r] = i = new Fd(e, t, n)), i;
		}
	};
let Hd = Fd;
(Hd.defaultVertexPrecision = Pl.HIGH), (Hd.defaultFragmentPrecision = ou.apple.device ? Pl.HIGH : Pl.MEDIUM);
let Vd = 0;
class Ud {
	constructor(e, t, n) {
		(this.group = !0),
			(this.syncUniforms = {}),
			(this.dirtyId = 0),
			(this.id = Vd++),
			(this.static = !!t),
			(this.ubo = !!n),
			e instanceof Vh ? ((this.buffer = e), (this.buffer.type = Fl.UNIFORM_BUFFER), (this.autoManage = !1), (this.ubo = !0)) : ((this.uniforms = e), this.ubo && ((this.buffer = new Vh(new Float32Array(1))), (this.buffer.type = Fl.UNIFORM_BUFFER), (this.autoManage = !0)));
	}
	update() {
		this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
	}
	add(e, t, n) {
		if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
		this.uniforms[e] = new Ud(t, n);
	}
	static from(e, t, n) {
		return new Ud(e, t, n);
	}
	static uboFrom(e, t) {
		return new Ud(e, null == t || t, !0);
	}
}
class zd {
	constructor(e, t) {
		(this.uniformBindCount = 0), (this.program = e), (this.uniformGroup = t ? (t instanceof Ud ? t : new Ud(t)) : new Ud({})), (this.disposeRunner = new Lh("disposeShader"));
	}
	checkUniformExists(e, t) {
		if (t.uniforms[e]) return !0;
		for (const n in t.uniforms) {
			const r = t.uniforms[n];
			if (r.group && this.checkUniformExists(e, r)) return !0;
		}
		return !1;
	}
	destroy() {
		(this.uniformGroup = null), this.disposeRunner.emit(this), this.disposeRunner.destroy();
	}
	get uniforms() {
		return this.uniformGroup.uniforms;
	}
	static from(e, t, n) {
		const r = Hd.from(e, t);
		return new zd(r, n);
	}
}
class $d {
	constructor(e, t) {
		if (((this.vertexSrc = e), (this.fragTemplate = t), (this.programCache = {}), (this.defaultGroupCache = {}), !t.includes("%count%"))) throw new Error('Fragment template must contain "%count%".');
		if (!t.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".');
	}
	generateShader(e) {
		if (!this.programCache[e]) {
			const t = new Int32Array(e);
			for (let r = 0; r < e; r++) t[r] = r;
			this.defaultGroupCache[e] = Ud.from({ uSamplers: t }, !0);
			let n = this.fragTemplate;
			(n = n.replace(/%count%/gi, `${e}`)), (n = n.replace(/%forloop%/gi, this.generateSampleSrc(e))), (this.programCache[e] = new Hd(this.vertexSrc, n));
		}
		const t = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new sd(), default: this.defaultGroupCache[e] };
		return new zd(this.programCache[e], t);
	}
	generateSampleSrc(e) {
		let t = "";
		(t += "\n"), (t += "\n");
		for (let n = 0; n < e; n++) n > 0 && (t += "\nelse "), n < e - 1 && (t += `if(vTextureId < ${n}.5)`), (t += "\n{"), (t += `\n\tcolor = texture2D(uSamplers[${n}], vTextureCoord);`), (t += "\n}");
		return (t += "\n"), (t += "\n"), t;
	}
}
class jd {
	constructor() {
		(this.elements = []), (this.ids = []), (this.count = 0);
	}
	clear() {
		for (let e = 0; e < this.count; e++) this.elements[e] = null;
		this.count = 0;
	}
}
class Wd {
	constructor(e) {
		this.renderer = e;
	}
	flush() {}
	destroy() {
		this.renderer = null;
	}
	start() {}
	stop() {
		this.flush();
	}
	render(e) {}
}
const Gd = class extends Wd {
	constructor(e) {
		super(e),
			this.setShaderGenerator(),
			(this.geometryClass = Yh),
			(this.vertexSize = 6),
			(this.state = Mh.for2d()),
			(this.size = 4 * Gd.defaultBatchSize),
			(this._vertexCount = 0),
			(this._indexCount = 0),
			(this._bufferedElements = []),
			(this._bufferedTextures = []),
			(this._bufferSize = 0),
			(this._shader = null),
			(this._packedGeometries = []),
			(this._packedGeometryPoolSize = 2),
			(this._flushId = 0),
			(this._aBuffers = {}),
			(this._iBuffers = {}),
			(this.maxTextures = 1),
			this.renderer.on("prerender", this.onPrerender, this),
			e.runners.contextChange.add(this),
			(this._dcIndex = 0),
			(this._aIndex = 0),
			(this._iIndex = 0),
			(this._attributeBuffer = null),
			(this._indexBuffer = null),
			(this._tempBoundTextures = []);
	}
	static get defaultMaxTextures() {
		var e;
		return (
			(this._defaultMaxTextures =
				null != (e = this._defaultMaxTextures)
					? e
					: (function (e) {
							let t = !0;
							const n = Vl.ADAPTER.getNavigator();
							if (iu.tablet || iu.phone) {
								if (iu.apple.device) {
									const e = n.userAgent.match(/OS (\d+)_(\d+)?/);
									e && parseInt(e[1], 10) < 11 && (t = !1);
								}
								if (iu.android.device) {
									const e = n.userAgent.match(/Android\s([0-9.]*)/);
									e && parseInt(e[1], 10) < 7 && (t = !1);
								}
							}
							return t ? e : 4;
					  })(32)),
			this._defaultMaxTextures
		);
	}
	static set defaultMaxTextures(e) {
		this._defaultMaxTextures = e;
	}
	static get canUploadSameBuffer() {
		var e;
		return (this._canUploadSameBuffer = null != (e = this._canUploadSameBuffer) ? e : !iu.apple.device), this._canUploadSameBuffer;
	}
	static set canUploadSameBuffer(e) {
		this._canUploadSameBuffer = e;
	}
	get MAX_TEXTURES() {
		return fc("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
	}
	static get defaultVertexSrc() {
		return "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = aTextureCoord;\n        vTextureId = aTextureId;\n        vColor = aColor * tint;\n}\n";
	}
	static get defaultFragmentTemplate() {
		return "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n        vec4 color;\n        %forloop%\n        gl_FragColor = color * vColor;\n}\n";
	}
	setShaderGenerator({ vertex: e = Gd.defaultVertexSrc, fragment: t = Gd.defaultFragmentTemplate } = {}) {
		this.shaderGenerator = new $d(e, t);
	}
	contextChange() {
		const e = this.renderer.gl;
		Vl.PREFER_ENV === bl.WEBGL_LEGACY ? (this.maxTextures = 1) : ((this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), Gd.defaultMaxTextures)), (this.maxTextures = Ah(this.maxTextures, e))), (this._shader = this.shaderGenerator.generateShader(this.maxTextures));
		for (let t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] = new this.geometryClass();
		this.initFlushBuffers();
	}
	initFlushBuffers() {
		const { _drawCallPool: e, _textureArrayPool: t } = Gd,
			n = this.size / 4,
			r = Math.floor(n / this.maxTextures) + 1;
		for (; e.length < n; ) e.push(new Fh());
		for (; t.length < r; ) t.push(new jd());
		for (let i = 0; i < this.maxTextures; i++) this._tempBoundTextures[i] = null;
	}
	onPrerender() {
		this._flushId = 0;
	}
	render(e) {
		e._texture.valid &&
			(this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), (this._vertexCount += e.vertexData.length / 2), (this._indexCount += e.indices.length), (this._bufferedTextures[this._bufferSize] = e._texture.baseTexture), (this._bufferedElements[this._bufferSize++] = e));
	}
	buildTexturesAndDrawCalls() {
		const { _bufferedTextures: e, maxTextures: t } = this,
			n = Gd._textureArrayPool,
			r = this.renderer.batch,
			i = this._tempBoundTextures,
			s = this.renderer.textureGC.count;
		let o = ++Bh._globalBatch,
			a = 0,
			l = n[0],
			u = 0;
		r.copyBoundTextures(i, t);
		for (let c = 0; c < this._bufferSize; ++c) {
			const h = e[c];
			(e[c] = null), h._batchEnabled !== o && (l.count >= t && (r.boundArray(l, i, o, t), this.buildDrawCalls(l, u, c), (u = c), (l = n[++a]), ++o), (h._batchEnabled = o), (h.touched = s), (l.elements[l.count++] = h));
		}
		l.count > 0 && (r.boundArray(l, i, o, t), this.buildDrawCalls(l, u, this._bufferSize), ++a, ++o);
		for (let c = 0; c < i.length; c++) i[c] = null;
		Bh._globalBatch = o;
	}
	buildDrawCalls(e, t, n) {
		const { _bufferedElements: r, _attributeBuffer: i, _indexBuffer: s, vertexSize: o } = this,
			a = Gd._drawCallPool;
		let l = this._dcIndex,
			u = this._aIndex,
			c = this._iIndex,
			h = a[l];
		(h.start = this._iIndex), (h.texArray = e);
		for (let d = t; d < n; ++d) {
			const n = r[d],
				p = n._texture.baseTexture,
				f = Xc[p.alphaMode ? 1 : 0][n.blendMode];
			(r[d] = null), t < d && h.blend !== f && ((h.size = c - h.start), (t = d), (h = a[++l]), (h.texArray = e), (h.start = c)), this.packInterleavedGeometry(n, i, s, u, c), (u += (n.vertexData.length / 2) * o), (c += n.indices.length), (h.blend = f);
		}
		t < n && ((h.size = c - h.start), ++l), (this._dcIndex = l), (this._aIndex = u), (this._iIndex = c);
	}
	bindAndClearTexArray(e) {
		const t = this.renderer.texture;
		for (let n = 0; n < e.count; n++) t.bind(e.elements[n], e.ids[n]), (e.elements[n] = null);
		e.count = 0;
	}
	updateGeometry() {
		const { _packedGeometries: e, _attributeBuffer: t, _indexBuffer: n } = this;
		Gd.canUploadSameBuffer
			? (e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers())
			: (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, (e[this._flushId] = new this.geometryClass())),
			  e[this._flushId]._buffer.update(t.rawBinaryData),
			  e[this._flushId]._indexBuffer.update(n),
			  this.renderer.geometry.bind(e[this._flushId]),
			  this.renderer.geometry.updateBuffers(),
			  this._flushId++);
	}
	drawBatches() {
		const e = this._dcIndex,
			{ gl: t, state: n } = this.renderer,
			r = Gd._drawCallPool;
		let i = null;
		for (let s = 0; s < e; s++) {
			const { texArray: e, type: o, size: a, start: l, blend: u } = r[s];
			i !== e && ((i = e), this.bindAndClearTexArray(e)), (this.state.blendMode = u), n.set(this.state), t.drawElements(o, a, t.UNSIGNED_SHORT, 2 * l);
		}
	}
	flush() {
		0 !== this._vertexCount &&
			((this._attributeBuffer = this.getAttributeBuffer(this._vertexCount)),
			(this._indexBuffer = this.getIndexBuffer(this._indexCount)),
			(this._aIndex = 0),
			(this._iIndex = 0),
			(this._dcIndex = 0),
			this.buildTexturesAndDrawCalls(),
			this.updateGeometry(),
			this.drawBatches(),
			(this._bufferSize = 0),
			(this._vertexCount = 0),
			(this._indexCount = 0));
	}
	start() {
		this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), Gd.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
	}
	stop() {
		this.flush();
	}
	destroy() {
		for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
		this.renderer.off("prerender", this.onPrerender, this), (this._aBuffers = null), (this._iBuffers = null), (this._packedGeometries = null), (this._attributeBuffer = null), (this._indexBuffer = null), this._shader && (this._shader.destroy(), (this._shader = null)), super.destroy();
	}
	getAttributeBuffer(e) {
		const t = eh(Math.ceil(e / 8)),
			n = nh(t),
			r = 8 * t;
		this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
		let i = this._aBuffers[r];
		return i || (this._aBuffers[r] = i = new Eh(r * this.vertexSize * 4)), i;
	}
	getIndexBuffer(e) {
		const t = eh(Math.ceil(e / 12)),
			n = nh(t),
			r = 12 * t;
		this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
		let i = this._iBuffers[n];
		return i || (this._iBuffers[n] = i = new Uint16Array(r)), i;
	}
	packInterleavedGeometry(e, t, n, r, i) {
		const { uint32View: s, float32View: o } = t,
			a = r / this.vertexSize,
			l = e.uvs,
			u = e.indices,
			c = e.vertexData,
			h = e._texture.baseTexture._batchLocation,
			d = Math.min(e.worldAlpha, 1),
			p = Wc.shared.setValue(e._tintRGB).toPremultiplied(d, e._texture.baseTexture.alphaMode > 0);
		for (let f = 0; f < c.length; f += 2) (o[r++] = c[f]), (o[r++] = c[f + 1]), (o[r++] = l[f]), (o[r++] = l[f + 1]), (s[r++] = p), (o[r++] = h);
		for (let f = 0; f < u.length; f++) n[i++] = a + u[f];
	}
};
let Yd = Gd;
(Yd.defaultBatchSize = 4096), (Yd.extension = { name: "batch", type: _h.RendererPlugin }), (Yd._drawCallPool = []), (Yd._textureArrayPool = []), Sh.add(Yd);
const Xd = class extends zd {
	constructor(e, t, n) {
		super(Hd.from(e || Xd.defaultVertexSrc, t || Xd.defaultFragmentSrc), n), (this.padding = 0), (this.resolution = Xd.defaultResolution), (this.multisample = Xd.defaultMultisample), (this.enabled = !0), (this.autoFit = !0), (this.state = new Mh());
	}
	apply(e, t, n, r, i) {
		e.applyFilter(this, t, n, r);
	}
	get blendMode() {
		return this.state.blendMode;
	}
	set blendMode(e) {
		this.state.blendMode = e;
	}
	get resolution() {
		return this._resolution;
	}
	set resolution(e) {
		this._resolution = e;
	}
	static get defaultVertexSrc() {
		return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n        gl_Position = filterVertexPosition();\n        vTextureCoord = filterTextureCoord();\n}\n";
	}
	static get defaultFragmentSrc() {
		return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n     gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
	}
};
let Kd = Xd;
(Kd.defaultResolution = 1), (Kd.defaultMultisample = Bl.NONE);
class qd {
	constructor() {
		(this.clearBeforeRender = !0), (this._backgroundColor = new Wc(0)), (this.alpha = 1);
	}
	init(e) {
		this.clearBeforeRender = e.clearBeforeRender;
		const { backgroundColor: t, background: n, backgroundAlpha: r } = e,
			i = null != n ? n : t;
		void 0 !== i && (this.color = i), (this.alpha = r);
	}
	get color() {
		return this._backgroundColor.value;
	}
	set color(e) {
		this._backgroundColor.setValue(e);
	}
	get alpha() {
		return this._backgroundColor.alpha;
	}
	set alpha(e) {
		this._backgroundColor.setAlpha(e);
	}
	get backgroundColor() {
		return this._backgroundColor;
	}
	destroy() {}
}
(qd.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }), (qd.extension = { type: [_h.RendererSystem, _h.CanvasRendererSystem], name: "background" }), Sh.add(qd);
class Zd {
	constructor(e) {
		(this.renderer = e), (this.emptyRenderer = new Wd(e)), (this.currentRenderer = this.emptyRenderer);
	}
	setObjectRenderer(e) {
		this.currentRenderer !== e && (this.currentRenderer.stop(), (this.currentRenderer = e), this.currentRenderer.start());
	}
	flush() {
		this.setObjectRenderer(this.emptyRenderer);
	}
	reset() {
		this.setObjectRenderer(this.emptyRenderer);
	}
	copyBoundTextures(e, t) {
		const { boundTextures: n } = this.renderer.texture;
		for (let r = t - 1; r >= 0; --r) (e[r] = n[r] || null), e[r] && (e[r]._batchLocation = r);
	}
	boundArray(e, t, n, r) {
		const { elements: i, ids: s, count: o } = e;
		let a = 0;
		for (let l = 0; l < o; l++) {
			const e = i[l],
				o = e._batchLocation;
			if (o >= 0 && o < r && t[o] === e) s[l] = o;
			else
				for (; a < r; ) {
					const r = t[a];
					if (!r || r._batchEnabled !== n || r._batchLocation !== a) {
						(s[l] = a), (e._batchLocation = a), (t[a] = e);
						break;
					}
					a++;
				}
		}
	}
	destroy() {
		this.renderer = null;
	}
}
(Zd.extension = { type: _h.RendererSystem, name: "batch" }), Sh.add(Zd);
let Jd = 0;
class Qd {
	constructor(e) {
		(this.renderer = e), (this.webGLVersion = 1), (this.extensions = {}), (this.supports = { uint32Indices: !1 }), (this.handleContextLost = this.handleContextLost.bind(this)), (this.handleContextRestored = this.handleContextRestored.bind(this));
	}
	get isLost() {
		return !this.gl || this.gl.isContextLost();
	}
	contextChange(e) {
		(this.gl = e), (this.renderer.gl = e), (this.renderer.CONTEXT_UID = Jd++);
	}
	init(e) {
		if (e.context) this.initFromContext(e.context);
		else {
			const t = this.renderer.background.alpha < 1,
				n = e.premultipliedAlpha;
			(this.preserveDrawingBuffer = e.preserveDrawingBuffer),
				(this.useContextAlpha = e.useContextAlpha),
				(this.powerPreference = e.powerPreference),
				this.initFromOptions({ alpha: t, premultipliedAlpha: n, antialias: e.antialias, stencil: !0, preserveDrawingBuffer: e.preserveDrawingBuffer, powerPreference: e.powerPreference });
		}
	}
	initFromContext(e) {
		(this.gl = e), this.validateContext(e), (this.renderer.gl = e), (this.renderer.CONTEXT_UID = Jd++), this.renderer.runners.contextChange.emit(e);
		const t = this.renderer.view;
		void 0 !== t.addEventListener && (t.addEventListener("webglcontextlost", this.handleContextLost, !1), t.addEventListener("webglcontextrestored", this.handleContextRestored, !1));
	}
	initFromOptions(e) {
		const t = this.createContext(this.renderer.view, e);
		this.initFromContext(t);
	}
	createContext(e, t) {
		let n;
		if ((Vl.PREFER_ENV >= bl.WEBGL2 && (n = e.getContext("webgl2", t)), n)) this.webGLVersion = 2;
		else if (((this.webGLVersion = 1), (n = e.getContext("webgl", t) || e.getContext("experimental-webgl", t)), !n)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
		return (this.gl = n), this.getExtensions(), this.gl;
	}
	getExtensions() {
		const { gl: e } = this,
			t = {
				loseContext: e.getExtension("WEBGL_lose_context"),
				anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
				floatTextureLinear: e.getExtension("OES_texture_float_linear"),
				s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
				s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
				etc: e.getExtension("WEBGL_compressed_texture_etc"),
				etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
				pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
				atc: e.getExtension("WEBGL_compressed_texture_atc"),
				astc: e.getExtension("WEBGL_compressed_texture_astc")
			};
		1 === this.webGLVersion
			? Object.assign(this.extensions, t, {
					drawBuffers: e.getExtension("WEBGL_draw_buffers"),
					depthTexture: e.getExtension("WEBGL_depth_texture"),
					vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
					uint32ElementIndex: e.getExtension("OES_element_index_uint"),
					floatTexture: e.getExtension("OES_texture_float"),
					floatTextureLinear: e.getExtension("OES_texture_float_linear"),
					textureHalfFloat: e.getExtension("OES_texture_half_float"),
					textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear")
			  })
			: 2 === this.webGLVersion && Object.assign(this.extensions, t, { colorBufferFloat: e.getExtension("EXT_color_buffer_float") });
	}
	handleContextLost(e) {
		e.preventDefault(),
			setTimeout(() => {
				this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
			}, 0);
	}
	handleContextRestored() {
		this.renderer.runners.contextChange.emit(this.gl);
	}
	destroy() {
		const e = this.renderer.view;
		(this.renderer = null),
			void 0 !== e.removeEventListener && (e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored)),
			this.gl.useProgram(null),
			this.extensions.loseContext && this.extensions.loseContext.loseContext();
	}
	postrender() {
		this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
	}
	validateContext(e) {
		const t = e.getContextAttributes(),
			n = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext;
		n && (this.webGLVersion = 2), t && !t.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
		const r = n || !!e.getExtension("OES_element_index_uint");
		(this.supports.uint32Indices = r), r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
	}
}
(Qd.defaultOptions = { context: null, antialias: !1, premultipliedAlpha: !0, preserveDrawingBuffer: !1, powerPreference: "default" }), (Qd.extension = { type: _h.RendererSystem, name: "context" }), Sh.add(Qd);
class ep extends Ph {
	upload(e, t, n) {
		const r = e.gl;
		r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === Rl.UNPACK);
		const i = t.realWidth,
			s = t.realHeight;
		return n.width === i && n.height === s ? r.texSubImage2D(t.target, 0, 0, 0, i, s, t.format, n.type, this.data) : ((n.width = i), (n.height = s), r.texImage2D(t.target, 0, n.internalFormat, i, s, 0, t.format, n.type, this.data)), !0;
	}
}
class tp {
	constructor(e, t) {
		(this.width = Math.round(e || 100)),
			(this.height = Math.round(t || 100)),
			(this.stencil = !1),
			(this.depth = !1),
			(this.dirtyId = 0),
			(this.dirtyFormat = 0),
			(this.dirtySize = 0),
			(this.depthTexture = null),
			(this.colorTextures = []),
			(this.glFramebuffers = {}),
			(this.disposeRunner = new Lh("disposeFramebuffer")),
			(this.multisample = Bl.NONE);
	}
	get colorTexture() {
		return this.colorTextures[0];
	}
	addColorTexture(e = 0, t) {
		return (this.colorTextures[e] = t || new Bh(null, { scaleMode: Al.NEAREST, resolution: 1, mipmap: Il.OFF, width: this.width, height: this.height })), this.dirtyId++, this.dirtyFormat++, this;
	}
	addDepthTexture(e) {
		return (this.depthTexture = e || new Bh(new ep(null, { width: this.width, height: this.height }), { scaleMode: Al.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: Il.OFF, format: Sl.DEPTH_COMPONENT, type: Tl.UNSIGNED_SHORT })), this.dirtyId++, this.dirtyFormat++, this;
	}
	enableDepth() {
		return (this.depth = !0), this.dirtyId++, this.dirtyFormat++, this;
	}
	enableStencil() {
		return (this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this;
	}
	resize(e, t) {
		if (((e = Math.round(e)), (t = Math.round(t)), e !== this.width || t !== this.height)) {
			(this.width = e), (this.height = t), this.dirtyId++, this.dirtySize++;
			for (let n = 0; n < this.colorTextures.length; n++) {
				const r = this.colorTextures[n],
					i = r.resolution;
				r.setSize(e / i, t / i);
			}
			if (this.depthTexture) {
				const n = this.depthTexture.resolution;
				this.depthTexture.setSize(e / n, t / n);
			}
		}
	}
	dispose() {
		this.disposeRunner.emit(this, !1);
	}
	destroyDepthTexture() {
		this.depthTexture && (this.depthTexture.destroy(), (this.depthTexture = null), ++this.dirtyId, ++this.dirtyFormat);
	}
}
class np extends Bh {
	constructor(e = {}) {
		if ("number" == typeof e) {
			e = { width: arguments[0], height: arguments[1], scaleMode: arguments[2], resolution: arguments[3] };
		}
		(e.width = e.width || 100),
			(e.height = e.height || 100),
			null != e.multisample || (e.multisample = Bl.NONE),
			super(null, e),
			(this.mipmap = Il.OFF),
			(this.valid = !0),
			(this._clear = new Wc([0, 0, 0, 0])),
			(this.framebuffer = new tp(this.realWidth, this.realHeight).addColorTexture(0, this)),
			(this.framebuffer.multisample = e.multisample),
			(this.maskStack = []),
			(this.filterStack = [{}]);
	}
	set clearColor(e) {
		this._clear.setValue(e);
	}
	get clearColor() {
		return this._clear.value;
	}
	get clear() {
		return this._clear;
	}
	resize(e, t) {
		this.framebuffer.resize(e * this.resolution, t * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
	}
	dispose() {
		this.framebuffer.dispose(), super.dispose();
	}
	destroy() {
		super.destroy(), this.framebuffer.destroyDepthTexture(), (this.framebuffer = null);
	}
}
class rp extends Oh {
	constructor(e) {
		const t = e;
		super(t.naturalWidth || t.videoWidth || t.width, t.naturalHeight || t.videoHeight || t.height), (this.source = e), (this.noSubImage = !1);
	}
	static crossOrigin(e, t, n) {
		void 0 !== n || t.startsWith("data:") ? !1 !== n && (e.crossOrigin = "string" == typeof n ? n : "anonymous") : (e.crossOrigin = yh(t));
	}
	upload(e, t, n, r) {
		const i = e.gl,
			s = t.realWidth,
			o = t.realHeight;
		if (((r = r || this.source), "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement)) {
			if (!r.complete || 0 === r.naturalWidth) return !1;
		} else if ("undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement && r.readyState <= 1 && 0 === r.buffered.length) return !1;
		return (
			i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === Rl.UNPACK),
			this.noSubImage || t.target !== i.TEXTURE_2D || n.width !== s || n.height !== o ? ((n.width = s), (n.height = o), i.texImage2D(t.target, 0, n.internalFormat, t.format, n.type, r)) : i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, t.format, n.type, r),
			!0
		);
	}
	update() {
		if (this.destroyed) return;
		const e = this.source,
			t = e.naturalWidth || e.videoWidth || e.width,
			n = e.naturalHeight || e.videoHeight || e.height;
		this.resize(t, n), super.update();
	}
	dispose() {
		this.source = null;
	}
}
class ip extends rp {
	constructor(e, t) {
		var n;
		if (((t = t || {}), "string" == typeof e)) {
			const n = new Image();
			rp.crossOrigin(n, e, t.crossorigin), (n.src = e), (e = n);
		}
		super(e),
			!e.complete && this._width && this._height && ((this._width = 0), (this._height = 0)),
			(this.url = e.src),
			(this._process = null),
			(this.preserveBitmap = !1),
			(this.createBitmap = (null != (n = t.createBitmap) ? n : Vl.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap),
			(this.alphaMode = "number" == typeof t.alphaMode ? t.alphaMode : null),
			(this.bitmap = null),
			(this._load = null),
			!1 !== t.autoLoad && this.load();
	}
	load(e) {
		return (
			this._load ||
				(void 0 !== e && (this.createBitmap = e),
				(this._load = new Promise((e, t) => {
					const n = this.source;
					this.url = n.src;
					const r = () => {
						this.destroyed || ((n.onload = null), (n.onerror = null), this.resize(n.width, n.height), (this._load = null), this.createBitmap ? e(this.process()) : e(this));
					};
					n.complete && n.src
						? r()
						: ((n.onload = r),
						  (n.onerror = (e) => {
								t(e), this.onError.emit(e);
						  }));
				}))),
			this._load
		);
	}
	process() {
		const e = this.source;
		if (null !== this._process) return this._process;
		if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this);
		const t = globalThis.createImageBitmap,
			n = !e.crossOrigin || "anonymous" === e.crossOrigin;
		return (
			(this._process = fetch(e.src, { mode: n ? "cors" : "no-cors" })
				.then((e) => e.blob())
				.then((n) => t(n, 0, 0, e.width, e.height, { premultiplyAlpha: null === this.alphaMode || this.alphaMode === Rl.UNPACK ? "premultiply" : "none" }))
				.then((e) => (this.destroyed ? Promise.reject() : ((this.bitmap = e), this.update(), (this._process = null), Promise.resolve(this))))),
			this._process
		);
	}
	upload(e, t, n) {
		if (("number" == typeof this.alphaMode && (t.alphaMode = this.alphaMode), !this.createBitmap)) return super.upload(e, t, n);
		if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
		if ((super.upload(e, t, n, this.bitmap), !this.preserveBitmap)) {
			let e = !0;
			const r = t._glTextures;
			for (const i in r) {
				const s = r[i];
				if (s !== n && s.dirtyId !== t.dirtyId) {
					e = !1;
					break;
				}
			}
			e && (this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
		}
		return !0;
	}
	dispose() {
		(this.source.onload = null), (this.source.onerror = null), super.dispose(), this.bitmap && (this.bitmap.close(), (this.bitmap = null)), (this._process = null), (this._load = null);
	}
	static test(e) {
		return "undefined" != typeof HTMLImageElement && ("string" == typeof e || e instanceof HTMLImageElement);
	}
}
class sp {
	constructor() {
		(this.x0 = 0), (this.y0 = 0), (this.x1 = 1), (this.y1 = 0), (this.x2 = 1), (this.y2 = 1), (this.x3 = 0), (this.y3 = 1), (this.uvsFloat32 = new Float32Array(8));
	}
	set(e, t, n) {
		const r = t.width,
			i = t.height;
		if (n) {
			const t = e.width / 2 / r,
				s = e.height / 2 / i,
				o = e.x / r + t,
				a = e.y / i + s;
			(n = pd.add(n, pd.NW)),
				(this.x0 = o + t * pd.uX(n)),
				(this.y0 = a + s * pd.uY(n)),
				(n = pd.add(n, 2)),
				(this.x1 = o + t * pd.uX(n)),
				(this.y1 = a + s * pd.uY(n)),
				(n = pd.add(n, 2)),
				(this.x2 = o + t * pd.uX(n)),
				(this.y2 = a + s * pd.uY(n)),
				(n = pd.add(n, 2)),
				(this.x3 = o + t * pd.uX(n)),
				(this.y3 = a + s * pd.uY(n));
		} else (this.x0 = e.x / r), (this.y0 = e.y / i), (this.x1 = (e.x + e.width) / r), (this.y1 = e.y / i), (this.x2 = (e.x + e.width) / r), (this.y2 = (e.y + e.height) / i), (this.x3 = e.x / r), (this.y3 = (e.y + e.height) / i);
		(this.uvsFloat32[0] = this.x0), (this.uvsFloat32[1] = this.y0), (this.uvsFloat32[2] = this.x1), (this.uvsFloat32[3] = this.y1), (this.uvsFloat32[4] = this.x2), (this.uvsFloat32[5] = this.y2), (this.uvsFloat32[6] = this.x3), (this.uvsFloat32[7] = this.y3);
	}
	toString() {
		return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
	}
}
const op = new sp();
function ap(e) {
	(e.destroy = function () {}), (e.on = function () {}), (e.once = function () {}), (e.emit = function () {});
}
class lp extends lu {
	constructor(e, t, n, r, i, s, o) {
		if (
			(super(),
			(this.noFrame = !1),
			t || ((this.noFrame = !0), (t = new ed(0, 0, 1, 1))),
			e instanceof lp && (e = e.baseTexture),
			(this.baseTexture = e),
			(this._frame = t),
			(this.trim = r),
			(this.valid = !1),
			(this._uvs = op),
			(this.uvMatrix = null),
			(this.orig = n || t),
			(this._rotate = Number(i || 0)),
			!0 === i)
		)
			this._rotate = 2;
		else if (this._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
		(this.defaultAnchor = s ? new Jh(s.x, s.y) : new Jh(0, 0)),
			(this.defaultBorders = o),
			(this._updateID = 0),
			(this.textureCacheIds = []),
			e.valid ? (this.noFrame ? e.valid && this.onBaseTextureUpdated(e) : (this.frame = t)) : e.once("loaded", this.onBaseTextureUpdated, this),
			this.noFrame && e.on("update", this.onBaseTextureUpdated, this);
	}
	update() {
		this.baseTexture.resource && this.baseTexture.resource.update();
	}
	onBaseTextureUpdated(e) {
		if (this.noFrame) {
			if (!this.baseTexture.valid) return;
			(this._frame.width = e.width), (this._frame.height = e.height), (this.valid = !0), this.updateUvs();
		} else this.frame = this._frame;
		this.emit("update", this);
	}
	destroy(e) {
		if (this.baseTexture) {
			if (e) {
				const { resource: e } = this.baseTexture;
				(null == e ? void 0 : e.url) && ch[e.url] && lp.removeFromCache(e.url), this.baseTexture.destroy();
			}
			this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), (this.baseTexture = null);
		}
		(this._frame = null), (this._uvs = null), (this.trim = null), (this.orig = null), (this.valid = !1), lp.removeFromCache(this), (this.textureCacheIds = null);
	}
	clone() {
		var e;
		const t = this._frame.clone(),
			n = this._frame === this.orig ? t : this.orig.clone(),
			r = new lp(this.baseTexture, !this.noFrame && t, n, null == (e = this.trim) ? void 0 : e.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
		return this.noFrame && (r._frame = t), r;
	}
	updateUvs() {
		this._uvs === op && (this._uvs = new sp()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
	}
	static from(e, t = {}, n = Vl.STRICT_TEXTURE_CACHE) {
		const r = "string" == typeof e;
		let i = null;
		if (r) i = e;
		else if (e instanceof Bh) {
			if (!e.cacheId) {
				const n = (null == t ? void 0 : t.pixiIdPrefix) || "pixiid";
				(e.cacheId = `${n}-${oh()}`), Bh.addToCache(e, e.cacheId);
			}
			i = e.cacheId;
		} else {
			if (!e._pixiId) {
				const n = (null == t ? void 0 : t.pixiIdPrefix) || "pixiid";
				e._pixiId = `${n}_${oh()}`;
			}
			i = e._pixiId;
		}
		let s = ch[i];
		if (r && n && !s) throw new Error(`The cacheId "${i}" does not exist in TextureCache.`);
		return s || e instanceof Bh ? !s && e instanceof Bh && ((s = new lp(e)), lp.addToCache(s, i)) : (t.resolution || (t.resolution = bh(e)), (s = new lp(new Bh(e, t))), (s.baseTexture.cacheId = i), Bh.addToCache(s.baseTexture, i), lp.addToCache(s, i)), s;
	}
	static fromURL(e, t) {
		const n = Object.assign({ autoLoad: !1 }, null == t ? void 0 : t.resourceOptions),
			r = lp.from(e, Object.assign({ resourceOptions: n }, t), !1),
			i = r.baseTexture.resource;
		return r.baseTexture.valid ? Promise.resolve(r) : i.load().then(() => Promise.resolve(r));
	}
	static fromBuffer(e, t, n, r) {
		return new lp(Bh.fromBuffer(e, t, n, r));
	}
	static fromLoader(e, t, n, r) {
		const i = new Bh(e, Object.assign({ scaleMode: Bh.defaultOptions.scaleMode, resolution: bh(t) }, r)),
			{ resource: s } = i;
		s instanceof ip && (s.url = t);
		const o = new lp(i);
		return (
			n || (n = t),
			Bh.addToCache(o.baseTexture, n),
			lp.addToCache(o, n),
			n !== t && (Bh.addToCache(o.baseTexture, t), lp.addToCache(o, t)),
			o.baseTexture.valid
				? Promise.resolve(o)
				: new Promise((e) => {
						o.baseTexture.once("loaded", () => e(o));
				  })
		);
	}
	static addToCache(e, t) {
		t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), ch[t] && ch[t] !== e && console.warn(`Texture added to the cache with an id [${t}] that already had an entry`), (ch[t] = e));
	}
	static removeFromCache(e) {
		if ("string" == typeof e) {
			const t = ch[e];
			if (t) {
				const n = t.textureCacheIds.indexOf(e);
				return n > -1 && t.textureCacheIds.splice(n, 1), delete ch[e], t;
			}
		} else if (null == e ? void 0 : e.textureCacheIds) {
			for (let t = 0; t < e.textureCacheIds.length; ++t) ch[e.textureCacheIds[t]] === e && delete ch[e.textureCacheIds[t]];
			return (e.textureCacheIds.length = 0), e;
		}
		return null;
	}
	get resolution() {
		return this.baseTexture.resolution;
	}
	get frame() {
		return this._frame;
	}
	set frame(e) {
		(this._frame = e), (this.noFrame = !1);
		const { x: t, y: n, width: r, height: i } = e,
			s = t + r > this.baseTexture.width,
			o = n + i > this.baseTexture.height;
		if (s || o) {
			const e = s && o ? "and" : "or",
				a = `X: ${t} + ${r} = ${t + r} > ${this.baseTexture.width}`,
				l = `Y: ${n} + ${i} = ${n + i} > ${this.baseTexture.height}`;
			throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${a} ${e} ${l}`);
		}
		(this.valid = r && i && this.baseTexture.valid), this.trim || this.rotate || (this.orig = e), this.valid && this.updateUvs();
	}
	get rotate() {
		return this._rotate;
	}
	set rotate(e) {
		(this._rotate = e), this.valid && this.updateUvs();
	}
	get width() {
		return this.orig.width;
	}
	get height() {
		return this.orig.height;
	}
	castToBaseTexture() {
		return this.baseTexture;
	}
	static get EMPTY() {
		return lp._EMPTY || ((lp._EMPTY = new lp(new Bh())), ap(lp._EMPTY), ap(lp._EMPTY.baseTexture)), lp._EMPTY;
	}
	static get WHITE() {
		if (!lp._WHITE) {
			const e = Vl.ADAPTER.createCanvas(16, 16),
				t = e.getContext("2d");
			(e.width = 16), (e.height = 16), (t.fillStyle = "white"), t.fillRect(0, 0, 16, 16), (lp._WHITE = new lp(Bh.from(e))), ap(lp._WHITE), ap(lp._WHITE.baseTexture);
		}
		return lp._WHITE;
	}
}
class up extends lp {
	constructor(e, t) {
		super(e, t), (this.valid = !0), (this.filterFrame = null), (this.filterPoolKey = null), this.updateUvs();
	}
	get framebuffer() {
		return this.baseTexture.framebuffer;
	}
	get multisample() {
		return this.framebuffer.multisample;
	}
	set multisample(e) {
		this.framebuffer.multisample = e;
	}
	resize(e, t, n = !0) {
		const r = this.baseTexture.resolution,
			i = Math.round(e * r) / r,
			s = Math.round(t * r) / r;
		(this.valid = i > 0 && s > 0), (this._frame.width = this.orig.width = i), (this._frame.height = this.orig.height = s), n && this.baseTexture.resize(i, s), this.updateUvs();
	}
	setResolution(e) {
		const { baseTexture: t } = this;
		t.resolution !== e && (t.setResolution(e), this.resize(t.width, t.height, !1));
	}
	static create(e) {
		return new up(new np(e));
	}
}
class cp {
	constructor(e) {
		(this.texturePool = {}), (this.textureOptions = e || {}), (this.enableFullScreen = !1), (this._pixelsWidth = 0), (this._pixelsHeight = 0);
	}
	createTexture(e, t, n = Bl.NONE) {
		const r = new np(Object.assign({ width: e, height: t, resolution: 1, multisample: n }, this.textureOptions));
		return new up(r);
	}
	getOptimalTexture(e, t, n = 1, r = Bl.NONE) {
		let i;
		(e = Math.ceil(e * n - 1e-6)),
			(t = Math.ceil(t * n - 1e-6)),
			this.enableFullScreen && e === this._pixelsWidth && t === this._pixelsHeight ? (i = r > 1 ? -r : -1) : ((i = (((65535 & (e = eh(e))) << 16) | (65535 & (t = eh(t)))) >>> 0), r > 1 && (i += 4294967296 * r)),
			this.texturePool[i] || (this.texturePool[i] = []);
		let s = this.texturePool[i].pop();
		return s || (s = this.createTexture(e, t, r)), (s.filterPoolKey = i), s.setResolution(n), s;
	}
	getFilterTexture(e, t, n) {
		const r = this.getOptimalTexture(e.width, e.height, t || e.resolution, n || Bl.NONE);
		return (r.filterFrame = e.filterFrame), r;
	}
	returnTexture(e) {
		const t = e.filterPoolKey;
		(e.filterFrame = null), this.texturePool[t].push(e);
	}
	returnFilterTexture(e) {
		this.returnTexture(e);
	}
	clear(e) {
		if ((e = !1 !== e))
			for (const t in this.texturePool) {
				const e = this.texturePool[t];
				if (e) for (let t = 0; t < e.length; t++) e[t].destroy(!0);
			}
		this.texturePool = {};
	}
	setScreenSize(e) {
		if (e.width !== this._pixelsWidth || e.height !== this._pixelsHeight) {
			this.enableFullScreen = e.width > 0 && e.height > 0;
			for (const e in this.texturePool) {
				if (!(Number(e) < 0)) continue;
				const t = this.texturePool[e];
				if (t) for (let e = 0; e < t.length; e++) t[e].destroy(!0);
				this.texturePool[e] = [];
			}
			(this._pixelsWidth = e.width), (this._pixelsHeight = e.height);
		}
	}
}
cp.SCREEN_KEY = -1;
class hp extends Gh {
	constructor() {
		super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]);
	}
}
class dp extends Gh {
	constructor() {
		super(),
			(this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
			(this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
			(this.vertexBuffer = new Vh(this.vertices)),
			(this.uvBuffer = new Vh(this.uvs)),
			this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
	}
	map(e, t) {
		let n = 0,
			r = 0;
		return (
			(this.uvs[0] = n),
			(this.uvs[1] = r),
			(this.uvs[2] = n + t.width / e.width),
			(this.uvs[3] = r),
			(this.uvs[4] = n + t.width / e.width),
			(this.uvs[5] = r + t.height / e.height),
			(this.uvs[6] = n),
			(this.uvs[7] = r + t.height / e.height),
			(n = t.x),
			(r = t.y),
			(this.vertices[0] = n),
			(this.vertices[1] = r),
			(this.vertices[2] = n + t.width),
			(this.vertices[3] = r),
			(this.vertices[4] = n + t.width),
			(this.vertices[5] = r + t.height),
			(this.vertices[6] = n),
			(this.vertices[7] = r + t.height),
			this.invalidate(),
			this
		);
	}
	invalidate() {
		return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
	}
}
class pp {
	constructor() {
		(this.renderTexture = null),
			(this.target = null),
			(this.legacy = !1),
			(this.resolution = 1),
			(this.multisample = Bl.NONE),
			(this.sourceFrame = new ed()),
			(this.destinationFrame = new ed()),
			(this.bindingSourceFrame = new ed()),
			(this.bindingDestinationFrame = new ed()),
			(this.filters = []),
			(this.transform = null);
	}
	clear() {
		(this.target = null), (this.filters = null), (this.renderTexture = null);
	}
}
const fp = [new Jh(), new Jh(), new Jh(), new Jh()],
	mp = new sd();
class vp {
	constructor(e) {
		(this.renderer = e),
			(this.defaultFilterStack = [{}]),
			(this.texturePool = new cp()),
			(this.statePool = []),
			(this.quad = new hp()),
			(this.quadUv = new dp()),
			(this.tempRect = new ed()),
			(this.activeState = {}),
			(this.globalUniforms = new Ud({ outputFrame: new ed(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, !0)),
			(this.forceClear = !1),
			(this.useMaxPadding = !1);
	}
	init() {
		this.texturePool.setScreenSize(this.renderer.view);
	}
	push(e, t) {
		var n, r;
		const i = this.renderer,
			s = this.defaultFilterStack,
			o = this.statePool.pop() || new pp(),
			a = this.renderer.renderTexture;
		let l = t[0].resolution,
			u = t[0].multisample,
			c = t[0].padding,
			h = t[0].autoFit,
			d = null == (n = t[0].legacy) || n;
		for (let m = 1; m < t.length; m++) {
			const e = t[m];
			(l = Math.min(l, e.resolution)), (u = Math.min(u, e.multisample)), (c = this.useMaxPadding ? Math.max(c, e.padding) : c + e.padding), (h = h && e.autoFit), (d = d || null == (r = e.legacy) || r);
		}
		1 === s.length && (this.defaultFilterStack[0].renderTexture = a.current), s.push(o), (o.resolution = l), (o.multisample = u), (o.legacy = d), (o.target = e), o.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)), o.sourceFrame.pad(c);
		const p = this.tempRect.copyFrom(a.sourceFrame);
		i.projection.transform && this.transformAABB(mp.copyFrom(i.projection.transform).invert(), p),
			h ? (o.sourceFrame.fit(p), (o.sourceFrame.width <= 0 || o.sourceFrame.height <= 0) && ((o.sourceFrame.width = 0), (o.sourceFrame.height = 0))) : o.sourceFrame.intersects(p) || ((o.sourceFrame.width = 0), (o.sourceFrame.height = 0)),
			this.roundFrame(o.sourceFrame, a.current ? a.current.resolution : i.resolution, a.sourceFrame, a.destinationFrame, i.projection.transform),
			(o.renderTexture = this.getOptimalFilterTexture(o.sourceFrame.width, o.sourceFrame.height, l, u)),
			(o.filters = t),
			(o.destinationFrame.width = o.renderTexture.width),
			(o.destinationFrame.height = o.renderTexture.height);
		const f = this.tempRect;
		(f.x = 0),
			(f.y = 0),
			(f.width = o.sourceFrame.width),
			(f.height = o.sourceFrame.height),
			(o.renderTexture.filterFrame = o.sourceFrame),
			o.bindingSourceFrame.copyFrom(a.sourceFrame),
			o.bindingDestinationFrame.copyFrom(a.destinationFrame),
			(o.transform = i.projection.transform),
			(i.projection.transform = null),
			a.bind(o.renderTexture, o.sourceFrame, f),
			i.framebuffer.clear(0, 0, 0, 0);
	}
	pop() {
		const e = this.defaultFilterStack,
			t = e.pop(),
			n = t.filters;
		this.activeState = t;
		const r = this.globalUniforms.uniforms;
		(r.outputFrame = t.sourceFrame), (r.resolution = t.resolution);
		const i = r.inputSize,
			s = r.inputPixel,
			o = r.inputClamp;
		if (
			((i[0] = t.destinationFrame.width),
			(i[1] = t.destinationFrame.height),
			(i[2] = 1 / i[0]),
			(i[3] = 1 / i[1]),
			(s[0] = Math.round(i[0] * t.resolution)),
			(s[1] = Math.round(i[1] * t.resolution)),
			(s[2] = 1 / s[0]),
			(s[3] = 1 / s[1]),
			(o[0] = 0.5 * s[2]),
			(o[1] = 0.5 * s[3]),
			(o[2] = t.sourceFrame.width * i[2] - 0.5 * s[2]),
			(o[3] = t.sourceFrame.height * i[3] - 0.5 * s[3]),
			t.legacy)
		) {
			const e = r.filterArea;
			(e[0] = t.destinationFrame.width), (e[1] = t.destinationFrame.height), (e[2] = t.sourceFrame.x), (e[3] = t.sourceFrame.y), (r.filterClamp = r.inputClamp);
		}
		this.globalUniforms.update();
		const a = e[e.length - 1];
		if ((this.renderer.framebuffer.blit(), 1 === n.length)) n[0].apply(this, t.renderTexture, a.renderTexture, Ll.BLEND, t), this.returnFilterTexture(t.renderTexture);
		else {
			let e = t.renderTexture,
				r = this.getOptimalFilterTexture(e.width, e.height, t.resolution);
			r.filterFrame = e.filterFrame;
			let i = 0;
			for (i = 0; i < n.length - 1; ++i) {
				1 === i && t.multisample > 1 && ((r = this.getOptimalFilterTexture(e.width, e.height, t.resolution)), (r.filterFrame = e.filterFrame)), n[i].apply(this, e, r, Ll.CLEAR, t);
				const s = e;
				(e = r), (r = s);
			}
			n[i].apply(this, e, a.renderTexture, Ll.BLEND, t), i > 1 && t.multisample > 1 && this.returnFilterTexture(t.renderTexture), this.returnFilterTexture(e), this.returnFilterTexture(r);
		}
		t.clear(), this.statePool.push(t);
	}
	bindAndClear(e, t = Ll.CLEAR) {
		const { renderTexture: n, state: r } = this.renderer;
		if ((e === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? (this.renderer.projection.transform = this.activeState.transform) : (this.renderer.projection.transform = null), null == e ? void 0 : e.filterFrame)) {
			const t = this.tempRect;
			(t.x = 0), (t.y = 0), (t.width = e.filterFrame.width), (t.height = e.filterFrame.height), n.bind(e, e.filterFrame, t);
		} else e !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(e) : this.renderer.renderTexture.bind(e, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
		const i = 1 & r.stateId || this.forceClear;
		(t === Ll.CLEAR || (t === Ll.BLIT && i)) && this.renderer.framebuffer.clear(0, 0, 0, 0);
	}
	applyFilter(e, t, n, r) {
		const i = this.renderer;
		i.state.set(e.state),
			this.bindAndClear(n, r),
			(e.uniforms.uSampler = t),
			(e.uniforms.filterGlobals = this.globalUniforms),
			i.shader.bind(e),
			(e.legacy = !!e.program.attributeData.aTextureCoord),
			e.legacy ? (this.quadUv.map(t._frame, t.filterFrame), i.geometry.bind(this.quadUv), i.geometry.draw(Cl.TRIANGLES)) : (i.geometry.bind(this.quad), i.geometry.draw(Cl.TRIANGLE_STRIP));
	}
	calculateSpriteMatrix(e, t) {
		const { sourceFrame: n, destinationFrame: r } = this.activeState,
			{ orig: i } = t._texture,
			s = e.set(r.width, 0, 0, r.height, n.x, n.y),
			o = t.worldTransform.copyTo(sd.TEMP_MATRIX);
		return o.invert(), s.prepend(o), s.scale(1 / i.width, 1 / i.height), s.translate(t.anchor.x, t.anchor.y), s;
	}
	destroy() {
		(this.renderer = null), this.texturePool.clear(!1);
	}
	getOptimalFilterTexture(e, t, n = 1, r = Bl.NONE) {
		return this.texturePool.getOptimalTexture(e, t, n, r);
	}
	getFilterTexture(e, t, n) {
		if ("number" == typeof e) {
			const n = e;
			(e = t), (t = n);
		}
		e = e || this.activeState.renderTexture;
		const r = this.texturePool.getOptimalTexture(e.width, e.height, t || e.resolution, n || Bl.NONE);
		return (r.filterFrame = e.filterFrame), r;
	}
	returnFilterTexture(e) {
		this.texturePool.returnTexture(e);
	}
	emptyPool() {
		this.texturePool.clear(!0);
	}
	resize() {
		this.texturePool.setScreenSize(this.renderer.view);
	}
	transformAABB(e, t) {
		const n = fp[0],
			r = fp[1],
			i = fp[2],
			s = fp[3];
		n.set(t.left, t.top), r.set(t.left, t.bottom), i.set(t.right, t.top), s.set(t.right, t.bottom), e.apply(n, n), e.apply(r, r), e.apply(i, i), e.apply(s, s);
		const o = Math.min(n.x, r.x, i.x, s.x),
			a = Math.min(n.y, r.y, i.y, s.y),
			l = Math.max(n.x, r.x, i.x, s.x),
			u = Math.max(n.y, r.y, i.y, s.y);
		(t.x = o), (t.y = a), (t.width = l - o), (t.height = u - a);
	}
	roundFrame(e, t, n, r, i) {
		if (!(e.width <= 0 || e.height <= 0 || n.width <= 0 || n.height <= 0)) {
			if (i) {
				const { a: e, b: t, c: n, d: r } = i;
				if ((Math.abs(t) > 1e-4 || Math.abs(n) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(r) > 1e-4)) return;
			}
			(i = i ? mp.copyFrom(i) : mp.identity())
				.translate(-n.x, -n.y)
				.scale(r.width / n.width, r.height / n.height)
				.translate(r.x, r.y),
				this.transformAABB(i, e),
				e.ceil(t),
				this.transformAABB(i.invert(), e);
		}
	}
}
(vp.extension = { type: _h.RendererSystem, name: "filter" }), Sh.add(vp);
class gp {
	constructor(e) {
		(this.framebuffer = e), (this.stencil = null), (this.dirtyId = -1), (this.dirtyFormat = -1), (this.dirtySize = -1), (this.multisample = Bl.NONE), (this.msaaBuffer = null), (this.blitFramebuffer = null), (this.mipLevel = 0);
	}
}
const yp = new ed();
class bp {
	constructor(e) {
		(this.renderer = e), (this.managedFramebuffers = []), (this.unknownFramebuffer = new tp(10, 10)), (this.msaaSamples = null);
	}
	contextChange() {
		this.disposeAll(!0);
		const e = (this.gl = this.renderer.gl);
		if (((this.CONTEXT_UID = this.renderer.CONTEXT_UID), (this.current = this.unknownFramebuffer), (this.viewport = new ed()), (this.hasMRT = !0), (this.writeDepthTexture = !0), 1 === this.renderer.context.webGLVersion)) {
			let t = this.renderer.context.extensions.drawBuffers,
				n = this.renderer.context.extensions.depthTexture;
			Vl.PREFER_ENV === bl.WEBGL_LEGACY && ((t = null), (n = null)), t ? (e.drawBuffers = (e) => t.drawBuffersWEBGL(e)) : ((this.hasMRT = !1), (e.drawBuffers = () => {})), n || (this.writeDepthTexture = !1);
		} else this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES);
	}
	bind(e, t, n = 0) {
		const { gl: r } = this;
		if (e) {
			const i = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
			this.current !== e && ((this.current = e), r.bindFramebuffer(r.FRAMEBUFFER, i.framebuffer)),
				i.mipLevel !== n && (e.dirtyId++, e.dirtyFormat++, (i.mipLevel = n)),
				i.dirtyId !== e.dirtyId && ((i.dirtyId = e.dirtyId), i.dirtyFormat !== e.dirtyFormat ? ((i.dirtyFormat = e.dirtyFormat), (i.dirtySize = e.dirtySize), this.updateFramebuffer(e, n)) : i.dirtySize !== e.dirtySize && ((i.dirtySize = e.dirtySize), this.resizeFramebuffer(e)));
			for (let t = 0; t < e.colorTextures.length; t++) {
				const n = e.colorTextures[t];
				this.renderer.texture.unbind(n.parentTextureArray || n);
			}
			if ((e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t)) {
				const e = t.width >> n,
					r = t.height >> n,
					i = e / t.width;
				this.setViewport(t.x * i, t.y * i, e, r);
			} else {
				const t = e.width >> n,
					r = e.height >> n;
				this.setViewport(0, 0, t, r);
			}
		} else this.current && ((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)), t ? this.setViewport(t.x, t.y, t.width, t.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
	}
	setViewport(e, t, n, r) {
		const i = this.viewport;
		(e = Math.round(e)), (t = Math.round(t)), (n = Math.round(n)), (r = Math.round(r)), (i.width === n && i.height === r && i.x === e && i.y === t) || ((i.x = e), (i.y = t), (i.width = n), (i.height = r), this.gl.viewport(e, t, n, r));
	}
	get size() {
		return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
	}
	clear(e, t, n, r, i = _l.COLOR | _l.DEPTH) {
		const { gl: s } = this;
		s.clearColor(e, t, n, r), s.clear(i);
	}
	initFramebuffer(e) {
		const { gl: t } = this,
			n = new gp(t.createFramebuffer());
		return (n.multisample = this.detectSamples(e.multisample)), (e.glFramebuffers[this.CONTEXT_UID] = n), this.managedFramebuffers.push(e), e.disposeRunner.add(this), n;
	}
	resizeFramebuffer(e) {
		const { gl: t } = this,
			n = e.glFramebuffers[this.CONTEXT_UID];
		n.stencil && (t.bindRenderbuffer(t.RENDERBUFFER, n.stencil), n.msaaBuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, n.multisample, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, e.width, e.height));
		const r = e.colorTextures;
		let i = r.length;
		t.drawBuffers || (i = Math.min(i, 1));
		for (let s = 0; s < i; s++) {
			const i = r[s],
				o = i.parentTextureArray || i;
			this.renderer.texture.bind(o, 0), 0 === s && n.msaaBuffer && (t.bindRenderbuffer(t.RENDERBUFFER, n.msaaBuffer), t.renderbufferStorageMultisample(t.RENDERBUFFER, n.multisample, o._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height));
		}
		e.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(e.depthTexture, 0);
	}
	updateFramebuffer(e, t) {
		const { gl: n } = this,
			r = e.glFramebuffers[this.CONTEXT_UID],
			i = e.colorTextures;
		let s = i.length;
		n.drawBuffers || (s = Math.min(s, 1)),
			r.multisample > 1 && this.canMultisampleFramebuffer(e) ? (r.msaaBuffer = r.msaaBuffer || n.createRenderbuffer()) : r.msaaBuffer && (n.deleteRenderbuffer(r.msaaBuffer), (r.msaaBuffer = null), r.blitFramebuffer && (r.blitFramebuffer.dispose(), (r.blitFramebuffer = null)));
		const o = [];
		for (let a = 0; a < s; a++) {
			const s = i[a],
				l = s.parentTextureArray || s;
			this.renderer.texture.bind(l, 0),
				0 === a && r.msaaBuffer
					? (n.bindRenderbuffer(n.RENDERBUFFER, r.msaaBuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, r.msaaBuffer))
					: (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + a, s.target, l._glTextures[this.CONTEXT_UID].texture, t), o.push(n.COLOR_ATTACHMENT0 + a));
		}
		if ((o.length > 1 && n.drawBuffers(o), e.depthTexture)) {
			if (this.writeDepthTexture) {
				const r = e.depthTexture;
				this.renderer.texture.bind(r, 0), n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, r._glTextures[this.CONTEXT_UID].texture, t);
			}
		}
		(!e.stencil && !e.depth) || (e.depthTexture && this.writeDepthTexture)
			? r.stencil && (n.deleteRenderbuffer(r.stencil), (r.stencil = null))
			: ((r.stencil = r.stencil || n.createRenderbuffer()),
			  n.bindRenderbuffer(n.RENDERBUFFER, r.stencil),
			  r.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, r.multisample, n.DEPTH24_STENCIL8, e.width, e.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, e.width, e.height),
			  n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r.stencil));
	}
	canMultisampleFramebuffer(e) {
		return 1 !== this.renderer.context.webGLVersion && e.colorTextures.length <= 1 && !e.depthTexture;
	}
	detectSamples(e) {
		const { msaaSamples: t } = this;
		let n = Bl.NONE;
		if (e <= 1 || null === t) return n;
		for (let r = 0; r < t.length; r++)
			if (t[r] <= e) {
				n = t[r];
				break;
			}
		return 1 === n && (n = Bl.NONE), n;
	}
	blit(e, t, n) {
		const { current: r, renderer: i, gl: s, CONTEXT_UID: o } = this;
		if (2 !== i.context.webGLVersion) return;
		if (!r) return;
		const a = r.glFramebuffers[o];
		if (!a) return;
		if (!e) {
			if (!a.msaaBuffer) return;
			const t = r.colorTextures[0];
			if (!t) return;
			a.blitFramebuffer || ((a.blitFramebuffer = new tp(r.width, r.height)), a.blitFramebuffer.addColorTexture(0, t)),
				(e = a.blitFramebuffer).colorTextures[0] !== t && ((e.colorTextures[0] = t), e.dirtyId++, e.dirtyFormat++),
				(e.width === r.width && e.height === r.height) || ((e.width = r.width), (e.height = r.height), e.dirtyId++, e.dirtySize++);
		}
		t || (((t = yp).width = r.width), (t.height = r.height)), n || (n = t);
		const l = t.width === n.width && t.height === n.height;
		this.bind(e), s.bindFramebuffer(s.READ_FRAMEBUFFER, a.framebuffer), s.blitFramebuffer(t.left, t.top, t.right, t.bottom, n.left, n.top, n.right, n.bottom, s.COLOR_BUFFER_BIT, l ? s.NEAREST : s.LINEAR), s.bindFramebuffer(s.READ_FRAMEBUFFER, e.glFramebuffers[this.CONTEXT_UID].framebuffer);
	}
	disposeFramebuffer(e, t) {
		const n = e.glFramebuffers[this.CONTEXT_UID],
			r = this.gl;
		if (!n) return;
		delete e.glFramebuffers[this.CONTEXT_UID];
		const i = this.managedFramebuffers.indexOf(e);
		i >= 0 && this.managedFramebuffers.splice(i, 1), e.disposeRunner.remove(this), t || (r.deleteFramebuffer(n.framebuffer), n.msaaBuffer && r.deleteRenderbuffer(n.msaaBuffer), n.stencil && r.deleteRenderbuffer(n.stencil)), n.blitFramebuffer && this.disposeFramebuffer(n.blitFramebuffer, t);
	}
	disposeAll(e) {
		const t = this.managedFramebuffers;
		this.managedFramebuffers = [];
		for (let n = 0; n < t.length; n++) this.disposeFramebuffer(t[n], e);
	}
	forceStencil() {
		const e = this.current;
		if (!e) return;
		const t = e.glFramebuffers[this.CONTEXT_UID];
		if (!t || t.stencil) return;
		e.stencil = !0;
		const n = e.width,
			r = e.height,
			i = this.gl,
			s = i.createRenderbuffer();
		i.bindRenderbuffer(i.RENDERBUFFER, s),
			t.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, t.multisample, i.DEPTH24_STENCIL8, n, r) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, n, r),
			(t.stencil = s),
			i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, s);
	}
	reset() {
		(this.current = this.unknownFramebuffer), (this.viewport = new ed());
	}
	destroy() {
		this.renderer = null;
	}
}
(bp.extension = { type: _h.RendererSystem, name: "framebuffer" }), Sh.add(bp);
const xp = { 5126: 4, 5123: 2, 5121: 1 };
class _p {
	constructor(e) {
		(this.renderer = e), (this._activeGeometry = null), (this._activeVao = null), (this.hasVao = !0), (this.hasInstance = !0), (this.canUseUInt32ElementIndex = !1), (this.managedGeometries = {});
	}
	contextChange() {
		this.disposeAll(!0);
		const e = (this.gl = this.renderer.gl),
			t = this.renderer.context;
		if (((this.CONTEXT_UID = this.renderer.CONTEXT_UID), 2 !== t.webGLVersion)) {
			let t = this.renderer.context.extensions.vertexArrayObject;
			Vl.PREFER_ENV === bl.WEBGL_LEGACY && (t = null),
				t
					? ((e.createVertexArray = () => t.createVertexArrayOES()), (e.bindVertexArray = (e) => t.bindVertexArrayOES(e)), (e.deleteVertexArray = (e) => t.deleteVertexArrayOES(e)))
					: ((this.hasVao = !1), (e.createVertexArray = () => null), (e.bindVertexArray = () => null), (e.deleteVertexArray = () => null));
		}
		if (2 !== t.webGLVersion) {
			const t = e.getExtension("ANGLE_instanced_arrays");
			t ? ((e.vertexAttribDivisor = (e, n) => t.vertexAttribDivisorANGLE(e, n)), (e.drawElementsInstanced = (e, n, r, i, s) => t.drawElementsInstancedANGLE(e, n, r, i, s)), (e.drawArraysInstanced = (e, n, r, i) => t.drawArraysInstancedANGLE(e, n, r, i))) : (this.hasInstance = !1);
		}
		this.canUseUInt32ElementIndex = 2 === t.webGLVersion || !!t.extensions.uint32ElementIndex;
	}
	bind(e, t) {
		t = t || this.renderer.shader.shader;
		const { gl: n } = this;
		let r = e.glVertexArrayObjects[this.CONTEXT_UID],
			i = !1;
		r || ((this.managedGeometries[e.id] = e), e.disposeRunner.add(this), (e.glVertexArrayObjects[this.CONTEXT_UID] = r = {}), (i = !0));
		const s = r[t.program.id] || this.initGeometryVao(e, t, i);
		(this._activeGeometry = e), this._activeVao !== s && ((this._activeVao = s), this.hasVao ? n.bindVertexArray(s) : this.activateVao(e, t.program)), this.updateBuffers();
	}
	reset() {
		this.unbind();
	}
	updateBuffers() {
		const e = this._activeGeometry,
			t = this.renderer.buffer;
		for (let n = 0; n < e.buffers.length; n++) {
			const r = e.buffers[n];
			t.update(r);
		}
	}
	checkCompatibility(e, t) {
		const n = e.attributes,
			r = t.attributeData;
		for (const i in r) if (!n[i]) throw new Error(`shader and geometry incompatible, geometry missing the "${i}" attribute`);
	}
	getSignature(e, t) {
		const n = e.attributes,
			r = t.attributeData,
			i = ["g", e.id];
		for (const s in n) r[s] && i.push(s, r[s].location);
		return i.join("-");
	}
	initGeometryVao(e, t, n = !0) {
		const r = this.gl,
			i = this.CONTEXT_UID,
			s = this.renderer.buffer,
			o = t.program;
		o.glPrograms[i] || this.renderer.shader.generateProgram(t), this.checkCompatibility(e, o);
		const a = this.getSignature(e, o),
			l = e.glVertexArrayObjects[this.CONTEXT_UID];
		let u = l[a];
		if (u) return (l[o.id] = u), u;
		const c = e.buffers,
			h = e.attributes,
			d = {},
			p = {};
		for (const f in c) (d[f] = 0), (p[f] = 0);
		for (const f in h) !h[f].size && o.attributeData[f] ? (h[f].size = o.attributeData[f].size) : h[f].size || console.warn(`PIXI Geometry attribute '${f}' size cannot be determined (likely the bound shader does not have the attribute)`), (d[h[f].buffer] += h[f].size * xp[h[f].type]);
		for (const f in h) {
			const e = h[f],
				t = e.size;
			void 0 === e.stride && (d[e.buffer] === t * xp[e.type] ? (e.stride = 0) : (e.stride = d[e.buffer])), void 0 === e.start && ((e.start = p[e.buffer]), (p[e.buffer] += t * xp[e.type]));
		}
		(u = r.createVertexArray()), r.bindVertexArray(u);
		for (let f = 0; f < c.length; f++) {
			const e = c[f];
			s.bind(e), n && e._glBuffers[i].refCount++;
		}
		return this.activateVao(e, o), (l[o.id] = u), (l[a] = u), r.bindVertexArray(null), s.unbind(Fl.ARRAY_BUFFER), u;
	}
	disposeGeometry(e, t) {
		var n;
		if (!this.managedGeometries[e.id]) return;
		delete this.managedGeometries[e.id];
		const r = e.glVertexArrayObjects[this.CONTEXT_UID],
			i = this.gl,
			s = e.buffers,
			o = null == (n = this.renderer) ? void 0 : n.buffer;
		if ((e.disposeRunner.remove(this), r)) {
			if (o)
				for (let e = 0; e < s.length; e++) {
					const n = s[e]._glBuffers[this.CONTEXT_UID];
					n && (n.refCount--, 0 !== n.refCount || t || o.dispose(s[e], t));
				}
			if (!t)
				for (const e in r)
					if ("g" === e[0]) {
						const t = r[e];
						this._activeVao === t && this.unbind(), i.deleteVertexArray(t);
					}
			delete e.glVertexArrayObjects[this.CONTEXT_UID];
		}
	}
	disposeAll(e) {
		const t = Object.keys(this.managedGeometries);
		for (let n = 0; n < t.length; n++) this.disposeGeometry(this.managedGeometries[t[n]], e);
	}
	activateVao(e, t) {
		const n = this.gl,
			r = this.CONTEXT_UID,
			i = this.renderer.buffer,
			s = e.buffers,
			o = e.attributes;
		e.indexBuffer && i.bind(e.indexBuffer);
		let a = null;
		for (const l in o) {
			const e = o[l],
				u = s[e.buffer],
				c = u._glBuffers[r];
			if (t.attributeData[l]) {
				a !== c && (i.bind(u), (a = c));
				const r = t.attributeData[l].location;
				if ((n.enableVertexAttribArray(r), n.vertexAttribPointer(r, e.size, e.type || n.FLOAT, e.normalized, e.stride, e.start), e.instance)) {
					if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
					n.vertexAttribDivisor(r, e.divisor);
				}
			}
		}
	}
	draw(e, t, n, r) {
		const { gl: i } = this,
			s = this._activeGeometry;
		if (s.indexBuffer) {
			const o = s.indexBuffer.data.BYTES_PER_ELEMENT,
				a = 2 === o ? i.UNSIGNED_SHORT : i.UNSIGNED_INT;
			2 === o || (4 === o && this.canUseUInt32ElementIndex) ? (s.instanced ? i.drawElementsInstanced(e, t || s.indexBuffer.data.length, a, (n || 0) * o, r || 1) : i.drawElements(e, t || s.indexBuffer.data.length, a, (n || 0) * o)) : console.warn("unsupported index buffer type: uint32");
		} else s.instanced ? i.drawArraysInstanced(e, n, t || s.getSize(), r || 1) : i.drawArrays(e, n, t || s.getSize());
		return this;
	}
	unbind() {
		this.gl.bindVertexArray(null), (this._activeVao = null), (this._activeGeometry = null);
	}
	destroy() {
		this.renderer = null;
	}
}
(_p.extension = { type: _h.RendererSystem, name: "geometry" }), Sh.add(_p);
const wp = new sd();
class Cp {
	constructor(e, t) {
		(this._texture = e), (this.mapCoord = new sd()), (this.uClampFrame = new Float32Array(4)), (this.uClampOffset = new Float32Array(2)), (this._textureID = -1), (this._updateID = 0), (this.clampOffset = 0), (this.clampMargin = void 0 === t ? 0.5 : t), (this.isSimple = !1);
	}
	get texture() {
		return this._texture;
	}
	set texture(e) {
		(this._texture = e), (this._textureID = -1);
	}
	multiplyUvs(e, t) {
		void 0 === t && (t = e);
		const n = this.mapCoord;
		for (let r = 0; r < e.length; r += 2) {
			const i = e[r],
				s = e[r + 1];
			(t[r] = i * n.a + s * n.c + n.tx), (t[r + 1] = i * n.b + s * n.d + n.ty);
		}
		return t;
	}
	update(e) {
		const t = this._texture;
		if (!t || !t.valid) return !1;
		if (!e && this._textureID === t._updateID) return !1;
		(this._textureID = t._updateID), this._updateID++;
		const n = t._uvs;
		this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
		const r = t.orig,
			i = t.trim;
		i && (wp.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(wp));
		const s = t.baseTexture,
			o = this.uClampFrame,
			a = this.clampMargin / s.resolution,
			l = this.clampOffset;
		return (
			(o[0] = (t._frame.x + a + l) / s.width),
			(o[1] = (t._frame.y + a + l) / s.height),
			(o[2] = (t._frame.x + t._frame.width - a + l) / s.width),
			(o[3] = (t._frame.y + t._frame.height - a + l) / s.height),
			(this.uClampOffset[0] = l / s.realWidth),
			(this.uClampOffset[1] = l / s.realHeight),
			(this.isSimple = t._frame.width === s.width && t._frame.height === s.height && 0 === t.rotate),
			!0
		);
	}
}
class Sp extends Kd {
	constructor(e, t, n) {
		let r = null;
		"string" != typeof e && void 0 === t && void 0 === n && ((r = e), (e = void 0), (t = void 0), (n = void 0)),
			super(
				e ||
					"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = aTextureCoord;\n        vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)    ).xy;\n}\n",
				t ||
					"varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n        float clip = step(3.5,\n                step(maskClamp.x, vMaskCoord.x) +\n                step(maskClamp.y, vMaskCoord.y) +\n                step(vMaskCoord.x, maskClamp.z) +\n                step(vMaskCoord.y, maskClamp.w));\n\n        vec4 original = texture2D(uSampler, vTextureCoord);\n        vec4 masky = texture2D(mask, vMaskCoord);\n        float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n        original *= (alphaMul * masky.r * alpha * clip);\n\n        gl_FragColor = original;\n}\n",
				n
			),
			(this.maskSprite = r),
			(this.maskMatrix = new sd());
	}
	get maskSprite() {
		return this._maskSprite;
	}
	set maskSprite(e) {
		(this._maskSprite = e), this._maskSprite && (this._maskSprite.renderable = !1);
	}
	apply(e, t, n, r) {
		const i = this._maskSprite,
			s = i._texture;
		s.valid &&
			(s.uvMatrix || (s.uvMatrix = new Cp(s, 0)),
			s.uvMatrix.update(),
			(this.uniforms.npmAlpha = s.baseTexture.alphaMode ? 0 : 1),
			(this.uniforms.mask = s),
			(this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, i).prepend(s.uvMatrix.mapCoord)),
			(this.uniforms.alpha = i.worldAlpha),
			(this.uniforms.maskClamp = s.uvMatrix.uClampFrame),
			e.applyFilter(this, t, n, r));
	}
}
class Ep {
	constructor(e = null) {
		(this.type = Nl.NONE),
			(this.autoDetect = !0),
			(this.maskObject = e || null),
			(this.pooled = !1),
			(this.isMaskData = !0),
			(this.resolution = null),
			(this.multisample = Kd.defaultMultisample),
			(this.enabled = !0),
			(this.colorMask = 15),
			(this._filters = null),
			(this._stencilCounter = 0),
			(this._scissorCounter = 0),
			(this._scissorRect = null),
			(this._scissorRectLocal = null),
			(this._colorMask = 15),
			(this._target = null);
	}
	get filter() {
		return this._filters ? this._filters[0] : null;
	}
	set filter(e) {
		e ? (this._filters ? (this._filters[0] = e) : (this._filters = [e])) : (this._filters = null);
	}
	reset() {
		this.pooled && ((this.maskObject = null), (this.type = Nl.NONE), (this.autoDetect = !0)), (this._target = null), (this._scissorRectLocal = null);
	}
	copyCountersOrReset(e) {
		e ? ((this._stencilCounter = e._stencilCounter), (this._scissorCounter = e._scissorCounter), (this._scissorRect = e._scissorRect)) : ((this._stencilCounter = 0), (this._scissorCounter = 0), (this._scissorRect = null));
	}
}
class Tp {
	constructor(e) {
		(this.renderer = e), (this.enableScissor = !0), (this.alphaMaskPool = []), (this.maskDataPool = []), (this.maskStack = []), (this.alphaMaskIndex = 0);
	}
	setMaskStack(e) {
		(this.maskStack = e), this.renderer.scissor.setMaskStack(e), this.renderer.stencil.setMaskStack(e);
	}
	push(e, t) {
		let n = t;
		if (!n.isMaskData) {
			const e = this.maskDataPool.pop() || new Ep();
			(e.pooled = !0), (e.maskObject = t), (n = e);
		}
		const r = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
		if ((n.copyCountersOrReset(r), (n._colorMask = r ? r._colorMask : 15), n.autoDetect && this.detect(n), (n._target = e), n.type !== Nl.SPRITE && this.maskStack.push(n), n.enabled))
			switch (n.type) {
				case Nl.SCISSOR:
					this.renderer.scissor.push(n);
					break;
				case Nl.STENCIL:
					this.renderer.stencil.push(n);
					break;
				case Nl.SPRITE:
					n.copyCountersOrReset(null), this.pushSpriteMask(n);
					break;
				case Nl.COLOR:
					this.pushColorMask(n);
			}
		n.type === Nl.SPRITE && this.maskStack.push(n);
	}
	pop(e) {
		const t = this.maskStack.pop();
		if (t && t._target === e) {
			if (t.enabled)
				switch (t.type) {
					case Nl.SCISSOR:
						this.renderer.scissor.pop(t);
						break;
					case Nl.STENCIL:
						this.renderer.stencil.pop(t.maskObject);
						break;
					case Nl.SPRITE:
						this.popSpriteMask(t);
						break;
					case Nl.COLOR:
						this.popColorMask(t);
				}
			if ((t.reset(), t.pooled && this.maskDataPool.push(t), 0 !== this.maskStack.length)) {
				const e = this.maskStack[this.maskStack.length - 1];
				e.type === Nl.SPRITE && e._filters && (e._filters[0].maskSprite = e.maskObject);
			}
		}
	}
	detect(e) {
		const t = e.maskObject;
		t ? (t.isSprite ? (e.type = Nl.SPRITE) : this.enableScissor && this.renderer.scissor.testScissor(e) ? (e.type = Nl.SCISSOR) : (e.type = Nl.STENCIL)) : (e.type = Nl.COLOR);
	}
	pushSpriteMask(e) {
		var t, n;
		const { maskObject: r } = e,
			i = e._target;
		let s = e._filters;
		s || ((s = this.alphaMaskPool[this.alphaMaskIndex]), s || (s = this.alphaMaskPool[this.alphaMaskIndex] = [new Sp()]));
		const o = this.renderer,
			a = o.renderTexture;
		let l, u;
		if (a.current) {
			const n = a.current;
			(l = e.resolution || n.resolution), (u = null != (t = e.multisample) ? t : n.multisample);
		} else (l = e.resolution || o.resolution), (u = null != (n = e.multisample) ? n : o.multisample);
		(s[0].resolution = l), (s[0].multisample = u), (s[0].maskSprite = r);
		const c = i.filterArea;
		(i.filterArea = r.getBounds(!0)), o.filter.push(i, s), (i.filterArea = c), e._filters || this.alphaMaskIndex++;
	}
	popSpriteMask(e) {
		this.renderer.filter.pop(), e._filters ? (e._filters[0].maskSprite = null) : (this.alphaMaskIndex--, (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null));
	}
	pushColorMask(e) {
		const t = e._colorMask,
			n = (e._colorMask = t & e.colorMask);
		n !== t && this.renderer.gl.colorMask(0 != (1 & n), 0 != (2 & n), 0 != (4 & n), 0 != (8 & n));
	}
	popColorMask(e) {
		const t = e._colorMask,
			n = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
		n !== t && this.renderer.gl.colorMask(0 != (1 & n), 0 != (2 & n), 0 != (4 & n), 0 != (8 & n));
	}
	destroy() {
		this.renderer = null;
	}
}
(Tp.extension = { type: _h.RendererSystem, name: "mask" }), Sh.add(Tp);
class kp {
	constructor(e) {
		(this.renderer = e), (this.maskStack = []), (this.glConst = 0);
	}
	getStackLength() {
		return this.maskStack.length;
	}
	setMaskStack(e) {
		const { gl: t } = this.renderer,
			n = this.getStackLength();
		this.maskStack = e;
		const r = this.getStackLength();
		r !== n && (0 === r ? t.disable(this.glConst) : (t.enable(this.glConst), this._useCurrent()));
	}
	_useCurrent() {}
	destroy() {
		(this.renderer = null), (this.maskStack = null);
	}
}
const Ap = new sd(),
	Mp = [],
	Ip = class extends kp {
		constructor(e) {
			super(e), (this.glConst = Vl.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST);
		}
		getStackLength() {
			const e = this.maskStack[this.maskStack.length - 1];
			return e ? e._scissorCounter : 0;
		}
		calcScissorRect(e) {
			var t;
			if (e._scissorRectLocal) return;
			const n = e._scissorRect,
				{ maskObject: r } = e,
				{ renderer: i } = this,
				s = i.renderTexture,
				o = r.getBounds(!0, null != (t = Mp.pop()) ? t : new ed());
			this.roundFrameToPixels(o, s.current ? s.current.resolution : i.resolution, s.sourceFrame, s.destinationFrame, i.projection.transform), n && o.fit(n), (e._scissorRectLocal = o);
		}
		static isMatrixRotated(e) {
			if (!e) return !1;
			const { a: t, b: n, c: r, d: i } = e;
			return (Math.abs(n) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(i) > 1e-4);
		}
		testScissor(e) {
			const { maskObject: t } = e;
			if (!t.isFastRect || !t.isFastRect()) return !1;
			if (Ip.isMatrixRotated(t.worldTransform)) return !1;
			if (Ip.isMatrixRotated(this.renderer.projection.transform)) return !1;
			this.calcScissorRect(e);
			const n = e._scissorRectLocal;
			return n.width > 0 && n.height > 0;
		}
		roundFrameToPixels(e, t, n, r, i) {
			Ip.isMatrixRotated(i) ||
				((i = i ? Ap.copyFrom(i) : Ap.identity())
					.translate(-n.x, -n.y)
					.scale(r.width / n.width, r.height / n.height)
					.translate(r.x, r.y),
				this.renderer.filter.transformAABB(i, e),
				e.fit(r),
				(e.x = Math.round(e.x * t)),
				(e.y = Math.round(e.y * t)),
				(e.width = Math.round(e.width * t)),
				(e.height = Math.round(e.height * t)));
		}
		push(e) {
			e._scissorRectLocal || this.calcScissorRect(e);
			const { gl: t } = this.renderer;
			e._scissorRect || t.enable(t.SCISSOR_TEST), e._scissorCounter++, (e._scissorRect = e._scissorRectLocal), this._useCurrent();
		}
		pop(e) {
			const { gl: t } = this.renderer;
			e && Mp.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST);
		}
		_useCurrent() {
			const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
			let t;
			(t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y), this.renderer.gl.scissor(e.x, t, e.width, e.height);
		}
	};
let Rp = Ip;
(Rp.extension = { type: _h.RendererSystem, name: "scissor" }), Sh.add(Rp);
class Lp extends kp {
	constructor(e) {
		super(e), (this.glConst = Vl.ADAPTER.getWebGLRenderingContext().STENCIL_TEST);
	}
	getStackLength() {
		const e = this.maskStack[this.maskStack.length - 1];
		return e ? e._stencilCounter : 0;
	}
	push(e) {
		const t = e.maskObject,
			{ gl: n } = this.renderer,
			r = e._stencilCounter;
		0 === r && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), e._stencilCounter++;
		const i = e._colorMask;
		0 !== i && ((e._colorMask = 0), n.colorMask(!1, !1, !1, !1)),
			n.stencilFunc(n.EQUAL, r, 4294967295),
			n.stencilOp(n.KEEP, n.KEEP, n.INCR),
			(t.renderable = !0),
			t.render(this.renderer),
			this.renderer.batch.flush(),
			(t.renderable = !1),
			0 !== i && ((e._colorMask = i), n.colorMask(0 != (1 & i), 0 != (2 & i), 0 != (4 & i), 0 != (8 & i))),
			this._useCurrent();
	}
	pop(e) {
		const t = this.renderer.gl;
		if (0 === this.getStackLength()) t.disable(t.STENCIL_TEST);
		else {
			const n = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null,
				r = n ? n._colorMask : 15;
			0 !== r && ((n._colorMask = 0), t.colorMask(!1, !1, !1, !1)),
				t.stencilOp(t.KEEP, t.KEEP, t.DECR),
				(e.renderable = !0),
				e.render(this.renderer),
				this.renderer.batch.flush(),
				(e.renderable = !1),
				0 !== r && ((n._colorMask = r), t.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))),
				this._useCurrent();
		}
	}
	_useCurrent() {
		const e = this.renderer.gl;
		e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
	}
}
(Lp.extension = { type: _h.RendererSystem, name: "stencil" }), Sh.add(Lp);
class Op {
	constructor(e) {
		(this.renderer = e),
			(this.plugins = {}),
			Object.defineProperties(this.plugins, {
				extract: { enumerable: !1, get: () => (fc("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), e.extract) },
				prepare: { enumerable: !1, get: () => (fc("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), e.prepare) },
				interaction: { enumerable: !1, get: () => (fc("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), e.events) }
			});
	}
	init() {
		const e = this.rendererPlugins;
		for (const t in e) this.plugins[t] = new e[t](this.renderer);
	}
	destroy() {
		for (const e in this.plugins) this.plugins[e].destroy(), (this.plugins[e] = null);
	}
}
(Op.extension = { type: [_h.RendererSystem, _h.CanvasRendererSystem], name: "_plugin" }), Sh.add(Op);
class Pp {
	constructor(e) {
		(this.renderer = e), (this.destinationFrame = null), (this.sourceFrame = null), (this.defaultFrame = null), (this.projectionMatrix = new sd()), (this.transform = null);
	}
	update(e, t, n, r) {
		(this.destinationFrame = e || this.destinationFrame || this.defaultFrame), (this.sourceFrame = t || this.sourceFrame || e), this.calculateProjection(this.destinationFrame, this.sourceFrame, n, r), this.transform && this.projectionMatrix.append(this.transform);
		const i = this.renderer;
		(i.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix), i.globalUniforms.update(), i.shader.shader && i.shader.syncUniformGroup(i.shader.shader.uniforms.globals);
	}
	calculateProjection(e, t, n, r) {
		const i = this.projectionMatrix,
			s = r ? -1 : 1;
		i.identity(), (i.a = (1 / t.width) * 2), (i.d = s * ((1 / t.height) * 2)), (i.tx = -1 - t.x * i.a), (i.ty = -s - t.y * i.d);
	}
	setTransform(e) {}
	destroy() {
		this.renderer = null;
	}
}
(Pp.extension = { type: _h.RendererSystem, name: "projection" }), Sh.add(Pp);
const Np = new vd();
class Dp {
	constructor(e) {
		(this.renderer = e), (this._tempMatrix = new sd());
	}
	generateTexture(e, t) {
		const n = t || {},
			{ region: r } = n,
			i = h(n, ["region"]),
			s = r || e.getLocalBounds(null, !0);
		0 === s.width && (s.width = 1), 0 === s.height && (s.height = 1);
		const o = up.create(u({ width: s.width, height: s.height }, i));
		(this._tempMatrix.tx = -s.x), (this._tempMatrix.ty = -s.y);
		const a = e.transform;
		return (e.transform = Np), this.renderer.render(e, { renderTexture: o, transform: this._tempMatrix, skipUpdateTransform: !!e.parent, blit: !0 }), (e.transform = a), o;
	}
	destroy() {}
}
(Dp.extension = { type: [_h.RendererSystem, _h.CanvasRendererSystem], name: "textureGenerator" }), Sh.add(Dp);
const Bp = new ed(),
	Fp = new ed();
class Hp {
	constructor(e) {
		(this.renderer = e), (this.defaultMaskStack = []), (this.current = null), (this.sourceFrame = new ed()), (this.destinationFrame = new ed()), (this.viewportFrame = new ed());
	}
	contextChange() {
		var e;
		const t = null == (e = this.renderer) ? void 0 : e.gl.getContextAttributes();
		this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha);
	}
	bind(e = null, t, n) {
		const r = this.renderer;
		let i, s, o;
		(this.current = e),
			e
				? ((i = e.baseTexture), (o = i.resolution), t || ((Bp.width = e.frame.width), (Bp.height = e.frame.height), (t = Bp)), n || ((Fp.x = e.frame.x), (Fp.y = e.frame.y), (Fp.width = t.width), (Fp.height = t.height), (n = Fp)), (s = i.framebuffer))
				: ((o = r.resolution), t || ((Bp.width = r._view.screen.width), (Bp.height = r._view.screen.height), (t = Bp)), n || (((n = Bp).width = t.width), (n.height = t.height)));
		const a = this.viewportFrame;
		(a.x = n.x * o),
			(a.y = n.y * o),
			(a.width = n.width * o),
			(a.height = n.height * o),
			e || (a.y = r.view.height - (a.y + a.height)),
			a.ceil(),
			this.renderer.framebuffer.bind(s, a),
			this.renderer.projection.update(n, t, o, !s),
			e ? this.renderer.mask.setMaskStack(i.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
			this.sourceFrame.copyFrom(t),
			this.destinationFrame.copyFrom(n);
	}
	clear(e, t) {
		const n = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor,
			r = Wc.shared.setValue(e || n);
		((this.current && this.current.baseTexture.alphaMode > 0) || (!this.current && this._rendererPremultipliedAlpha)) && r.premultiply(r.alpha);
		const i = this.destinationFrame,
			s = this.current ? this.current.baseTexture : this.renderer._view.screen,
			o = i.width !== s.width || i.height !== s.height;
		if (o) {
			let { x: e, y: t, width: n, height: r } = this.viewportFrame;
			(e = Math.round(e)), (t = Math.round(t)), (n = Math.round(n)), (r = Math.round(r)), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(e, t, n, r);
		}
		this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, t), o && this.renderer.scissor.pop();
	}
	resize() {
		this.bind(null);
	}
	reset() {
		this.bind(null);
	}
	destroy() {
		this.renderer = null;
	}
}
(Hp.extension = { type: _h.RendererSystem, name: "renderTexture" }), Sh.add(Hp);
class Vp {}
class Up {
	constructor(e, t) {
		(this.program = e), (this.uniformData = t), (this.uniformGroups = {}), (this.uniformDirtyGroups = {}), (this.uniformBufferBindings = {});
	}
	destroy() {
		(this.uniformData = null), (this.uniformGroups = null), (this.uniformDirtyGroups = null), (this.uniformBufferBindings = null), (this.program = null);
	}
}
function zp(e, t) {
	var n;
	const r = gd(e, e.VERTEX_SHADER, t.vertexSrc),
		i = gd(e, e.FRAGMENT_SHADER, t.fragmentSrc),
		s = e.createProgram();
	e.attachShader(s, r), e.attachShader(s, i);
	const o = null == (n = t.extra) ? void 0 : n.transformFeedbackVaryings;
	if (
		(o && ("function" != typeof e.transformFeedbackVaryings ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(s, o.names, "separate" === o.bufferMode ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)),
		e.linkProgram(s),
		e.getProgramParameter(s, e.LINK_STATUS) ||
			(function (e, t, n, r) {
				e.getProgramParameter(t, e.LINK_STATUS) ||
					(e.getShaderParameter(n, e.COMPILE_STATUS) || kd(e, n),
					e.getShaderParameter(r, e.COMPILE_STATUS) || kd(e, r),
					console.error("PixiJS Error: Could not initialize shader."),
					"" !== e.getProgramInfoLog(t) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)));
			})(e, s, r, i),
		(t.attributeData = (function (e, t) {
			const n = {},
				r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
			for (let i = 0; i < r; i++) {
				const r = t.getActiveAttrib(e, i);
				if (r.name.startsWith("gl_")) continue;
				const s = Ld(t, r.type),
					o = { type: s, name: r.name, size: Md(s), location: t.getAttribLocation(e, r.name) };
				n[r.name] = o;
			}
			return n;
		})(s, e)),
		(t.uniformData = (function (e, t) {
			const n = {},
				r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
			for (let i = 0; i < r; i++) {
				const r = t.getActiveUniform(e, i),
					s = r.name.replace(/\[.*?\]$/, ""),
					o = !!r.name.match(/\[.*?\]$/),
					a = Ld(t, r.type);
				n[s] = { name: s, index: i, type: a, size: r.size, isArray: o, value: bd(a, r.size) };
			}
			return n;
		})(s, e)),
		!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc))
	) {
		const n = Object.keys(t.attributeData);
		n.sort((e, t) => (e > t ? 1 : -1));
		for (let r = 0; r < n.length; r++) (t.attributeData[n[r]].location = r), e.bindAttribLocation(s, r, n[r]);
		e.linkProgram(s);
	}
	e.deleteShader(r), e.deleteShader(i);
	const a = {};
	for (const l in t.uniformData) {
		const n = t.uniformData[l];
		a[l] = { location: e.getUniformLocation(s, l), value: bd(n.type, n.size) };
	}
	return new Up(s, a);
}
function $p(e, t, n, r, i) {
	n.buffer.update(i);
}
const jp = {
		float: "\n                data[offset] = v;\n        ",
		vec2: "\n                data[offset] = v[0];\n                data[offset+1] = v[1];\n        ",
		vec3: "\n                data[offset] = v[0];\n                data[offset+1] = v[1];\n                data[offset+2] = v[2];\n\n        ",
		vec4: "\n                data[offset] = v[0];\n                data[offset+1] = v[1];\n                data[offset+2] = v[2];\n                data[offset+3] = v[3];\n        ",
		mat2: "\n                data[offset] = v[0];\n                data[offset+1] = v[1];\n\n                data[offset+4] = v[2];\n                data[offset+5] = v[3];\n        ",
		mat3: "\n                data[offset] = v[0];\n                data[offset+1] = v[1];\n                data[offset+2] = v[2];\n\n                data[offset + 4] = v[3];\n                data[offset + 5] = v[4];\n                data[offset + 6] = v[5];\n\n                data[offset + 8] = v[6];\n                data[offset + 9] = v[7];\n                data[offset + 10] = v[8];\n        ",
		mat4: "\n                for(var i = 0; i < 16; i++)\n                {\n                        data[offset + i] = v[i];\n                }\n        "
	},
	Wp = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
function Gp(e) {
	const t = e.map((e) => ({ data: e, offset: 0, dataLen: 0, dirty: 0 }));
	let n = 0,
		r = 0,
		i = 0;
	for (let s = 0; s < t.length; s++) {
		const e = t[s];
		if (((n = Wp[e.data.type]), e.data.size > 1 && (n = Math.max(n, 16) * e.data.size), (e.dataLen = n), r % n != 0 && r < 16)) {
			const e = (r % n) % 16;
			(r += e), (i += e);
		}
		r + n > 16 ? ((i = 16 * Math.ceil(i / 16)), (e.offset = i), (i += n), (r = n)) : ((e.offset = i), (r += n), (i += n));
	}
	return (i = 16 * Math.ceil(i / 16)), { uboElements: t, size: i };
}
function Yp(e, t) {
	const n = [];
	for (const r in e) t[r] && n.push(t[r]);
	return n.sort((e, t) => e.index - t.index), n;
}
function Xp(e, t) {
	if (!e.autoManage) return { size: 0, syncFunc: $p };
	const n = Yp(e.uniforms, t),
		{ uboElements: r, size: i } = Gp(n),
		s = ["\n        var v = null;\n        var v2 = null;\n        var cv = null;\n        var t = 0;\n        var gl = renderer.gl\n        var index = 0;\n        var data = buffer.data;\n        "];
	for (let o = 0; o < r.length; o++) {
		const t = r[o],
			n = e.uniforms[t.data.name],
			i = t.data.name;
		let a = !1;
		for (let e = 0; e < xd.length; e++) {
			const r = xd[e];
			if (r.codeUbo && r.test(t.data, n)) {
				s.push(`offset = ${t.offset / 4};`, xd[e].codeUbo(t.data.name, n)), (a = !0);
				break;
			}
		}
		if (!a)
			if (t.data.size > 1) {
				const e = Md(t.data.type),
					n = Math.max(Wp[t.data.type] / 16, 1),
					r = e / n,
					o = (4 - (r % 4)) % 4;
				s.push(
					`\n                                cv = ud.${i}.value;\n                                v = uv.${i};\n                                offset = ${t.offset / 4};\n\n                                t = 0;\n\n                                for(var i=0; i < ${
						t.data.size * n
					}; i++)\n                                {\n                                        for(var j = 0; j < ${r}; j++)\n                                        {\n                                                data[offset++] = v[t++];\n                                        }\n                                        offset += ${o};\n                                }\n\n                                `
				);
			} else {
				const e = jp[t.data.type];
				s.push(`\n                                cv = ud.${i}.value;\n                                v = uv.${i};\n                                offset = ${t.offset / 4};\n                                ${e};\n                                `);
			}
	}
	return s.push("\n             renderer.buffer.update(buffer);\n        "), { size: i, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", s.join("\n")) };
}
let Kp = 0;
const qp = { textureCount: 0, uboCount: 0 };
class Zp {
	constructor(e) {
		(this.destroyed = !1), (this.renderer = e), this.systemCheck(), (this.gl = null), (this.shader = null), (this.program = null), (this.cache = {}), (this._uboCache = {}), (this.id = Kp++);
	}
	systemCheck() {
		if (!Nd()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
	}
	contextChange(e) {
		(this.gl = e), this.reset();
	}
	bind(e, t) {
		e.disposeRunner.add(this), (e.uniforms.globals = this.renderer.globalUniforms);
		const n = e.program,
			r = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
		return (this.shader = e), this.program !== n && ((this.program = n), this.gl.useProgram(r.program)), t || ((qp.textureCount = 0), (qp.uboCount = 0), this.syncUniformGroup(e.uniformGroup, qp)), r;
	}
	setUniforms(e) {
		const t = this.shader.program,
			n = t.glPrograms[this.renderer.CONTEXT_UID];
		t.syncUniforms(n.uniformData, e, this.renderer);
	}
	syncUniformGroup(e, t) {
		const n = this.getGlProgram();
		(e.static && e.dirtyId === n.uniformDirtyGroups[e.id]) || ((n.uniformDirtyGroups[e.id] = e.dirtyId), this.syncUniforms(e, n, t));
	}
	syncUniforms(e, t, n) {
		(e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e))(t.uniformData, e.uniforms, this.renderer, n);
	}
	createSyncGroups(e) {
		const t = this.getSignature(e, this.shader.program.uniformData, "u");
		return (
			this.cache[t] ||
				(this.cache[t] = (function (e, t) {
					var n;
					const r = ["\n                var v = null;\n                var cv = null;\n                var cu = null;\n                var t = 0;\n                var gl = renderer.gl;\n        "];
					for (const i in e.uniforms) {
						const s = t[i];
						if (!s) {
							(null == (n = e.uniforms[i]) ? void 0 : n.group) &&
								(e.uniforms[i].ubo
									? r.push(`\n                                                renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');\n                                        `)
									: r.push(`\n                                                renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                                        `));
							continue;
						}
						const o = e.uniforms[i];
						let a = !1;
						for (let e = 0; e < xd.length; e++)
							if (xd[e].test(s, o)) {
								r.push(xd[e].code(i, o)), (a = !0);
								break;
							}
						if (!a) {
							const e = (1 !== s.size || s.isArray ? wd : _d)[s.type].replace("location", `ud["${i}"].location`);
							r.push(`\n                        cu = ud["${i}"];\n                        cv = cu.value;\n                        v = uv["${i}"];\n                        ${e};`);
						}
					}
					return new Function("ud", "uv", "renderer", "syncData", r.join("\n"));
				})(e, this.shader.program.uniformData)),
			(e.syncUniforms[this.shader.program.id] = this.cache[t]),
			e.syncUniforms[this.shader.program.id]
		);
	}
	syncUniformBufferGroup(e, t) {
		const n = this.getGlProgram();
		if (!e.static || 0 !== e.dirtyId || !n.uniformGroups[e.id]) {
			e.dirtyId = 0;
			const r = n.uniformGroups[e.id] || this.createSyncBufferGroup(e, n, t);
			e.buffer.update(), r(n.uniformData, e.uniforms, this.renderer, qp, e.buffer);
		}
		this.renderer.buffer.bindBufferBase(e.buffer, n.uniformBufferBindings[t]);
	}
	createSyncBufferGroup(e, t, n) {
		const { gl: r } = this.renderer;
		this.renderer.buffer.bind(e.buffer);
		const i = this.gl.getUniformBlockIndex(t.program, n);
		(t.uniformBufferBindings[n] = this.shader.uniformBindCount), r.uniformBlockBinding(t.program, i, this.shader.uniformBindCount), this.shader.uniformBindCount++;
		const s = this.getSignature(e, this.shader.program.uniformData, "ubo");
		let o = this._uboCache[s];
		if ((o || (o = this._uboCache[s] = Xp(e, this.shader.program.uniformData)), e.autoManage)) {
			const t = new Float32Array(o.size / 4);
			e.buffer.update(t);
		}
		return (t.uniformGroups[e.id] = o.syncFunc), t.uniformGroups[e.id];
	}
	getSignature(e, t, n) {
		const r = e.uniforms,
			i = [`${n}-`];
		for (const s in r) i.push(s), t[s] && i.push(t[s].type);
		return i.join("-");
	}
	getGlProgram() {
		return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
	}
	generateProgram(e) {
		const t = this.gl,
			n = e.program,
			r = zp(t, n);
		return (n.glPrograms[this.renderer.CONTEXT_UID] = r), r;
	}
	reset() {
		(this.program = null), (this.shader = null);
	}
	disposeShader(e) {
		this.shader === e && (this.shader = null);
	}
	destroy() {
		(this.renderer = null), (this.destroyed = !0);
	}
}
(Zp.extension = { type: _h.RendererSystem, name: "shader" }), Sh.add(Zp);
class Jp {
	constructor(e) {
		this.renderer = e;
	}
	run(e) {
		const { renderer: t } = this;
		t.runners.init.emit(t.options), e.hello && console.log(`PixiJS 7.2.4 - ${t.rendererLogId} - https://pixijs.com`), t.resize(t.screen.width, t.screen.height);
	}
	destroy() {}
}
(Jp.defaultOptions = { hello: !1 }), (Jp.extension = { type: [_h.RendererSystem, _h.CanvasRendererSystem], name: "startup" }), Sh.add(Jp);
const Qp = class {
	constructor() {
		(this.gl = null),
			(this.stateId = 0),
			(this.polygonOffset = 0),
			(this.blendMode = wl.NONE),
			(this._blendEq = !1),
			(this.map = []),
			(this.map[0] = this.setBlend),
			(this.map[1] = this.setOffset),
			(this.map[2] = this.setCullFace),
			(this.map[3] = this.setDepthTest),
			(this.map[4] = this.setFrontFace),
			(this.map[5] = this.setDepthMask),
			(this.checks = []),
			(this.defaultState = new Mh()),
			(this.defaultState.blend = !0);
	}
	contextChange(e) {
		(this.gl = e),
			(this.blendModes = (function (e, t = []) {
				return (
					(t[wl.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.ADD] = [e.ONE, e.ONE]),
					(t[wl.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.NONE] = [0, 0]),
					(t[wl.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE]),
					(t[wl.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.SRC_IN] = [e.DST_ALPHA, e.ZERO]),
					(t[wl.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO]),
					(t[wl.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE]),
					(t[wl.DST_IN] = [e.ZERO, e.SRC_ALPHA]),
					(t[wl.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA]),
					(t[wl.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA]),
					(t[wl.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD]),
					t
				);
			})(e)),
			this.set(this.defaultState),
			this.reset();
	}
	set(e) {
		if (((e = e || this.defaultState), this.stateId !== e.data)) {
			let t = this.stateId ^ e.data,
				n = 0;
			for (; t; ) 1 & t && this.map[n].call(this, !!(e.data & (1 << n))), (t >>= 1), n++;
			this.stateId = e.data;
		}
		for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
	}
	forceState(e) {
		e = e || this.defaultState;
		for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & (1 << t)));
		for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
		this.stateId = e.data;
	}
	setBlend(e) {
		this.updateCheck(Qp.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND);
	}
	setOffset(e) {
		this.updateCheck(Qp.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
	}
	setDepthTest(e) {
		this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
	}
	setDepthMask(e) {
		this.gl.depthMask(e);
	}
	setCullFace(e) {
		this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE);
	}
	setFrontFace(e) {
		this.gl.frontFace(this.gl[e ? "CW" : "CCW"]);
	}
	setBlendMode(e) {
		if (e === this.blendMode) return;
		this.blendMode = e;
		const t = this.blendModes[e],
			n = this.gl;
		2 === t.length ? n.blendFunc(t[0], t[1]) : n.blendFuncSeparate(t[0], t[1], t[2], t[3]), 6 === t.length ? ((this._blendEq = !0), n.blendEquationSeparate(t[4], t[5])) : this._blendEq && ((this._blendEq = !1), n.blendEquationSeparate(n.FUNC_ADD, n.FUNC_ADD));
	}
	setPolygonOffset(e, t) {
		this.gl.polygonOffset(e, t);
	}
	reset() {
		this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), (this._blendEq = !0), (this.blendMode = -1), this.setBlendMode(0);
	}
	updateCheck(e, t) {
		const n = this.checks.indexOf(e);
		t && -1 === n ? this.checks.push(e) : t || -1 === n || this.checks.splice(n, 1);
	}
	static checkBlendMode(e, t) {
		e.setBlendMode(t.blendMode);
	}
	static checkPolygonOffset(e, t) {
		e.setPolygonOffset(1, t.polygonOffset);
	}
	destroy() {
		this.gl = null;
	}
};
let ef = Qp;
(ef.extension = { type: _h.RendererSystem, name: "state" }), Sh.add(ef);
class tf extends lu {
	constructor() {
		super(...arguments), (this.runners = {}), (this._systemsHash = {});
	}
	setup(e) {
		var t;
		this.addRunners(...e.runners);
		const n = (null != (t = e.priority) ? t : []).filter((t) => e.systems[t]),
			r = [...n, ...Object.keys(e.systems).filter((e) => !n.includes(e))];
		for (const i of r) this.addSystem(e.systems[i], i);
	}
	addRunners(...e) {
		e.forEach((e) => {
			this.runners[e] = new Lh(e);
		});
	}
	addSystem(e, t) {
		const n = new e(this);
		if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
		(this[t] = n), (this._systemsHash[t] = n);
		for (const r in this.runners) this.runners[r].add(n);
		return this;
	}
	emitWithCustomOptions(e, t) {
		const n = Object.keys(this._systemsHash);
		e.items.forEach((r) => {
			const i = n.find((e) => this._systemsHash[e] === r);
			r[e.name](t[i]);
		});
	}
	destroy() {
		Object.values(this.runners).forEach((e) => {
			e.destroy();
		}),
			(this._systemsHash = {});
	}
}
const nf = class {
	constructor(e) {
		(this.renderer = e), (this.count = 0), (this.checkCount = 0), (this.maxIdle = nf.defaultMaxIdle), (this.checkCountMax = nf.defaultCheckCountMax), (this.mode = nf.defaultMode);
	}
	postrender() {
		this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== Ol.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && ((this.checkCount = 0), this.run())));
	}
	run() {
		const e = this.renderer.texture,
			t = e.managedTextures;
		let n = !1;
		for (let r = 0; r < t.length; r++) {
			const i = t[r];
			!i.framebuffer && this.count - i.touched > this.maxIdle && (e.destroyTexture(i, !0), (t[r] = null), (n = !0));
		}
		if (n) {
			let e = 0;
			for (let n = 0; n < t.length; n++) null !== t[n] && (t[e++] = t[n]);
			t.length = e;
		}
	}
	unload(e) {
		const t = this.renderer.texture,
			n = e._texture;
		n && !n.framebuffer && t.destroyTexture(n);
		for (let r = e.children.length - 1; r >= 0; r--) this.unload(e.children[r]);
	}
	destroy() {
		this.renderer = null;
	}
};
let rf = nf;
(rf.defaultMode = Ol.AUTO), (rf.defaultMaxIdle = 3600), (rf.defaultCheckCountMax = 600), (rf.extension = { type: _h.RendererSystem, name: "textureGC" }), Sh.add(rf);
class sf {
	constructor(e) {
		(this.texture = e), (this.width = -1), (this.height = -1), (this.dirtyId = -1), (this.dirtyStyleId = -1), (this.mipmap = !1), (this.wrapMode = 33071), (this.type = Tl.UNSIGNED_BYTE), (this.internalFormat = Sl.RGBA), (this.samplerType = 0);
	}
}
class of {
	constructor(e) {
		(this.renderer = e), (this.boundTextures = []), (this.currentLocation = -1), (this.managedTextures = []), (this._unknownBoundTextures = !1), (this.unknownTexture = new Bh()), (this.hasIntegerTextures = !1);
	}
	contextChange() {
		const e = (this.gl = this.renderer.gl);
		(this.CONTEXT_UID = this.renderer.CONTEXT_UID),
			(this.webGLVersion = this.renderer.context.webGLVersion),
			(this.internalFormats = (function (e) {
				let t;
				return (
					(t =
						"WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext
							? {
									[Tl.UNSIGNED_BYTE]: {
										[Sl.RGBA]: e.RGBA8,
										[Sl.RGB]: e.RGB8,
										[Sl.RG]: e.RG8,
										[Sl.RED]: e.R8,
										[Sl.RGBA_INTEGER]: e.RGBA8UI,
										[Sl.RGB_INTEGER]: e.RGB8UI,
										[Sl.RG_INTEGER]: e.RG8UI,
										[Sl.RED_INTEGER]: e.R8UI,
										[Sl.ALPHA]: e.ALPHA,
										[Sl.LUMINANCE]: e.LUMINANCE,
										[Sl.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
									},
									[Tl.BYTE]: { [Sl.RGBA]: e.RGBA8_SNORM, [Sl.RGB]: e.RGB8_SNORM, [Sl.RG]: e.RG8_SNORM, [Sl.RED]: e.R8_SNORM, [Sl.RGBA_INTEGER]: e.RGBA8I, [Sl.RGB_INTEGER]: e.RGB8I, [Sl.RG_INTEGER]: e.RG8I, [Sl.RED_INTEGER]: e.R8I },
									[Tl.UNSIGNED_SHORT]: { [Sl.RGBA_INTEGER]: e.RGBA16UI, [Sl.RGB_INTEGER]: e.RGB16UI, [Sl.RG_INTEGER]: e.RG16UI, [Sl.RED_INTEGER]: e.R16UI, [Sl.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16 },
									[Tl.SHORT]: { [Sl.RGBA_INTEGER]: e.RGBA16I, [Sl.RGB_INTEGER]: e.RGB16I, [Sl.RG_INTEGER]: e.RG16I, [Sl.RED_INTEGER]: e.R16I },
									[Tl.UNSIGNED_INT]: { [Sl.RGBA_INTEGER]: e.RGBA32UI, [Sl.RGB_INTEGER]: e.RGB32UI, [Sl.RG_INTEGER]: e.RG32UI, [Sl.RED_INTEGER]: e.R32UI, [Sl.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24 },
									[Tl.INT]: { [Sl.RGBA_INTEGER]: e.RGBA32I, [Sl.RGB_INTEGER]: e.RGB32I, [Sl.RG_INTEGER]: e.RG32I, [Sl.RED_INTEGER]: e.R32I },
									[Tl.FLOAT]: { [Sl.RGBA]: e.RGBA32F, [Sl.RGB]: e.RGB32F, [Sl.RG]: e.RG32F, [Sl.RED]: e.R32F, [Sl.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F },
									[Tl.HALF_FLOAT]: { [Sl.RGBA]: e.RGBA16F, [Sl.RGB]: e.RGB16F, [Sl.RG]: e.RG16F, [Sl.RED]: e.R16F },
									[Tl.UNSIGNED_SHORT_5_6_5]: { [Sl.RGB]: e.RGB565 },
									[Tl.UNSIGNED_SHORT_4_4_4_4]: { [Sl.RGBA]: e.RGBA4 },
									[Tl.UNSIGNED_SHORT_5_5_5_1]: { [Sl.RGBA]: e.RGB5_A1 },
									[Tl.UNSIGNED_INT_2_10_10_10_REV]: { [Sl.RGBA]: e.RGB10_A2, [Sl.RGBA_INTEGER]: e.RGB10_A2UI },
									[Tl.UNSIGNED_INT_10F_11F_11F_REV]: { [Sl.RGB]: e.R11F_G11F_B10F },
									[Tl.UNSIGNED_INT_5_9_9_9_REV]: { [Sl.RGB]: e.RGB9_E5 },
									[Tl.UNSIGNED_INT_24_8]: { [Sl.DEPTH_STENCIL]: e.DEPTH24_STENCIL8 },
									[Tl.FLOAT_32_UNSIGNED_INT_24_8_REV]: { [Sl.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8 }
							  }
							: {
									[Tl.UNSIGNED_BYTE]: { [Sl.RGBA]: e.RGBA, [Sl.RGB]: e.RGB, [Sl.ALPHA]: e.ALPHA, [Sl.LUMINANCE]: e.LUMINANCE, [Sl.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA },
									[Tl.UNSIGNED_SHORT_5_6_5]: { [Sl.RGB]: e.RGB },
									[Tl.UNSIGNED_SHORT_4_4_4_4]: { [Sl.RGBA]: e.RGBA },
									[Tl.UNSIGNED_SHORT_5_5_5_1]: { [Sl.RGBA]: e.RGBA }
							  }),
					t
				);
			})(e));
		const t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
		this.boundTextures.length = t;
		for (let r = 0; r < t; r++) this.boundTextures[r] = null;
		this.emptyTextures = {};
		const n = new sf(e.createTexture());
		e.bindTexture(e.TEXTURE_2D, n.texture),
			e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)),
			(this.emptyTextures[e.TEXTURE_2D] = n),
			(this.emptyTextures[e.TEXTURE_CUBE_MAP] = new sf(e.createTexture())),
			e.bindTexture(e.TEXTURE_CUBE_MAP, this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);
		for (let r = 0; r < 6; r++) e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, null);
		e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
		for (let r = 0; r < this.boundTextures.length; r++) this.bind(null, r);
	}
	bind(e, t = 0) {
		const { gl: n } = this;
		if ((null == (e = null == e ? void 0 : e.castToBaseTexture()) ? void 0 : e.valid) && !e.parentTextureArray) {
			e.touched = this.renderer.textureGC.count;
			const r = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
			this.boundTextures[t] !== e && (this.currentLocation !== t && ((this.currentLocation = t), n.activeTexture(n.TEXTURE0 + t)), n.bindTexture(e.target, r.texture)),
				r.dirtyId !== e.dirtyId ? (this.currentLocation !== t && ((this.currentLocation = t), n.activeTexture(n.TEXTURE0 + t)), this.updateTexture(e)) : r.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e),
				(this.boundTextures[t] = e);
		} else this.currentLocation !== t && ((this.currentLocation = t), n.activeTexture(n.TEXTURE0 + t)), n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture), (this.boundTextures[t] = null);
	}
	reset() {
		(this._unknownBoundTextures = !0), (this.hasIntegerTextures = !1), (this.currentLocation = -1);
		for (let e = 0; e < this.boundTextures.length; e++) this.boundTextures[e] = this.unknownTexture;
	}
	unbind(e) {
		const { gl: t, boundTextures: n } = this;
		if (this._unknownBoundTextures) {
			this._unknownBoundTextures = !1;
			for (let e = 0; e < n.length; e++) n[e] === this.unknownTexture && this.bind(null, e);
		}
		for (let r = 0; r < n.length; r++) n[r] === e && (this.currentLocation !== r && (t.activeTexture(t.TEXTURE0 + r), (this.currentLocation = r)), t.bindTexture(e.target, this.emptyTextures[e.target].texture), (n[r] = null));
	}
	ensureSamplerType(e) {
		const { boundTextures: t, hasIntegerTextures: n, CONTEXT_UID: r } = this;
		if (n)
			for (let i = e - 1; i >= 0; --i) {
				const e = t[i];
				if (e) {
					e._glTextures[r].samplerType !== kl.FLOAT && this.renderer.texture.unbind(e);
				}
			}
	}
	initTexture(e) {
		const t = new sf(this.gl.createTexture());
		return (t.dirtyId = -1), (e._glTextures[this.CONTEXT_UID] = t), this.managedTextures.push(e), e.on("dispose", this.destroyTexture, this), t;
	}
	initTextureType(e, t) {
		var n, r;
		(t.internalFormat = null != (r = null == (n = this.internalFormats[e.type]) ? void 0 : n[e.format]) ? r : e.format), 2 === this.webGLVersion && e.type === Tl.HALF_FLOAT ? (t.type = this.gl.HALF_FLOAT) : (t.type = e.type);
	}
	updateTexture(e) {
		var t;
		const n = e._glTextures[this.CONTEXT_UID];
		if (!n) return;
		const r = this.renderer;
		if ((this.initTextureType(e, n), null == (t = e.resource) ? void 0 : t.upload(r, e, n))) n.samplerType !== kl.FLOAT && (this.hasIntegerTextures = !0);
		else {
			const t = e.realWidth,
				i = e.realHeight,
				s = r.gl;
			(n.width !== t || n.height !== i || n.dirtyId < 0) && ((n.width = t), (n.height = i), s.texImage2D(e.target, 0, n.internalFormat, t, i, 0, e.format, n.type, null));
		}
		e.dirtyStyleId !== n.dirtyStyleId && this.updateTextureStyle(e), (n.dirtyId = e.dirtyId);
	}
	destroyTexture(e, t) {
		const { gl: n } = this;
		if ((e = e.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(e), n.deleteTexture(e._glTextures[this.CONTEXT_UID].texture), e.off("dispose", this.destroyTexture, this), delete e._glTextures[this.CONTEXT_UID], !t)) {
			const t = this.managedTextures.indexOf(e);
			-1 !== t && rh(this.managedTextures, t, 1);
		}
	}
	updateTextureStyle(e) {
		var t;
		const n = e._glTextures[this.CONTEXT_UID];
		n &&
			((e.mipmap !== Il.POW2 && 2 === this.webGLVersion) || e.isPowerOfTwo ? (n.mipmap = e.mipmap >= 1) : (n.mipmap = !1),
			2 === this.webGLVersion || e.isPowerOfTwo ? (n.wrapMode = e.wrapMode) : (n.wrapMode = Ml.CLAMP),
			(null == (t = e.resource) ? void 0 : t.style(this.renderer, e, n)) || this.setStyle(e, n),
			(n.dirtyStyleId = e.dirtyStyleId));
	}
	setStyle(e, t) {
		const n = this.gl;
		if ((t.mipmap && e.mipmap !== Il.ON_MANUAL && n.generateMipmap(e.target), n.texParameteri(e.target, n.TEXTURE_WRAP_S, t.wrapMode), n.texParameteri(e.target, n.TEXTURE_WRAP_T, t.wrapMode), t.mipmap)) {
			n.texParameteri(e.target, n.TEXTURE_MIN_FILTER, e.scaleMode === Al.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST);
			const t = this.renderer.context.extensions.anisotropicFiltering;
			if (t && e.anisotropicLevel > 0 && e.scaleMode === Al.LINEAR) {
				const r = Math.min(e.anisotropicLevel, n.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
				n.texParameterf(e.target, t.TEXTURE_MAX_ANISOTROPY_EXT, r);
			}
		} else n.texParameteri(e.target, n.TEXTURE_MIN_FILTER, e.scaleMode === Al.LINEAR ? n.LINEAR : n.NEAREST);
		n.texParameteri(e.target, n.TEXTURE_MAG_FILTER, e.scaleMode === Al.LINEAR ? n.LINEAR : n.NEAREST);
	}
	destroy() {
		this.renderer = null;
	}
}
(of.extension = { type: _h.RendererSystem, name: "texture" }), Sh.add(of);
class af {
	constructor(e) {
		this.renderer = e;
	}
	contextChange() {
		(this.gl = this.renderer.gl), (this.CONTEXT_UID = this.renderer.CONTEXT_UID);
	}
	bind(e) {
		const { gl: t, CONTEXT_UID: n } = this,
			r = e._glTransformFeedbacks[n] || this.createGLTransformFeedback(e);
		t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, r);
	}
	unbind() {
		const { gl: e } = this;
		e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null);
	}
	beginTransformFeedback(e, t) {
		const { gl: n, renderer: r } = this;
		t && r.shader.bind(t), n.beginTransformFeedback(e);
	}
	endTransformFeedback() {
		const { gl: e } = this;
		e.endTransformFeedback();
	}
	createGLTransformFeedback(e) {
		const { gl: t, renderer: n, CONTEXT_UID: r } = this,
			i = t.createTransformFeedback();
		(e._glTransformFeedbacks[r] = i), t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, i);
		for (let s = 0; s < e.buffers.length; s++) {
			const i = e.buffers[s];
			i && (n.buffer.update(i), i._glBuffers[r].refCount++, t.bindBufferBase(t.TRANSFORM_FEEDBACK_BUFFER, s, i._glBuffers[r].buffer || null));
		}
		return t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null), e.disposeRunner.add(this), i;
	}
	disposeTransformFeedback(e, t) {
		const n = e._glTransformFeedbacks[this.CONTEXT_UID],
			r = this.gl;
		e.disposeRunner.remove(this);
		const i = this.renderer.buffer;
		if (i)
			for (let s = 0; s < e.buffers.length; s++) {
				const n = e.buffers[s];
				if (!n) continue;
				const r = n._glBuffers[this.CONTEXT_UID];
				r && (r.refCount--, 0 !== r.refCount || t || i.dispose(n, t));
			}
		n && (t || r.deleteTransformFeedback(n), delete e._glTransformFeedbacks[this.CONTEXT_UID]);
	}
	destroy() {
		this.renderer = null;
	}
}
(af.extension = { type: _h.RendererSystem, name: "transformFeedback" }), Sh.add(af);
class lf {
	constructor(e) {
		this.renderer = e;
	}
	init(e) {
		(this.screen = new ed(0, 0, e.width, e.height)), (this.element = e.view || Vl.ADAPTER.createCanvas()), (this.resolution = e.resolution || Vl.RESOLUTION), (this.autoDensity = !!e.autoDensity);
	}
	resizeView(e, t) {
		(this.element.width = Math.round(e * this.resolution)), (this.element.height = Math.round(t * this.resolution));
		const n = this.element.width / this.resolution,
			r = this.element.height / this.resolution;
		(this.screen.width = n), (this.screen.height = r), this.autoDensity && ((this.element.style.width = `${n}px`), (this.element.style.height = `${r}px`)), this.renderer.emit("resize", n, r), this.renderer.runners.resize.emit(this.screen.width, this.screen.height);
	}
	destroy(e) {
		var t;
		e && (null == (t = this.element.parentNode) || t.removeChild(this.element)), (this.renderer = null), (this.element = null), (this.screen = null);
	}
}
(lf.defaultOptions = { width: 800, height: 600, resolution: Vl.RESOLUTION, autoDensity: !1 }),
	(lf.extension = { type: [_h.RendererSystem, _h.CanvasRendererSystem], name: "_view" }),
	Sh.add(lf),
	(Vl.PREFER_ENV = bl.WEBGL2),
	(Vl.STRICT_TEXTURE_CACHE = !1),
	(Vl.RENDER_OPTIONS = u(u(u(u({}, Qd.defaultOptions), qd.defaultOptions), lf.defaultOptions), Jp.defaultOptions)),
	Object.defineProperties(Vl, {
		WRAP_MODE: {
			get: () => Bh.defaultOptions.wrapMode,
			set(e) {
				fc("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), (Bh.defaultOptions.wrapMode = e);
			}
		},
		SCALE_MODE: {
			get: () => Bh.defaultOptions.scaleMode,
			set(e) {
				fc("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), (Bh.defaultOptions.scaleMode = e);
			}
		},
		MIPMAP_TEXTURES: {
			get: () => Bh.defaultOptions.mipmap,
			set(e) {
				fc("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), (Bh.defaultOptions.mipmap = e);
			}
		},
		ANISOTROPIC_LEVEL: {
			get: () => Bh.defaultOptions.anisotropicLevel,
			set(e) {
				fc("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"), (Bh.defaultOptions.anisotropicLevel = e);
			}
		},
		FILTER_RESOLUTION: {
			get: () => (fc("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), Kd.defaultResolution),
			set(e) {
				Kd.defaultResolution = e;
			}
		},
		FILTER_MULTISAMPLE: {
			get: () => (fc("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), Kd.defaultMultisample),
			set(e) {
				Kd.defaultMultisample = e;
			}
		},
		SPRITE_MAX_TEXTURES: {
			get: () => Yd.defaultMaxTextures,
			set(e) {
				fc("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), (Yd.defaultMaxTextures = e);
			}
		},
		SPRITE_BATCH_SIZE: {
			get: () => Yd.defaultBatchSize,
			set(e) {
				fc("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), (Yd.defaultBatchSize = e);
			}
		},
		CAN_UPLOAD_SAME_BUFFER: {
			get: () => Yd.canUploadSameBuffer,
			set(e) {
				fc("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), (Yd.canUploadSameBuffer = e);
			}
		},
		GC_MODE: {
			get: () => rf.defaultMode,
			set(e) {
				fc("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), (rf.defaultMode = e);
			}
		},
		GC_MAX_IDLE: {
			get: () => rf.defaultMaxIdle,
			set(e) {
				fc("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), (rf.defaultMaxIdle = e);
			}
		},
		GC_MAX_CHECK_COUNT: {
			get: () => rf.defaultCheckCountMax,
			set(e) {
				fc("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), (rf.defaultCheckCountMax = e);
			}
		},
		PRECISION_VERTEX: {
			get: () => Hd.defaultVertexPrecision,
			set(e) {
				fc("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), (Hd.defaultVertexPrecision = e);
			}
		},
		PRECISION_FRAGMENT: {
			get: () => Hd.defaultFragmentPrecision,
			set(e) {
				fc("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), (Hd.defaultFragmentPrecision = e);
			}
		}
	});
var uf = ((e) => ((e[(e.INTERACTION = 50)] = "INTERACTION"), (e[(e.HIGH = 25)] = "HIGH"), (e[(e.NORMAL = 0)] = "NORMAL"), (e[(e.LOW = -25)] = "LOW"), (e[(e.UTILITY = -50)] = "UTILITY"), e))(uf || {});
class cf {
	constructor(e, t = null, n = 0, r = !1) {
		(this.next = null), (this.previous = null), (this._destroyed = !1), (this.fn = e), (this.context = t), (this.priority = n), (this.once = r);
	}
	match(e, t = null) {
		return this.fn === e && this.context === t;
	}
	emit(e) {
		this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
		const t = this.next;
		return this.once && this.destroy(!0), this._destroyed && (this.next = null), t;
	}
	connect(e) {
		(this.previous = e), e.next && (e.next.previous = this), (this.next = e.next), (e.next = this);
	}
	destroy(e = !1) {
		(this._destroyed = !0), (this.fn = null), (this.context = null), this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
		const t = this.next;
		return (this.next = e ? null : t), (this.previous = null), t;
	}
}
const hf = class {
	constructor() {
		(this.autoStart = !1),
			(this.deltaTime = 1),
			(this.lastTime = -1),
			(this.speed = 1),
			(this.started = !1),
			(this._requestId = null),
			(this._maxElapsedMS = 100),
			(this._minElapsedMS = 0),
			(this._protected = !1),
			(this._lastFrame = -1),
			(this._head = new cf(null, null, 1 / 0)),
			(this.deltaMS = 1 / hf.targetFPMS),
			(this.elapsedMS = 1 / hf.targetFPMS),
			(this._tick = (e) => {
				(this._requestId = null), this.started && (this.update(e), this.started && null === this._requestId && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
			});
	}
	_requestIfNeeded() {
		null === this._requestId && this._head.next && ((this.lastTime = performance.now()), (this._lastFrame = this.lastTime), (this._requestId = requestAnimationFrame(this._tick)));
	}
	_cancelIfNeeded() {
		null !== this._requestId && (cancelAnimationFrame(this._requestId), (this._requestId = null));
	}
	_startIfPossible() {
		this.started ? this._requestIfNeeded() : this.autoStart && this.start();
	}
	add(e, t, n = uf.NORMAL) {
		return this._addListener(new cf(e, t, n));
	}
	addOnce(e, t, n = uf.NORMAL) {
		return this._addListener(new cf(e, t, n, !0));
	}
	_addListener(e) {
		let t = this._head.next,
			n = this._head;
		if (t) {
			for (; t; ) {
				if (e.priority > t.priority) {
					e.connect(n);
					break;
				}
				(n = t), (t = t.next);
			}
			e.previous || e.connect(n);
		} else e.connect(n);
		return this._startIfPossible(), this;
	}
	remove(e, t) {
		let n = this._head.next;
		for (; n; ) n = n.match(e, t) ? n.destroy() : n.next;
		return this._head.next || this._cancelIfNeeded(), this;
	}
	get count() {
		if (!this._head) return 0;
		let e = 0,
			t = this._head;
		for (; (t = t.next); ) e++;
		return e;
	}
	start() {
		this.started || ((this.started = !0), this._requestIfNeeded());
	}
	stop() {
		this.started && ((this.started = !1), this._cancelIfNeeded());
	}
	destroy() {
		if (!this._protected) {
			this.stop();
			let e = this._head.next;
			for (; e; ) e = e.destroy(!0);
			this._head.destroy(), (this._head = null);
		}
	}
	update(e = performance.now()) {
		let t;
		if (e > this.lastTime) {
			if (((t = this.elapsedMS = e - this.lastTime), t > this._maxElapsedMS && (t = this._maxElapsedMS), (t *= this.speed), this._minElapsedMS)) {
				const t = (e - this._lastFrame) | 0;
				if (t < this._minElapsedMS) return;
				this._lastFrame = e - (t % this._minElapsedMS);
			}
			(this.deltaMS = t), (this.deltaTime = this.deltaMS * hf.targetFPMS);
			const n = this._head;
			let r = n.next;
			for (; r; ) r = r.emit(this.deltaTime);
			n.next || this._cancelIfNeeded();
		} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
		this.lastTime = e;
	}
	get FPS() {
		return 1e3 / this.elapsedMS;
	}
	get minFPS() {
		return 1e3 / this._maxElapsedMS;
	}
	set minFPS(e) {
		const t = Math.min(this.maxFPS, e),
			n = Math.min(Math.max(0, t) / 1e3, hf.targetFPMS);
		this._maxElapsedMS = 1 / n;
	}
	get maxFPS() {
		return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
	}
	set maxFPS(e) {
		if (0 === e) this._minElapsedMS = 0;
		else {
			const t = Math.max(this.minFPS, e);
			this._minElapsedMS = 1 / (t / 1e3);
		}
	}
	static get shared() {
		if (!hf._shared) {
			const e = (hf._shared = new hf());
			(e.autoStart = !0), (e._protected = !0);
		}
		return hf._shared;
	}
	static get system() {
		if (!hf._system) {
			const e = (hf._system = new hf());
			(e.autoStart = !0), (e._protected = !0);
		}
		return hf._system;
	}
};
let df = hf;
(df.targetFPMS = 0.06),
	Object.defineProperties(Vl, {
		TARGET_FPMS: {
			get: () => df.targetFPMS,
			set(e) {
				fc("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), (df.targetFPMS = e);
			}
		}
	});
class pf {
	static init(e) {
		(e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
			Object.defineProperty(this, "ticker", {
				set(e) {
					this._ticker && this._ticker.remove(this.render, this), (this._ticker = e), e && e.add(this.render, this, uf.LOW);
				},
				get() {
					return this._ticker;
				}
			}),
			(this.stop = () => {
				this._ticker.stop();
			}),
			(this.start = () => {
				this._ticker.start();
			}),
			(this._ticker = null),
			(this.ticker = e.sharedTicker ? df.shared : new df()),
			e.autoStart && this.start();
	}
	static destroy() {
		if (this._ticker) {
			const e = this._ticker;
			(this.ticker = null), e.destroy();
		}
	}
}
(pf.extension = _h.Application), Sh.add(pf);
const ff = [];
function mf(e) {
	for (const t of ff) if (t.test(e)) return new t(e);
	throw new Error("Unable to auto-detect a suitable renderer.");
}
Sh.handleByList(_h.Renderer, ff);
const vf = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n        vTextureCoord = aTextureCoord;\n}",
	gf =
		"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n        gl_Position = filterVertexPosition();\n        vTextureCoord = filterTextureCoord();\n}\n";
class yf {
	constructor(e) {
		this.renderer = e;
	}
	contextChange(e) {
		let t;
		if (1 === this.renderer.context.webGLVersion) {
			const n = e.getParameter(e.FRAMEBUFFER_BINDING);
			e.bindFramebuffer(e.FRAMEBUFFER, null), (t = e.getParameter(e.SAMPLES)), e.bindFramebuffer(e.FRAMEBUFFER, n);
		} else {
			const n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
			e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), (t = e.getParameter(e.SAMPLES)), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);
		}
		t >= Bl.HIGH ? (this.multisample = Bl.HIGH) : t >= Bl.MEDIUM ? (this.multisample = Bl.MEDIUM) : t >= Bl.LOW ? (this.multisample = Bl.LOW) : (this.multisample = Bl.NONE);
	}
	destroy() {}
}
(yf.extension = { type: _h.RendererSystem, name: "_multisample" }), Sh.add(yf);
class bf {
	constructor(e) {
		(this.buffer = e || null), (this.updateID = -1), (this.byteLength = -1), (this.refCount = 0);
	}
}
class xf {
	constructor(e) {
		(this.renderer = e), (this.managedBuffers = {}), (this.boundBufferBases = {});
	}
	destroy() {
		this.renderer = null;
	}
	contextChange() {
		this.disposeAll(!0), (this.gl = this.renderer.gl), (this.CONTEXT_UID = this.renderer.CONTEXT_UID);
	}
	bind(e) {
		const { gl: t, CONTEXT_UID: n } = this,
			r = e._glBuffers[n] || this.createGLBuffer(e);
		t.bindBuffer(e.type, r.buffer);
	}
	unbind(e) {
		const { gl: t } = this;
		t.bindBuffer(e, null);
	}
	bindBufferBase(e, t) {
		const { gl: n, CONTEXT_UID: r } = this;
		if (this.boundBufferBases[t] !== e) {
			const i = e._glBuffers[r] || this.createGLBuffer(e);
			(this.boundBufferBases[t] = e), n.bindBufferBase(n.UNIFORM_BUFFER, t, i.buffer);
		}
	}
	bindBufferRange(e, t, n) {
		const { gl: r, CONTEXT_UID: i } = this;
		n = n || 0;
		const s = e._glBuffers[i] || this.createGLBuffer(e);
		r.bindBufferRange(r.UNIFORM_BUFFER, t || 0, s.buffer, 256 * n, 256);
	}
	update(e) {
		const { gl: t, CONTEXT_UID: n } = this,
			r = e._glBuffers[n] || this.createGLBuffer(e);
		if (e._updateID !== r.updateID)
			if (((r.updateID = e._updateID), t.bindBuffer(e.type, r.buffer), r.byteLength >= e.data.byteLength)) t.bufferSubData(e.type, 0, e.data);
			else {
				const n = e.static ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
				(r.byteLength = e.data.byteLength), t.bufferData(e.type, e.data, n);
			}
	}
	dispose(e, t) {
		if (!this.managedBuffers[e.id]) return;
		delete this.managedBuffers[e.id];
		const n = e._glBuffers[this.CONTEXT_UID],
			r = this.gl;
		e.disposeRunner.remove(this), n && (t || r.deleteBuffer(n.buffer), delete e._glBuffers[this.CONTEXT_UID]);
	}
	disposeAll(e) {
		const t = Object.keys(this.managedBuffers);
		for (let n = 0; n < t.length; n++) this.dispose(this.managedBuffers[t[n]], e);
	}
	createGLBuffer(e) {
		const { CONTEXT_UID: t, gl: n } = this;
		return (e._glBuffers[t] = new bf(n.createBuffer())), (this.managedBuffers[e.id] = e), e.disposeRunner.add(this), e._glBuffers[t];
	}
}
(xf.extension = { type: _h.RendererSystem, name: "buffer" }), Sh.add(xf);
class _f {
	constructor(e) {
		this.renderer = e;
	}
	render(e, t) {
		const n = this.renderer;
		let r, i, s, o;
		if ((t && ((r = t.renderTexture), (i = t.clear), (s = t.transform), (o = t.skipUpdateTransform)), (this.renderingToScreen = !r), n.runners.prerender.emit(), n.emit("prerender"), (n.projection.transform = s), !n.context.isLost)) {
			if ((r || (this.lastObjectRendered = e), !o)) {
				const t = e.enableTempParent();
				e.updateTransform(), e.disableTempParent(t);
			}
			n.renderTexture.bind(r),
				n.batch.currentRenderer.start(),
				(null != i ? i : n.background.clearBeforeRender) && n.renderTexture.clear(),
				e.render(n),
				n.batch.currentRenderer.flush(),
				r && (t.blit && n.framebuffer.blit(), r.baseTexture.update()),
				n.runners.postrender.emit(),
				(n.projection.transform = null),
				n.emit("postrender");
		}
	}
	destroy() {
		(this.renderer = null), (this.lastObjectRendered = null);
	}
}
(_f.extension = { type: _h.RendererSystem, name: "objectRenderer" }), Sh.add(_f);
const wf = class extends tf {
	constructor(e) {
		super(), (this.type = xl.WEBGL), (e = Object.assign({}, Vl.RENDER_OPTIONS, e)), (this.gl = null), (this.CONTEXT_UID = 0), (this.globalUniforms = new Ud({ projectionMatrix: new sd() }, !0));
		const t = {
			runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
			systems: wf.__systems,
			priority: [
				"_view",
				"textureGenerator",
				"background",
				"_plugin",
				"startup",
				"context",
				"state",
				"texture",
				"buffer",
				"geometry",
				"framebuffer",
				"transformFeedback",
				"mask",
				"scissor",
				"stencil",
				"projection",
				"textureGC",
				"filter",
				"renderTexture",
				"batch",
				"objectRenderer",
				"_multisample"
			]
		};
		this.setup(t),
			"useContextAlpha" in e &&
				(fc("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), (e.premultipliedAlpha = e.useContextAlpha && "notMultiplied" !== e.useContextAlpha), (e.backgroundAlpha = !1 === e.useContextAlpha ? 1 : e.backgroundAlpha)),
			(this._plugin.rendererPlugins = wf.__plugins),
			(this.options = e),
			this.startup.run(this.options);
	}
	static test(e) {
		return !(null == e ? void 0 : e.forceCanvas) && vc();
	}
	render(e, t) {
		this.objectRenderer.render(e, t);
	}
	resize(e, t) {
		this._view.resizeView(e, t);
	}
	reset() {
		return this.runners.reset.emit(), this;
	}
	clear() {
		this.renderTexture.bind(), this.renderTexture.clear();
	}
	destroy(e = !1) {
		this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, { _view: e }), super.destroy();
	}
	get plugins() {
		return this._plugin.plugins;
	}
	get multisample() {
		return this._multisample.multisample;
	}
	get width() {
		return this._view.element.width;
	}
	get height() {
		return this._view.element.height;
	}
	get resolution() {
		return this._view.resolution;
	}
	set resolution(e) {
		(this._view.resolution = e), this.runners.resolutionChange.emit(e);
	}
	get autoDensity() {
		return this._view.autoDensity;
	}
	get view() {
		return this._view.element;
	}
	get screen() {
		return this._view.screen;
	}
	get lastObjectRendered() {
		return this.objectRenderer.lastObjectRendered;
	}
	get renderingToScreen() {
		return this.objectRenderer.renderingToScreen;
	}
	get rendererLogId() {
		return `WebGL ${this.context.webGLVersion}`;
	}
	get clearBeforeRender() {
		return fc("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
	}
	get useContextAlpha() {
		return fc("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
	}
	get preserveDrawingBuffer() {
		return fc("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
	}
	get backgroundColor() {
		return fc("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
	}
	set backgroundColor(e) {
		fc("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), (this.background.color = e);
	}
	get backgroundAlpha() {
		return fc("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
	}
	set backgroundAlpha(e) {
		fc("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), (this.background.alpha = e);
	}
	get powerPreference() {
		return fc("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
	}
	generateTexture(e, t) {
		return this.textureGenerator.generateTexture(e, t);
	}
};
let Cf = wf;
(Cf.extension = { type: _h.Renderer, priority: 1 }), (Cf.__plugins = {}), (Cf.__systems = {}), Sh.handleByMap(_h.RendererPlugin, Cf.__plugins), Sh.handleByMap(_h.RendererSystem, Cf.__systems), Sh.add(Cf);
class Sf extends Oh {
	constructor(e, t) {
		const { width: n, height: r } = t || {};
		super(n, r), (this.items = []), (this.itemDirtyIds = []);
		for (let i = 0; i < e; i++) {
			const e = new Bh();
			this.items.push(e), this.itemDirtyIds.push(-2);
		}
		(this.length = e), (this._load = null), (this.baseTexture = null);
	}
	initFromArray(e, t) {
		for (let n = 0; n < this.length; n++) e[n] && (e[n].castToBaseTexture ? this.addBaseTextureAt(e[n].castToBaseTexture(), n) : e[n] instanceof Oh ? this.addResourceAt(e[n], n) : this.addResourceAt(Rh(e[n], t), n));
	}
	dispose() {
		for (let e = 0, t = this.length; e < t; e++) this.items[e].destroy();
		(this.items = null), (this.itemDirtyIds = null), (this._load = null);
	}
	addResourceAt(e, t) {
		if (!this.items[t]) throw new Error(`Index ${t} is out of bounds`);
		return e.valid && !this.valid && this.resize(e.width, e.height), this.items[t].setResource(e), this;
	}
	bind(e) {
		if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
		super.bind(e);
		for (let t = 0; t < this.length; t++) (this.items[t].parentTextureArray = e), this.items[t].on("update", e.update, e);
	}
	unbind(e) {
		super.unbind(e);
		for (let t = 0; t < this.length; t++) (this.items[t].parentTextureArray = null), this.items[t].off("update", e.update, e);
	}
	load() {
		if (this._load) return this._load;
		const e = this.items
			.map((e) => e.resource)
			.filter((e) => e)
			.map((e) => e.load());
		return (
			(this._load = Promise.all(e).then(() => {
				const { realWidth: e, realHeight: t } = this.items[0];
				return this.resize(e, t), Promise.resolve(this);
			})),
			this._load
		);
	}
}
class Ef extends Sf {
	constructor(e, t) {
		const { width: n, height: r } = t || {};
		let i, s;
		Array.isArray(e) ? ((i = e), (s = e.length)) : (s = e), super(s, { width: n, height: r }), i && this.initFromArray(i, t);
	}
	addBaseTextureAt(e, t) {
		if (!e.resource) throw new Error("ArrayResource does not support RenderTexture");
		return this.addResourceAt(e.resource, t), this;
	}
	bind(e) {
		super.bind(e), (e.target = El.TEXTURE_2D_ARRAY);
	}
	upload(e, t, n) {
		const { length: r, itemDirtyIds: i, items: s } = this,
			{ gl: o } = e;
		n.dirtyId < 0 && o.texImage3D(o.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, r, 0, t.format, n.type, null);
		for (let a = 0; a < r; a++) {
			const e = s[a];
			i[a] < e.dirtyId && ((i[a] = e.dirtyId), e.valid && o.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, a, e.resource.width, e.resource.height, 1, t.format, n.type, e.resource.source));
		}
		return !0;
	}
}
class Tf extends rp {
	constructor(e) {
		super(e);
	}
	static test(e) {
		const { OffscreenCanvas: t } = globalThis;
		return !!(t && e instanceof t) || (globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement);
	}
}
const kf = class extends Sf {
	constructor(e, t) {
		const { width: n, height: r, autoLoad: i, linkBaseTexture: s } = t || {};
		if (e && e.length !== kf.SIDES) throw new Error(`Invalid length. Got ${e.length}, expected 6`);
		super(6, { width: n, height: r });
		for (let o = 0; o < kf.SIDES; o++) this.items[o].target = El.TEXTURE_CUBE_MAP_POSITIVE_X + o;
		(this.linkBaseTexture = !1 !== s), e && this.initFromArray(e, t), !1 !== i && this.load();
	}
	bind(e) {
		super.bind(e), (e.target = El.TEXTURE_CUBE_MAP);
	}
	addBaseTextureAt(e, t, n) {
		if ((void 0 === n && (n = this.linkBaseTexture), !this.items[t])) throw new Error(`Index ${t} is out of bounds`);
		if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0) {
			if (!e.resource) throw new Error("CubeResource does not support copying of renderTexture.");
			this.addResourceAt(e.resource, t);
		} else (e.target = El.TEXTURE_CUBE_MAP_POSITIVE_X + t), (e.parentTextureArray = this.baseTexture), (this.items[t] = e);
		return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), (this.items[t] = e), this;
	}
	upload(e, t, n) {
		const r = this.itemDirtyIds;
		for (let i = 0; i < kf.SIDES; i++) {
			const s = this.items[i];
			(r[i] < s.dirtyId || n.dirtyId < t.dirtyId) && (s.valid && s.resource ? (s.resource.upload(e, s, n), (r[i] = s.dirtyId)) : r[i] < -1 && (e.gl.texImage2D(s.target, 0, n.internalFormat, t.realWidth, t.realHeight, 0, t.format, n.type, null), (r[i] = -1)));
		}
		return !0;
	}
	static test(e) {
		return Array.isArray(e) && e.length === kf.SIDES;
	}
};
let Af = kf;
Af.SIDES = 6;
class Mf extends rp {
	constructor(e, t) {
		var n;
		let r, i;
		(t = t || {}),
			"string" == typeof e ? ((r = Mf.EMPTY), (i = e)) : ((r = e), (i = null)),
			super(r),
			(this.url = i),
			(this.crossOrigin = null == (n = t.crossOrigin) || n),
			(this.alphaMode = "number" == typeof t.alphaMode ? t.alphaMode : null),
			(this._load = null),
			!1 !== t.autoLoad && this.load();
	}
	load() {
		return (
			this._load ||
				(this._load = new Promise(async (e, t) => {
					if (null !== this.url)
						try {
							const t = await Vl.ADAPTER.fetch(this.url, { mode: this.crossOrigin ? "cors" : "no-cors" });
							if (this.destroyed) return;
							const n = await t.blob();
							if (this.destroyed) return;
							const r = await createImageBitmap(n, { premultiplyAlpha: null === this.alphaMode || this.alphaMode === Rl.UNPACK ? "premultiply" : "none" });
							if (this.destroyed) return;
							(this.source = r), this.update(), e(this);
						} catch (Kj) {
							if (this.destroyed) return;
							t(Kj), this.onError.emit(Kj);
						}
					else e(this);
				})),
			this._load
		);
	}
	upload(e, t, n) {
		return this.source instanceof ImageBitmap ? ("number" == typeof this.alphaMode && (t.alphaMode = this.alphaMode), super.upload(e, t, n)) : (this.load(), !1);
	}
	dispose() {
		this.source instanceof ImageBitmap && this.source.close(), super.dispose(), (this._load = null);
	}
	static test(e) {
		return !!globalThis.createImageBitmap && "undefined" != typeof ImageBitmap && ("string" == typeof e || e instanceof ImageBitmap);
	}
	static get EMPTY() {
		var e;
		return (Mf._EMPTY = null != (e = Mf._EMPTY) ? e : Vl.ADAPTER.createCanvas(0, 0)), Mf._EMPTY;
	}
}
const If = class extends rp {
	constructor(e, t) {
		(t = t || {}),
			super(Vl.ADAPTER.createCanvas()),
			(this._width = 0),
			(this._height = 0),
			(this.svg = e),
			(this.scale = t.scale || 1),
			(this._overrideWidth = t.width),
			(this._overrideHeight = t.height),
			(this._resolve = null),
			(this._crossorigin = t.crossorigin),
			(this._load = null),
			!1 !== t.autoLoad && this.load();
	}
	load() {
		return (
			this._load ||
				(this._load = new Promise((e) => {
					if (
						((this._resolve = () => {
							this.resize(this.source.width, this.source.height), e(this);
						}),
						If.SVG_XML.test(this.svg.trim()))
					) {
						if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
						this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
					}
					this._loadSvg();
				})),
			this._load
		);
	}
	_loadSvg() {
		const e = new Image();
		rp.crossOrigin(e, this.svg, this._crossorigin),
			(e.src = this.svg),
			(e.onerror = (t) => {
				this._resolve && ((e.onerror = null), this.onError.emit(t));
			}),
			(e.onload = () => {
				if (!this._resolve) return;
				const t = e.width,
					n = e.height;
				if (!t || !n) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
				let r = t * this.scale,
					i = n * this.scale;
				(this._overrideWidth || this._overrideHeight) && ((r = this._overrideWidth || (this._overrideHeight / n) * t), (i = this._overrideHeight || (this._overrideWidth / t) * n)), (r = Math.round(r)), (i = Math.round(i));
				const s = this.source;
				(s.width = r), (s.height = i), (s._pixiId = `canvas_${oh()}`), s.getContext("2d").drawImage(e, 0, 0, t, n, 0, 0, r, i), this._resolve(), (this._resolve = null);
			});
	}
	static getSize(e) {
		const t = If.SVG_SIZE.exec(e),
			n = {};
		return t && ((n[t[1]] = Math.round(parseFloat(t[3]))), (n[t[5]] = Math.round(parseFloat(t[7])))), n;
	}
	dispose() {
		super.dispose(), (this._resolve = null), (this._crossorigin = null);
	}
	static test(e, t) {
		return "svg" === t || ("string" == typeof e && e.startsWith("data:image/svg+xml")) || ("string" == typeof e && If.SVG_XML.test(e));
	}
};
let Rf = If;
(Rf.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m), (Rf.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i);
const Lf = class extends rp {
	constructor(e, t) {
		if (((t = t || {}), !(e instanceof HTMLVideoElement))) {
			const n = document.createElement("video");
			n.setAttribute("preload", "auto"), n.setAttribute("webkit-playsinline", ""), n.setAttribute("playsinline", ""), "string" == typeof e && (e = [e]);
			const r = e[0].src || e[0];
			rp.crossOrigin(n, r, t.crossorigin);
			for (let t = 0; t < e.length; ++t) {
				const r = document.createElement("source");
				let { src: i, mime: s } = e[t];
				i = i || e[t];
				const o = i.split("?").shift().toLowerCase(),
					a = o.slice(o.lastIndexOf(".") + 1);
				(s = s || Lf.MIME_TYPES[a] || `video/${a}`), (r.src = i), (r.type = s), n.appendChild(r);
			}
			e = n;
		}
		super(e),
			(this.noSubImage = !0),
			(this._autoUpdate = !0),
			(this._isConnectedToTicker = !1),
			(this._updateFPS = t.updateFPS || 0),
			(this._msToNextUpdate = 0),
			(this.autoPlay = !1 !== t.autoPlay),
			(this._load = null),
			(this._resolve = null),
			(this._onCanPlay = this._onCanPlay.bind(this)),
			(this._onError = this._onError.bind(this)),
			!1 !== t.autoLoad && this.load();
	}
	update(e = 0) {
		if (!this.destroyed) {
			const e = df.shared.elapsedMS * this.source.playbackRate;
			(this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0));
		}
	}
	load() {
		if (this._load) return this._load;
		const e = this.source;
		return (
			(e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0),
			e.addEventListener("play", this._onPlayStart.bind(this)),
			e.addEventListener("pause", this._onPlayStop.bind(this)),
			this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)),
			(this._load = new Promise((t) => {
				this.valid ? t(this) : ((this._resolve = t), e.load());
			})),
			this._load
		);
	}
	_onError(e) {
		this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
	}
	_isSourcePlaying() {
		const e = this.source;
		return !e.paused && !e.ended && this._isSourceReady();
	}
	_isSourceReady() {
		return this.source.readyState > 2;
	}
	_onPlayStart() {
		this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (df.shared.add(this.update, this), (this._isConnectedToTicker = !0));
	}
	_onPlayStop() {
		this._isConnectedToTicker && (df.shared.remove(this.update, this), (this._isConnectedToTicker = !1));
	}
	_onCanPlay() {
		const e = this.source;
		e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
		const t = this.valid;
		this.resize(e.videoWidth, e.videoHeight), !t && this._resolve && (this._resolve(this), (this._resolve = null)), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
	}
	dispose() {
		this._isConnectedToTicker && (df.shared.remove(this.update, this), (this._isConnectedToTicker = !1));
		const e = this.source;
		e && (e.removeEventListener("error", this._onError, !0), e.pause(), (e.src = ""), e.load()), super.dispose();
	}
	get autoUpdate() {
		return this._autoUpdate;
	}
	set autoUpdate(e) {
		e !== this._autoUpdate &&
			((this._autoUpdate = e),
			!this._autoUpdate && this._isConnectedToTicker ? (df.shared.remove(this.update, this), (this._isConnectedToTicker = !1)) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (df.shared.add(this.update, this), (this._isConnectedToTicker = !0)));
	}
	get updateFPS() {
		return this._updateFPS;
	}
	set updateFPS(e) {
		e !== this._updateFPS && (this._updateFPS = e);
	}
	static test(e, t) {
		return (globalThis.HTMLVideoElement && e instanceof HTMLVideoElement) || Lf.TYPES.includes(t);
	}
};
let Of = Lf;
(Of.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"]), (Of.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }), Ih.push(Mf, ip, Tf, Of, Rf, Ph, Af, Ef);
class Pf {
	constructor() {
		(this._glTransformFeedbacks = {}), (this.buffers = []), (this.disposeRunner = new Lh("disposeTransformFeedback"));
	}
	bindBuffer(e, t) {
		this.buffers[e] = t;
	}
	destroy() {
		this.disposeRunner.emit(this, !1);
	}
}
let Nf;
function Df(e) {
	const t = Vl.ADAPTER.createCanvas(6, 1),
		n = t.getContext("2d");
	return (n.fillStyle = e), n.fillRect(0, 0, 6, 1), t;
}
function Bf() {
	if ("undefined" == typeof document) return !1;
	if (void 0 !== Nf) return Nf;
	const e = Df("#ff00ff"),
		t = Df("#ffff00"),
		n = Vl.ADAPTER.createCanvas(6, 1).getContext("2d");
	(n.globalCompositeOperation = "multiply"), n.drawImage(e, 0, 0), n.drawImage(t, 2, 0);
	const r = n.getImageData(2, 0, 1, 1);
	if (r) {
		const e = r.data;
		Nf = 255 === e[0] && 0 === e[1] && 0 === e[2];
	} else Nf = !1;
	return Nf;
}
(Bh.prototype.getDrawableSource = function () {
	const e = this.resource;
	return e ? e.bitmap || e.source : null;
}),
	(np.prototype._canvasRenderTarget = null),
	(lp.prototype.patternCache = null),
	(lp.prototype.tintCache = null);
const Ff = new sd();
class Hf {
	constructor(e) {
		(this.activeResolution = 1),
			(this.smoothProperty = "imageSmoothingEnabled"),
			(this.blendModes = (function (e = []) {
				return (
					Bf()
						? ((e[wl.NORMAL] = "source-over"),
						  (e[wl.ADD] = "lighter"),
						  (e[wl.MULTIPLY] = "multiply"),
						  (e[wl.SCREEN] = "screen"),
						  (e[wl.OVERLAY] = "overlay"),
						  (e[wl.DARKEN] = "darken"),
						  (e[wl.LIGHTEN] = "lighten"),
						  (e[wl.COLOR_DODGE] = "color-dodge"),
						  (e[wl.COLOR_BURN] = "color-burn"),
						  (e[wl.HARD_LIGHT] = "hard-light"),
						  (e[wl.SOFT_LIGHT] = "soft-light"),
						  (e[wl.DIFFERENCE] = "difference"),
						  (e[wl.EXCLUSION] = "exclusion"),
						  (e[wl.HUE] = "hue"),
						  (e[wl.SATURATION] = "saturation"),
						  (e[wl.COLOR] = "color"),
						  (e[wl.LUMINOSITY] = "luminosity"))
						: ((e[wl.NORMAL] = "source-over"),
						  (e[wl.ADD] = "lighter"),
						  (e[wl.MULTIPLY] = "source-over"),
						  (e[wl.SCREEN] = "source-over"),
						  (e[wl.OVERLAY] = "source-over"),
						  (e[wl.DARKEN] = "source-over"),
						  (e[wl.LIGHTEN] = "source-over"),
						  (e[wl.COLOR_DODGE] = "source-over"),
						  (e[wl.COLOR_BURN] = "source-over"),
						  (e[wl.HARD_LIGHT] = "source-over"),
						  (e[wl.SOFT_LIGHT] = "source-over"),
						  (e[wl.DIFFERENCE] = "source-over"),
						  (e[wl.EXCLUSION] = "source-over"),
						  (e[wl.HUE] = "source-over"),
						  (e[wl.SATURATION] = "source-over"),
						  (e[wl.COLOR] = "source-over"),
						  (e[wl.LUMINOSITY] = "source-over")),
					(e[wl.NORMAL_NPM] = e[wl.NORMAL]),
					(e[wl.ADD_NPM] = e[wl.ADD]),
					(e[wl.SCREEN_NPM] = e[wl.SCREEN]),
					(e[wl.SRC_IN] = "source-in"),
					(e[wl.SRC_OUT] = "source-out"),
					(e[wl.SRC_ATOP] = "source-atop"),
					(e[wl.DST_OVER] = "destination-over"),
					(e[wl.DST_IN] = "destination-in"),
					(e[wl.DST_OUT] = "destination-out"),
					(e[wl.DST_ATOP] = "destination-atop"),
					(e[wl.XOR] = "xor"),
					(e[wl.SUBTRACT] = "source-over"),
					e
				);
			})()),
			(this._activeBlendMode = null),
			(this._projTransform = null),
			(this._outerBlend = !1),
			(this.renderer = e);
	}
	init() {
		const e = this.renderer.background.alpha < 1;
		if (((this.rootContext = this.renderer.view.getContext("2d", { alpha: e })), (this.activeContext = this.rootContext), !this.rootContext.imageSmoothingEnabled)) {
			const e = this.rootContext;
			e.webkitImageSmoothingEnabled
				? (this.smoothProperty = "webkitImageSmoothingEnabled")
				: e.mozImageSmoothingEnabled
				? (this.smoothProperty = "mozImageSmoothingEnabled")
				: e.oImageSmoothingEnabled
				? (this.smoothProperty = "oImageSmoothingEnabled")
				: e.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled");
		}
	}
	setContextTransform(e, t, n) {
		let r = e;
		const i = this._projTransform,
			s = this.activeResolution;
		(n = n || s), i && ((r = Ff), r.copyFrom(e), r.prepend(i)), t ? this.activeContext.setTransform(r.a * n, r.b * n, r.c * n, r.d * n, (r.tx * s) | 0, (r.ty * s) | 0) : this.activeContext.setTransform(r.a * n, r.b * n, r.c * n, r.d * n, r.tx * s, r.ty * s);
	}
	clear(e, t) {
		const { activeContext: n, renderer: r } = this,
			i = e ? Wc.shared.setValue(e) : this.renderer.background.backgroundColor;
		n.clearRect(0, 0, r.width, r.height), e && ((n.globalAlpha = null != t ? t : this.renderer.background.alpha), (n.fillStyle = i.toHex()), n.fillRect(0, 0, r.width, r.height), (n.globalAlpha = 1));
	}
	setBlendMode(e, t) {
		const n = e === wl.SRC_IN || e === wl.SRC_OUT || e === wl.DST_IN || e === wl.DST_ATOP;
		!t && n && (e = wl.NORMAL), this._activeBlendMode !== e && ((this._activeBlendMode = e), (this._outerBlend = n), (this.activeContext.globalCompositeOperation = this.blendModes[e]));
	}
	resize() {
		this.smoothProperty && (this.rootContext[this.smoothProperty] = Bh.defaultOptions.scaleMode === Al.LINEAR);
	}
	invalidateBlendMode() {
		this._activeBlendMode = this.blendModes.indexOf(this.activeContext.globalCompositeOperation);
	}
	destroy() {
		(this.renderer = null), (this.rootContext = null), (this.activeContext = null), (this.smoothProperty = null);
	}
}
(Hf.extension = { type: _h.CanvasRendererSystem, name: "canvasContext" }), Sh.add(Hf);
class Vf {
	constructor(e) {
		(this._foundShapes = []), (this.renderer = e);
	}
	pushMask(e) {
		const t = this.renderer,
			n = e.maskObject || e;
		t.canvasContext.activeContext.save();
		const r = this._foundShapes;
		if ((this.recursiveFindShapes(n, r), r.length > 0)) {
			const e = t.canvasContext.activeContext;
			e.beginPath();
			for (let t = 0; t < r.length; t++) {
				const e = r[t],
					n = e.transform.worldTransform;
				this.renderer.canvasContext.setContextTransform(n), this.renderGraphicsShape(e);
			}
			(r.length = 0), e.clip();
		}
	}
	recursiveFindShapes(e, t) {
		e.geometry && e.geometry.graphicsData && t.push(e);
		const { children: n } = e;
		if (n) for (let r = 0; r < n.length; r++) this.recursiveFindShapes(n[r], t);
	}
	renderGraphicsShape(e) {
		e.finishPoly();
		const t = this.renderer.canvasContext.activeContext,
			n = e.geometry.graphicsData,
			r = n.length;
		if (0 !== r)
			for (let i = 0; i < r; i++) {
				const e = n[i],
					r = e.shape;
				if (r.type === Zh.POLY) {
					let n = r.points;
					const i = e.holes;
					let s, o, a, l;
					t.moveTo(n[0], n[1]);
					for (let e = 1; e < n.length / 2; e++) t.lineTo(n[2 * e], n[2 * e + 1]);
					if (i.length > 0) {
						(s = 0), (a = n[0]), (l = n[1]);
						for (let e = 2; e + 2 < n.length; e += 2) s += (n[e] - a) * (n[e + 3] - l) - (n[e + 2] - a) * (n[e + 1] - l);
						for (let e = 0; e < i.length; e++)
							if (((n = i[e].shape.points), n)) {
								(o = 0), (a = n[0]), (l = n[1]);
								for (let e = 2; e + 2 < n.length; e += 2) o += (n[e] - a) * (n[e + 3] - l) - (n[e + 2] - a) * (n[e + 1] - l);
								if (o * s < 0) {
									t.moveTo(n[0], n[1]);
									for (let e = 2; e < n.length; e += 2) t.lineTo(n[e], n[e + 1]);
								} else {
									t.moveTo(n[n.length - 2], n[n.length - 1]);
									for (let e = n.length - 4; e >= 0; e -= 2) t.lineTo(n[e], n[e + 1]);
								}
								i[e].shape.closeStroke && t.closePath();
							}
					}
					n[0] === n[n.length - 2] && n[1] === n[n.length - 1] && t.closePath();
				} else if (r.type === Zh.RECT) t.rect(r.x, r.y, r.width, r.height), t.closePath();
				else if (r.type === Zh.CIRC) t.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), t.closePath();
				else if (r.type === Zh.ELIP) {
					const e = 2 * r.width,
						n = 2 * r.height,
						i = r.x - e / 2,
						s = r.y - n / 2,
						o = 0.5522848,
						a = (e / 2) * o,
						l = (n / 2) * o,
						u = i + e,
						c = s + n,
						h = i + e / 2,
						d = s + n / 2;
					t.moveTo(i, d), t.bezierCurveTo(i, d - l, h - a, s, h, s), t.bezierCurveTo(h + a, s, u, d - l, u, d), t.bezierCurveTo(u, d + l, h + a, c, h, c), t.bezierCurveTo(h - a, c, i, d + l, i, d), t.closePath();
				} else if (r.type === Zh.RREC) {
					const e = r.x,
						n = r.y,
						i = r.width,
						s = r.height;
					let o = r.radius;
					const a = Math.min(i, s) / 2;
					(o = o > a ? a : o),
						t.moveTo(e, n + o),
						t.lineTo(e, n + s - o),
						t.quadraticCurveTo(e, n + s, e + o, n + s),
						t.lineTo(e + i - o, n + s),
						t.quadraticCurveTo(e + i, n + s, e + i, n + s - o),
						t.lineTo(e + i, n + o),
						t.quadraticCurveTo(e + i, n, e + i - o, n),
						t.lineTo(e + o, n),
						t.quadraticCurveTo(e, n, e, n + o),
						t.closePath();
				}
			}
	}
	popMask(e) {
		e.canvasContext.activeContext.restore(), e.canvasContext.invalidateBlendMode();
	}
	destroy() {}
}
(Vf.extension = { type: _h.CanvasRendererSystem, name: "mask" }), Sh.add(Vf);
class Uf {
	constructor(e) {
		this.renderer = e;
	}
	render(e, t) {
		const n = this.renderer;
		if (!n.view) return;
		const r = n.canvasContext;
		let i, s, o, a;
		t && ((i = t.renderTexture), (s = t.clear), (o = t.transform), (a = t.skipUpdateTransform)), (this.renderingToScreen = !i), n.emit("prerender");
		const l = n.resolution;
		i
			? ((i = i.castToBaseTexture()),
			  i._canvasRenderTarget || ((i._canvasRenderTarget = new dh(i.width, i.height, i.resolution)), (i.resource = new Tf(i._canvasRenderTarget.canvas)), (i.valid = !0)),
			  (r.activeContext = i._canvasRenderTarget.context),
			  (n.canvasContext.activeResolution = i._canvasRenderTarget.resolution))
			: ((r.activeContext = r.rootContext), (r.activeResolution = l));
		const u = r.activeContext;
		if (((r._projTransform = o || null), i || (this.lastObjectRendered = e), !a)) {
			const t = e.enableTempParent();
			e.updateTransform(), e.disableTempParent(t);
		}
		if ((u.save(), u.setTransform(1, 0, 0, 1, 0, 0), (u.globalAlpha = 1), (r._activeBlendMode = wl.NORMAL), (r._outerBlend = !1), (u.globalCompositeOperation = r.blendModes[wl.NORMAL]), null != s ? s : n.background.clearBeforeRender))
			if (this.renderingToScreen) {
				u.clearRect(0, 0, n.width, n.height);
				const e = n.background;
				e.alpha > 0 && ((u.globalAlpha = e.backgroundColor.alpha), (u.fillStyle = e.backgroundColor.toHex()), u.fillRect(0, 0, n.width, n.height), (u.globalAlpha = 1));
			} else (i = i), i._canvasRenderTarget.clear(), i.clear.alpha > 0 && ((u.globalAlpha = i.clear.alpha), (u.fillStyle = i.clear.toHex()), u.fillRect(0, 0, i.realWidth, i.realHeight), (u.globalAlpha = 1));
		const c = r.activeContext;
		(r.activeContext = u), e.renderCanvas(n), (r.activeContext = c), u.restore(), (r.activeResolution = l), (r._projTransform = null), n.emit("postrender");
	}
	destroy() {
		(this.lastObjectRendered = null), (this.render = null);
	}
}
(Uf.extension = { type: _h.CanvasRendererSystem, name: "objectRenderer" }), Sh.add(Uf);
const { deprecation: zf } = xh,
	$f = class extends tf {
		constructor(e) {
			super(), (this.type = xl.CANVAS), (this.rendererLogId = "Canvas"), (e = Object.assign({}, Vl.RENDER_OPTIONS, e));
			const t = { runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"], systems: $f.__systems, priority: ["textureGenerator", "background", "_view", "_plugin", "startup", "mask", "canvasContext", "objectRenderer"] };
			this.setup(t),
				"useContextAlpha" in e && (zf("7.0.0", "options.useContextAlpha is deprecated, use options.backgroundAlpha instead"), (e.backgroundAlpha = !1 === e.useContextAlpha ? 1 : e.backgroundAlpha)),
				(this._plugin.rendererPlugins = $f.__plugins),
				(this.options = e),
				this.startup.run(this.options);
		}
		static test() {
			return !0;
		}
		generateTexture(e, t) {
			return this.textureGenerator.generateTexture(e, t);
		}
		reset() {}
		render(e, t) {
			this.objectRenderer.render(e, t);
		}
		clear() {
			this.canvasContext.clear();
		}
		destroy(e) {
			this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, { _view: e }), super.destroy();
		}
		get plugins() {
			return this._plugin.plugins;
		}
		resize(e, t) {
			this._view.resizeView(e, t);
		}
		get width() {
			return this._view.element.width;
		}
		get height() {
			return this._view.element.height;
		}
		get resolution() {
			return this._view.resolution;
		}
		set resolution(e) {
			(this._view.resolution = e), this.runners.resolutionChange.emit(e);
		}
		get autoDensity() {
			return this._view.autoDensity;
		}
		get view() {
			return this._view.element;
		}
		get screen() {
			return this._view.screen;
		}
		get lastObjectRendered() {
			return this.objectRenderer.lastObjectRendered;
		}
		get renderingToScreen() {
			return this.objectRenderer.renderingToScreen;
		}
		get clearBeforeRender() {
			return this.background.clearBeforeRender;
		}
		get blendModes() {
			return zf("7.0.0", "renderer.blendModes has been deprecated, please use renderer.canvasContext.blendModes instead"), this.canvasContext.blendModes;
		}
		get maskManager() {
			return zf("7.0.0", "renderer.maskManager has been deprecated, please use renderer.mask instead"), this.mask;
		}
		get refresh() {
			return zf("7.0.0", "renderer.refresh has been deprecated"), !0;
		}
		get rootContext() {
			return zf("7.0.0", "renderer.rootContext has been deprecated, please use renderer.canvasContext.rootContext instead"), this.canvasContext.rootContext;
		}
		get context() {
			return zf("7.0.0", "renderer.context has been deprecated, please use renderer.canvasContext.activeContext instead"), this.canvasContext.activeContext;
		}
		get smoothProperty() {
			return zf("7.0.0", "renderer.smoothProperty has been deprecated, please use renderer.canvasContext.smoothProperty instead"), this.canvasContext.smoothProperty;
		}
		setBlendMode(e, t) {
			zf("7.0.0", "renderer.setBlendMode has been deprecated, use renderer.canvasContext.setBlendMode instead"), this.canvasContext.setBlendMode(e, t);
		}
		invalidateBlendMode() {
			zf("7.0.0", "renderer.invalidateBlendMode has been deprecated, use renderer.canvasContext.invalidateBlendMode instead"), this.canvasContext.invalidateBlendMode();
		}
		setContextTransform(e, t, n) {
			zf("7.0.0", "renderer.setContextTransform has been deprecated, use renderer.canvasContext.setContextTransform instead"), this.canvasContext.setContextTransform(e, t, n);
		}
		get backgroundColor() {
			return zf("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
		}
		set backgroundColor(e) {
			zf("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), (this.background.color = e);
		}
		get backgroundAlpha() {
			return zf("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
		}
		set backgroundAlpha(e) {
			zf("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), (this.background.alpha = e);
		}
		get preserveDrawingBuffer() {
			return zf("7.0.0", "renderer.preserveDrawingBuffer has been deprecated"), !1;
		}
		get useContextAlpha() {
			return zf("7.0.0", "renderer.useContextAlpha has been deprecated"), !1;
		}
	};
let jf = $f;
(jf.extension = { type: _h.Renderer, priority: 0 }), (jf.__plugins = {}), (jf.__systems = {}), Sh.handleByMap(_h.CanvasRendererPlugin, jf.__plugins), Sh.handleByMap(_h.CanvasRendererSystem, jf.__systems), Sh.add(jf);
const Wf = {
	canvas: null,
	getTintedCanvas: (e, t) => {
		const n = e.texture,
			r = `#${`00000${(0 | (t = Wf.roundColor(t))).toString(16)}`.slice(-6)}`;
		n.tintCache = n.tintCache || {};
		const i = n.tintCache[r];
		let s;
		if (i) {
			if (i.tintId === n._updateID) return n.tintCache[r];
			s = n.tintCache[r];
		} else s = Vl.ADAPTER.createCanvas();
		if ((Wf.tintMethod(n, t, s), (s.tintId = n._updateID), Wf.convertTintToImage && void 0 !== s.toDataURL)) {
			const e = new Image();
			(e.src = s.toDataURL()), (n.tintCache[r] = e);
		} else n.tintCache[r] = s;
		return s;
	},
	getTintedPattern: (e, t) => {
		const n = `#${`00000${(0 | (t = Wf.roundColor(t))).toString(16)}`.slice(-6)}`;
		e.patternCache = e.patternCache || {};
		let r = e.patternCache[n];
		return (null == r ? void 0 : r.tintId) === e._updateID || (Wf.canvas || (Wf.canvas = Vl.ADAPTER.createCanvas()), Wf.tintMethod(e, t, Wf.canvas), (r = Wf.canvas.getContext("2d").createPattern(Wf.canvas, "repeat")), (r.tintId = e._updateID), (e.patternCache[n] = r)), r;
	},
	tintWithMultiply: (e, t, n) => {
		const r = n.getContext("2d"),
			i = e._frame.clone(),
			s = e.baseTexture.resolution;
		(i.x *= s), (i.y *= s), (i.width *= s), (i.height *= s), (n.width = Math.ceil(i.width)), (n.height = Math.ceil(i.height)), r.save(), (r.fillStyle = `#${`00000${(0 | t).toString(16)}`.slice(-6)}`), r.fillRect(0, 0, i.width, i.height), (r.globalCompositeOperation = "multiply");
		const o = e.baseTexture.getDrawableSource();
		r.drawImage(o, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), (r.globalCompositeOperation = "destination-atop"), r.drawImage(o, i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), r.restore();
	},
	tintWithOverlay: (e, t, n) => {
		const r = n.getContext("2d"),
			i = e._frame.clone(),
			s = e.baseTexture.resolution;
		(i.x *= s),
			(i.y *= s),
			(i.width *= s),
			(i.height *= s),
			(n.width = Math.ceil(i.width)),
			(n.height = Math.ceil(i.height)),
			r.save(),
			(r.globalCompositeOperation = "copy"),
			(r.fillStyle = `#${`00000${(0 | t).toString(16)}`.slice(-6)}`),
			r.fillRect(0, 0, i.width, i.height),
			(r.globalCompositeOperation = "destination-atop"),
			r.drawImage(e.baseTexture.getDrawableSource(), i.x, i.y, i.width, i.height, 0, 0, i.width, i.height),
			r.restore();
	},
	tintWithPerPixel: (e, t, n) => {
		const r = n.getContext("2d"),
			i = e._frame.clone(),
			s = e.baseTexture.resolution;
		(i.x *= s), (i.y *= s), (i.width *= s), (i.height *= s), (n.width = Math.ceil(i.width)), (n.height = Math.ceil(i.height)), r.save(), (r.globalCompositeOperation = "copy"), r.drawImage(e.baseTexture.getDrawableSource(), i.x, i.y, i.width, i.height, 0, 0, i.width, i.height), r.restore();
		const [o, a, l] = Wc.shared.setValue(t).toArray(),
			u = r.getImageData(0, 0, i.width, i.height),
			c = u.data;
		for (let h = 0; h < c.length; h += 4) (c[h + 0] *= o), (c[h + 1] *= a), (c[h + 2] *= l);
		r.putImageData(u, 0, 0);
	},
	roundColor: (e) => Wc.shared.setValue(e).round(Wf.cacheStepsPerColorChannel).toNumber(),
	cacheStepsPerColorChannel: 8,
	convertTintToImage: !1,
	canUseMultiply: Bf(),
	tintMethod: null
};
Wf.tintMethod = Wf.canUseMultiply ? Wf.tintWithMultiply : Wf.tintWithPerPixel;
class Gf {
	constructor() {
		(this.minX = 1 / 0), (this.minY = 1 / 0), (this.maxX = -1 / 0), (this.maxY = -1 / 0), (this.rect = null), (this.updateID = -1);
	}
	isEmpty() {
		return this.minX > this.maxX || this.minY > this.maxY;
	}
	clear() {
		(this.minX = 1 / 0), (this.minY = 1 / 0), (this.maxX = -1 / 0), (this.maxY = -1 / 0);
	}
	getRectangle(e) {
		return this.minX > this.maxX || this.minY > this.maxY ? ed.EMPTY : (((e = e || new ed(0, 0, 1, 1)).x = this.minX), (e.y = this.minY), (e.width = this.maxX - this.minX), (e.height = this.maxY - this.minY), e);
	}
	addPoint(e) {
		(this.minX = Math.min(this.minX, e.x)), (this.maxX = Math.max(this.maxX, e.x)), (this.minY = Math.min(this.minY, e.y)), (this.maxY = Math.max(this.maxY, e.y));
	}
	addPointMatrix(e, t) {
		const { a: n, b: r, c: i, d: s, tx: o, ty: a } = e,
			l = n * t.x + i * t.y + o,
			u = r * t.x + s * t.y + a;
		(this.minX = Math.min(this.minX, l)), (this.maxX = Math.max(this.maxX, l)), (this.minY = Math.min(this.minY, u)), (this.maxY = Math.max(this.maxY, u));
	}
	addQuad(e) {
		let t = this.minX,
			n = this.minY,
			r = this.maxX,
			i = this.maxY,
			s = e[0],
			o = e[1];
		(t = s < t ? s : t),
			(n = o < n ? o : n),
			(r = s > r ? s : r),
			(i = o > i ? o : i),
			(s = e[2]),
			(o = e[3]),
			(t = s < t ? s : t),
			(n = o < n ? o : n),
			(r = s > r ? s : r),
			(i = o > i ? o : i),
			(s = e[4]),
			(o = e[5]),
			(t = s < t ? s : t),
			(n = o < n ? o : n),
			(r = s > r ? s : r),
			(i = o > i ? o : i),
			(s = e[6]),
			(o = e[7]),
			(t = s < t ? s : t),
			(n = o < n ? o : n),
			(r = s > r ? s : r),
			(i = o > i ? o : i),
			(this.minX = t),
			(this.minY = n),
			(this.maxX = r),
			(this.maxY = i);
	}
	addFrame(e, t, n, r, i) {
		this.addFrameMatrix(e.worldTransform, t, n, r, i);
	}
	addFrameMatrix(e, t, n, r, i) {
		const s = e.a,
			o = e.b,
			a = e.c,
			l = e.d,
			u = e.tx,
			c = e.ty;
		let h = this.minX,
			d = this.minY,
			p = this.maxX,
			f = this.maxY,
			m = s * t + a * n + u,
			v = o * t + l * n + c;
		(h = m < h ? m : h),
			(d = v < d ? v : d),
			(p = m > p ? m : p),
			(f = v > f ? v : f),
			(m = s * r + a * n + u),
			(v = o * r + l * n + c),
			(h = m < h ? m : h),
			(d = v < d ? v : d),
			(p = m > p ? m : p),
			(f = v > f ? v : f),
			(m = s * t + a * i + u),
			(v = o * t + l * i + c),
			(h = m < h ? m : h),
			(d = v < d ? v : d),
			(p = m > p ? m : p),
			(f = v > f ? v : f),
			(m = s * r + a * i + u),
			(v = o * r + l * i + c),
			(h = m < h ? m : h),
			(d = v < d ? v : d),
			(p = m > p ? m : p),
			(f = v > f ? v : f),
			(this.minX = h),
			(this.minY = d),
			(this.maxX = p),
			(this.maxY = f);
	}
	addVertexData(e, t, n) {
		let r = this.minX,
			i = this.minY,
			s = this.maxX,
			o = this.maxY;
		for (let a = t; a < n; a += 2) {
			const t = e[a],
				n = e[a + 1];
			(r = t < r ? t : r), (i = n < i ? n : i), (s = t > s ? t : s), (o = n > o ? n : o);
		}
		(this.minX = r), (this.minY = i), (this.maxX = s), (this.maxY = o);
	}
	addVertices(e, t, n, r) {
		this.addVerticesMatrix(e.worldTransform, t, n, r);
	}
	addVerticesMatrix(e, t, n, r, i = 0, s = i) {
		const o = e.a,
			a = e.b,
			l = e.c,
			u = e.d,
			c = e.tx,
			h = e.ty;
		let d = this.minX,
			p = this.minY,
			f = this.maxX,
			m = this.maxY;
		for (let v = n; v < r; v += 2) {
			const e = t[v],
				n = t[v + 1],
				r = o * e + l * n + c,
				g = u * n + a * e + h;
			(d = Math.min(d, r - i)), (f = Math.max(f, r + i)), (p = Math.min(p, g - s)), (m = Math.max(m, g + s));
		}
		(this.minX = d), (this.minY = p), (this.maxX = f), (this.maxY = m);
	}
	addBounds(e) {
		const t = this.minX,
			n = this.minY,
			r = this.maxX,
			i = this.maxY;
		(this.minX = e.minX < t ? e.minX : t), (this.minY = e.minY < n ? e.minY : n), (this.maxX = e.maxX > r ? e.maxX : r), (this.maxY = e.maxY > i ? e.maxY : i);
	}
	addBoundsMask(e, t) {
		const n = e.minX > t.minX ? e.minX : t.minX,
			r = e.minY > t.minY ? e.minY : t.minY,
			i = e.maxX < t.maxX ? e.maxX : t.maxX,
			s = e.maxY < t.maxY ? e.maxY : t.maxY;
		if (n <= i && r <= s) {
			const e = this.minX,
				t = this.minY,
				o = this.maxX,
				a = this.maxY;
			(this.minX = n < e ? n : e), (this.minY = r < t ? r : t), (this.maxX = i > o ? i : o), (this.maxY = s > a ? s : a);
		}
	}
	addBoundsMatrix(e, t) {
		this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY);
	}
	addBoundsArea(e, t) {
		const n = e.minX > t.x ? e.minX : t.x,
			r = e.minY > t.y ? e.minY : t.y,
			i = e.maxX < t.x + t.width ? e.maxX : t.x + t.width,
			s = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
		if (n <= i && r <= s) {
			const e = this.minX,
				t = this.minY,
				o = this.maxX,
				a = this.maxY;
			(this.minX = n < e ? n : e), (this.minY = r < t ? r : t), (this.maxX = i > o ? i : o), (this.maxY = s > a ? s : a);
		}
	}
	pad(e = 0, t = e) {
		this.isEmpty() || ((this.minX -= e), (this.maxX += e), (this.minY -= t), (this.maxY += t));
	}
	addFramePad(e, t, n, r, i, s) {
		(e -= i), (t -= s), (n += i), (r += s), (this.minX = this.minX < e ? this.minX : e), (this.maxX = this.maxX > n ? this.maxX : n), (this.minY = this.minY < t ? this.minY : t), (this.maxY = this.maxY > r ? this.maxY : r);
	}
}
class Yf extends lu {
	constructor() {
		super(),
			(this.tempDisplayObjectParent = null),
			(this.transform = new vd()),
			(this.alpha = 1),
			(this.visible = !0),
			(this.renderable = !0),
			(this.cullable = !1),
			(this.cullArea = null),
			(this.parent = null),
			(this.worldAlpha = 1),
			(this._lastSortedIndex = 0),
			(this._zIndex = 0),
			(this.filterArea = null),
			(this.filters = null),
			(this._enabledFilters = null),
			(this._bounds = new Gf()),
			(this._localBounds = null),
			(this._boundsID = 0),
			(this._boundsRect = null),
			(this._localBoundsRect = null),
			(this._mask = null),
			(this._maskRefCount = 0),
			(this._destroyed = !1),
			(this.isSprite = !1),
			(this.isMask = !1);
	}
	static mixin(e) {
		const t = Object.keys(e);
		for (let n = 0; n < t.length; ++n) {
			const r = t[n];
			Object.defineProperty(Yf.prototype, r, Object.getOwnPropertyDescriptor(e, r));
		}
	}
	get destroyed() {
		return this._destroyed;
	}
	_recursivePostUpdateTransform() {
		this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
	}
	updateTransform() {
		this._boundsID++, this.transform.updateTransform(this.parent.transform), (this.worldAlpha = this.alpha * this.parent.worldAlpha);
	}
	getBounds(e, t) {
		return (
			e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : ((this.parent = this._tempDisplayObjectParent), this.updateTransform(), (this.parent = null))),
			this._bounds.updateID !== this._boundsID && (this.calculateBounds(), (this._bounds.updateID = this._boundsID)),
			t || (this._boundsRect || (this._boundsRect = new ed()), (t = this._boundsRect)),
			this._bounds.getRectangle(t)
		);
	}
	getLocalBounds(e) {
		e || (this._localBoundsRect || (this._localBoundsRect = new ed()), (e = this._localBoundsRect)), this._localBounds || (this._localBounds = new Gf());
		const t = this.transform,
			n = this.parent;
		(this.parent = null), (this.transform = this._tempDisplayObjectParent.transform);
		const r = this._bounds,
			i = this._boundsID;
		this._bounds = this._localBounds;
		const s = this.getBounds(!1, e);
		return (this.parent = n), (this.transform = t), (this._bounds = r), (this._bounds.updateID += this._boundsID - i), s;
	}
	toGlobal(e, t, n = !1) {
		return n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : ((this.parent = this._tempDisplayObjectParent), this.displayObjectUpdateTransform(), (this.parent = null))), this.worldTransform.apply(e, t);
	}
	toLocal(e, t, n, r) {
		return t && (e = t.toGlobal(e, n, r)), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : ((this.parent = this._tempDisplayObjectParent), this.displayObjectUpdateTransform(), (this.parent = null))), this.worldTransform.applyInverse(e, n);
	}
	setParent(e) {
		if (!e || !e.addChild) throw new Error("setParent: Argument must be a Container");
		return e.addChild(this), e;
	}
	removeFromParent() {
		var e;
		null == (e = this.parent) || e.removeChild(this);
	}
	setTransform(e = 0, t = 0, n = 1, r = 1, i = 0, s = 0, o = 0, a = 0, l = 0) {
		return (this.position.x = e), (this.position.y = t), (this.scale.x = n || 1), (this.scale.y = r || 1), (this.rotation = i), (this.skew.x = s), (this.skew.y = o), (this.pivot.x = a), (this.pivot.y = l), this;
	}
	destroy(e) {
		this.removeFromParent(),
			(this._destroyed = !0),
			(this.transform = null),
			(this.parent = null),
			(this._bounds = null),
			(this.mask = null),
			(this.cullArea = null),
			(this.filters = null),
			(this.filterArea = null),
			(this.hitArea = null),
			(this.eventMode = "auto"),
			(this.interactiveChildren = !1),
			this.emit("destroyed"),
			this.removeAllListeners();
	}
	get _tempDisplayObjectParent() {
		return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new Xf()), this.tempDisplayObjectParent;
	}
	enableTempParent() {
		const e = this.parent;
		return (this.parent = this._tempDisplayObjectParent), e;
	}
	disableTempParent(e) {
		this.parent = e;
	}
	get x() {
		return this.position.x;
	}
	set x(e) {
		this.transform.position.x = e;
	}
	get y() {
		return this.position.y;
	}
	set y(e) {
		this.transform.position.y = e;
	}
	get worldTransform() {
		return this.transform.worldTransform;
	}
	get localTransform() {
		return this.transform.localTransform;
	}
	get position() {
		return this.transform.position;
	}
	set position(e) {
		this.transform.position.copyFrom(e);
	}
	get scale() {
		return this.transform.scale;
	}
	set scale(e) {
		this.transform.scale.copyFrom(e);
	}
	get pivot() {
		return this.transform.pivot;
	}
	set pivot(e) {
		this.transform.pivot.copyFrom(e);
	}
	get skew() {
		return this.transform.skew;
	}
	set skew(e) {
		this.transform.skew.copyFrom(e);
	}
	get rotation() {
		return this.transform.rotation;
	}
	set rotation(e) {
		this.transform.rotation = e;
	}
	get angle() {
		return this.transform.rotation * Kh;
	}
	set angle(e) {
		this.transform.rotation = e * qh;
	}
	get zIndex() {
		return this._zIndex;
	}
	set zIndex(e) {
		(this._zIndex = e), this.parent && (this.parent.sortDirty = !0);
	}
	get worldVisible() {
		let e = this;
		do {
			if (!e.visible) return !1;
			e = e.parent;
		} while (e);
		return !0;
	}
	get mask() {
		return this._mask;
	}
	set mask(e) {
		if (this._mask !== e) {
			if (this._mask) {
				const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
				e && (e._maskRefCount--, 0 === e._maskRefCount && ((e.renderable = !0), (e.isMask = !1)));
			}
			if (((this._mask = e), this._mask)) {
				const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
				e && (0 === e._maskRefCount && ((e.renderable = !1), (e.isMask = !0)), e._maskRefCount++);
			}
		}
	}
}
class Xf extends Yf {
	constructor() {
		super(...arguments), (this.sortDirty = null);
	}
}
Yf.prototype.displayObjectUpdateTransform = Yf.prototype.updateTransform;
const Kf = new sd();
function qf(e, t) {
	return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex;
}
const Zf = class extends Yf {
	constructor() {
		super(), (this.children = []), (this.sortableChildren = Zf.defaultSortableChildren), (this.sortDirty = !1);
	}
	onChildrenChange(e) {}
	addChild(...e) {
		if (e.length > 1) for (let t = 0; t < e.length; t++) this.addChild(e[t]);
		else {
			const t = e[0];
			t.parent && t.parent.removeChild(t), (t.parent = this), (this.sortDirty = !0), (t.transform._parentID = -1), this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this);
		}
		return e[0];
	}
	addChildAt(e, t) {
		if (t < 0 || t > this.children.length) throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
		return e.parent && e.parent.removeChild(e), (e.parent = this), (this.sortDirty = !0), (e.transform._parentID = -1), this.children.splice(t, 0, e), this._boundsID++, this.onChildrenChange(t), e.emit("added", this), this.emit("childAdded", e, this, t), e;
	}
	swapChildren(e, t) {
		if (e === t) return;
		const n = this.getChildIndex(e),
			r = this.getChildIndex(t);
		(this.children[n] = t), (this.children[r] = e), this.onChildrenChange(n < r ? n : r);
	}
	getChildIndex(e) {
		const t = this.children.indexOf(e);
		if (-1 === t) throw new Error("The supplied DisplayObject must be a child of the caller");
		return t;
	}
	setChildIndex(e, t) {
		if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
		const n = this.getChildIndex(e);
		rh(this.children, n, 1), this.children.splice(t, 0, e), this.onChildrenChange(t);
	}
	getChildAt(e) {
		if (e < 0 || e >= this.children.length) throw new Error(`getChildAt: Index (${e}) does not exist.`);
		return this.children[e];
	}
	removeChild(...e) {
		if (e.length > 1) for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
		else {
			const t = e[0],
				n = this.children.indexOf(t);
			if (-1 === n) return null;
			(t.parent = null), (t.transform._parentID = -1), rh(this.children, n, 1), this._boundsID++, this.onChildrenChange(n), t.emit("removed", this), this.emit("childRemoved", t, this, n);
		}
		return e[0];
	}
	removeChildAt(e) {
		const t = this.getChildAt(e);
		return (t.parent = null), (t.transform._parentID = -1), rh(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), t.emit("removed", this), this.emit("childRemoved", t, this, e), t;
	}
	removeChildren(e = 0, t = this.children.length) {
		const n = e,
			r = t - n;
		let i;
		if (r > 0 && r <= t) {
			i = this.children.splice(n, r);
			for (let e = 0; e < i.length; ++e) (i[e].parent = null), i[e].transform && (i[e].transform._parentID = -1);
			this._boundsID++, this.onChildrenChange(e);
			for (let e = 0; e < i.length; ++e) i[e].emit("removed", this), this.emit("childRemoved", i[e], this, e);
			return i;
		}
		if (0 === r && 0 === this.children.length) return [];
		throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
	}
	sortChildren() {
		let e = !1;
		for (let t = 0, n = this.children.length; t < n; ++t) {
			const n = this.children[t];
			(n._lastSortedIndex = t), e || 0 === n.zIndex || (e = !0);
		}
		e && this.children.length > 1 && this.children.sort(qf), (this.sortDirty = !1);
	}
	updateTransform() {
		this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), (this.worldAlpha = this.alpha * this.parent.worldAlpha);
		for (let e = 0, t = this.children.length; e < t; ++e) {
			const t = this.children[e];
			t.visible && t.updateTransform();
		}
	}
	calculateBounds() {
		this._bounds.clear(), this._calculateBounds();
		for (let e = 0; e < this.children.length; e++) {
			const t = this.children[e];
			if (t.visible && t.renderable)
				if ((t.calculateBounds(), t._mask)) {
					const e = t._mask.isMaskData ? t._mask.maskObject : t._mask;
					e ? (e.calculateBounds(), this._bounds.addBoundsMask(t._bounds, e._bounds)) : this._bounds.addBounds(t._bounds);
				} else t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds);
		}
		this._bounds.updateID = this._boundsID;
	}
	getLocalBounds(e, t = !1) {
		const n = super.getLocalBounds(e);
		if (!t)
			for (let r = 0, i = this.children.length; r < i; ++r) {
				const e = this.children[r];
				e.visible && e.updateTransform();
			}
		return n;
	}
	_calculateBounds() {}
	_renderWithCulling(e) {
		const t = e.renderTexture.sourceFrame;
		if (!(t.width > 0 && t.height > 0)) return;
		let n, r;
		this.cullArea ? ((n = this.cullArea), (r = this.worldTransform)) : this._render !== Zf.prototype._render && (n = this.getBounds(!0));
		const i = e.projection.transform;
		if ((i && (r ? ((r = Kf.copyFrom(r)), r.prepend(i)) : (r = i)), n && t.intersects(n, r))) this._render(e);
		else if (this.cullArea) return;
		for (let s = 0, o = this.children.length; s < o; ++s) {
			const t = this.children[s],
				n = t.cullable;
			(t.cullable = n || !this.cullArea), t.render(e), (t.cullable = n);
		}
	}
	render(e) {
		var t;
		if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
			if (this._mask || (null == (t = this.filters) ? void 0 : t.length)) this.renderAdvanced(e);
			else if (this.cullable) this._renderWithCulling(e);
			else {
				this._render(e);
				for (let t = 0, n = this.children.length; t < n; ++t) this.children[t].render(e);
			}
	}
	renderAdvanced(e) {
		var t, n, r;
		const i = this.filters,
			s = this._mask;
		if (i) {
			this._enabledFilters || (this._enabledFilters = []), (this._enabledFilters.length = 0);
			for (let e = 0; e < i.length; e++) i[e].enabled && this._enabledFilters.push(i[e]);
		}
		const o = (i && (null == (t = this._enabledFilters) ? void 0 : t.length)) || (s && (!s.isMaskData || (s.enabled && (s.autoDetect || s.type !== Nl.NONE))));
		if ((o && e.batch.flush(), i && (null == (n = this._enabledFilters) ? void 0 : n.length) && e.filter.push(this, this._enabledFilters), s && e.mask.push(this, this._mask), this.cullable)) this._renderWithCulling(e);
		else {
			this._render(e);
			for (let t = 0, n = this.children.length; t < n; ++t) this.children[t].render(e);
		}
		o && e.batch.flush(), s && e.mask.pop(this), i && (null == (r = this._enabledFilters) ? void 0 : r.length) && e.filter.pop();
	}
	_render(e) {}
	destroy(e) {
		super.destroy(), (this.sortDirty = !1);
		const t = "boolean" == typeof e ? e : null == e ? void 0 : e.children,
			n = this.removeChildren(0, this.children.length);
		if (t) for (let r = 0; r < n.length; ++r) n[r].destroy(e);
	}
	get width() {
		return this.scale.x * this.getLocalBounds().width;
	}
	set width(e) {
		const t = this.getLocalBounds().width;
		(this.scale.x = 0 !== t ? e / t : 1), (this._width = e);
	}
	get height() {
		return this.scale.y * this.getLocalBounds().height;
	}
	set height(e) {
		const t = this.getLocalBounds().height;
		(this.scale.y = 0 !== t ? e / t : 1), (this._height = e);
	}
};
let Jf = Zf;
(Jf.defaultSortableChildren = !1),
	(Jf.prototype.containerUpdateTransform = Jf.prototype.updateTransform),
	Object.defineProperties(Vl, {
		SORTABLE_CHILDREN: {
			get: () => Jf.defaultSortableChildren,
			set(e) {
				fc("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), (Jf.defaultSortableChildren = e);
			}
		}
	});
const Qf = new Jh(),
	em = new Uint16Array([0, 1, 2, 0, 2, 3]);
class tm extends Jf {
	constructor(e) {
		super(),
			(this._anchor = new fd(this._onAnchorUpdate, this, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0)),
			(this._texture = null),
			(this._width = 0),
			(this._height = 0),
			(this._tintColor = new Wc(16777215)),
			(this._tintRGB = null),
			(this.tint = 16777215),
			(this.blendMode = wl.NORMAL),
			(this._cachedTint = 16777215),
			(this.uvs = null),
			(this.texture = e || lp.EMPTY),
			(this.vertexData = new Float32Array(8)),
			(this.vertexTrimmedData = null),
			(this._transformID = -1),
			(this._textureID = -1),
			(this._transformTrimmedID = -1),
			(this._textureTrimmedID = -1),
			(this.indices = em),
			(this.pluginName = "batch"),
			(this.isSprite = !0),
			(this._roundPixels = Vl.ROUND_PIXELS);
	}
	_onTextureUpdate() {
		(this._textureID = -1), (this._textureTrimmedID = -1), (this._cachedTint = 16777215), this._width && (this.scale.x = (ih(this.scale.x) * this._width) / this._texture.orig.width), this._height && (this.scale.y = (ih(this.scale.y) * this._height) / this._texture.orig.height);
	}
	_onAnchorUpdate() {
		(this._transformID = -1), (this._transformTrimmedID = -1);
	}
	calculateVertices() {
		const e = this._texture;
		if (this._transformID === this.transform._worldID && this._textureID === e._updateID) return;
		this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), (this._transformID = this.transform._worldID), (this._textureID = e._updateID);
		const t = this.transform.worldTransform,
			n = t.a,
			r = t.b,
			i = t.c,
			s = t.d,
			o = t.tx,
			a = t.ty,
			l = this.vertexData,
			u = e.trim,
			c = e.orig,
			h = this._anchor;
		let d = 0,
			p = 0,
			f = 0,
			m = 0;
		if (
			(u ? ((p = u.x - h._x * c.width), (d = p + u.width), (m = u.y - h._y * c.height), (f = m + u.height)) : ((p = -h._x * c.width), (d = p + c.width), (m = -h._y * c.height), (f = m + c.height)),
			(l[0] = n * p + i * m + o),
			(l[1] = s * m + r * p + a),
			(l[2] = n * d + i * m + o),
			(l[3] = s * m + r * d + a),
			(l[4] = n * d + i * f + o),
			(l[5] = s * f + r * d + a),
			(l[6] = n * p + i * f + o),
			(l[7] = s * f + r * p + a),
			this._roundPixels)
		) {
			const e = Vl.RESOLUTION;
			for (let t = 0; t < l.length; ++t) l[t] = Math.round(l[t] * e) / e;
		}
	}
	calculateTrimmedVertices() {
		if (this.vertexTrimmedData) {
			if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
		} else this.vertexTrimmedData = new Float32Array(8);
		(this._transformTrimmedID = this.transform._worldID), (this._textureTrimmedID = this._texture._updateID);
		const e = this._texture,
			t = this.vertexTrimmedData,
			n = e.orig,
			r = this._anchor,
			i = this.transform.worldTransform,
			s = i.a,
			o = i.b,
			a = i.c,
			l = i.d,
			u = i.tx,
			c = i.ty,
			h = -r._x * n.width,
			d = h + n.width,
			p = -r._y * n.height,
			f = p + n.height;
		(t[0] = s * h + a * p + u), (t[1] = l * p + o * h + c), (t[2] = s * d + a * p + u), (t[3] = l * p + o * d + c), (t[4] = s * d + a * f + u), (t[5] = l * f + o * d + c), (t[6] = s * h + a * f + u), (t[7] = l * f + o * h + c);
	}
	_render(e) {
		this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
	}
	_calculateBounds() {
		const e = this._texture.trim,
			t = this._texture.orig;
		!e || (e.width === t.width && e.height === t.height) ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
	}
	getLocalBounds(e) {
		return 0 === this.children.length
			? (this._localBounds || (this._localBounds = new Gf()),
			  (this._localBounds.minX = this._texture.orig.width * -this._anchor._x),
			  (this._localBounds.minY = this._texture.orig.height * -this._anchor._y),
			  (this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x)),
			  (this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y)),
			  e || (this._localBoundsRect || (this._localBoundsRect = new ed()), (e = this._localBoundsRect)),
			  this._localBounds.getRectangle(e))
			: super.getLocalBounds.call(this, e);
	}
	containsPoint(e) {
		this.worldTransform.applyInverse(e, Qf);
		const t = this._texture.orig.width,
			n = this._texture.orig.height,
			r = -t * this.anchor.x;
		let i = 0;
		return Qf.x >= r && Qf.x < r + t && ((i = -n * this.anchor.y), Qf.y >= i && Qf.y < i + n);
	}
	destroy(e) {
		super.destroy(e), this._texture.off("update", this._onTextureUpdate, this), (this._anchor = null);
		if ("boolean" == typeof e ? e : null == e ? void 0 : e.texture) {
			const t = "boolean" == typeof e ? e : null == e ? void 0 : e.baseTexture;
			this._texture.destroy(!!t);
		}
		this._texture = null;
	}
	static from(e, t) {
		const n = e instanceof lp ? e : lp.from(e, t);
		return new tm(n);
	}
	set roundPixels(e) {
		this._roundPixels !== e && (this._transformID = -1), (this._roundPixels = e);
	}
	get roundPixels() {
		return this._roundPixels;
	}
	get width() {
		return Math.abs(this.scale.x) * this._texture.orig.width;
	}
	set width(e) {
		const t = ih(this.scale.x) || 1;
		(this.scale.x = (t * e) / this._texture.orig.width), (this._width = e);
	}
	get height() {
		return Math.abs(this.scale.y) * this._texture.orig.height;
	}
	set height(e) {
		const t = ih(this.scale.y) || 1;
		(this.scale.y = (t * e) / this._texture.orig.height), (this._height = e);
	}
	get anchor() {
		return this._anchor;
	}
	set anchor(e) {
		this._anchor.copyFrom(e);
	}
	get tint() {
		return this._tintColor.value;
	}
	set tint(e) {
		this._tintColor.setValue(e), (this._tintRGB = this._tintColor.toLittleEndianNumber());
	}
	get tintValue() {
		return this._tintColor.toNumber();
	}
	get texture() {
		return this._texture;
	}
	set texture(e) {
		this._texture !== e &&
			(this._texture && this._texture.off("update", this._onTextureUpdate, this),
			(this._texture = e || lp.EMPTY),
			(this._cachedTint = 16777215),
			(this._textureID = -1),
			(this._textureTrimmedID = -1),
			e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
	}
}
const nm = new Jh();
class rm extends tm {
	constructor(e, t = 100, n = 100) {
		super(e), (this.tileTransform = new vd()), (this._width = t), (this._height = n), (this.uvMatrix = this.texture.uvMatrix || new Cp(e)), (this.pluginName = "tilingSprite"), (this.uvRespectAnchor = !1);
	}
	get clampMargin() {
		return this.uvMatrix.clampMargin;
	}
	set clampMargin(e) {
		(this.uvMatrix.clampMargin = e), this.uvMatrix.update(!0);
	}
	get tileScale() {
		return this.tileTransform.scale;
	}
	set tileScale(e) {
		this.tileTransform.scale.copyFrom(e);
	}
	get tilePosition() {
		return this.tileTransform.position;
	}
	set tilePosition(e) {
		this.tileTransform.position.copyFrom(e);
	}
	_onTextureUpdate() {
		this.uvMatrix && (this.uvMatrix.texture = this._texture), (this._cachedTint = 16777215);
	}
	_render(e) {
		const t = this._texture;
		t && t.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
	}
	_calculateBounds() {
		const e = this._width * -this._anchor._x,
			t = this._height * -this._anchor._y,
			n = this._width * (1 - this._anchor._x),
			r = this._height * (1 - this._anchor._y);
		this._bounds.addFrame(this.transform, e, t, n, r);
	}
	getLocalBounds(e) {
		return 0 === this.children.length
			? ((this._bounds.minX = this._width * -this._anchor._x),
			  (this._bounds.minY = this._height * -this._anchor._y),
			  (this._bounds.maxX = this._width * (1 - this._anchor._x)),
			  (this._bounds.maxY = this._height * (1 - this._anchor._y)),
			  e || (this._localBoundsRect || (this._localBoundsRect = new ed()), (e = this._localBoundsRect)),
			  this._bounds.getRectangle(e))
			: super.getLocalBounds.call(this, e);
	}
	containsPoint(e) {
		this.worldTransform.applyInverse(e, nm);
		const t = this._width,
			n = this._height,
			r = -t * this.anchor._x;
		if (nm.x >= r && nm.x < r + t) {
			const e = -n * this.anchor._y;
			if (nm.y >= e && nm.y < e + n) return !0;
		}
		return !1;
	}
	destroy(e) {
		super.destroy(e), (this.tileTransform = null), (this.uvMatrix = null);
	}
	static from(e, t) {
		const n = e instanceof lp ? e : lp.from(e, t);
		return new rm(n, t.width, t.height);
	}
	get width() {
		return this._width;
	}
	set width(e) {
		this._width = e;
	}
	get height() {
		return this._height;
	}
	set height(e) {
		this._height = e;
	}
}
var im =
	"#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
const sm = new sd();
class om extends Wd {
	constructor(e) {
		super(e), e.runners.contextChange.add(this), (this.quad = new dp()), (this.state = Mh.for2d());
	}
	contextChange() {
		const e = this.renderer,
			t = { globals: e.globalUniforms };
		(this.simpleShader = zd.from(
			im,
			"#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n        vec4 texSample = texture2D(uSampler, vTextureCoord);\n        gl_FragColor = texSample * uColor;\n}\n",
			t
		)),
			(this.shader =
				e.context.webGLVersion > 1
					? zd.from(
							"#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
							"#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n        vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n        fragmentColor = texSample * uColor;\n}\n",
							t
					  )
					: zd.from(
							im,
							"#version 100\n#ifdef GL_EXT_shader_texture_lod\n        #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n        vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        #ifdef GL_EXT_shader_texture_lod\n                vec4 texSample = unclamped == coord\n                        ? texture2D(uSampler, coord) \n                        : texture2DLodEXT(uSampler, coord, 0);\n        #else\n                vec4 texSample = texture2D(uSampler, coord);\n        #endif\n\n        gl_FragColor = texSample * uColor;\n}\n",
							t
					  ));
	}
	render(e) {
		const t = this.renderer,
			n = this.quad;
		let r = n.vertices;
		(r[0] = r[6] = e._width * -e.anchor.x), (r[1] = r[3] = e._height * -e.anchor.y), (r[2] = r[4] = e._width * (1 - e.anchor.x)), (r[5] = r[7] = e._height * (1 - e.anchor.y));
		const i = e.uvRespectAnchor ? e.anchor.x : 0,
			s = e.uvRespectAnchor ? e.anchor.y : 0;
		(r = n.uvs), (r[0] = r[6] = -i), (r[1] = r[3] = -s), (r[2] = r[4] = 1 - i), (r[5] = r[7] = 1 - s), n.invalidate();
		const o = e._texture,
			a = o.baseTexture,
			l = a.alphaMode > 0,
			u = e.tileTransform.localTransform,
			c = e.uvMatrix;
		let h = a.isPowerOfTwo && o.frame.width === a.width && o.frame.height === a.height;
		h && (a._glTextures[t.CONTEXT_UID] ? (h = a.wrapMode !== Ml.CLAMP) : a.wrapMode === Ml.CLAMP && (a.wrapMode = Ml.REPEAT));
		const d = h ? this.simpleShader : this.shader,
			p = o.width,
			f = o.height,
			m = e._width,
			v = e._height;
		sm.set((u.a * p) / m, (u.b * p) / v, (u.c * f) / m, (u.d * f) / v, u.tx / m, u.ty / v),
			sm.invert(),
			h ? sm.prepend(c.mapCoord) : ((d.uniforms.uMapCoord = c.mapCoord.toArray(!0)), (d.uniforms.uClampFrame = c.uClampFrame), (d.uniforms.uClampOffset = c.uClampOffset)),
			(d.uniforms.uTransform = sm.toArray(!0)),
			(d.uniforms.uColor = Wc.shared.setValue(e.tint).premultiply(e.worldAlpha, l).toArray(d.uniforms.uColor)),
			(d.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0)),
			(d.uniforms.uSampler = o),
			t.shader.bind(d),
			t.geometry.bind(n),
			(this.state.blendMode = Kc(e.blendMode, l)),
			t.state.set(this.state),
			t.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
	}
}
(om.extension = { name: "tilingSprite", type: _h.RendererPlugin }), Sh.add(om);
const am = new sd(),
	lm = new sd(),
	um = [new Jh(), new Jh(), new Jh(), new Jh()];
rm.prototype._renderCanvas = function (e) {
	const t = this._texture;
	if (!t.baseTexture.valid) return;
	const n = e.canvasContext.activeContext,
		r = this.worldTransform,
		i = t.baseTexture,
		s = i.getDrawableSource(),
		o = i.resolution;
	if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tintValue) {
		this._textureID = this._texture._updateID;
		const e = new dh(t._frame.width, t._frame.height, o);
		16777215 !== this.tintValue ? ((this._tintedCanvas = Wf.getTintedCanvas(this, this.tintValue)), e.context.drawImage(this._tintedCanvas, 0, 0)) : e.context.drawImage(s, -t._frame.x * o, -t._frame.y * o),
			(this._cachedTint = this.tintValue),
			(this._canvasPattern = e.context.createPattern(e.canvas, "repeat"));
	}
	(n.globalAlpha = this.worldAlpha), e.canvasContext.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform();
	const a = this.tileTransform.localTransform,
		l = this._width,
		u = this._height;
	am.identity(), lm.copyFrom(a), this.uvRespectAnchor || lm.translate(-this.anchor.x * l, -this.anchor.y * u), lm.scale(1 / o, 1 / o), am.prepend(lm), am.prepend(r), e.canvasContext.setContextTransform(am), (n.fillStyle = this._canvasPattern);
	const c = this.anchor.x * -l,
		h = this.anchor.y * -u;
	um[0].set(c, h), um[1].set(c + l, h), um[2].set(c + l, h + u), um[3].set(c, h + u);
	for (let d = 0; d < 4; d++) lm.applyInverse(um[d], um[d]);
	n.beginPath(), n.moveTo(um[0].x, um[0].y);
	for (let d = 1; d < 4; d++) n.lineTo(um[d].x, um[d].y);
	n.closePath(), n.fill();
};
class cm extends Jf {
	constructor(e = 1500, t, n = 16384, r = !1) {
		super();
		n > 16384 && (n = 16384),
			(this._properties = [!1, !0, !1, !1, !1]),
			(this._maxSize = e),
			(this._batchSize = n),
			(this._buffers = null),
			(this._bufferUpdateIDs = []),
			(this._updateID = 0),
			(this.interactiveChildren = !1),
			(this.blendMode = wl.NORMAL),
			(this.autoResize = r),
			(this.roundPixels = !0),
			(this.baseTexture = null),
			this.setProperties(t),
			(this._tintColor = new Wc(0)),
			(this.tintRgb = new Float32Array(3)),
			(this.tint = 16777215);
	}
	setProperties(e) {
		e &&
			((this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0]),
			(this._properties[1] = "position" in e ? !!e.position : this._properties[1]),
			(this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2]),
			(this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3]),
			(this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]));
	}
	updateTransform() {
		this.displayObjectUpdateTransform();
	}
	get tint() {
		return this._tintColor.value;
	}
	set tint(e) {
		this._tintColor.setValue(e), this._tintColor.toRgbArray(this.tintRgb);
	}
	render(e) {
		this.visible &&
			!(this.worldAlpha <= 0) &&
			this.children.length &&
			this.renderable &&
			(this.baseTexture || ((this.baseTexture = this.children[0]._texture.baseTexture), this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
	}
	onChildrenChange(e) {
		const t = Math.floor(e / this._batchSize);
		for (; this._bufferUpdateIDs.length < t; ) this._bufferUpdateIDs.push(0);
		this._bufferUpdateIDs[t] = ++this._updateID;
	}
	dispose() {
		if (this._buffers) {
			for (let e = 0; e < this._buffers.length; ++e) this._buffers[e].destroy();
			this._buffers = null;
		}
	}
	destroy(e) {
		super.destroy(e), this.dispose(), (this._properties = null), (this._buffers = null), (this._bufferUpdateIDs = null);
	}
}
class hm {
	constructor(e, t, n) {
		(this.geometry = new Gh()), (this.indexBuffer = null), (this.size = n), (this.dynamicProperties = []), (this.staticProperties = []);
		for (let r = 0; r < e.length; ++r) {
			let n = e[r];
			(n = { attributeName: n.attributeName, size: n.size, uploadFunction: n.uploadFunction, type: n.type || Tl.FLOAT, offset: n.offset }), t[r] ? this.dynamicProperties.push(n) : this.staticProperties.push(n);
		}
		(this.staticStride = 0), (this.staticBuffer = null), (this.staticData = null), (this.staticDataUint32 = null), (this.dynamicStride = 0), (this.dynamicBuffer = null), (this.dynamicData = null), (this.dynamicDataUint32 = null), (this._updateID = 0), this.initBuffers();
	}
	initBuffers() {
		const e = this.geometry;
		let t = 0;
		(this.indexBuffer = new Vh(Zc(this.size), !0, !0)), e.addIndex(this.indexBuffer), (this.dynamicStride = 0);
		for (let s = 0; s < this.dynamicProperties.length; ++s) {
			const e = this.dynamicProperties[s];
			(e.offset = t), (t += e.size), (this.dynamicStride += e.size);
		}
		const n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
		(this.dynamicData = new Float32Array(n)), (this.dynamicDataUint32 = new Uint32Array(n)), (this.dynamicBuffer = new Vh(this.dynamicData, !1, !1));
		let r = 0;
		this.staticStride = 0;
		for (let s = 0; s < this.staticProperties.length; ++s) {
			const e = this.staticProperties[s];
			(e.offset = r), (r += e.size), (this.staticStride += e.size);
		}
		const i = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
		(this.staticData = new Float32Array(i)), (this.staticDataUint32 = new Uint32Array(i)), (this.staticBuffer = new Vh(this.staticData, !0, !1));
		for (let s = 0; s < this.dynamicProperties.length; ++s) {
			const t = this.dynamicProperties[s];
			e.addAttribute(t.attributeName, this.dynamicBuffer, 0, t.type === Tl.UNSIGNED_BYTE, t.type, 4 * this.dynamicStride, 4 * t.offset);
		}
		for (let s = 0; s < this.staticProperties.length; ++s) {
			const t = this.staticProperties[s];
			e.addAttribute(t.attributeName, this.staticBuffer, 0, t.type === Tl.UNSIGNED_BYTE, t.type, 4 * this.staticStride, 4 * t.offset);
		}
	}
	uploadDynamic(e, t, n) {
		for (let r = 0; r < this.dynamicProperties.length; r++) {
			const i = this.dynamicProperties[r];
			i.uploadFunction(e, t, n, i.type === Tl.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, i.offset);
		}
		this.dynamicBuffer._updateID++;
	}
	uploadStatic(e, t, n) {
		for (let r = 0; r < this.staticProperties.length; r++) {
			const i = this.staticProperties[r];
			i.uploadFunction(e, t, n, i.type === Tl.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, i.offset);
		}
		this.staticBuffer._updateID++;
	}
	destroy() {
		(this.indexBuffer = null), (this.dynamicProperties = null), (this.dynamicBuffer = null), (this.dynamicData = null), (this.dynamicDataUint32 = null), (this.staticProperties = null), (this.staticBuffer = null), (this.staticData = null), (this.staticDataUint32 = null), this.geometry.destroy();
	}
}
class dm extends Wd {
	constructor(e) {
		super(e),
			(this.shader = null),
			(this.properties = null),
			(this.tempMatrix = new sd()),
			(this.properties = [
				{ attributeName: "aVertexPosition", size: 2, uploadFunction: this.uploadVertices, offset: 0 },
				{ attributeName: "aPositionCoord", size: 2, uploadFunction: this.uploadPosition, offset: 0 },
				{ attributeName: "aRotation", size: 1, uploadFunction: this.uploadRotation, offset: 0 },
				{ attributeName: "aTextureCoord", size: 2, uploadFunction: this.uploadUvs, offset: 0 },
				{ attributeName: "aColor", size: 1, type: Tl.UNSIGNED_BYTE, uploadFunction: this.uploadTint, offset: 0 }
			]),
			(this.shader = zd.from(
				"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n        float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n        float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n        vec2 v = vec2(x, y);\n        v = v + aPositionCoord;\n\n        gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = aTextureCoord;\n        vColor = aColor * uColor;\n}\n",
				"varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n        gl_FragColor = color;\n}",
				{}
			)),
			(this.state = Mh.for2d());
	}
	render(e) {
		const t = e.children,
			n = e._maxSize,
			r = e._batchSize,
			i = this.renderer;
		let s = t.length;
		if (0 === s) return;
		s > n && !e.autoResize && (s = n);
		let o = e._buffers;
		o || (o = e._buffers = this.generateBuffers(e));
		const a = t[0]._texture.baseTexture,
			l = a.alphaMode > 0;
		(this.state.blendMode = Kc(e.blendMode, l)), i.state.set(this.state);
		const u = i.gl,
			c = e.worldTransform.copyTo(this.tempMatrix);
		c.prepend(i.globalUniforms.uniforms.projectionMatrix),
			(this.shader.uniforms.translationMatrix = c.toArray(!0)),
			(this.shader.uniforms.uColor = Wc.shared.setValue(e.tintRgb).premultiply(e.worldAlpha, l).toArray(this.shader.uniforms.uColor)),
			(this.shader.uniforms.uSampler = a),
			this.renderer.shader.bind(this.shader);
		let h = !1;
		for (let d = 0, p = 0; d < s; d += r, p += 1) {
			let n = s - d;
			n > r && (n = r), p >= o.length && o.push(this._generateOneMoreBuffer(e));
			const a = o[p];
			a.uploadDynamic(t, d, n);
			const l = e._bufferUpdateIDs[p] || 0;
			(h = h || a._updateID < l), h && ((a._updateID = e._updateID), a.uploadStatic(t, d, n)), i.geometry.bind(a.geometry), u.drawElements(u.TRIANGLES, 6 * n, u.UNSIGNED_SHORT, 0);
		}
	}
	generateBuffers(e) {
		const t = [],
			n = e._maxSize,
			r = e._batchSize,
			i = e._properties;
		for (let s = 0; s < n; s += r) t.push(new hm(this.properties, i, r));
		return t;
	}
	_generateOneMoreBuffer(e) {
		const t = e._batchSize,
			n = e._properties;
		return new hm(this.properties, n, t);
	}
	uploadVertices(e, t, n, r, i, s) {
		let o = 0,
			a = 0,
			l = 0,
			u = 0;
		for (let c = 0; c < n; ++c) {
			const n = e[t + c],
				h = n._texture,
				d = n.scale.x,
				p = n.scale.y,
				f = h.trim,
				m = h.orig;
			f ? ((a = f.x - n.anchor.x * m.width), (o = a + f.width), (u = f.y - n.anchor.y * m.height), (l = u + f.height)) : ((o = m.width * (1 - n.anchor.x)), (a = m.width * -n.anchor.x), (l = m.height * (1 - n.anchor.y)), (u = m.height * -n.anchor.y)),
				(r[s] = a * d),
				(r[s + 1] = u * p),
				(r[s + i] = o * d),
				(r[s + i + 1] = u * p),
				(r[s + 2 * i] = o * d),
				(r[s + 2 * i + 1] = l * p),
				(r[s + 3 * i] = a * d),
				(r[s + 3 * i + 1] = l * p),
				(s += 4 * i);
		}
	}
	uploadPosition(e, t, n, r, i, s) {
		for (let o = 0; o < n; o++) {
			const n = e[t + o].position;
			(r[s] = n.x), (r[s + 1] = n.y), (r[s + i] = n.x), (r[s + i + 1] = n.y), (r[s + 2 * i] = n.x), (r[s + 2 * i + 1] = n.y), (r[s + 3 * i] = n.x), (r[s + 3 * i + 1] = n.y), (s += 4 * i);
		}
	}
	uploadRotation(e, t, n, r, i, s) {
		for (let o = 0; o < n; o++) {
			const n = e[t + o].rotation;
			(r[s] = n), (r[s + i] = n), (r[s + 2 * i] = n), (r[s + 3 * i] = n), (s += 4 * i);
		}
	}
	uploadUvs(e, t, n, r, i, s) {
		for (let o = 0; o < n; ++o) {
			const n = e[t + o]._texture._uvs;
			n
				? ((r[s] = n.x0), (r[s + 1] = n.y0), (r[s + i] = n.x1), (r[s + i + 1] = n.y1), (r[s + 2 * i] = n.x2), (r[s + 2 * i + 1] = n.y2), (r[s + 3 * i] = n.x3), (r[s + 3 * i + 1] = n.y3), (s += 4 * i))
				: ((r[s] = 0), (r[s + 1] = 0), (r[s + i] = 0), (r[s + i + 1] = 0), (r[s + 2 * i] = 0), (r[s + 2 * i + 1] = 0), (r[s + 3 * i] = 0), (r[s + 3 * i + 1] = 0), (s += 4 * i));
		}
	}
	uploadTint(e, t, n, r, i, s) {
		for (let o = 0; o < n; ++o) {
			const n = e[t + o],
				a = Wc.shared.setValue(n._tintRGB).toPremultiplied(n.alpha, n.texture.baseTexture.alphaMode > 0);
			(r[s] = a), (r[s + i] = a), (r[s + 2 * i] = a), (r[s + 3 * i] = a), (s += 4 * i);
		}
	}
	destroy() {
		super.destroy(), this.shader && (this.shader.destroy(), (this.shader = null)), (this.tempMatrix = null);
	}
}
(dm.extension = { name: "particle", type: _h.RendererPlugin }),
	Sh.add(dm),
	(cm.prototype.renderCanvas = function (e) {
		if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) return;
		const t = e.canvasContext.activeContext,
			n = this.worldTransform;
		let r = !0,
			i = 0,
			s = 0,
			o = 0,
			a = 0;
		e.canvasContext.setBlendMode(this.blendMode), (t.globalAlpha = this.worldAlpha), this.displayObjectUpdateTransform();
		for (let l = 0; l < this.children.length; ++l) {
			const u = this.children[l];
			if (!u.visible) continue;
			if (!u._texture.valid) continue;
			const c = u._texture.frame;
			if (((t.globalAlpha = this.worldAlpha * u.alpha), u.rotation % (2 * Math.PI) == 0))
				r && (e.canvasContext.setContextTransform(n, !1, 1), (r = !1)), (i = u.anchor.x * (-c.width * u.scale.x) + u.position.x + 0.5), (s = u.anchor.y * (-c.height * u.scale.y) + u.position.y + 0.5), (o = c.width * u.scale.x), (a = c.height * u.scale.y);
			else {
				r || (r = !0), u.displayObjectUpdateTransform();
				const t = u.worldTransform;
				e.canvasContext.setContextTransform(t, this.roundPixels, 1), (i = u.anchor.x * -c.width + 0.5), (s = u.anchor.y * -c.height + 0.5), (o = c.width), (a = c.height);
			}
			const h = u._texture.baseTexture.resolution,
				d = e.canvasContext.activeResolution;
			t.drawImage(u._texture.baseTexture.getDrawableSource(), c.x * h, c.y * h, c.width * h, c.height * h, i * d, s * d, o * d, a * d);
		}
	}),
	(Jf.prototype._renderCanvas = function (e) {}),
	(Jf.prototype.renderCanvas = function (e) {
		if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
			this._mask && e.mask.pushMask(this._mask), this._renderCanvas(e);
			for (let t = 0, n = this.children.length; t < n; ++t) this.children[t].renderCanvas(e);
			this._mask && e.mask.popMask(e);
		}
	}),
	(Yf.prototype.renderCanvas = function (e) {});
var pm = ((e) => ((e[(e.LINEAR_VERTICAL = 0)] = "LINEAR_VERTICAL"), (e[(e.LINEAR_HORIZONTAL = 1)] = "LINEAR_HORIZONTAL"), e))(pm || {});
const fm = { willReadFrequently: !0 },
	mm = class {
		static get experimentalLetterSpacingSupported() {
			let e = mm._experimentalLetterSpacingSupported;
			if (void 0 !== e) {
				const t = Vl.ADAPTER.getCanvasRenderingContext2D().prototype;
				e = mm._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
			}
			return e;
		}
		constructor(e, t, n, r, i, s, o, a, l) {
			(this.text = e), (this.style = t), (this.width = n), (this.height = r), (this.lines = i), (this.lineWidths = s), (this.lineHeight = o), (this.maxLineWidth = a), (this.fontProperties = l);
		}
		static measureText(e, t, n, r = mm._canvas) {
			n = null == n ? t.wordWrap : n;
			const i = t.toFontString(),
				s = mm.measureFont(i);
			0 === s.fontSize && ((s.fontSize = t.fontSize), (s.ascent = t.fontSize));
			const o = r.getContext("2d", fm);
			o.font = i;
			const a = (n ? mm.wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/),
				l = new Array(a.length);
			let u = 0;
			for (let p = 0; p < a.length; p++) {
				const e = mm._measureText(a[p], t.letterSpacing, o);
				(l[p] = e), (u = Math.max(u, e));
			}
			let c = u + t.strokeThickness;
			t.dropShadow && (c += t.dropShadowDistance);
			const h = t.lineHeight || s.fontSize + t.strokeThickness;
			let d = Math.max(h, s.fontSize + 2 * t.strokeThickness) + (a.length - 1) * (h + t.leading);
			return t.dropShadow && (d += t.dropShadowDistance), new mm(e, t, c, d, a, l, h + t.leading, u, s);
		}
		static _measureText(e, t, n) {
			let r = !1;
			mm.experimentalLetterSpacingSupported && (mm.experimentalLetterSpacing ? ((n.letterSpacing = `${t}px`), (n.textLetterSpacing = `${t}px`), (r = !0)) : ((n.letterSpacing = "0px"), (n.textLetterSpacing = "0px")));
			let i = n.measureText(e).width;
			return i > 0 && (r ? (i -= t) : (i += (mm.graphemeSegmenter(e).length - 1) * t)), i;
		}
		static wordWrap(e, t, n = mm._canvas) {
			const r = n.getContext("2d", fm);
			let i = 0,
				s = "",
				o = "";
			const a = Object.create(null),
				{ letterSpacing: l, whiteSpace: u } = t,
				c = mm.collapseSpaces(u),
				h = mm.collapseNewlines(u);
			let d = !c;
			const p = t.wordWrapWidth + l,
				f = mm.tokenize(e);
			for (let m = 0; m < f.length; m++) {
				let e = f[m];
				if (mm.isNewline(e)) {
					if (!h) {
						(o += mm.addLine(s)), (d = !c), (s = ""), (i = 0);
						continue;
					}
					e = " ";
				}
				if (c) {
					const t = mm.isBreakingSpace(e),
						n = mm.isBreakingSpace(s[s.length - 1]);
					if (t && n) continue;
				}
				const n = mm.getFromCache(e, l, a, r);
				if (n > p)
					if (("" !== s && ((o += mm.addLine(s)), (s = ""), (i = 0)), mm.canBreakWords(e, t.breakWords))) {
						const n = mm.wordWrapSplit(e);
						for (let u = 0; u < n.length; u++) {
							let c = n[u],
								h = c,
								f = 1;
							for (; n[u + f]; ) {
								const r = n[u + f];
								if (mm.canBreakChars(h, r, e, u, t.breakWords)) break;
								(c += r), (h = r), f++;
							}
							u += f - 1;
							const m = mm.getFromCache(c, l, a, r);
							m + i > p && ((o += mm.addLine(s)), (d = !1), (s = ""), (i = 0)), (s += c), (i += m);
						}
					} else {
						s.length > 0 && ((o += mm.addLine(s)), (s = ""), (i = 0));
						const t = m === f.length - 1;
						(o += mm.addLine(e, !t)), (d = !1), (s = ""), (i = 0);
					}
				else n + i > p && ((d = !1), (o += mm.addLine(s)), (s = ""), (i = 0)), (s.length > 0 || !mm.isBreakingSpace(e) || d) && ((s += e), (i += n));
			}
			return (o += mm.addLine(s, !1)), o;
		}
		static addLine(e, t = !0) {
			return (e = mm.trimRight(e)), (e = t ? `${e}\n` : e);
		}
		static getFromCache(e, t, n, r) {
			let i = n[e];
			return "number" != typeof i && ((i = mm._measureText(e, t, r) + t), (n[e] = i)), i;
		}
		static collapseSpaces(e) {
			return "normal" === e || "pre-line" === e;
		}
		static collapseNewlines(e) {
			return "normal" === e;
		}
		static trimRight(e) {
			if ("string" != typeof e) return "";
			for (let t = e.length - 1; t >= 0; t--) {
				const n = e[t];
				if (!mm.isBreakingSpace(n)) break;
				e = e.slice(0, -1);
			}
			return e;
		}
		static isNewline(e) {
			return "string" == typeof e && mm._newlines.includes(e.charCodeAt(0));
		}
		static isBreakingSpace(e, t) {
			return "string" == typeof e && mm._breakingSpaces.includes(e.charCodeAt(0));
		}
		static tokenize(e) {
			const t = [];
			let n = "";
			if ("string" != typeof e) return t;
			for (let r = 0; r < e.length; r++) {
				const i = e[r],
					s = e[r + 1];
				mm.isBreakingSpace(i, s) || mm.isNewline(i) ? ("" !== n && (t.push(n), (n = "")), t.push(i)) : (n += i);
			}
			return "" !== n && t.push(n), t;
		}
		static canBreakWords(e, t) {
			return t;
		}
		static canBreakChars(e, t, n, r, i) {
			return !0;
		}
		static wordWrapSplit(e) {
			return mm.graphemeSegmenter(e);
		}
		static measureFont(e) {
			if (mm._fonts[e]) return mm._fonts[e];
			const t = { ascent: 0, descent: 0, fontSize: 0 },
				n = mm._canvas,
				r = mm._context;
			r.font = e;
			const i = mm.METRICS_STRING + mm.BASELINE_SYMBOL,
				s = Math.ceil(r.measureText(i).width);
			let o = Math.ceil(r.measureText(mm.BASELINE_SYMBOL).width);
			const a = Math.ceil(mm.HEIGHT_MULTIPLIER * o);
			if (((o = (o * mm.BASELINE_MULTIPLIER) | 0), 0 === s || 0 === a)) return (mm._fonts[e] = t), t;
			(n.width = s), (n.height = a), (r.fillStyle = "#f00"), r.fillRect(0, 0, s, a), (r.font = e), (r.textBaseline = "alphabetic"), (r.fillStyle = "#000"), r.fillText(i, 0, o);
			const l = r.getImageData(0, 0, s, a).data,
				u = l.length,
				c = 4 * s;
			let h = 0,
				d = 0,
				p = !1;
			for (h = 0; h < o; ++h) {
				for (let e = 0; e < c; e += 4)
					if (255 !== l[d + e]) {
						p = !0;
						break;
					}
				if (p) break;
				d += c;
			}
			for (t.ascent = o - h, d = u - c, p = !1, h = a; h > o; --h) {
				for (let e = 0; e < c; e += 4)
					if (255 !== l[d + e]) {
						p = !0;
						break;
					}
				if (p) break;
				d -= c;
			}
			return (t.descent = h - o), (t.fontSize = t.ascent + t.descent), (mm._fonts[e] = t), t;
		}
		static clearMetrics(e = "") {
			e ? delete mm._fonts[e] : (mm._fonts = {});
		}
		static get _canvas() {
			if (!mm.__canvas) {
				let t;
				try {
					const e = new OffscreenCanvas(0, 0),
						n = e.getContext("2d", fm);
					if (null == n ? void 0 : n.measureText) return (mm.__canvas = e), e;
					t = Vl.ADAPTER.createCanvas();
				} catch (e) {
					t = Vl.ADAPTER.createCanvas();
				}
				(t.width = t.height = 10), (mm.__canvas = t);
			}
			return mm.__canvas;
		}
		static get _context() {
			return mm.__context || (mm.__context = mm._canvas.getContext("2d", fm)), mm.__context;
		}
	};
let vm = mm;
(vm.METRICS_STRING = "|ÉqÅ"),
	(vm.BASELINE_SYMBOL = "M"),
	(vm.BASELINE_MULTIPLIER = 1.4),
	(vm.HEIGHT_MULTIPLIER = 2),
	(vm.graphemeSegmenter = (() => {
		if ("function" == typeof (null == Intl ? void 0 : Intl.Segmenter)) {
			const e = new Intl.Segmenter();
			return (t) => [...e.segment(t)].map((e) => e.segment);
		}
		return (e) => [...e];
	})()),
	(vm.experimentalLetterSpacing = !1),
	(vm._fonts = {}),
	(vm._newlines = [10, 13]),
	(vm._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]);
const gm = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
	ym = class {
		constructor(e) {
			(this.styleID = 0), this.reset(), _m(this, e, e);
		}
		clone() {
			const e = {};
			return _m(e, this, ym.defaultStyle), new ym(e);
		}
		reset() {
			_m(this, ym.defaultStyle, ym.defaultStyle);
		}
		get align() {
			return this._align;
		}
		set align(e) {
			this._align !== e && ((this._align = e), this.styleID++);
		}
		get breakWords() {
			return this._breakWords;
		}
		set breakWords(e) {
			this._breakWords !== e && ((this._breakWords = e), this.styleID++);
		}
		get dropShadow() {
			return this._dropShadow;
		}
		set dropShadow(e) {
			this._dropShadow !== e && ((this._dropShadow = e), this.styleID++);
		}
		get dropShadowAlpha() {
			return this._dropShadowAlpha;
		}
		set dropShadowAlpha(e) {
			this._dropShadowAlpha !== e && ((this._dropShadowAlpha = e), this.styleID++);
		}
		get dropShadowAngle() {
			return this._dropShadowAngle;
		}
		set dropShadowAngle(e) {
			this._dropShadowAngle !== e && ((this._dropShadowAngle = e), this.styleID++);
		}
		get dropShadowBlur() {
			return this._dropShadowBlur;
		}
		set dropShadowBlur(e) {
			this._dropShadowBlur !== e && ((this._dropShadowBlur = e), this.styleID++);
		}
		get dropShadowColor() {
			return this._dropShadowColor;
		}
		set dropShadowColor(e) {
			const t = xm(e);
			this._dropShadowColor !== t && ((this._dropShadowColor = t), this.styleID++);
		}
		get dropShadowDistance() {
			return this._dropShadowDistance;
		}
		set dropShadowDistance(e) {
			this._dropShadowDistance !== e && ((this._dropShadowDistance = e), this.styleID++);
		}
		get fill() {
			return this._fill;
		}
		set fill(e) {
			const t = xm(e);
			this._fill !== t && ((this._fill = t), this.styleID++);
		}
		get fillGradientType() {
			return this._fillGradientType;
		}
		set fillGradientType(e) {
			this._fillGradientType !== e && ((this._fillGradientType = e), this.styleID++);
		}
		get fillGradientStops() {
			return this._fillGradientStops;
		}
		set fillGradientStops(e) {
			(function (e, t) {
				if (!Array.isArray(e) || !Array.isArray(t)) return !1;
				if (e.length !== t.length) return !1;
				for (let n = 0; n < e.length; ++n) if (e[n] !== t[n]) return !1;
				return !0;
			})(this._fillGradientStops, e) || ((this._fillGradientStops = e), this.styleID++);
		}
		get fontFamily() {
			return this._fontFamily;
		}
		set fontFamily(e) {
			this.fontFamily !== e && ((this._fontFamily = e), this.styleID++);
		}
		get fontSize() {
			return this._fontSize;
		}
		set fontSize(e) {
			this._fontSize !== e && ((this._fontSize = e), this.styleID++);
		}
		get fontStyle() {
			return this._fontStyle;
		}
		set fontStyle(e) {
			this._fontStyle !== e && ((this._fontStyle = e), this.styleID++);
		}
		get fontVariant() {
			return this._fontVariant;
		}
		set fontVariant(e) {
			this._fontVariant !== e && ((this._fontVariant = e), this.styleID++);
		}
		get fontWeight() {
			return this._fontWeight;
		}
		set fontWeight(e) {
			this._fontWeight !== e && ((this._fontWeight = e), this.styleID++);
		}
		get letterSpacing() {
			return this._letterSpacing;
		}
		set letterSpacing(e) {
			this._letterSpacing !== e && ((this._letterSpacing = e), this.styleID++);
		}
		get lineHeight() {
			return this._lineHeight;
		}
		set lineHeight(e) {
			this._lineHeight !== e && ((this._lineHeight = e), this.styleID++);
		}
		get leading() {
			return this._leading;
		}
		set leading(e) {
			this._leading !== e && ((this._leading = e), this.styleID++);
		}
		get lineJoin() {
			return this._lineJoin;
		}
		set lineJoin(e) {
			this._lineJoin !== e && ((this._lineJoin = e), this.styleID++);
		}
		get miterLimit() {
			return this._miterLimit;
		}
		set miterLimit(e) {
			this._miterLimit !== e && ((this._miterLimit = e), this.styleID++);
		}
		get padding() {
			return this._padding;
		}
		set padding(e) {
			this._padding !== e && ((this._padding = e), this.styleID++);
		}
		get stroke() {
			return this._stroke;
		}
		set stroke(e) {
			const t = xm(e);
			this._stroke !== t && ((this._stroke = t), this.styleID++);
		}
		get strokeThickness() {
			return this._strokeThickness;
		}
		set strokeThickness(e) {
			this._strokeThickness !== e && ((this._strokeThickness = e), this.styleID++);
		}
		get textBaseline() {
			return this._textBaseline;
		}
		set textBaseline(e) {
			this._textBaseline !== e && ((this._textBaseline = e), this.styleID++);
		}
		get trim() {
			return this._trim;
		}
		set trim(e) {
			this._trim !== e && ((this._trim = e), this.styleID++);
		}
		get whiteSpace() {
			return this._whiteSpace;
		}
		set whiteSpace(e) {
			this._whiteSpace !== e && ((this._whiteSpace = e), this.styleID++);
		}
		get wordWrap() {
			return this._wordWrap;
		}
		set wordWrap(e) {
			this._wordWrap !== e && ((this._wordWrap = e), this.styleID++);
		}
		get wordWrapWidth() {
			return this._wordWrapWidth;
		}
		set wordWrapWidth(e) {
			this._wordWrapWidth !== e && ((this._wordWrapWidth = e), this.styleID++);
		}
		toFontString() {
			const e = "number" == typeof this.fontSize ? `${this.fontSize}px` : this.fontSize;
			let t = this.fontFamily;
			Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
			for (let n = t.length - 1; n >= 0; n--) {
				let e = t[n].trim();
				/([\"\'])[^\'\"]+\1/.test(e) || gm.includes(e) || (e = `"${e}"`), (t[n] = e);
			}
			return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`;
		}
	};
let bm = ym;
function xm(e) {
	const t = Wc.shared;
	return Array.isArray(e) ? e.map((e) => t.setValue(e).toHex()) : t.setValue(e).toHex();
}
function _m(e, t, n) {
	for (const r in n) Array.isArray(t[r]) ? (e[r] = t[r].slice()) : (e[r] = t[r]);
}
bm.defaultStyle = {
	align: "left",
	breakWords: !1,
	dropShadow: !1,
	dropShadowAlpha: 1,
	dropShadowAngle: Math.PI / 6,
	dropShadowBlur: 0,
	dropShadowColor: "black",
	dropShadowDistance: 5,
	fill: "black",
	fillGradientType: pm.LINEAR_VERTICAL,
	fillGradientStops: [],
	fontFamily: "Arial",
	fontSize: 26,
	fontStyle: "normal",
	fontVariant: "normal",
	fontWeight: "normal",
	leading: 0,
	letterSpacing: 0,
	lineHeight: 0,
	lineJoin: "miter",
	miterLimit: 10,
	padding: 0,
	stroke: "black",
	strokeThickness: 0,
	textBaseline: "alphabetic",
	trim: !1,
	whiteSpace: "pre",
	wordWrap: !1,
	wordWrapWidth: 100
};
const wm = { texture: !0, children: !1, baseTexture: !0 },
	Cm = class extends tm {
		constructor(e, t, n) {
			var r;
			let i = !1;
			n || ((n = Vl.ADAPTER.createCanvas()), (i = !0)), (n.width = 3), (n.height = 3);
			const s = lp.from(n);
			(s.orig = new ed()),
				(s.trim = new ed()),
				super(s),
				(this._ownCanvas = i),
				(this.canvas = n),
				(this.context = n.getContext("2d", { willReadFrequently: !0 })),
				(this._resolution = null != (r = Cm.defaultResolution) ? r : Vl.RESOLUTION),
				(this._autoResolution = Cm.defaultAutoResolution),
				(this._text = null),
				(this._style = null),
				(this._styleListener = null),
				(this._font = ""),
				(this.text = e),
				(this.style = t),
				(this.localStyleID = -1);
		}
		static get experimentalLetterSpacing() {
			return vm.experimentalLetterSpacing;
		}
		static set experimentalLetterSpacing(e) {
			fc("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), (vm.experimentalLetterSpacing = e);
		}
		updateText(e) {
			const t = this._style;
			if ((this.localStyleID !== t.styleID && ((this.dirty = !0), (this.localStyleID = t.styleID)), !this.dirty && e)) return;
			this._font = this._style.toFontString();
			const n = this.context,
				r = vm.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
				i = r.width,
				s = r.height,
				o = r.lines,
				a = r.lineHeight,
				l = r.lineWidths,
				u = r.maxLineWidth,
				c = r.fontProperties;
			let h, d;
			(this.canvas.width = Math.ceil(Math.ceil(Math.max(1, i) + 2 * t.padding) * this._resolution)),
				(this.canvas.height = Math.ceil(Math.ceil(Math.max(1, s) + 2 * t.padding) * this._resolution)),
				n.scale(this._resolution, this._resolution),
				n.clearRect(0, 0, this.canvas.width, this.canvas.height),
				(n.font = this._font),
				(n.lineWidth = t.strokeThickness),
				(n.textBaseline = t.textBaseline),
				(n.lineJoin = t.lineJoin),
				(n.miterLimit = t.miterLimit);
			const p = t.dropShadow ? 2 : 1;
			for (let f = 0; f < p; ++f) {
				const e = t.dropShadow && 0 === f,
					i = e ? Math.ceil(Math.max(1, s) + 2 * t.padding) : 0,
					p = i * this._resolution;
				if (e) {
					(n.fillStyle = "black"), (n.strokeStyle = "black");
					const e = t.dropShadowColor,
						r = t.dropShadowBlur * this._resolution,
						i = t.dropShadowDistance * this._resolution;
					(n.shadowColor = Wc.shared.setValue(e).setAlpha(t.dropShadowAlpha).toRgbaString()), (n.shadowBlur = r), (n.shadowOffsetX = Math.cos(t.dropShadowAngle) * i), (n.shadowOffsetY = Math.sin(t.dropShadowAngle) * i + p);
				} else (n.fillStyle = this._generateFillStyle(t, o, r)), (n.strokeStyle = t.stroke), (n.shadowColor = "black"), (n.shadowBlur = 0), (n.shadowOffsetX = 0), (n.shadowOffsetY = 0);
				let m = (a - c.fontSize) / 2;
				a - c.fontSize < 0 && (m = 0);
				for (let n = 0; n < o.length; n++)
					(h = t.strokeThickness / 2),
						(d = t.strokeThickness / 2 + n * a + c.ascent + m),
						"right" === t.align ? (h += u - l[n]) : "center" === t.align && (h += (u - l[n]) / 2),
						t.stroke && t.strokeThickness && this.drawLetterSpacing(o[n], h + t.padding, d + t.padding - i, !0),
						t.fill && this.drawLetterSpacing(o[n], h + t.padding, d + t.padding - i);
			}
			this.updateTexture();
		}
		drawLetterSpacing(e, t, n, r = !1) {
			const i = this._style.letterSpacing;
			let s = !1;
			if ((vm.experimentalLetterSpacingSupported && (vm.experimentalLetterSpacing ? ((this.context.letterSpacing = `${i}px`), (this.context.textLetterSpacing = `${i}px`), (s = !0)) : ((this.context.letterSpacing = "0px"), (this.context.textLetterSpacing = "0px"))), 0 === i || s))
				return void (r ? this.context.strokeText(e, t, n) : this.context.fillText(e, t, n));
			let o = t;
			const a = vm.graphemeSegmenter(e);
			let l = this.context.measureText(e).width,
				u = 0;
			for (let c = 0; c < a.length; ++c) {
				const e = a[c];
				r ? this.context.strokeText(e, o, n) : this.context.fillText(e, o, n);
				let t = "";
				for (let n = c + 1; n < a.length; ++n) t += a[n];
				(u = this.context.measureText(t).width), (o += l - u + i), (l = u);
			}
		}
		updateTexture() {
			const e = this.canvas;
			if (this._style.trim) {
				const t = vh(e);
				t.data && ((e.width = t.width), (e.height = t.height), this.context.putImageData(t.data, 0, 0));
			}
			const t = this._texture,
				n = this._style,
				r = n.trim ? 0 : n.padding,
				i = t.baseTexture;
			(t.trim.width = t._frame.width = e.width / this._resolution),
				(t.trim.height = t._frame.height = e.height / this._resolution),
				(t.trim.x = -r),
				(t.trim.y = -r),
				(t.orig.width = t._frame.width - 2 * r),
				(t.orig.height = t._frame.height - 2 * r),
				this._onTextureUpdate(),
				i.setRealSize(e.width, e.height, this._resolution),
				t.updateUvs(),
				(this.dirty = !1);
		}
		_render(e) {
			this._autoResolution && this._resolution !== e.resolution && ((this._resolution = e.resolution), (this.dirty = !0)), this.updateText(!0), super._render(e);
		}
		updateTransform() {
			this.updateText(!0), super.updateTransform();
		}
		getBounds(e, t) {
			return this.updateText(!0), -1 === this._textureID && (e = !1), super.getBounds(e, t);
		}
		getLocalBounds(e) {
			return this.updateText(!0), super.getLocalBounds.call(this, e);
		}
		_calculateBounds() {
			this.calculateVertices(), this._bounds.addQuad(this.vertexData);
		}
		_generateFillStyle(e, t, n) {
			const r = e.fill;
			if (!Array.isArray(r)) return r;
			if (1 === r.length) return r[0];
			let i;
			const s = e.dropShadow ? e.dropShadowDistance : 0,
				o = e.padding || 0,
				a = this.canvas.width / this._resolution - s - 2 * o,
				l = this.canvas.height / this._resolution - s - 2 * o,
				u = r.slice(),
				c = e.fillGradientStops.slice();
			if (!c.length) {
				const e = u.length + 1;
				for (let t = 1; t < e; ++t) c.push(t / e);
			}
			if ((u.unshift(r[0]), c.unshift(0), u.push(r[r.length - 1]), c.push(1), e.fillGradientType === pm.LINEAR_VERTICAL)) {
				i = this.context.createLinearGradient(a / 2, o, a / 2, l + o);
				const r = n.fontProperties.fontSize + e.strokeThickness;
				for (let e = 0; e < t.length; e++) {
					const s = n.lineHeight * (e - 1) + r,
						o = n.lineHeight * e;
					let a = o;
					e > 0 && s > o && (a = (o + s) / 2);
					const h = o + r,
						d = n.lineHeight * (e + 1);
					let p = h;
					e + 1 < t.length && d < h && (p = (h + d) / 2);
					const f = (p - a) / l;
					for (let e = 0; e < u.length; e++) {
						let t = 0;
						t = "number" == typeof c[e] ? c[e] : e / u.length;
						let n = Math.min(1, Math.max(0, a / l + t * f));
						(n = Number(n.toFixed(5))), i.addColorStop(n, u[e]);
					}
				}
			} else {
				i = this.context.createLinearGradient(o, l / 2, a + o, l / 2);
				const e = u.length + 1;
				let t = 1;
				for (let n = 0; n < u.length; n++) {
					let r;
					(r = "number" == typeof c[n] ? c[n] : t / e), i.addColorStop(r, u[n]), t++;
				}
			}
			return i;
		}
		destroy(e) {
			"boolean" == typeof e && (e = { children: e }), (e = Object.assign({}, wm, e)), super.destroy(e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), (this.context = null), (this.canvas = null), (this._style = null);
		}
		get width() {
			return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
		}
		set width(e) {
			this.updateText(!0);
			const t = ih(this.scale.x) || 1;
			(this.scale.x = (t * e) / this._texture.orig.width), (this._width = e);
		}
		get height() {
			return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
		}
		set height(e) {
			this.updateText(!0);
			const t = ih(this.scale.y) || 1;
			(this.scale.y = (t * e) / this._texture.orig.height), (this._height = e);
		}
		get style() {
			return this._style;
		}
		set style(e) {
			(e = e || {}), (this._style = e instanceof bm ? e : new bm(e)), (this.localStyleID = -1), (this.dirty = !0);
		}
		get text() {
			return this._text;
		}
		set text(e) {
			(e = String(null == e ? "" : e)), this._text !== e && ((this._text = e), (this.dirty = !0));
		}
		get resolution() {
			return this._resolution;
		}
		set resolution(e) {
			(this._autoResolution = !1), this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
		}
	};
let Sm = Cm;
(Sm.defaultAutoResolution = !0),
	(Sm.prototype._renderCanvas = function (e) {
		this._autoResolution && this._resolution !== e.resolution && ((this._resolution = e.resolution), (this.dirty = !0)), this.updateText(!0), tm.prototype._renderCanvas.call(this, e);
	});
const Em = new sd();
(Yf.prototype._cacheAsBitmap = !1), (Yf.prototype._cacheData = null), (Yf.prototype._cacheAsBitmapResolution = null), (Yf.prototype._cacheAsBitmapMultisample = null);
class Tm {
	constructor() {
		(this.textureCacheId = null),
			(this.originalRender = null),
			(this.originalRenderCanvas = null),
			(this.originalCalculateBounds = null),
			(this.originalGetLocalBounds = null),
			(this.originalUpdateTransform = null),
			(this.originalDestroy = null),
			(this.originalMask = null),
			(this.originalFilterArea = null),
			(this.originalContainsPoint = null),
			(this.sprite = null);
	}
}
Object.defineProperties(Yf.prototype, {
	cacheAsBitmapResolution: {
		get() {
			return this._cacheAsBitmapResolution;
		},
		set(e) {
			e !== this._cacheAsBitmapResolution && ((this._cacheAsBitmapResolution = e), this.cacheAsBitmap && ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
		}
	},
	cacheAsBitmapMultisample: {
		get() {
			return this._cacheAsBitmapMultisample;
		},
		set(e) {
			e !== this._cacheAsBitmapMultisample && ((this._cacheAsBitmapMultisample = e), this.cacheAsBitmap && ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
		}
	},
	cacheAsBitmap: {
		get() {
			return this._cacheAsBitmap;
		},
		set(e) {
			if (this._cacheAsBitmap === e) return;
			let t;
			(this._cacheAsBitmap = e),
				e
					? (this._cacheData || (this._cacheData = new Tm()),
					  (t = this._cacheData),
					  (t.originalRender = this.render),
					  (t.originalRenderCanvas = this.renderCanvas),
					  (t.originalUpdateTransform = this.updateTransform),
					  (t.originalCalculateBounds = this.calculateBounds),
					  (t.originalGetLocalBounds = this.getLocalBounds),
					  (t.originalDestroy = this.destroy),
					  (t.originalContainsPoint = this.containsPoint),
					  (t.originalMask = this._mask),
					  (t.originalFilterArea = this.filterArea),
					  (this.render = this._renderCached),
					  (this.renderCanvas = this._renderCachedCanvas),
					  (this.destroy = this._cacheAsBitmapDestroy))
					: ((t = this._cacheData),
					  t.sprite && this._destroyCachedDisplayObject(),
					  (this.render = t.originalRender),
					  (this.renderCanvas = t.originalRenderCanvas),
					  (this.calculateBounds = t.originalCalculateBounds),
					  (this.getLocalBounds = t.originalGetLocalBounds),
					  (this.destroy = t.originalDestroy),
					  (this.updateTransform = t.originalUpdateTransform),
					  (this.containsPoint = t.originalContainsPoint),
					  (this._mask = t.originalMask),
					  (this.filterArea = t.originalFilterArea));
		}
	}
}),
	(Yf.prototype._renderCached = function (e) {
		!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(e), (this._cacheData.sprite.transform._worldID = this.transform._worldID), (this._cacheData.sprite.worldAlpha = this.worldAlpha), this._cacheData.sprite._render(e));
	}),
	(Yf.prototype._initCachedDisplayObject = function (e) {
		var t, n, r;
		if (null == (t = this._cacheData) ? void 0 : t.sprite) return;
		const i = this.alpha;
		(this.alpha = 1), e.batch.flush();
		const s = this.getLocalBounds(null, !0).clone();
		if (null == (n = this.filters) ? void 0 : n.length) {
			const e = this.filters[0].padding;
			s.pad(e);
		}
		s.ceil(Vl.RESOLUTION);
		const o = e.renderTexture.current,
			a = e.renderTexture.sourceFrame.clone(),
			l = e.renderTexture.destinationFrame.clone(),
			u = e.projection.transform,
			c = up.create({ width: s.width, height: s.height, resolution: this.cacheAsBitmapResolution || e.resolution, multisample: null != (r = this.cacheAsBitmapMultisample) ? r : e.multisample }),
			h = `cacheAsBitmap_${oh()}`;
		(this._cacheData.textureCacheId = h), Bh.addToCache(c.baseTexture, h), lp.addToCache(c, h);
		const d = this.transform.localTransform.copyTo(Em).invert().translate(-s.x, -s.y);
		(this.render = this._cacheData.originalRender),
			e.render(this, { renderTexture: c, clear: !0, transform: d, skipUpdateTransform: !1 }),
			e.framebuffer.blit(),
			(e.projection.transform = u),
			e.renderTexture.bind(o, a, l),
			(this.render = this._renderCached),
			(this.updateTransform = this.displayObjectUpdateTransform),
			(this.calculateBounds = this._calculateCachedBounds),
			(this.getLocalBounds = this._getCachedLocalBounds),
			(this._mask = null),
			(this.filterArea = null),
			(this.alpha = i);
		const p = new tm(c);
		(p.transform.worldTransform = this.transform.worldTransform),
			(p.anchor.x = -s.x / s.width),
			(p.anchor.y = -s.y / s.height),
			(p.alpha = i),
			(p._bounds = this._bounds),
			(this._cacheData.sprite = p),
			(this.transform._parentID = -1),
			this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)),
			(this.containsPoint = p.containsPoint.bind(p));
	}),
	(Yf.prototype._renderCachedCanvas = function (e) {
		!this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(e), (this._cacheData.sprite.worldAlpha = this.worldAlpha), this._cacheData.sprite._renderCanvas(e));
	}),
	(Yf.prototype._initCachedDisplayObjectCanvas = function (e) {
		var t;
		if (null == (t = this._cacheData) ? void 0 : t.sprite) return;
		const n = this.getLocalBounds(null, !0),
			r = this.alpha;
		this.alpha = 1;
		const i = e.canvasContext.activeContext,
			s = e._projTransform;
		n.ceil(Vl.RESOLUTION);
		const o = up.create({ width: n.width, height: n.height }),
			a = `cacheAsBitmap_${oh()}`;
		(this._cacheData.textureCacheId = a), Bh.addToCache(o.baseTexture, a), lp.addToCache(o, a);
		const l = Em;
		this.transform.localTransform.copyTo(l),
			l.invert(),
			(l.tx -= n.x),
			(l.ty -= n.y),
			(this.renderCanvas = this._cacheData.originalRenderCanvas),
			e.render(this, { renderTexture: o, clear: !0, transform: l, skipUpdateTransform: !1 }),
			(e.canvasContext.activeContext = i),
			(e._projTransform = s),
			(this.renderCanvas = this._renderCachedCanvas),
			(this.updateTransform = this.displayObjectUpdateTransform),
			(this.calculateBounds = this._calculateCachedBounds),
			(this.getLocalBounds = this._getCachedLocalBounds),
			(this._mask = null),
			(this.filterArea = null),
			(this.alpha = r);
		const u = new tm(o);
		(u.transform.worldTransform = this.transform.worldTransform),
			(u.anchor.x = -n.x / n.width),
			(u.anchor.y = -n.y / n.height),
			(u.alpha = r),
			(u._bounds = this._bounds),
			(this._cacheData.sprite = u),
			(this.transform._parentID = -1),
			this.parent ? this.updateTransform() : ((this.parent = e._tempDisplayObjectParent), this.updateTransform(), (this.parent = null)),
			(this.containsPoint = u.containsPoint.bind(u));
	}),
	(Yf.prototype._calculateCachedBounds = function () {
		this._bounds.clear(), (this._cacheData.sprite.transform._worldID = this.transform._worldID), this._cacheData.sprite._calculateBounds(), (this._bounds.updateID = this._boundsID);
	}),
	(Yf.prototype._getCachedLocalBounds = function () {
		return this._cacheData.sprite.getLocalBounds(null);
	}),
	(Yf.prototype._destroyCachedDisplayObject = function () {
		this._cacheData.sprite._texture.destroy(!0), (this._cacheData.sprite = null), Bh.removeFromCache(this._cacheData.textureCacheId), lp.removeFromCache(this._cacheData.textureCacheId), (this._cacheData.textureCacheId = null);
	}),
	(Yf.prototype._cacheAsBitmapDestroy = function (e) {
		(this.cacheAsBitmap = !1), this.destroy(e);
	}),
	(Yf.prototype.name = null),
	(Jf.prototype.getChildByName = function (e, t) {
		for (let n = 0, r = this.children.length; n < r; n++) if (this.children[n].name === e) return this.children[n];
		if (t)
			for (let n = 0, r = this.children.length; n < r; n++) {
				const t = this.children[n];
				if (!t.getChildByName) continue;
				const r = t.getChildByName(e, !0);
				if (r) return r;
			}
		return null;
	}),
	(Yf.prototype.getGlobalPosition = function (e = new Jh(), t = !1) {
		return this.parent ? this.parent.toGlobal(this.position, e, t) : ((e.x = this.position.x), (e.y = this.position.y)), e;
	});
class km extends Kd {
	constructor(e = 1) {
		super(vf, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n     gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", { uAlpha: 1 }), (this.alpha = e);
	}
	get alpha() {
		return this.uniforms.uAlpha;
	}
	set alpha(e) {
		this.uniforms.uAlpha = e;
	}
}
const Am = {
		5: [0.153388, 0.221461, 0.250301],
		7: [0.071303, 0.131514, 0.189879, 0.214607],
		9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
		11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
		13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
		15: [489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
	},
	Mm = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "        gl_FragColor = vec4(0.0);", "        %blur%", "}"].join("\n");
class Im extends Kd {
	constructor(e, t = 8, n = 4, r = Kd.defaultResolution, i = 5) {
		super(
			(function (e, t) {
				const n = Math.ceil(e / 2);
				let r,
					i =
						"\n        attribute vec2 aVertexPosition;\n\n        uniform mat3 projectionMatrix;\n\n        uniform float strength;\n\n        varying vec2 vBlurTexCoords[%size%];\n\n        uniform vec4 inputSize;\n        uniform vec4 outputFrame;\n\n        vec4 filterVertexPosition( void )\n        {\n                vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n                return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n        }\n\n        vec2 filterTextureCoord( void )\n        {\n                return aVertexPosition * (outputFrame.zw * inputSize.zw);\n        }\n\n        void main(void)\n        {\n                gl_Position = filterVertexPosition();\n\n                vec2 textureCoord = filterTextureCoord();\n                %blur%\n        }",
					s = "";
				r = t ? "vBlurTexCoords[%index%] =    textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =    textureCoord + vec2(0.0, %sampleIndex% * strength);";
				for (let o = 0; o < e; o++) {
					let e = r.replace("%index%", o.toString());
					(e = e.replace("%sampleIndex%", o - (n - 1) + ".0")), (s += e), (s += "\n");
				}
				return (i = i.replace("%blur%", s)), (i = i.replace("%size%", e.toString())), i;
			})(i, e),
			(function (e) {
				const t = Am[e],
					n = t.length;
				let r,
					i = Mm,
					s = "";
				for (let o = 0; o < e; o++) {
					let i = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", o.toString());
					(r = o), o >= n && (r = e - o - 1), (i = i.replace("%value%", t[r].toString())), (s += i), (s += "\n");
				}
				return (i = i.replace("%blur%", s)), (i = i.replace("%size%", e.toString())), i;
			})(i)
		),
			(this.horizontal = e),
			(this.resolution = r),
			(this._quality = 0),
			(this.quality = n),
			(this.blur = t);
	}
	apply(e, t, n, r) {
		if (
			(n
				? this.horizontal
					? (this.uniforms.strength = (1 / n.width) * (n.width / t.width))
					: (this.uniforms.strength = (1 / n.height) * (n.height / t.height))
				: this.horizontal
				? (this.uniforms.strength = (1 / e.renderer.width) * (e.renderer.width / t.width))
				: (this.uniforms.strength = (1 / e.renderer.height) * (e.renderer.height / t.height)),
			(this.uniforms.strength *= this.strength),
			(this.uniforms.strength /= this.passes),
			1 === this.passes)
		)
			e.applyFilter(this, t, n, r);
		else {
			const i = e.getFilterTexture(),
				s = e.renderer;
			let o = t,
				a = i;
			(this.state.blend = !1), e.applyFilter(this, o, a, Ll.CLEAR);
			for (let t = 1; t < this.passes - 1; t++) {
				e.bindAndClear(o, Ll.BLIT), (this.uniforms.uSampler = a);
				const t = a;
				(a = o), (o = t), s.shader.bind(this), s.geometry.draw(5);
			}
			(this.state.blend = !0), e.applyFilter(this, a, n, r), e.returnFilterTexture(i);
		}
	}
	get blur() {
		return this.strength;
	}
	set blur(e) {
		(this.padding = 1 + 2 * Math.abs(e)), (this.strength = e);
	}
	get quality() {
		return this._quality;
	}
	set quality(e) {
		(this._quality = e), (this.passes = e);
	}
}
class Rm extends Kd {
	constructor(e = 8, t = 4, n = Kd.defaultResolution, r = 5) {
		super(), (this._repeatEdgePixels = !1), (this.blurXFilter = new Im(!0, e, t, n, r)), (this.blurYFilter = new Im(!1, e, t, n, r)), (this.resolution = n), (this.quality = t), (this.blur = e), (this.repeatEdgePixels = !1);
	}
	apply(e, t, n, r) {
		const i = Math.abs(this.blurXFilter.strength),
			s = Math.abs(this.blurYFilter.strength);
		if (i && s) {
			const i = e.getFilterTexture();
			this.blurXFilter.apply(e, t, i, Ll.CLEAR), this.blurYFilter.apply(e, i, n, r), e.returnFilterTexture(i);
		} else s ? this.blurYFilter.apply(e, t, n, r) : this.blurXFilter.apply(e, t, n, r);
	}
	updatePadding() {
		this._repeatEdgePixels ? (this.padding = 0) : (this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)));
	}
	get blur() {
		return this.blurXFilter.blur;
	}
	set blur(e) {
		(this.blurXFilter.blur = this.blurYFilter.blur = e), this.updatePadding();
	}
	get quality() {
		return this.blurXFilter.quality;
	}
	set quality(e) {
		this.blurXFilter.quality = this.blurYFilter.quality = e;
	}
	get blurX() {
		return this.blurXFilter.blur;
	}
	set blurX(e) {
		(this.blurXFilter.blur = e), this.updatePadding();
	}
	get blurY() {
		return this.blurYFilter.blur;
	}
	set blurY(e) {
		(this.blurYFilter.blur = e), this.updatePadding();
	}
	get blendMode() {
		return this.blurYFilter.blendMode;
	}
	set blendMode(e) {
		this.blurYFilter.blendMode = e;
	}
	get repeatEdgePixels() {
		return this._repeatEdgePixels;
	}
	set repeatEdgePixels(e) {
		(this._repeatEdgePixels = e), this.updatePadding();
	}
}
class Lm extends Kd {
	constructor() {
		const e = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 };
		super(
			gf,
			"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n        vec4 c = texture2D(uSampler, vTextureCoord);\n\n        if (uAlpha == 0.0) {\n                gl_FragColor = c;\n                return;\n        }\n\n        // Un-premultiply alpha before applying the color matrix. See issue #3539.\n        if (c.a > 0.0) {\n            c.rgb /= c.a;\n        }\n\n        vec4 result;\n\n        result.r = (m[0] * c.r);\n                result.r += (m[1] * c.g);\n                result.r += (m[2] * c.b);\n                result.r += (m[3] * c.a);\n                result.r += m[4];\n\n        result.g = (m[5] * c.r);\n                result.g += (m[6] * c.g);\n                result.g += (m[7] * c.b);\n                result.g += (m[8] * c.a);\n                result.g += m[9];\n\n        result.b = (m[10] * c.r);\n             result.b += (m[11] * c.g);\n             result.b += (m[12] * c.b);\n             result.b += (m[13] * c.a);\n             result.b += m[14];\n\n        result.a = (m[15] * c.r);\n             result.a += (m[16] * c.g);\n             result.a += (m[17] * c.b);\n             result.a += (m[18] * c.a);\n             result.a += m[19];\n\n        vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n        // Premultiply alpha again.\n        rgb *= result.a;\n\n        gl_FragColor = vec4(rgb, result.a);\n}\n",
			e
		),
			(this.alpha = 1);
	}
	_loadMatrix(e, t = !1) {
		let n = e;
		t && (this._multiply(n, this.uniforms.m, e), (n = this._colorMatrix(n))), (this.uniforms.m = n);
	}
	_multiply(e, t, n) {
		return (
			(e[0] = t[0] * n[0] + t[1] * n[5] + t[2] * n[10] + t[3] * n[15]),
			(e[1] = t[0] * n[1] + t[1] * n[6] + t[2] * n[11] + t[3] * n[16]),
			(e[2] = t[0] * n[2] + t[1] * n[7] + t[2] * n[12] + t[3] * n[17]),
			(e[3] = t[0] * n[3] + t[1] * n[8] + t[2] * n[13] + t[3] * n[18]),
			(e[4] = t[0] * n[4] + t[1] * n[9] + t[2] * n[14] + t[3] * n[19] + t[4]),
			(e[5] = t[5] * n[0] + t[6] * n[5] + t[7] * n[10] + t[8] * n[15]),
			(e[6] = t[5] * n[1] + t[6] * n[6] + t[7] * n[11] + t[8] * n[16]),
			(e[7] = t[5] * n[2] + t[6] * n[7] + t[7] * n[12] + t[8] * n[17]),
			(e[8] = t[5] * n[3] + t[6] * n[8] + t[7] * n[13] + t[8] * n[18]),
			(e[9] = t[5] * n[4] + t[6] * n[9] + t[7] * n[14] + t[8] * n[19] + t[9]),
			(e[10] = t[10] * n[0] + t[11] * n[5] + t[12] * n[10] + t[13] * n[15]),
			(e[11] = t[10] * n[1] + t[11] * n[6] + t[12] * n[11] + t[13] * n[16]),
			(e[12] = t[10] * n[2] + t[11] * n[7] + t[12] * n[12] + t[13] * n[17]),
			(e[13] = t[10] * n[3] + t[11] * n[8] + t[12] * n[13] + t[13] * n[18]),
			(e[14] = t[10] * n[4] + t[11] * n[9] + t[12] * n[14] + t[13] * n[19] + t[14]),
			(e[15] = t[15] * n[0] + t[16] * n[5] + t[17] * n[10] + t[18] * n[15]),
			(e[16] = t[15] * n[1] + t[16] * n[6] + t[17] * n[11] + t[18] * n[16]),
			(e[17] = t[15] * n[2] + t[16] * n[7] + t[17] * n[12] + t[18] * n[17]),
			(e[18] = t[15] * n[3] + t[16] * n[8] + t[17] * n[13] + t[18] * n[18]),
			(e[19] = t[15] * n[4] + t[16] * n[9] + t[17] * n[14] + t[18] * n[19] + t[19]),
			e
		);
	}
	_colorMatrix(e) {
		const t = new Float32Array(e);
		return (t[4] /= 255), (t[9] /= 255), (t[14] /= 255), (t[19] /= 255), t;
	}
	brightness(e, t) {
		const n = [e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(n, t);
	}
	tint(e, t) {
		const [n, r, i] = Wc.shared.setValue(e).toArray(),
			s = [n, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(s, t);
	}
	greyscale(e, t) {
		const n = [e, e, e, 0, 0, e, e, e, 0, 0, e, e, e, 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(n, t);
	}
	blackAndWhite(e) {
		this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], e);
	}
	hue(e, t) {
		e = ((e || 0) / 180) * Math.PI;
		const n = Math.cos(e),
			r = Math.sin(e),
			i = 1 / 3,
			s = (0, Math.sqrt)(i),
			o = [n + (1 - n) * i, i * (1 - n) - s * r, i * (1 - n) + s * r, 0, 0, i * (1 - n) + s * r, n + i * (1 - n), i * (1 - n) - s * r, 0, 0, i * (1 - n) - s * r, i * (1 - n) + s * r, n + i * (1 - n), 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(o, t);
	}
	contrast(e, t) {
		const n = (e || 0) + 1,
			r = -0.5 * (n - 1),
			i = [n, 0, 0, 0, r, 0, n, 0, 0, r, 0, 0, n, 0, r, 0, 0, 0, 1, 0];
		this._loadMatrix(i, t);
	}
	saturate(e = 0, t) {
		const n = (2 * e) / 3 + 1,
			r = -0.5 * (n - 1),
			i = [n, r, r, 0, 0, r, n, r, 0, 0, r, r, n, 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(i, t);
	}
	desaturate() {
		this.saturate(-1);
	}
	negative(e) {
		this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], e);
	}
	sepia(e) {
		this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], e);
	}
	technicolor(e) {
		this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], e);
	}
	polaroid(e) {
		this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], e);
	}
	toBGR(e) {
		this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], e);
	}
	kodachrome(e) {
		this._loadMatrix(
			[1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0],
			e
		);
	}
	browni(e) {
		this._loadMatrix(
			[0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0],
			e
		);
	}
	vintage(e) {
		this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], e);
	}
	colorTone(e, t, n, r, i) {
		(e = e || 0.2), (t = t || 0.15), (n = n || 16770432), (r = r || 3375104);
		const s = Wc.shared,
			[o, a, l] = s.setValue(n).toArray(),
			[u, c, h] = s.setValue(r).toArray(),
			d = [0.3, 0.59, 0.11, 0, 0, o, a, l, e, 0, u, c, h, t, 0, o - u, a - c, l - h, 0, 0];
		this._loadMatrix(d, i);
	}
	night(e, t) {
		const n = [-2 * (e = e || 0.1), -e, 0, 0, 0, -e, 0, e, 0, 0, 0, e, 2 * e, 0, 0, 0, 0, 0, 1, 0];
		this._loadMatrix(n, t);
	}
	predator(e, t) {
		const n = [
			11.224130630493164 * e,
			-4.794486999511719 * e,
			-2.8746118545532227 * e,
			0 * e,
			0.40342438220977783 * e,
			-3.6330697536468506 * e,
			9.193157196044922 * e,
			-2.951810836791992 * e,
			0 * e,
			-1.316135048866272 * e,
			-3.2184197902679443 * e,
			-4.2375030517578125 * e,
			7.476448059082031 * e,
			0 * e,
			0.8044459223747253 * e,
			0,
			0,
			0,
			1,
			0
		];
		this._loadMatrix(n, t);
	}
	lsd(e) {
		this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], e);
	}
	reset() {
		this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1);
	}
	get matrix() {
		return this.uniforms.m;
	}
	set matrix(e) {
		this.uniforms.m = e;
	}
	get alpha() {
		return this.uniforms.uAlpha;
	}
	set alpha(e) {
		this.uniforms.uAlpha = e;
	}
}
Lm.prototype.grayscale = Lm.prototype.greyscale;
class Om extends Kd {
	constructor(e, t) {
		const n = new sd();
		(e.renderable = !1),
			super(
				"attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)    ).xy;\n}\n",
				"varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n    vec4 map =    texture2D(mapSampler, vFilterCoord);\n\n    map -= 0.5;\n    map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n    gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n",
				{ mapSampler: e._texture, filterMatrix: n, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }
			),
			(this.maskSprite = e),
			(this.maskMatrix = n),
			null == t && (t = 20),
			(this.scale = new Jh(t, t));
	}
	apply(e, t, n, r) {
		(this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite)), (this.uniforms.scale.x = this.scale.x), (this.uniforms.scale.y = this.scale.y);
		const i = this.maskSprite.worldTransform,
			s = Math.sqrt(i.a * i.a + i.b * i.b),
			o = Math.sqrt(i.c * i.c + i.d * i.d);
		0 !== s && 0 !== o && ((this.uniforms.rotation[0] = i.a / s), (this.uniforms.rotation[1] = i.b / s), (this.uniforms.rotation[2] = i.c / o), (this.uniforms.rotation[3] = i.d / o)), e.applyFilter(this, t, n, r);
	}
	get map() {
		return this.uniforms.mapSampler;
	}
	set map(e) {
		this.uniforms.mapSampler = e;
	}
}
class Pm extends Kd {
	constructor() {
		super(
			"\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n                             out vec2 v_rgbNW, out vec2 v_rgbNE,\n                             out vec2 v_rgbSW, out vec2 v_rgbSE,\n                             out vec2 v_rgbM) {\n        v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n        v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n        v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n        v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n        v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n     gl_Position = filterVertexPosition();\n\n     vFragCoord = aVertexPosition * outputFrame.zw;\n\n     texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n",
			'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN     (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL     (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX         8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n                    vec2 v_rgbNW, vec2 v_rgbNE,\n                    vec2 v_rgbSW, vec2 v_rgbSE,\n                    vec2 v_rgbM) {\n        vec4 color;\n        vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n        vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n        vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n        vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n        vec4 texColor = texture2D(tex, v_rgbM);\n        vec3 rgbM    = texColor.xyz;\n        vec3 luma = vec3(0.299, 0.587, 0.114);\n        float lumaNW = dot(rgbNW, luma);\n        float lumaNE = dot(rgbNE, luma);\n        float lumaSW = dot(rgbSW, luma);\n        float lumaSE = dot(rgbSE, luma);\n        float lumaM    = dot(rgbM,    luma);\n        float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n        float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n        mediump vec2 dir;\n        dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n        dir.y =    ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n        float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                                                    (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n        float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n        dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n                            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                                    dir * rcpDirMin)) * inverseVP;\n\n        vec3 rgbA = 0.5 * (\n                                             texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                                             texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n        vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                                                         texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                                                         texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n        float lumaB = dot(rgbB, luma);\n        if ((lumaB < lumaMin) || (lumaB > lumaMax))\n                color = vec4(rgbA, texColor.a);\n        else\n                color = vec4(rgbB, texColor.a);\n        return color;\n}\n\nvoid main() {\n\n            vec4 color;\n\n            color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n            gl_FragColor = color;\n}\n'
		);
	}
}
class Nm extends Kd {
	constructor(e = 0.5, t = Math.random()) {
		super(
			gf,
			"precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n        return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n        vec4 color = texture2D(uSampler, vTextureCoord);\n        float randomValue = rand(gl_FragCoord.xy * uSeed);\n        float diff = (randomValue - 0.5) * uNoise;\n\n        // Un-premultiply alpha before applying the color matrix. See issue #3539.\n        if (color.a > 0.0) {\n                color.rgb /= color.a;\n        }\n\n        color.r += diff;\n        color.g += diff;\n        color.b += diff;\n\n        // Premultiply alpha again.\n        color.rgb *= color.a;\n\n        gl_FragColor = color;\n}\n",
			{ uNoise: 0, uSeed: 0 }
		),
			(this.noise = e),
			(this.seed = t);
	}
	get noise() {
		return this.uniforms.uNoise;
	}
	set noise(e) {
		this.uniforms.uNoise = e;
	}
	get seed() {
		return this.uniforms.uSeed;
	}
	set seed(e) {
		this.uniforms.uSeed = e;
	}
}
const Dm = { AlphaFilter: km, BlurFilter: Rm, BlurFilterPass: Im, ColorMatrixFilter: Lm, DisplacementFilter: Om, FXAAFilter: Pm, NoiseFilter: Nm };
Object.entries(Dm).forEach(([e, t]) => {
	Object.defineProperty(Dm, e, { get: () => (fc("7.1.0", `filters.${e} has moved to ${e}`), t) });
});
const Bm = new (class {
	constructor() {
		(this.interactionFrequency = 10), (this._deltaTime = 0), (this._didMove = !1), (this.tickerAdded = !1), (this._pauseUpdate = !0);
	}
	init(e) {
		this.removeTickerListener(), (this.events = e), (this.interactionFrequency = 10), (this._deltaTime = 0), (this._didMove = !1), (this.tickerAdded = !1), (this._pauseUpdate = !0);
	}
	get pauseUpdate() {
		return this._pauseUpdate;
	}
	set pauseUpdate(e) {
		this._pauseUpdate = e;
	}
	addTickerListener() {
		!this.tickerAdded && this.domElement && (df.system.add(this.tickerUpdate, this, uf.INTERACTION), (this.tickerAdded = !0));
	}
	removeTickerListener() {
		this.tickerAdded && (df.system.remove(this.tickerUpdate, this), (this.tickerAdded = !1));
	}
	pointerMoved() {
		this._didMove = !0;
	}
	update() {
		if (!this.domElement || this._pauseUpdate) return;
		if (this._didMove) return void (this._didMove = !1);
		const e = this.events.rootPointerEvent;
		(this.events.supportsTouchEvents && "touch" === e.pointerType) || globalThis.document.dispatchEvent(new PointerEvent("pointermove", { clientX: e.clientX, clientY: e.clientY }));
	}
	tickerUpdate(e) {
		(this._deltaTime += e), this._deltaTime < this.interactionFrequency || ((this._deltaTime = 0), this.update());
	}
})();
class Fm {
	constructor(e) {
		(this.bubbles = !0),
			(this.cancelBubble = !0),
			(this.cancelable = !1),
			(this.composed = !1),
			(this.defaultPrevented = !1),
			(this.eventPhase = Fm.prototype.NONE),
			(this.propagationStopped = !1),
			(this.propagationImmediatelyStopped = !1),
			(this.layer = new Jh()),
			(this.page = new Jh()),
			(this.NONE = 0),
			(this.CAPTURING_PHASE = 1),
			(this.AT_TARGET = 2),
			(this.BUBBLING_PHASE = 3),
			(this.manager = e);
	}
	get layerX() {
		return this.layer.x;
	}
	get layerY() {
		return this.layer.y;
	}
	get pageX() {
		return this.page.x;
	}
	get pageY() {
		return this.page.y;
	}
	get data() {
		return this;
	}
	composedPath() {
		return !this.manager || (this.path && this.path[this.path.length - 1] === this.target) || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
	}
	initEvent(e, t, n) {
		throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
	}
	initUIEvent(e, t, n, r, i) {
		throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
	}
	preventDefault() {
		this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), (this.defaultPrevented = !0);
	}
	stopImmediatePropagation() {
		this.propagationImmediatelyStopped = !0;
	}
	stopPropagation() {
		this.propagationStopped = !0;
	}
}
class Hm extends Fm {
	constructor() {
		super(...arguments), (this.client = new Jh()), (this.movement = new Jh()), (this.offset = new Jh()), (this.global = new Jh()), (this.screen = new Jh());
	}
	get clientX() {
		return this.client.x;
	}
	get clientY() {
		return this.client.y;
	}
	get x() {
		return this.clientX;
	}
	get y() {
		return this.clientY;
	}
	get movementX() {
		return this.movement.x;
	}
	get movementY() {
		return this.movement.y;
	}
	get offsetX() {
		return this.offset.x;
	}
	get offsetY() {
		return this.offset.y;
	}
	get globalX() {
		return this.global.x;
	}
	get globalY() {
		return this.global.y;
	}
	get screenX() {
		return this.screen.x;
	}
	get screenY() {
		return this.screen.y;
	}
	getLocalPosition(e, t, n) {
		return e.worldTransform.applyInverse(n || this.global, t);
	}
	getModifierState(e) {
		return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e);
	}
	initMouseEvent(e, t, n, r, i, s, o, a, l, u, c, h, d, p, f) {
		throw new Error("Method not implemented.");
	}
}
class Vm extends Hm {
	constructor() {
		super(...arguments), (this.width = 0), (this.height = 0), (this.isPrimary = !1);
	}
	getCoalescedEvents() {
		return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
	}
	getPredictedEvents() {
		throw new Error("getPredictedEvents is not supported!");
	}
}
class Um extends Hm {
	constructor() {
		super(...arguments), (this.DOM_DELTA_PIXEL = 0), (this.DOM_DELTA_LINE = 1), (this.DOM_DELTA_PAGE = 2);
	}
}
(Um.DOM_DELTA_PIXEL = 0), (Um.DOM_DELTA_LINE = 1), (Um.DOM_DELTA_PAGE = 2);
const zm = new Jh(),
	$m = new Jh();
class jm {
	constructor(e) {
		(this.dispatch = new lu()),
			(this.moveOnAll = !1),
			(this.enableGlobalMoveEvents = !0),
			(this.mappingState = { trackingData: {} }),
			(this.eventPool = new Map()),
			(this._allInteractiveElements = []),
			(this._hitElements = []),
			(this._isPointerMoveEvent = !1),
			(this.rootTarget = e),
			(this.hitPruneFn = this.hitPruneFn.bind(this)),
			(this.hitTestFn = this.hitTestFn.bind(this)),
			(this.mapPointerDown = this.mapPointerDown.bind(this)),
			(this.mapPointerMove = this.mapPointerMove.bind(this)),
			(this.mapPointerOut = this.mapPointerOut.bind(this)),
			(this.mapPointerOver = this.mapPointerOver.bind(this)),
			(this.mapPointerUp = this.mapPointerUp.bind(this)),
			(this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
			(this.mapWheel = this.mapWheel.bind(this)),
			(this.mappingTable = {}),
			this.addEventMapping("pointerdown", this.mapPointerDown),
			this.addEventMapping("pointermove", this.mapPointerMove),
			this.addEventMapping("pointerout", this.mapPointerOut),
			this.addEventMapping("pointerleave", this.mapPointerOut),
			this.addEventMapping("pointerover", this.mapPointerOver),
			this.addEventMapping("pointerup", this.mapPointerUp),
			this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
			this.addEventMapping("wheel", this.mapWheel);
	}
	addEventMapping(e, t) {
		this.mappingTable[e] || (this.mappingTable[e] = []), this.mappingTable[e].push({ fn: t, priority: 0 }), this.mappingTable[e].sort((e, t) => e.priority - t.priority);
	}
	dispatchEvent(e, t) {
		(e.propagationStopped = !1), (e.propagationImmediatelyStopped = !1), this.propagate(e, t), this.dispatch.emit(t || e.type, e);
	}
	mapEvent(e) {
		if (!this.rootTarget) return;
		const t = this.mappingTable[e.type];
		if (t) for (let n = 0, r = t.length; n < r; n++) t[n].fn(e);
		else console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
	}
	hitTest(e, t) {
		Bm.pauseUpdate = !0;
		const n = this[this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, zm.set(e, t), this.hitTestFn, this.hitPruneFn);
		return n && n[0];
	}
	propagate(e, t) {
		if (!e.target) return;
		const n = e.composedPath();
		e.eventPhase = e.CAPTURING_PHASE;
		for (let r = 0, i = n.length - 1; r < i; r++) if (((e.currentTarget = n[r]), this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped)) return;
		if (((e.eventPhase = e.AT_TARGET), (e.currentTarget = e.target), this.notifyTarget(e, t), !e.propagationStopped && !e.propagationImmediatelyStopped)) {
			e.eventPhase = e.BUBBLING_PHASE;
			for (let r = n.length - 2; r >= 0; r--) if (((e.currentTarget = n[r]), this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped)) return;
		}
	}
	all(e, t, n = this._allInteractiveElements) {
		if (0 === n.length) return;
		e.eventPhase = e.BUBBLING_PHASE;
		const r = Array.isArray(t) ? t : [t];
		for (let i = n.length - 1; i >= 0; i--)
			r.forEach((t) => {
				(e.currentTarget = n[i]), this.notifyTarget(e, t);
			});
	}
	propagationPath(e) {
		const t = [e];
		for (let n = 0; n < 2048 && e !== this.rootTarget; n++) {
			if (!e.parent) throw new Error("Cannot find propagation path to disconnected target");
			t.push(e.parent), (e = e.parent);
		}
		return t.reverse(), t;
	}
	hitTestMoveRecursive(e, t, n, r, i, s = !1) {
		let o = !1;
		if (this._interactivePrune(e)) return null;
		if ((("dynamic" !== e.eventMode && "dynamic" !== t) || (Bm.pauseUpdate = !1), e.interactiveChildren && e.children)) {
			const a = e.children;
			for (let l = a.length - 1; l >= 0; l--) {
				const u = a[l],
					c = this.hitTestMoveRecursive(u, this._isInteractive(t) ? t : u.eventMode, n, r, i, s || i(e, n));
				if (c) {
					if (c.length > 0 && !c[c.length - 1].parent) continue;
					const t = e.isInteractive();
					(c.length > 0 || t) && (t && this._allInteractiveElements.push(e), c.push(e)), 0 === this._hitElements.length && (this._hitElements = c), (o = !0);
				}
			}
		}
		const a = this._isInteractive(t),
			l = e.isInteractive();
		return l && l && this._allInteractiveElements.push(e), s || this._hitElements.length > 0 ? null : o ? this._hitElements : a && !i(e, n) && r(e, n) ? (l ? [e] : []) : null;
	}
	hitTestRecursive(e, t, n, r, i) {
		if (this._interactivePrune(e) || i(e, n)) return null;
		if ((("dynamic" !== e.eventMode && "dynamic" !== t) || (Bm.pauseUpdate = !1), e.interactiveChildren && e.children)) {
			const s = e.children;
			for (let o = s.length - 1; o >= 0; o--) {
				const a = s[o],
					l = this.hitTestRecursive(a, this._isInteractive(t) ? t : a.eventMode, n, r, i);
				if (l) {
					if (l.length > 0 && !l[l.length - 1].parent) continue;
					const t = e.isInteractive();
					return (l.length > 0 || t) && l.push(e), l;
				}
			}
		}
		const s = this._isInteractive(t),
			o = e.isInteractive();
		return s && r(e, n) ? (o ? [e] : []) : null;
	}
	_isInteractive(e) {
		return "static" === e || "dynamic" === e;
	}
	_interactivePrune(e) {
		return !(e && !e.isMask && e.visible && e.renderable) || "none" === e.eventMode || ("passive" === e.eventMode && !e.interactiveChildren) || !!e.isMask;
	}
	hitPruneFn(e, t) {
		var n;
		if (e.hitArea && (e.worldTransform.applyInverse(t, $m), !e.hitArea.contains($m.x, $m.y))) return !0;
		if (e._mask) {
			const r = e._mask.isMaskData ? e._mask.maskObject : e._mask;
			if (r && !(null == (n = r.containsPoint) ? void 0 : n.call(r, t))) return !0;
		}
		return !1;
	}
	hitTestFn(e, t) {
		return "passive" !== e.eventMode && (!!e.hitArea || (!!e.containsPoint && e.containsPoint(t)));
	}
	notifyTarget(e, t) {
		var n, r;
		const i = `on${(t = null != t ? t : e.type)}`;
		null == (r = (n = e.currentTarget)[i]) || r.call(n, e);
		const s = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t;
		this.notifyListeners(e, s), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, t);
	}
	mapPointerDown(e) {
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		const t = this.createPointerEvent(e);
		if ((this.dispatchEvent(t, "pointerdown"), "touch" === t.pointerType)) this.dispatchEvent(t, "touchstart");
		else if ("mouse" === t.pointerType || "pen" === t.pointerType) {
			const e = 2 === t.button;
			this.dispatchEvent(t, e ? "rightdown" : "mousedown");
		}
		(this.trackingData(e.pointerId).pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t);
	}
	mapPointerMove(e) {
		var t, n, r;
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		(this._allInteractiveElements.length = 0), (this._hitElements.length = 0), (this._isPointerMoveEvent = !0);
		const i = this.createPointerEvent(e);
		this._isPointerMoveEvent = !1;
		const s = "mouse" === i.pointerType || "pen" === i.pointerType,
			o = this.trackingData(e.pointerId),
			a = this.findMountedTarget(o.overTargets);
		if ((null == (t = o.overTargets) ? void 0 : t.length) > 0 && a !== i.target) {
			const t = "mousemove" === e.type ? "mouseout" : "pointerout",
				n = this.createPointerEvent(e, t, a);
			if ((this.dispatchEvent(n, "pointerout"), s && this.dispatchEvent(n, "mouseout"), !i.composedPath().includes(a))) {
				const t = this.createPointerEvent(e, "pointerleave", a);
				for (t.eventPhase = t.AT_TARGET; t.target && !i.composedPath().includes(t.target); ) (t.currentTarget = t.target), this.notifyTarget(t), s && this.notifyTarget(t, "mouseleave"), (t.target = t.target.parent);
				this.freeEvent(t);
			}
			this.freeEvent(n);
		}
		if (a !== i.target) {
			const t = "mousemove" === e.type ? "mouseover" : "pointerover",
				n = this.clonePointerEvent(i, t);
			this.dispatchEvent(n, "pointerover"), s && this.dispatchEvent(n, "mouseover");
			let r = null == a ? void 0 : a.parent;
			for (; r && r !== this.rootTarget.parent && r !== i.target; ) r = r.parent;
			if (!r || r === this.rootTarget.parent) {
				const e = this.clonePointerEvent(i, "pointerenter");
				for (e.eventPhase = e.AT_TARGET; e.target && e.target !== a && e.target !== this.rootTarget.parent; ) (e.currentTarget = e.target), this.notifyTarget(e), s && this.notifyTarget(e, "mouseenter"), (e.target = e.target.parent);
				this.freeEvent(e);
			}
			this.freeEvent(n);
		}
		const l = [],
			u = null == (n = this.enableGlobalMoveEvents) || n;
		this.moveOnAll ? l.push("pointermove") : this.dispatchEvent(i, "pointermove"),
			u && l.push("globalpointermove"),
			"touch" === i.pointerType && (this.moveOnAll ? l.splice(1, 0, "touchmove") : this.dispatchEvent(i, "touchmove"), u && l.push("globaltouchmove")),
			s && (this.moveOnAll ? l.splice(1, 0, "mousemove") : this.dispatchEvent(i, "mousemove"), u && l.push("globalmousemove"), (this.cursor = null == (r = i.target) ? void 0 : r.cursor)),
			l.length > 0 && this.all(i, l),
			(this._allInteractiveElements.length = 0),
			(this._hitElements.length = 0),
			(o.overTargets = i.composedPath()),
			this.freeEvent(i);
	}
	mapPointerOver(e) {
		var t;
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		const n = this.trackingData(e.pointerId),
			r = this.createPointerEvent(e),
			i = "mouse" === r.pointerType || "pen" === r.pointerType;
		this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"), "mouse" === r.pointerType && (this.cursor = null == (t = r.target) ? void 0 : t.cursor);
		const s = this.clonePointerEvent(r, "pointerenter");
		for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; ) (s.currentTarget = s.target), this.notifyTarget(s), i && this.notifyTarget(s, "mouseenter"), (s.target = s.target.parent);
		(n.overTargets = r.composedPath()), this.freeEvent(r), this.freeEvent(s);
	}
	mapPointerOut(e) {
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		const t = this.trackingData(e.pointerId);
		if (t.overTargets) {
			const n = "mouse" === e.pointerType || "pen" === e.pointerType,
				r = this.findMountedTarget(t.overTargets),
				i = this.createPointerEvent(e, "pointerout", r);
			this.dispatchEvent(i), n && this.dispatchEvent(i, "mouseout");
			const s = this.createPointerEvent(e, "pointerleave", r);
			for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent; ) (s.currentTarget = s.target), this.notifyTarget(s), n && this.notifyTarget(s, "mouseleave"), (s.target = s.target.parent);
			(t.overTargets = null), this.freeEvent(i), this.freeEvent(s);
		}
		this.cursor = null;
	}
	mapPointerUp(e) {
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		const t = performance.now(),
			n = this.createPointerEvent(e);
		if ((this.dispatchEvent(n, "pointerup"), "touch" === n.pointerType)) this.dispatchEvent(n, "touchend");
		else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
			const e = 2 === n.button;
			this.dispatchEvent(n, e ? "rightup" : "mouseup");
		}
		const r = this.trackingData(e.pointerId),
			i = this.findMountedTarget(r.pressTargetsByButton[e.button]);
		let s = i;
		if (i && !n.composedPath().includes(i)) {
			let t = i;
			for (; t && !n.composedPath().includes(t); ) {
				if (((n.currentTarget = t), this.notifyTarget(n, "pointerupoutside"), "touch" === n.pointerType)) this.notifyTarget(n, "touchendoutside");
				else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
					const e = 2 === n.button;
					this.notifyTarget(n, e ? "rightupoutside" : "mouseupoutside");
				}
				t = t.parent;
			}
			delete r.pressTargetsByButton[e.button], (s = t);
		}
		if (s) {
			const i = this.clonePointerEvent(n, "click");
			(i.target = s), (i.path = null), r.clicksByButton[e.button] || (r.clicksByButton[e.button] = { clickCount: 0, target: i.target, timeStamp: t });
			const o = r.clicksByButton[e.button];
			if ((o.target === i.target && t - o.timeStamp < 200 ? ++o.clickCount : (o.clickCount = 1), (o.target = i.target), (o.timeStamp = t), (i.detail = o.clickCount), "mouse" === i.pointerType)) {
				const e = 2 === i.button;
				this.dispatchEvent(i, e ? "rightclick" : "click");
			} else "touch" === i.pointerType && this.dispatchEvent(i, "tap");
			this.dispatchEvent(i, "pointertap"), this.freeEvent(i);
		}
		this.freeEvent(n);
	}
	mapPointerUpOutside(e) {
		if (!(e instanceof Vm)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
		const t = this.trackingData(e.pointerId),
			n = this.findMountedTarget(t.pressTargetsByButton[e.button]),
			r = this.createPointerEvent(e);
		if (n) {
			let i = n;
			for (; i; )
				(r.currentTarget = i), this.notifyTarget(r, "pointerupoutside"), "touch" === r.pointerType ? this.notifyTarget(r, "touchendoutside") : ("mouse" !== r.pointerType && "pen" !== r.pointerType) || this.notifyTarget(r, 2 === r.button ? "rightupoutside" : "mouseupoutside"), (i = i.parent);
			delete t.pressTargetsByButton[e.button];
		}
		this.freeEvent(r);
	}
	mapWheel(e) {
		if (!(e instanceof Um)) return void console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
		const t = this.createWheelEvent(e);
		this.dispatchEvent(t), this.freeEvent(t);
	}
	findMountedTarget(e) {
		if (!e) return null;
		let t = e[0];
		for (let n = 1; n < e.length && e[n].parent === t; n++) t = e[n];
		return t;
	}
	createPointerEvent(e, t, n) {
		var r;
		const i = this.allocateEvent(Vm);
		return this.copyPointerData(e, i), this.copyMouseData(e, i), this.copyData(e, i), (i.nativeEvent = e.nativeEvent), (i.originalEvent = e), (i.target = null != (r = null != n ? n : this.hitTest(i.global.x, i.global.y)) ? r : this._hitElements[0]), "string" == typeof t && (i.type = t), i;
	}
	createWheelEvent(e) {
		const t = this.allocateEvent(Um);
		return this.copyWheelData(e, t), this.copyMouseData(e, t), this.copyData(e, t), (t.nativeEvent = e.nativeEvent), (t.originalEvent = e), (t.target = this.hitTest(t.global.x, t.global.y)), t;
	}
	clonePointerEvent(e, t) {
		const n = this.allocateEvent(Vm);
		return (n.nativeEvent = e.nativeEvent), (n.originalEvent = e.originalEvent), this.copyPointerData(e, n), this.copyMouseData(e, n), this.copyData(e, n), (n.target = e.target), (n.path = e.composedPath().slice()), (n.type = null != t ? t : n.type), n;
	}
	copyWheelData(e, t) {
		(t.deltaMode = e.deltaMode), (t.deltaX = e.deltaX), (t.deltaY = e.deltaY), (t.deltaZ = e.deltaZ);
	}
	copyPointerData(e, t) {
		e instanceof Vm &&
			t instanceof Vm &&
			((t.pointerId = e.pointerId), (t.width = e.width), (t.height = e.height), (t.isPrimary = e.isPrimary), (t.pointerType = e.pointerType), (t.pressure = e.pressure), (t.tangentialPressure = e.tangentialPressure), (t.tiltX = e.tiltX), (t.tiltY = e.tiltY), (t.twist = e.twist));
	}
	copyMouseData(e, t) {
		e instanceof Hm &&
			t instanceof Hm &&
			((t.altKey = e.altKey), (t.button = e.button), (t.buttons = e.buttons), t.client.copyFrom(e.client), (t.ctrlKey = e.ctrlKey), (t.metaKey = e.metaKey), t.movement.copyFrom(e.movement), t.screen.copyFrom(e.screen), (t.shiftKey = e.shiftKey), t.global.copyFrom(e.global));
	}
	copyData(e, t) {
		(t.isTrusted = e.isTrusted), (t.srcElement = e.srcElement), (t.timeStamp = performance.now()), (t.type = e.type), (t.detail = e.detail), (t.view = e.view), (t.which = e.which), t.layer.copyFrom(e.layer), t.page.copyFrom(e.page);
	}
	trackingData(e) {
		return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[e];
	}
	allocateEvent(e) {
		this.eventPool.has(e) || this.eventPool.set(e, []);
		const t = this.eventPool.get(e).pop() || new e(this);
		return (t.eventPhase = t.NONE), (t.currentTarget = null), (t.path = null), (t.target = null), t;
	}
	freeEvent(e) {
		if (e.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
		const t = e.constructor;
		this.eventPool.has(t) || this.eventPool.set(t, []), this.eventPool.get(t).push(e);
	}
	notifyListeners(e, t) {
		const n = e.currentTarget._events[t];
		if (n && e.currentTarget.isInteractive())
			if ("fn" in n) n.once && e.currentTarget.removeListener(t, n.fn, void 0, !0), n.fn.call(n.context, e);
			else for (let r = 0, i = n.length; r < i && !e.propagationImmediatelyStopped; r++) n[r].once && e.currentTarget.removeListener(t, n[r].fn, void 0, !0), n[r].fn.call(n[r].context, e);
	}
}
const Wm = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" },
	Gm = class {
		constructor(e) {
			(this.supportsTouchEvents = "ontouchstart" in globalThis),
				(this.supportsPointerEvents = !!globalThis.PointerEvent),
				(this.domElement = null),
				(this.resolution = 1),
				(this.renderer = e),
				(this.rootBoundary = new jm(null)),
				Bm.init(this),
				(this.autoPreventDefault = !0),
				(this.eventsAdded = !1),
				(this.rootPointerEvent = new Vm(null)),
				(this.rootWheelEvent = new Um(null)),
				(this.cursorStyles = { default: "inherit", pointer: "pointer" }),
				(this.features = new Proxy(u({}, Gm.defaultEventFeatures), { set: (e, t, n) => ("globalMove" === t && (this.rootBoundary.enableGlobalMoveEvents = n), (e[t] = n), !0) })),
				(this.onPointerDown = this.onPointerDown.bind(this)),
				(this.onPointerMove = this.onPointerMove.bind(this)),
				(this.onPointerUp = this.onPointerUp.bind(this)),
				(this.onPointerOverOut = this.onPointerOverOut.bind(this)),
				(this.onWheel = this.onWheel.bind(this));
		}
		static get defaultEventMode() {
			return this._defaultEventMode;
		}
		init(e) {
			var t, n;
			const { view: r, resolution: i } = this.renderer;
			this.setTargetElement(r), (this.resolution = i), (Gm._defaultEventMode = null != (t = e.eventMode) ? t : "auto"), Object.assign(this.features, null != (n = e.eventFeatures) ? n : {}), (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove);
		}
		resolutionChange(e) {
			this.resolution = e;
		}
		destroy() {
			this.setTargetElement(null), (this.renderer = null);
		}
		setCursor(e) {
			e = e || "default";
			let t = !0;
			if ((globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1), this.currentCursor === e)) return;
			this.currentCursor = e;
			const n = this.cursorStyles[e];
			if (n)
				switch (typeof n) {
					case "string":
						t && (this.domElement.style.cursor = n);
						break;
					case "function":
						n(e);
						break;
					case "object":
						t && Object.assign(this.domElement.style, n);
				}
			else t && "string" == typeof e && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e);
		}
		get pointer() {
			return this.rootPointerEvent;
		}
		onPointerDown(e) {
			if (!this.features.click) return;
			if (((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.supportsTouchEvents && "touch" === e.pointerType)) return;
			const t = this.normalizeToPointerData(e);
			if (this.autoPreventDefault && t[0].isNormalized) {
				(e.cancelable || !("cancelable" in e)) && e.preventDefault();
			}
			for (let n = 0, r = t.length; n < r; n++) {
				const e = t[n],
					r = this.bootstrapEvent(this.rootPointerEvent, e);
				this.rootBoundary.mapEvent(r);
			}
			this.setCursor(this.rootBoundary.cursor);
		}
		onPointerMove(e) {
			if (!this.features.move) return;
			if (((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.supportsTouchEvents && "touch" === e.pointerType)) return;
			Bm.pointerMoved();
			const t = this.normalizeToPointerData(e);
			for (let n = 0, r = t.length; n < r; n++) {
				const e = this.bootstrapEvent(this.rootPointerEvent, t[n]);
				this.rootBoundary.mapEvent(e);
			}
			this.setCursor(this.rootBoundary.cursor);
		}
		onPointerUp(e) {
			if (!this.features.click) return;
			if (((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.supportsTouchEvents && "touch" === e.pointerType)) return;
			let t = e.target;
			e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
			const n = t !== this.domElement ? "outside" : "",
				r = this.normalizeToPointerData(e);
			for (let i = 0, s = r.length; i < s; i++) {
				const e = this.bootstrapEvent(this.rootPointerEvent, r[i]);
				(e.type += n), this.rootBoundary.mapEvent(e);
			}
			this.setCursor(this.rootBoundary.cursor);
		}
		onPointerOverOut(e) {
			if (!this.features.click) return;
			if (((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.supportsTouchEvents && "touch" === e.pointerType)) return;
			const t = this.normalizeToPointerData(e);
			for (let n = 0, r = t.length; n < r; n++) {
				const e = this.bootstrapEvent(this.rootPointerEvent, t[n]);
				this.rootBoundary.mapEvent(e);
			}
			this.setCursor(this.rootBoundary.cursor);
		}
		onWheel(e) {
			if (!this.features.wheel) return;
			const t = this.normalizeWheelEvent(e);
			(this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.rootBoundary.mapEvent(t);
		}
		setTargetElement(e) {
			this.removeEvents(), (this.domElement = e), (Bm.domElement = e), this.addEvents();
		}
		addEvents() {
			if (this.eventsAdded || !this.domElement) return;
			Bm.addTickerListener();
			const e = this.domElement.style;
			e && (globalThis.navigator.msPointerEnabled ? ((e.msContentZooming = "none"), (e.msTouchAction = "none")) : this.supportsPointerEvents && (e.touchAction = "none")),
				this.supportsPointerEvents
					? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
					  this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
					  this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
					  this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
					  globalThis.addEventListener("pointerup", this.onPointerUp, !0))
					: (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
					  this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
					  this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
					  this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
					  globalThis.addEventListener("mouseup", this.onPointerUp, !0)),
				this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)),
				this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }),
				(this.eventsAdded = !0);
		}
		removeEvents() {
			if (!this.eventsAdded || !this.domElement) return;
			Bm.removeTickerListener();
			const e = this.domElement.style;
			globalThis.navigator.msPointerEnabled ? ((e.msContentZooming = ""), (e.msTouchAction = "")) : this.supportsPointerEvents && (e.touchAction = ""),
				this.supportsPointerEvents
					? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
					  this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
					  this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
					  this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
					  globalThis.removeEventListener("pointerup", this.onPointerUp, !0))
					: (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
					  this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
					  this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
					  this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
					  globalThis.removeEventListener("mouseup", this.onPointerUp, !0)),
				this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)),
				this.domElement.removeEventListener("wheel", this.onWheel, !0),
				(this.domElement = null),
				(this.eventsAdded = !1);
		}
		mapPositionToPoint(e, t, n) {
			let r;
			r = this.domElement.parentElement ? this.domElement.getBoundingClientRect() : { x: 0, y: 0, width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 };
			const i = 1 / this.resolution;
			(e.x = (t - r.left) * (this.domElement.width / r.width) * i), (e.y = (n - r.top) * (this.domElement.height / r.height) * i);
		}
		normalizeToPointerData(e) {
			const t = [];
			if (this.supportsTouchEvents && e instanceof TouchEvent)
				for (let n = 0, r = e.changedTouches.length; n < r; n++) {
					const r = e.changedTouches[n];
					void 0 === r.button && (r.button = 0),
						void 0 === r.buttons && (r.buttons = 1),
						void 0 === r.isPrimary && (r.isPrimary = 1 === e.touches.length && "touchstart" === e.type),
						void 0 === r.width && (r.width = r.radiusX || 1),
						void 0 === r.height && (r.height = r.radiusY || 1),
						void 0 === r.tiltX && (r.tiltX = 0),
						void 0 === r.tiltY && (r.tiltY = 0),
						void 0 === r.pointerType && (r.pointerType = "touch"),
						void 0 === r.pointerId && (r.pointerId = r.identifier || 0),
						void 0 === r.pressure && (r.pressure = r.force || 0.5),
						void 0 === r.twist && (r.twist = 0),
						void 0 === r.tangentialPressure && (r.tangentialPressure = 0),
						void 0 === r.layerX && (r.layerX = r.offsetX = r.clientX),
						void 0 === r.layerY && (r.layerY = r.offsetY = r.clientY),
						(r.isNormalized = !0),
						(r.type = e.type),
						t.push(r);
				}
			else if (globalThis.MouseEvent && (!(e instanceof MouseEvent) || (this.supportsPointerEvents && e instanceof globalThis.PointerEvent))) t.push(e);
			else {
				const n = e;
				void 0 === n.isPrimary && (n.isPrimary = !0),
					void 0 === n.width && (n.width = 1),
					void 0 === n.height && (n.height = 1),
					void 0 === n.tiltX && (n.tiltX = 0),
					void 0 === n.tiltY && (n.tiltY = 0),
					void 0 === n.pointerType && (n.pointerType = "mouse"),
					void 0 === n.pointerId && (n.pointerId = 1),
					void 0 === n.pressure && (n.pressure = 0.5),
					void 0 === n.twist && (n.twist = 0),
					void 0 === n.tangentialPressure && (n.tangentialPressure = 0),
					(n.isNormalized = !0),
					t.push(n);
			}
			return t;
		}
		normalizeWheelEvent(e) {
			const t = this.rootWheelEvent;
			return (
				this.transferMouseData(t, e), (t.deltaX = e.deltaX), (t.deltaY = e.deltaY), (t.deltaZ = e.deltaZ), (t.deltaMode = e.deltaMode), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), (t.nativeEvent = e), (t.type = e.type), t
			);
		}
		bootstrapEvent(e, t) {
			return (
				(e.originalEvent = null),
				(e.nativeEvent = t),
				(e.pointerId = t.pointerId),
				(e.width = t.width),
				(e.height = t.height),
				(e.isPrimary = t.isPrimary),
				(e.pointerType = t.pointerType),
				(e.pressure = t.pressure),
				(e.tangentialPressure = t.tangentialPressure),
				(e.tiltX = t.tiltX),
				(e.tiltY = t.tiltY),
				(e.twist = t.twist),
				this.transferMouseData(e, t),
				this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
				e.global.copyFrom(e.screen),
				e.offset.copyFrom(e.screen),
				(e.isTrusted = t.isTrusted),
				"pointerleave" === e.type && (e.type = "pointerout"),
				e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")),
				e.type.startsWith("touch") && (e.type = Wm[e.type] || e.type),
				e
			);
		}
		transferMouseData(e, t) {
			(e.isTrusted = t.isTrusted),
				(e.srcElement = t.srcElement),
				(e.timeStamp = performance.now()),
				(e.type = t.type),
				(e.altKey = t.altKey),
				(e.button = t.button),
				(e.buttons = t.buttons),
				(e.client.x = t.clientX),
				(e.client.y = t.clientY),
				(e.ctrlKey = t.ctrlKey),
				(e.metaKey = t.metaKey),
				(e.movement.x = t.movementX),
				(e.movement.y = t.movementY),
				(e.page.x = t.pageX),
				(e.page.y = t.pageY),
				(e.relatedTarget = null),
				(e.shiftKey = t.shiftKey);
		}
	};
let Ym = Gm;
function Xm(e) {
	return "dynamic" === e || "static" === e;
}
(Ym.extension = { name: "events", type: [_h.RendererSystem, _h.CanvasRendererSystem] }), (Ym.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }), Sh.add(Ym);
const Km = {
	onclick: null,
	onmousedown: null,
	onmouseenter: null,
	onmouseleave: null,
	onmousemove: null,
	onglobalmousemove: null,
	onmouseout: null,
	onmouseover: null,
	onmouseup: null,
	onmouseupoutside: null,
	onpointercancel: null,
	onpointerdown: null,
	onpointerenter: null,
	onpointerleave: null,
	onpointermove: null,
	onglobalpointermove: null,
	onpointerout: null,
	onpointerover: null,
	onpointertap: null,
	onpointerup: null,
	onpointerupoutside: null,
	onrightclick: null,
	onrightdown: null,
	onrightup: null,
	onrightupoutside: null,
	ontap: null,
	ontouchcancel: null,
	ontouchend: null,
	ontouchendoutside: null,
	ontouchmove: null,
	onglobaltouchmove: null,
	ontouchstart: null,
	onwheel: null,
	_internalInteractive: void 0,
	get interactive() {
		var e;
		return null != (e = this._internalInteractive) ? e : Xm(Ym.defaultEventMode);
	},
	set interactive(e) {
		fc("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."), (this._internalInteractive = e), (this.eventMode = e ? "static" : "auto");
	},
	_internalEventMode: void 0,
	get eventMode() {
		var e;
		return null != (e = this._internalEventMode) ? e : Ym.defaultEventMode;
	},
	set eventMode(e) {
		(this._internalInteractive = Xm(e)), (this._internalEventMode = e);
	},
	isInteractive() {
		return "static" === this.eventMode || "dynamic" === this.eventMode;
	},
	interactiveChildren: !0,
	hitArea: null,
	addEventListener(e, t, n) {
		const r = "function" == typeof t ? void 0 : t;
		(e = ("boolean" == typeof n && n) || ("object" == typeof n && n.capture) ? `${e}capture` : e), (t = "function" == typeof t ? t : t.handleEvent), this.on(e, t, r);
	},
	removeEventListener(e, t, n) {
		const r = "function" == typeof t ? void 0 : t;
		(e = ("boolean" == typeof n && n) || ("object" == typeof n && n.capture) ? `${e}capture` : e), (t = "function" == typeof t ? t : t.handleEvent), this.off(e, t, r);
	},
	dispatchEvent(e) {
		if (!(e instanceof Fm)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
		return (e.defaultPrevented = !1), (e.path = null), (e.target = this), e.manager.dispatchEvent(e), !e.defaultPrevented;
	}
};
Yf.mixin(Km);
const qm = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: !0, renderId: -1 };
Yf.mixin(qm);
class Zm {
	constructor(e) {
		(this.debug = !1), (this._isActive = !1), (this._isMobileAccessibility = !1), (this.pool = []), (this.renderId = 0), (this.children = []), (this.androidUpdateCount = 0), (this.androidUpdateFrequency = 500), (this._hookDiv = null), (ou.tablet || ou.phone) && this.createTouchHook();
		const t = document.createElement("div");
		(t.style.width = "100px"),
			(t.style.height = "100px"),
			(t.style.position = "absolute"),
			(t.style.top = "0px"),
			(t.style.left = "0px"),
			(t.style.zIndex = (2).toString()),
			(this.div = t),
			(this.renderer = e),
			(this._onKeyDown = this._onKeyDown.bind(this)),
			(this._onMouseMove = this._onMouseMove.bind(this)),
			globalThis.addEventListener("keydown", this._onKeyDown, !1);
	}
	get isActive() {
		return this._isActive;
	}
	get isMobileAccessibility() {
		return this._isMobileAccessibility;
	}
	createTouchHook() {
		const e = document.createElement("button");
		(e.style.width = "1px"),
			(e.style.height = "1px"),
			(e.style.position = "absolute"),
			(e.style.top = "-1000px"),
			(e.style.left = "-1000px"),
			(e.style.zIndex = (2).toString()),
			(e.style.backgroundColor = "#FF0000"),
			(e.title = "select to enable accessibility for this content"),
			e.addEventListener("focus", () => {
				(this._isMobileAccessibility = !0), this.activate(), this.destroyTouchHook();
			}),
			document.body.appendChild(e),
			(this._hookDiv = e);
	}
	destroyTouchHook() {
		this._hookDiv && (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
	}
	activate() {
		var e;
		this._isActive ||
			((this._isActive = !0), globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), null == (e = this.renderer.view.parentNode) || e.appendChild(this.div));
	}
	deactivate() {
		var e;
		this._isActive &&
			!this._isMobileAccessibility &&
			((this._isActive = !1), globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), null == (e = this.div.parentNode) || e.removeChild(this.div));
	}
	updateAccessibleObjects(e) {
		if (!e.visible || !e.accessibleChildren) return;
		e.accessible && e.isInteractive() && (e._accessibleActive || this.addChild(e), (e.renderId = this.renderId));
		const t = e.children;
		if (t) for (let n = 0; n < t.length; n++) this.updateAccessibleObjects(t[n]);
	}
	update() {
		const e = performance.now();
		if (ou.android.device && e < this.androidUpdateCount) return;
		if (((this.androidUpdateCount = e + this.androidUpdateFrequency), !this.renderer.renderingToScreen)) return;
		this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
		const { x: t, y: n, width: r, height: i } = this.renderer.view.getBoundingClientRect(),
			{ width: s, height: o, resolution: a } = this.renderer,
			l = (r / s) * a,
			u = (i / o) * a;
		let c = this.div;
		(c.style.left = `${t}px`), (c.style.top = `${n}px`), (c.style.width = `${s}px`), (c.style.height = `${o}px`);
		for (let h = 0; h < this.children.length; h++) {
			const e = this.children[h];
			if (e.renderId !== this.renderId) (e._accessibleActive = !1), rh(this.children, h, 1), this.div.removeChild(e._accessibleDiv), this.pool.push(e._accessibleDiv), (e._accessibleDiv = null), h--;
			else {
				c = e._accessibleDiv;
				let t = e.hitArea;
				const n = e.worldTransform;
				e.hitArea
					? ((c.style.left = (n.tx + t.x * n.a) * l + "px"), (c.style.top = (n.ty + t.y * n.d) * u + "px"), (c.style.width = t.width * n.a * l + "px"), (c.style.height = t.height * n.d * u + "px"))
					: ((t = e.getBounds()),
					  this.capHitArea(t),
					  (c.style.left = t.x * l + "px"),
					  (c.style.top = t.y * u + "px"),
					  (c.style.width = t.width * l + "px"),
					  (c.style.height = t.height * u + "px"),
					  c.title !== e.accessibleTitle && null !== e.accessibleTitle && (c.title = e.accessibleTitle),
					  c.getAttribute("aria-label") !== e.accessibleHint && null !== e.accessibleHint && c.setAttribute("aria-label", e.accessibleHint)),
					(e.accessibleTitle === c.title && e.tabIndex === c.tabIndex) || ((c.title = e.accessibleTitle), (c.tabIndex = e.tabIndex), this.debug && this.updateDebugHTML(c));
			}
		}
		this.renderId++;
	}
	updateDebugHTML(e) {
		e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`;
	}
	capHitArea(e) {
		e.x < 0 && ((e.width += e.x), (e.x = 0)), e.y < 0 && ((e.height += e.y), (e.y = 0));
		const { width: t, height: n } = this.renderer;
		e.x + e.width > t && (e.width = t - e.x), e.y + e.height > n && (e.height = n - e.y);
	}
	addChild(e) {
		let t = this.pool.pop();
		t ||
			((t = document.createElement("button")),
			(t.style.width = "100px"),
			(t.style.height = "100px"),
			(t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent"),
			(t.style.position = "absolute"),
			(t.style.zIndex = (2).toString()),
			(t.style.borderStyle = "none"),
			navigator.userAgent.toLowerCase().includes("chrome") ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"),
			navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"),
			t.addEventListener("click", this._onClick.bind(this)),
			t.addEventListener("focus", this._onFocus.bind(this)),
			t.addEventListener("focusout", this._onFocusOut.bind(this))),
			(t.style.pointerEvents = e.accessiblePointerEvents),
			(t.type = e.accessibleType),
			e.accessibleTitle && null !== e.accessibleTitle ? (t.title = e.accessibleTitle) : (e.accessibleHint && null !== e.accessibleHint) || (t.title = `displayObject ${e.tabIndex}`),
			e.accessibleHint && null !== e.accessibleHint && t.setAttribute("aria-label", e.accessibleHint),
			this.debug && this.updateDebugHTML(t),
			(e._accessibleActive = !0),
			(e._accessibleDiv = t),
			(t.displayObject = e),
			this.children.push(e),
			this.div.appendChild(e._accessibleDiv),
			(e._accessibleDiv.tabIndex = e.tabIndex);
	}
	_dispatchEvent(e, t) {
		const { displayObject: n } = e.target,
			r = this.renderer.events.rootBoundary,
			i = Object.assign(new Fm(r), { target: n });
		(r.rootTarget = this.renderer.lastObjectRendered), t.forEach((e) => r.dispatchEvent(i, e));
	}
	_onClick(e) {
		this._dispatchEvent(e, ["click", "pointertap", "tap"]);
	}
	_onFocus(e) {
		e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"]);
	}
	_onFocusOut(e) {
		e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"]);
	}
	_onKeyDown(e) {
		9 === e.keyCode && this.activate();
	}
	_onMouseMove(e) {
		(0 === e.movementX && 0 === e.movementY) || this.deactivate();
	}
	destroy() {
		this.destroyTouchHook(), (this.div = null), globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), (this.pool = null), (this.children = null), (this.renderer = null);
	}
}
(Zm.extension = { name: "accessibility", type: [_h.RendererPlugin, _h.CanvasRendererPlugin] }), Sh.add(Zm);
const Jm = class {
	constructor(e) {
		(this.stage = new Jf()),
			(e = Object.assign({ forceCanvas: !1 }, e)),
			(this.renderer = mf(e)),
			Jm._plugins.forEach((t) => {
				t.init.call(this, e);
			});
	}
	render() {
		this.renderer.render(this.stage);
	}
	get view() {
		return this.renderer.view;
	}
	get screen() {
		return this.renderer.screen;
	}
	destroy(e, t) {
		const n = Jm._plugins.slice(0);
		n.reverse(),
			n.forEach((e) => {
				e.destroy.call(this);
			}),
			this.stage.destroy(t),
			(this.stage = null),
			this.renderer.destroy(e),
			(this.renderer = null);
	}
};
let Qm = Jm;
(Qm._plugins = []), Sh.handleByList(_h.Application, Qm._plugins);
class ev {
	static init(e) {
		Object.defineProperty(this, "resizeTo", {
			set(e) {
				globalThis.removeEventListener("resize", this.queueResize), (this._resizeTo = e), e && (globalThis.addEventListener("resize", this.queueResize), this.resize());
			},
			get() {
				return this._resizeTo;
			}
		}),
			(this.queueResize = () => {
				this._resizeTo && (this.cancelResize(), (this._resizeId = requestAnimationFrame(() => this.resize())));
			}),
			(this.cancelResize = () => {
				this._resizeId && (cancelAnimationFrame(this._resizeId), (this._resizeId = null));
			}),
			(this.resize = () => {
				if (!this._resizeTo) return;
				let e, t;
				if ((this.cancelResize(), this._resizeTo === globalThis.window)) (e = globalThis.innerWidth), (t = globalThis.innerHeight);
				else {
					const { clientWidth: n, clientHeight: r } = this._resizeTo;
					(e = n), (t = r);
				}
				this.renderer.resize(e, t), this.render();
			}),
			(this._resizeId = null),
			(this._resizeTo = null),
			(this.resizeTo = e.resizeTo || null);
	}
	static destroy() {
		globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), (this.cancelResize = null), (this.queueResize = null), (this.resizeTo = null), (this.resize = null);
	}
}
(ev.extension = _h.Application), Sh.add(ev);
const tv = { loader: _h.LoadParser, resolver: _h.ResolveParser, cache: _h.CacheParser, detection: _h.DetectionParser };
Sh.handle(
	_h.Asset,
	(e) => {
		const t = e.ref;
		Object.entries(tv)
			.filter(([e]) => !!t[e])
			.forEach(([e, n]) => {
				var r;
				return Sh.add(Object.assign(t[e], { extension: null != (r = t[e].extension) ? r : n }));
			});
	},
	(e) => {
		const t = e.ref;
		Object.keys(tv)
			.filter((e) => !!t[e])
			.forEach((e) => Sh.remove(t[e]));
	}
);
class nv {
	constructor(e, t = !1) {
		(this._loader = e), (this._assetList = []), (this._isLoading = !1), (this._maxConcurrent = 1), (this.verbose = t);
	}
	add(e) {
		e.forEach((e) => {
			this._assetList.push(e);
		}),
			this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
			this._isActive && !this._isLoading && this._next();
	}
	async _next() {
		if (this._assetList.length && this._isActive) {
			this._isLoading = !0;
			const e = [],
				t = Math.min(this._assetList.length, this._maxConcurrent);
			for (let n = 0; n < t; n++) e.push(this._assetList.pop());
			await this._loader.load(e), (this._isLoading = !1), this._next();
		}
	}
	get active() {
		return this._isActive;
	}
	set active(e) {
		this._isActive !== e && ((this._isActive = e), e && !this._isLoading && this._next());
	}
}
function rv(e, t) {
	if (Array.isArray(t)) {
		for (const n of t) if (e.startsWith(`data:${n}`)) return !0;
		return !1;
	}
	return e.startsWith(`data:${t}`);
}
function iv(e, t) {
	const n = e.split("?")[0],
		r = dc.extname(n).toLowerCase();
	return Array.isArray(t) ? t.includes(r) : r === t;
}
const sv = (e, t) => (Array.isArray(e) || (e = [e]), t ? e.map((e) => ("string" == typeof e ? t(e) : e)) : e),
	ov = (e, t) => {
		const n = t.split("?")[1];
		return n && (e += `?${n}`), e;
	};
function av(e, t, n, r, i) {
	const s = t[n];
	for (let o = 0; o < s.length; o++) {
		const a = s[o];
		n < t.length - 1 ? av(e.replace(r[n], a), t, n + 1, r, i) : i.push(e.replace(r[n], a));
	}
}
function lv(e) {
	const t = e.match(/\{(.*?)\}/g),
		n = [];
	if (t) {
		const r = [];
		t.forEach((e) => {
			const t = e.substring(1, e.length - 1).split(",");
			r.push(t);
		}),
			av(e, r, 0, t, n);
	} else n.push(e);
	return n;
}
const uv = (e) => !Array.isArray(e);
const cv = new (class {
	constructor() {
		(this._parsers = []), (this._cache = new Map()), (this._cacheMap = new Map());
	}
	reset() {
		this._cacheMap.clear(), this._cache.clear();
	}
	has(e) {
		return this._cache.has(e);
	}
	get(e) {
		const t = this._cache.get(e);
		return t || console.warn(`[Assets] Asset id ${e} was not found in the Cache`), t;
	}
	set(e, t) {
		const n = sv(e);
		let r;
		for (let o = 0; o < this.parsers.length; o++) {
			const e = this.parsers[o];
			if (e.test(t)) {
				r = e.getCacheableAssets(n, t);
				break;
			}
		}
		r ||
			((r = {}),
			n.forEach((e) => {
				r[e] = t;
			}));
		const i = Object.keys(r),
			s = { cacheKeys: i, keys: n };
		if (
			(n.forEach((e) => {
				this._cacheMap.set(e, s);
			}),
			i.forEach((e) => {
				this._cache.has(e) && this._cache.get(e) !== t && console.warn("[Cache] already has key:", e), this._cache.set(e, r[e]);
			}),
			t instanceof lp)
		) {
			const e = t;
			n.forEach((t) => {
				e.baseTexture !== lp.EMPTY.baseTexture && Bh.addToCache(e.baseTexture, t), lp.addToCache(e, t);
			});
		}
	}
	remove(e) {
		if ((this._cacheMap.get(e), !this._cacheMap.has(e))) return void console.warn(`[Assets] Asset id ${e} was not found in the Cache`);
		const t = this._cacheMap.get(e);
		t.cacheKeys.forEach((e) => {
			this._cache.delete(e);
		}),
			t.keys.forEach((e) => {
				this._cacheMap.delete(e);
			});
	}
	get parsers() {
		return this._parsers;
	}
})();
class hv {
	constructor() {
		(this._parsers = []), (this._parsersValidated = !1), (this.parsers = new Proxy(this._parsers, { set: (e, t, n) => ((this._parsersValidated = !1), (e[t] = n), !0) })), (this.promiseCache = {});
	}
	reset() {
		(this._parsersValidated = !1), (this.promiseCache = {});
	}
	_getLoadPromiseAndParser(e, t) {
		const n = { promise: null, parser: null };
		return (
			(n.promise = (async () => {
				var r, i;
				let s = null,
					o = null;
				if ((t.loadParser && ((o = this._parserHash[t.loadParser]), o || console.warn(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)), !o)) {
					for (let n = 0; n < this.parsers.length; n++) {
						const i = this.parsers[n];
						if (i.load && (null == (r = i.test) ? void 0 : r.call(i, e, t, this))) {
							o = i;
							break;
						}
					}
					if (!o) return console.warn(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
				}
				(s = await o.load(e, t, this)), (n.parser = o);
				for (let e = 0; e < this.parsers.length; e++) {
					const r = this.parsers[e];
					r.parse && r.parse && (await (null == (i = r.testParse) ? void 0 : i.call(r, s, t, this))) && ((s = (await r.parse(s, t, this)) || s), (n.parser = r));
				}
				return s;
			})()),
			n
		);
	}
	async load(e, t) {
		this._parsersValidated || this._validateParsers();
		let n = 0;
		const r = {},
			i = uv(e),
			s = sv(e, (e) => ({ src: e })),
			o = s.length,
			a = s.map(async (e) => {
				const i = dc.toAbsolute(e.src);
				if (!r[e.src])
					try {
						this.promiseCache[i] || (this.promiseCache[i] = this._getLoadPromiseAndParser(i, e)), (r[e.src] = await this.promiseCache[i].promise), t && t(++n / o);
					} catch (Kj) {
						throw (delete this.promiseCache[i], delete r[e.src], new Error(`[Loader.load] Failed to load ${i}.\n${Kj}`));
					}
			});
		return await Promise.all(a), i ? r[s[0].src] : r;
	}
	async unload(e) {
		const t = sv(e, (e) => ({ src: e })).map(async (e) => {
			var t, n;
			const r = dc.toAbsolute(e.src),
				i = this.promiseCache[r];
			if (i) {
				const s = await i.promise;
				null == (n = null == (t = i.parser) ? void 0 : t.unload) || n.call(t, s, e, this), delete this.promiseCache[r];
			}
		});
		await Promise.all(t);
	}
	_validateParsers() {
		(this._parsersValidated = !0), (this._parserHash = this._parsers.filter((e) => e.name).reduce((e, t) => (e[t.name] && console.warn(`[Assets] loadParser name conflict "${t.name}"`), c(u({}, e), { [t.name]: t })), {}));
	}
}
var dv = ((e) => ((e[(e.Low = 0)] = "Low"), (e[(e.Normal = 1)] = "Normal"), (e[(e.High = 2)] = "High"), e))(dv || {});
const pv = {
	extension: { type: _h.LoadParser, priority: dv.Low },
	name: "loadJson",
	test: (e) => rv(e, "application/json") || iv(e, ".json"),
	async load(e) {
		const t = await Vl.ADAPTER.fetch(e);
		return await t.json();
	}
};
Sh.add(pv);
const fv = {
	name: "loadTxt",
	extension: { type: _h.LoadParser, priority: dv.Low },
	test: (e) => rv(e, "text/plain") || iv(e, ".txt"),
	async load(e) {
		const t = await Vl.ADAPTER.fetch(e);
		return await t.text();
	}
};
Sh.add(fv);
const mv = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
	vv = [".ttf", ".otf", ".woff", ".woff2"],
	gv = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
	yv = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function bv(e) {
	const t = dc.extname(e),
		n = dc
			.basename(e, t)
			.replace(/(-|_)/g, " ")
			.toLowerCase()
			.split(" ")
			.map((e) => e.charAt(0).toUpperCase() + e.slice(1));
	let r = n.length > 0;
	for (const s of n)
		if (!s.match(yv)) {
			r = !1;
			break;
		}
	let i = n.join(" ");
	return r || (i = `"${i.replace(/[\\"]/g, "\\$&")}"`), i;
}
const xv = {
	extension: { type: _h.LoadParser, priority: dv.Low },
	name: "loadWebFont",
	test: (e) => rv(e, gv) || iv(e, vv),
	async load(e, t) {
		var n, r, i, s, o, a;
		const l = Vl.ADAPTER.getFontFaceSet();
		if (l) {
			const h = [],
				d = null != (r = null == (n = t.data) ? void 0 : n.family) ? r : bv(e),
				p = null != (o = null == (s = null == (i = t.data) ? void 0 : i.weights) ? void 0 : s.filter((e) => mv.includes(e))) ? o : ["normal"],
				f = null != (a = t.data) ? a : {};
			for (let t = 0; t < p.length; t++) {
				const n = p[t],
					r = new FontFace(d, `url(${encodeURI(e)})`, c(u({}, f), { weight: n }));
				await r.load(), l.add(r), h.push(r);
			}
			return 1 === h.length ? h[0] : h;
		}
		return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
	},
	unload(e) {
		(Array.isArray(e) ? e : [e]).forEach((e) => Vl.ADAPTER.getFontFaceSet().delete(e));
	}
};
Sh.add(xv);
let _v,
	wv = 0;
const Cv = {
		id: "checkImageBitmap",
		code: "\n        async function checkImageBitmap()\n        {\n                try\n                {\n                        if (typeof createImageBitmap !== 'function') return false;\n\n                        const response = await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=');\n                        const imageBlob =    await response.blob();\n                        const imageBitmap = await createImageBitmap(imageBlob);\n\n                        return imageBitmap.width === 1 && imageBitmap.height === 1;\n                }\n                catch (e)\n                {\n                        return false;\n                }\n        }\n        checkImageBitmap().then((result) => { self.postMessage(result); });\n        "
	},
	Sv = {
		id: "loadImageBitmap",
		code: "\n        async function loadImageBitmap(url)\n        {\n                const response = await fetch(url);\n\n                if (!response.ok)\n                {\n                        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: `\n                                + `${response.status} ${response.statusText}`);\n                }\n\n                const imageBlob =    await response.blob();\n                const imageBitmap = await createImageBitmap(imageBlob);\n\n                return imageBitmap;\n        }\n        self.onmessage = async (event) =>\n        {\n                try\n                {\n                        const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n                        self.postMessage({\n                                data: imageBitmap,\n                                uuid: event.data.uuid,\n                                id: event.data.id,\n                        }, [imageBitmap]);\n                }\n                catch(e)\n                {\n                        self.postMessage({\n                                error: e,\n                                uuid: event.data.uuid,\n                                id: event.data.id,\n                        });\n                }\n        };"
	};
let Ev;
const Tv = new (class {
	constructor() {
		(this._initialized = !1), (this._createdWorkers = 0), (this.workerPool = []), (this.queue = []), (this.resolveHash = {});
	}
	isImageBitmapSupported() {
		return (
			void 0 !== this._isImageBitmapSupported ||
				(this._isImageBitmapSupported = new Promise((e) => {
					const t = URL.createObjectURL(new Blob([Cv.code], { type: "application/javascript" })),
						n = new Worker(t);
					n.addEventListener("message", (r) => {
						n.terminate(), URL.revokeObjectURL(t), e(r.data);
					});
				})),
			this._isImageBitmapSupported
		);
	}
	loadImageBitmap(e) {
		return this._run("loadImageBitmap", [e]);
	}
	async _initWorkers() {
		this._initialized || (this._initialized = !0);
	}
	getWorker() {
		void 0 === _v && (_v = navigator.hardwareConcurrency || 4);
		let e = this.workerPool.pop();
		return (
			!e &&
				this._createdWorkers < _v &&
				(Ev || (Ev = URL.createObjectURL(new Blob([Sv.code], { type: "application/javascript" }))),
				this._createdWorkers++,
				(e = new Worker(Ev)),
				e.addEventListener("message", (e) => {
					this.complete(e.data), this.returnWorker(e.target), this.next();
				})),
			e
		);
	}
	returnWorker(e) {
		this.workerPool.push(e);
	}
	complete(e) {
		void 0 !== e.error ? this.resolveHash[e.uuid].reject(e.error) : this.resolveHash[e.uuid].resolve(e.data), (this.resolveHash[e.uuid] = null);
	}
	async _run(e, t) {
		await this._initWorkers();
		const n = new Promise((n, r) => {
			this.queue.push({ id: e, arguments: t, resolve: n, reject: r });
		});
		return this.next(), n;
	}
	next() {
		if (!this.queue.length) return;
		const e = this.getWorker();
		if (!e) return;
		const t = this.queue.pop(),
			n = t.id;
		(this.resolveHash[wv] = { resolve: t.resolve, reject: t.reject }), e.postMessage({ data: t.arguments, uuid: wv++, id: n });
	}
})();
function kv(e, t, n) {
	const r = new lp(e);
	return (
		r.baseTexture.on("dispose", () => {
			delete t.promiseCache[n];
		}),
		r
	);
}
const Av = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
	Mv = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function Iv(e) {
	const t = await Vl.ADAPTER.fetch(e);
	if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
	const n = await t.blob();
	return await createImageBitmap(n);
}
const Rv = {
	name: "loadTextures",
	extension: { type: _h.LoadParser, priority: dv.High },
	config: { preferWorkers: !0, preferCreateImageBitmap: !0, crossOrigin: "anonymous" },
	test: (e) => rv(e, Mv) || iv(e, Av),
	async load(e, t, n) {
		let r = null;
		r =
			globalThis.createImageBitmap && this.config.preferCreateImageBitmap
				? this.config.preferWorkers && (await Tv.isImageBitmapSupported())
					? await Tv.loadImageBitmap(e)
					: await Iv(e)
				: await new Promise((t) => {
						(r = new Image()),
							(r.crossOrigin = this.config.crossOrigin),
							(r.src = e),
							r.complete
								? t(r)
								: (r.onload = () => {
										t(r);
								  });
				  });
		const i = new Bh(r, u({ resolution: bh(e) }, t.data));
		return (i.resource.src = e), kv(i, n, e);
	},
	unload(e) {
		e.destroy(!0);
	}
};
Sh.add(Rv);
const Lv = {
	extension: { type: _h.LoadParser, priority: dv.High },
	name: "loadSVG",
	test: (e) => rv(e, "image/svg+xml") || iv(e, ".svg"),
	testParse: async (e) => Rf.test(e),
	async parse(e, t, n) {
		var r;
		const i = new Rf(e, null == (r = null == t ? void 0 : t.data) ? void 0 : r.resourceOptions);
		await i.load();
		const s = new Bh(i, u({ resolution: bh(e) }, null == t ? void 0 : t.data));
		s.resource.src = e;
		return kv(s, n, e);
	},
	load: async (e, t) => (await Vl.ADAPTER.fetch(e)).text(),
	unload: Rv.unload
};
Sh.add(Lv);
class Ov {
	constructor() {
		(this._defaultBundleIdentifierOptions = { connector: "-", createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`, extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "") }),
			(this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector),
			(this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId),
			(this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
			(this._assetMap = {}),
			(this._preferredOrder = []),
			(this._parsers = []),
			(this._resolverHash = {}),
			(this._bundles = {});
	}
	setBundleIdentifier(e) {
		var t, n, r;
		if (
			((this._bundleIdConnector = null != (t = e.connector) ? t : this._bundleIdConnector),
			(this._createBundleAssetId = null != (n = e.createBundleAssetId) ? n : this._createBundleAssetId),
			(this._extractAssetIdFromBundle = null != (r = e.extractAssetIdFromBundle) ? r : this._extractAssetIdFromBundle),
			"bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")))
		)
			throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
	}
	prefer(...e) {
		e.forEach((e) => {
			this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params));
		}),
			(this._resolverHash = {});
	}
	set basePath(e) {
		this._basePath = e;
	}
	get basePath() {
		return this._basePath;
	}
	set rootPath(e) {
		this._rootPath = e;
	}
	get rootPath() {
		return this._rootPath;
	}
	get parsers() {
		return this._parsers;
	}
	reset() {
		this.setBundleIdentifier(this._defaultBundleIdentifierOptions), (this._assetMap = {}), (this._preferredOrder = []), (this._resolverHash = {}), (this._rootPath = null), (this._basePath = null), (this._manifest = null), (this._bundles = {}), (this._defaultSearchParams = null);
	}
	setDefaultSearchParams(e) {
		if ("string" == typeof e) this._defaultSearchParams = e;
		else {
			const t = e;
			this._defaultSearchParams = Object.keys(t)
				.map((e) => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`)
				.join("&");
		}
	}
	addManifest(e) {
		this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
			(this._manifest = e),
			e.bundles.forEach((e) => {
				this.addBundle(e.name, e.assets);
			});
	}
	addBundle(e, t) {
		const n = [];
		Array.isArray(t)
			? t.forEach((t) => {
					if ("string" == typeof t.name) {
						const r = this._createBundleAssetId(e, t.name);
						n.push(r), this.add([t.name, r], t.srcs, t.data);
					} else {
						const r = t.name.map((t) => this._createBundleAssetId(e, t));
						r.forEach((e) => {
							n.push(e);
						}),
							this.add([...t.name, ...r], t.srcs);
					}
			  })
			: Object.keys(t).forEach((r) => {
					n.push(this._createBundleAssetId(e, r)), this.add([r, this._createBundleAssetId(e, r)], t[r]);
			  }),
			(this._bundles[e] = n);
	}
	add(e, t, n) {
		const r = sv(e);
		r.forEach((e) => {
			this.hasKey(e) && console.warn(`[Resolver] already has key: ${e} overwriting`);
		}),
			Array.isArray(t) || (t = "string" == typeof t ? lv(t) : [t]);
		const i = t.map((e) => {
			var t;
			let i = e;
			if ("string" == typeof e) {
				let t = !1;
				for (let n = 0; n < this._parsers.length; n++) {
					const r = this._parsers[n];
					if (r.test(e)) {
						(i = r.parse(e)), (t = !0);
						break;
					}
				}
				t || (i = { src: e });
			}
			return i.format || (i.format = i.src.split(".").pop()), i.alias || (i.alias = r), (this._basePath || this._rootPath) && (i.src = dc.toAbsolute(i.src, this._basePath, this._rootPath)), (i.src = this._appendDefaultSearchParams(i.src)), (i.data = null != (t = i.data) ? t : n), i;
		});
		r.forEach((e) => {
			this._assetMap[e] = i;
		});
	}
	resolveBundle(e) {
		const t = uv(e);
		e = sv(e);
		const n = {};
		return (
			e.forEach((e) => {
				const t = this._bundles[e];
				if (t) {
					const r = this.resolve(t),
						i = {};
					for (const t in r) {
						const n = r[t];
						i[this._extractAssetIdFromBundle(e, t)] = n;
					}
					n[e] = i;
				}
			}),
			t ? n[e[0]] : n
		);
	}
	resolveUrl(e) {
		const t = this.resolve(e);
		if ("string" != typeof e) {
			const e = {};
			for (const n in t) e[n] = t[n].src;
			return e;
		}
		return t.src;
	}
	resolve(e) {
		const t = uv(e);
		e = sv(e);
		const n = {};
		return (
			e.forEach((e) => {
				var t;
				if (!this._resolverHash[e])
					if (this._assetMap[e]) {
						let n = this._assetMap[e];
						const r = this._getPreferredOrder(n),
							i = n[0];
						null == r ||
							r.priority.forEach((e) => {
								r.params[e].forEach((t) => {
									const r = n.filter((n) => !!n[e] && n[e] === t);
									r.length && (n = r);
								});
							}),
							(this._resolverHash[e] = null != (t = n[0]) ? t : i);
					} else {
						let t = e;
						(this._basePath || this._rootPath) && (t = dc.toAbsolute(t, this._basePath, this._rootPath)), (t = this._appendDefaultSearchParams(t)), (this._resolverHash[e] = { src: t });
					}
				n[e] = this._resolverHash[e];
			}),
			t ? n[e[0]] : n
		);
	}
	hasKey(e) {
		return !!this._assetMap[e];
	}
	hasBundle(e) {
		return !!this._bundles[e];
	}
	_getPreferredOrder(e) {
		for (let t = 0; t < e.length; t++) {
			const t = e[0],
				n = this._preferredOrder.find((e) => e.params.format.includes(t.format));
			if (n) return n;
		}
		return this._preferredOrder[0];
	}
	_appendDefaultSearchParams(e) {
		if (!this._defaultSearchParams) return e;
		return `${e}${/\?/.test(e) ? "&" : "?"}${this._defaultSearchParams}`;
	}
}
class Pv {
	constructor() {
		(this._detections = []), (this._initialized = !1), (this.resolver = new Ov()), (this.loader = new hv()), (this.cache = cv), (this._backgroundLoader = new nv(this.loader)), (this._backgroundLoader.active = !0), this.reset();
	}
	async init(e = {}) {
		var t, n, r, i;
		if (this._initialized) return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
		if (((this._initialized = !0), e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest)) {
			let t = e.manifest;
			"string" == typeof t && (t = await this.load(t)), this.resolver.addManifest(t);
		}
		const s = null != (n = null == (t = e.texturePreference) ? void 0 : t.resolution) ? n : 1,
			o = "number" == typeof s ? [s] : s;
		let a = [];
		if (null == (r = e.texturePreference) ? void 0 : r.format) {
			const t = null == (i = e.texturePreference) ? void 0 : i.format;
			a = "string" == typeof t ? [t] : t;
			for (const e of this._detections) (await e.test()) || (a = await e.remove(a));
		} else for (const l of this._detections) (await l.test()) && (a = await l.add(a));
		this.resolver.prefer({ params: { format: a, resolution: o } }), e.preferences && this.setPreferences(e.preferences);
	}
	add(e, t, n) {
		this.resolver.add(e, t, n);
	}
	async load(e, t) {
		this._initialized || (await this.init());
		const n = uv(e),
			r = sv(e).map((e) => ("string" != typeof e ? (this.resolver.add(e.src, e), e.src) : (this.resolver.hasKey(e) || this.resolver.add(e, e), e))),
			i = this.resolver.resolve(r),
			s = await this._mapLoadToResolve(i, t);
		return n ? s[r[0]] : s;
	}
	addBundle(e, t) {
		this.resolver.addBundle(e, t);
	}
	async loadBundle(e, t) {
		this._initialized || (await this.init());
		let n = !1;
		"string" == typeof e && ((n = !0), (e = [e]));
		const r = this.resolver.resolveBundle(e),
			i = {},
			s = Object.keys(r);
		let o = 0,
			a = 0;
		const l = () => {
				null == t || t(++o / a);
			},
			u = s.map((e) => {
				const t = r[e];
				return (
					(a += Object.keys(t).length),
					this._mapLoadToResolve(t, l).then((t) => {
						i[e] = t;
					})
				);
			});
		return await Promise.all(u), n ? i[e[0]] : i;
	}
	async backgroundLoad(e) {
		this._initialized || (await this.init()), "string" == typeof e && (e = [e]);
		const t = this.resolver.resolve(e);
		this._backgroundLoader.add(Object.values(t));
	}
	async backgroundLoadBundle(e) {
		this._initialized || (await this.init()), "string" == typeof e && (e = [e]);
		const t = this.resolver.resolveBundle(e);
		Object.values(t).forEach((e) => {
			this._backgroundLoader.add(Object.values(e));
		});
	}
	reset() {
		this.resolver.reset(), this.loader.reset(), this.cache.reset(), (this._initialized = !1);
	}
	get(e) {
		if ("string" == typeof e) return cv.get(e);
		const t = {};
		for (let n = 0; n < e.length; n++) t[n] = cv.get(e[n]);
		return t;
	}
	async _mapLoadToResolve(e, t) {
		const n = Object.values(e),
			r = Object.keys(e);
		this._backgroundLoader.active = !1;
		const i = await this.loader.load(n, t);
		this._backgroundLoader.active = !0;
		const s = {};
		return (
			n.forEach((e, t) => {
				const n = i[e.src],
					o = [e.src];
				e.alias && o.push(...e.alias), (s[r[t]] = n), cv.set(o, n);
			}),
			s
		);
	}
	async unload(e) {
		this._initialized || (await this.init());
		const t = sv(e).map((e) => ("string" != typeof e ? e.src : e)),
			n = this.resolver.resolve(t);
		await this._unloadFromResolved(n);
	}
	async unloadBundle(e) {
		this._initialized || (await this.init()), (e = sv(e));
		const t = this.resolver.resolveBundle(e),
			n = Object.keys(t).map((e) => this._unloadFromResolved(t[e]));
		await Promise.all(n);
	}
	async _unloadFromResolved(e) {
		const t = Object.values(e);
		t.forEach((e) => {
			cv.remove(e.src);
		}),
			await this.loader.unload(t);
	}
	get detections() {
		return this._detections;
	}
	get preferWorkers() {
		return Rv.config.preferWorkers;
	}
	set preferWorkers(e) {
		fc("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({ preferWorkers: e });
	}
	setPreferences(e) {
		this.loader.parsers.forEach((t) => {
			t.config &&
				Object.keys(t.config)
					.filter((t) => t in e)
					.forEach((n) => {
						t.config[n] = e[n];
					});
		});
	}
}
const Nv = new Pv();
Sh.handleByList(_h.LoadParser, Nv.loader.parsers).handleByList(_h.ResolveParser, Nv.resolver.parsers).handleByList(_h.CacheParser, Nv.cache.parsers).handleByList(_h.DetectionParser, Nv.detections);
const Dv = {
	extension: _h.CacheParser,
	test: (e) => Array.isArray(e) && e.every((e) => e instanceof lp),
	getCacheableAssets: (e, t) => {
		const n = {};
		return (
			e.forEach((e) => {
				t.forEach((t, r) => {
					n[e + (0 === r ? "" : r + 1)] = t;
				});
			}),
			n
		);
	}
};
Sh.add(Dv);
const Bv = {
	extension: { type: _h.DetectionParser, priority: 1 },
	test: async () => {
		if (!globalThis.createImageBitmap) return !1;
		const e = await Vl.ADAPTER.fetch(
			"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
		).then((e) => e.blob());
		return createImageBitmap(e).then(
			() => !0,
			() => !1
		);
	},
	add: async (e) => [...e, "avif"],
	remove: async (e) => e.filter((e) => "avif" !== e)
};
Sh.add(Bv);
const Fv = {
	extension: { type: _h.DetectionParser, priority: 0 },
	test: async () => {
		if (!globalThis.createImageBitmap) return !1;
		const e = await Vl.ADAPTER.fetch("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=").then((e) => e.blob());
		return createImageBitmap(e).then(
			() => !0,
			() => !1
		);
	},
	add: async (e) => [...e, "webp"],
	remove: async (e) => e.filter((e) => "webp" !== e)
};
Sh.add(Fv);
const Hv = ["png", "jpg", "jpeg"],
	Vv = { extension: { type: _h.DetectionParser, priority: -1 }, test: () => Promise.resolve(!0), add: async (e) => [...e, ...Hv], remove: async (e) => e.filter((e) => !Hv.includes(e)) };
Sh.add(Vv);
const Uv = {
	extension: _h.ResolveParser,
	test: Rv.test,
	parse: (e) => {
		var t, n;
		return { resolution: parseFloat(null != (n = null == (t = Vl.RETINA_PREFIX.exec(e)) ? void 0 : t[1]) ? n : "1"), format: e.split(".").pop(), src: e };
	}
};
Sh.add(Uv);
var zv = ((e) => (
	(e[(e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776)] = "COMPRESSED_RGB_S3TC_DXT1_EXT"),
	(e[(e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777)] = "COMPRESSED_RGBA_S3TC_DXT1_EXT"),
	(e[(e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778)] = "COMPRESSED_RGBA_S3TC_DXT3_EXT"),
	(e[(e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779)] = "COMPRESSED_RGBA_S3TC_DXT5_EXT"),
	(e[(e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917)] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"),
	(e[(e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918)] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"),
	(e[(e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919)] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"),
	(e[(e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916)] = "COMPRESSED_SRGB_S3TC_DXT1_EXT"),
	(e[(e.COMPRESSED_R11_EAC = 37488)] = "COMPRESSED_R11_EAC"),
	(e[(e.COMPRESSED_SIGNED_R11_EAC = 37489)] = "COMPRESSED_SIGNED_R11_EAC"),
	(e[(e.COMPRESSED_RG11_EAC = 37490)] = "COMPRESSED_RG11_EAC"),
	(e[(e.COMPRESSED_SIGNED_RG11_EAC = 37491)] = "COMPRESSED_SIGNED_RG11_EAC"),
	(e[(e.COMPRESSED_RGB8_ETC2 = 37492)] = "COMPRESSED_RGB8_ETC2"),
	(e[(e.COMPRESSED_RGBA8_ETC2_EAC = 37496)] = "COMPRESSED_RGBA8_ETC2_EAC"),
	(e[(e.COMPRESSED_SRGB8_ETC2 = 37493)] = "COMPRESSED_SRGB8_ETC2"),
	(e[(e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497)] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"),
	(e[(e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494)] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
	(e[(e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495)] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
	(e[(e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840)] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"),
	(e[(e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842)] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"),
	(e[(e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841)] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"),
	(e[(e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843)] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"),
	(e[(e.COMPRESSED_RGB_ETC1_WEBGL = 36196)] = "COMPRESSED_RGB_ETC1_WEBGL"),
	(e[(e.COMPRESSED_RGB_ATC_WEBGL = 35986)] = "COMPRESSED_RGB_ATC_WEBGL"),
	(e[(e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986)] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"),
	(e[(e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798)] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"),
	(e[(e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808)] = "COMPRESSED_RGBA_ASTC_4x4_KHR"),
	e
))(zv || {});
const $v = {
	33776: 0.5,
	33777: 0.5,
	33778: 1,
	33779: 1,
	35916: 0.5,
	35917: 0.5,
	35918: 1,
	35919: 1,
	37488: 0.5,
	37489: 0.5,
	37490: 1,
	37491: 1,
	37492: 0.5,
	37496: 1,
	37493: 0.5,
	37497: 1,
	37494: 0.5,
	37495: 0.5,
	35840: 0.5,
	35842: 0.5,
	35841: 0.25,
	35843: 0.25,
	36196: 0.5,
	35986: 0.5,
	35986: 1,
	34798: 1,
	37808: 1
};
let jv, Wv;
function Gv() {
	Wv = {
		s3tc: jv.getExtension("WEBGL_compressed_texture_s3tc"),
		s3tc_sRGB: jv.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
		etc: jv.getExtension("WEBGL_compressed_texture_etc"),
		etc1: jv.getExtension("WEBGL_compressed_texture_etc1"),
		pvrtc: jv.getExtension("WEBGL_compressed_texture_pvrtc") || jv.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
		atc: jv.getExtension("WEBGL_compressed_texture_atc"),
		astc: jv.getExtension("WEBGL_compressed_texture_astc")
	};
}
const Yv = {
	extension: { type: _h.DetectionParser, priority: 2 },
	test: async () => {
		const e = Vl.ADAPTER.createCanvas().getContext("webgl");
		return e ? ((jv = e), !0) : (console.warn("WebGL not available for compressed textures."), !1);
	},
	add: async (e) => {
		Wv || Gv();
		const t = [];
		for (const n in Wv) {
			Wv[n] && t.push(n);
		}
		return [...t, ...e];
	},
	remove: async (e) => (Wv || Gv(), e.filter((e) => !(e in Wv)))
};
Sh.add(Yv);
class Xv extends Ph {
	constructor(e, t = { width: 1, height: 1, autoLoad: !0 }) {
		let n, r;
		"string" == typeof e ? ((n = e), (r = new Uint8Array())) : ((n = null), (r = e)),
			super(r, t),
			(this.origin = n),
			(this.buffer = r ? new Eh(r) : null),
			(this._load = null),
			(this.loaded = !1),
			null !== this.origin && !1 !== t.autoLoad && this.load(),
			null === this.origin && this.buffer && ((this._load = Promise.resolve(this)), (this.loaded = !0), this.onBlobLoaded(this.buffer.rawBinaryData));
	}
	onBlobLoaded(e) {}
	load() {
		return (
			this._load ||
				(this._load = fetch(this.origin)
					.then((e) => e.blob())
					.then((e) => e.arrayBuffer())
					.then((e) => ((this.data = new Uint32Array(e)), (this.buffer = new Eh(e)), (this.loaded = !0), this.onBlobLoaded(e), this.update(), this))),
			this._load
		);
	}
}
class Kv extends Xv {
	constructor(e, t) {
		super(e, t),
			(this.format = t.format),
			(this.levels = t.levels || 1),
			(this._width = t.width),
			(this._height = t.height),
			(this._extension = Kv._formatToExtension(this.format)),
			(t.levelBuffers || this.buffer) && (this._levelBuffers = t.levelBuffers || Kv._createLevelBuffers(e instanceof Uint8Array ? e : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height));
	}
	upload(e, t, n) {
		const r = e.gl;
		if (!e.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
		if (!this._levelBuffers) return !1;
		for (let i = 0, s = this.levels; i < s; i++) {
			const { levelID: e, levelWidth: t, levelHeight: n, levelBuffer: s } = this._levelBuffers[i];
			r.compressedTexImage2D(r.TEXTURE_2D, e, this.format, t, n, 0, s);
		}
		return !0;
	}
	onBlobLoaded() {
		this._levelBuffers = Kv._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
	}
	static _formatToExtension(e) {
		if (e >= 33776 && e <= 33779) return "s3tc";
		if (e >= 37488 && e <= 37497) return "etc";
		if (e >= 35840 && e <= 35843) return "pvrtc";
		if (e >= 36196) return "etc1";
		if (e >= 35986 && e <= 34798) return "atc";
		throw new Error("Invalid (compressed) texture format given!");
	}
	static _createLevelBuffers(e, t, n, r, i, s, o) {
		const a = new Array(n);
		let l = e.byteOffset,
			u = s,
			c = o,
			h = (u + r - 1) & ~(r - 1),
			d = (c + i - 1) & ~(i - 1),
			p = h * d * $v[t];
		for (let f = 0; f < n; f++) (a[f] = { levelID: f, levelWidth: n > 1 ? u : h, levelHeight: n > 1 ? c : d, levelBuffer: new Uint8Array(e.buffer, l, p) }), (l += p), (u = u >> 1 || 1), (c = c >> 1 || 1), (h = (u + r - 1) & ~(r - 1)), (d = (c + i - 1) & ~(i - 1)), (p = h * d * $v[t]);
		return a;
	}
}
const qv = 3,
	Zv = 4,
	Jv = 7,
	Qv = 19,
	eg = 2,
	tg = 0,
	ng = 1,
	rg = 2,
	ig = 3,
	sg = { 827611204: zv.COMPRESSED_RGBA_S3TC_DXT1_EXT, 861165636: zv.COMPRESSED_RGBA_S3TC_DXT3_EXT, 894720068: zv.COMPRESSED_RGBA_S3TC_DXT5_EXT },
	og = {
		70: zv.COMPRESSED_RGBA_S3TC_DXT1_EXT,
		71: zv.COMPRESSED_RGBA_S3TC_DXT1_EXT,
		73: zv.COMPRESSED_RGBA_S3TC_DXT3_EXT,
		74: zv.COMPRESSED_RGBA_S3TC_DXT3_EXT,
		76: zv.COMPRESSED_RGBA_S3TC_DXT5_EXT,
		77: zv.COMPRESSED_RGBA_S3TC_DXT5_EXT,
		72: zv.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
		75: zv.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
		78: zv.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
	};
function ag(e) {
	const t = new Uint32Array(e);
	if (542327876 !== t[0]) throw new Error("Invalid DDS file magic word");
	const n = new Uint32Array(e, 0, 124 / Uint32Array.BYTES_PER_ELEMENT),
		r = n[qv],
		i = n[Zv],
		s = n[Jv],
		o = new Uint32Array(e, Qv * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT),
		a = o[1];
	if (4 & a) {
		const n = o[eg];
		if (808540228 !== n) {
			const t = sg[n],
				o = new Uint8Array(e, 128);
			return [new Kv(o, { format: t, width: i, height: r, levels: s })];
		}
		const a = 128,
			l = new Uint32Array(t.buffer, a, 20 / Uint32Array.BYTES_PER_ELEMENT),
			u = l[tg],
			c = l[ng],
			h = l[rg],
			d = l[ig],
			p = og[u];
		if (void 0 === p) throw new Error(`DDSParser cannot parse texture data with DXGI format ${u}`);
		if (4 === h) throw new Error("DDSParser does not support cubemap textures");
		if (6 === c) throw new Error("DDSParser does not supported 3D texture data");
		const f = new Array(),
			m = 148;
		if (1 === d) f.push(new Uint8Array(e, m));
		else {
			const t = $v[p];
			let n = 0,
				o = i,
				a = r;
			for (let e = 0; e < s; e++) {
				(n += Math.max(1, (o + 3) & -4) * Math.max(1, (a + 3) & -4) * t), (o >>>= 1), (a >>>= 1);
			}
			let l = m;
			for (let r = 0; r < d; r++) f.push(new Uint8Array(e, l, n)), (l += n);
		}
		return f.map((e) => new Kv(e, { format: p, width: i, height: r, levels: s }));
	}
	if (64 & a) throw new Error("DDSParser does not support uncompressed texture data.");
	if (512 & a) throw new Error("DDSParser does not supported YUV uncompressed texture data.");
	if (131072 & a) throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
	if (2 & a) throw new Error("DDSParser does not support single-channel (alpha) texture data!");
	throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
const lg = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
	ug = 12,
	cg = 16,
	hg = 24,
	dg = 28,
	pg = 36,
	fg = 40,
	mg = 44,
	vg = 48,
	gg = 52,
	yg = 56,
	bg = 60,
	xg = { [Tl.UNSIGNED_BYTE]: 1, [Tl.UNSIGNED_SHORT]: 2, [Tl.INT]: 4, [Tl.UNSIGNED_INT]: 4, [Tl.FLOAT]: 4, [Tl.HALF_FLOAT]: 8 },
	_g = { [Sl.RGBA]: 4, [Sl.RGB]: 3, [Sl.RG]: 2, [Sl.RED]: 1, [Sl.LUMINANCE]: 1, [Sl.LUMINANCE_ALPHA]: 2, [Sl.ALPHA]: 1 },
	wg = { [Tl.UNSIGNED_SHORT_4_4_4_4]: 2, [Tl.UNSIGNED_SHORT_5_5_5_1]: 2, [Tl.UNSIGNED_SHORT_5_6_5]: 2 };
function Cg(e, t, n = !1) {
	const r = new DataView(t);
	if (
		!(function (e, t) {
			for (let n = 0; n < lg.length; n++) if (t.getUint8(n) !== lg[n]) return console.error(`${e} is not a valid *.ktx file!`), !1;
			return !0;
		})(e, r)
	)
		return null;
	const i = 67305985 === r.getUint32(ug, !0),
		s = r.getUint32(cg, i),
		o = r.getUint32(hg, i),
		a = r.getUint32(dg, i),
		l = r.getUint32(pg, i),
		u = r.getUint32(fg, i) || 1,
		c = r.getUint32(mg, i) || 1,
		h = r.getUint32(vg, i) || 1,
		d = r.getUint32(gg, i),
		p = r.getUint32(yg, i),
		f = r.getUint32(bg, i);
	if (0 === u || 1 !== c) throw new Error("Only 2D textures are supported");
	if (1 !== d) throw new Error("CubeTextures are not supported by KTXLoader yet!");
	if (1 !== h) throw new Error("WebGL does not support array textures");
	const m = (l + 3) & -4,
		v = (u + 3) & -4,
		g = new Array(h);
	let y,
		b = l * u;
	if ((0 === s && (b = m * v), (y = 0 !== s ? (xg[s] ? xg[s] * _g[o] : wg[s]) : $v[a]), void 0 === y)) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
	const x = n
		? (function (e, t, n) {
				const r = new Map();
				let i = 0;
				for (; i < t; ) {
					const s = e.getUint32(64 + i, n),
						o = 64 + i + 4,
						a = 3 - ((s + 3) % 4);
					if (0 === s || s > t - i) {
						console.error("KTXLoader: keyAndValueByteSize out of bounds");
						break;
					}
					let l = 0;
					for (; l < s && 0 !== e.getUint8(o + l); l++);
					if (-1 === l) {
						console.error("KTXLoader: Failed to find null byte terminating kvData key");
						break;
					}
					const u = new TextDecoder().decode(new Uint8Array(e.buffer, o, l)),
						c = new DataView(e.buffer, o + l + 1, s - l - 1);
					r.set(u, c), (i += 4 + s + a);
				}
				return r;
		  })(r, f, i)
		: null;
	let _ = b * y,
		w = l,
		C = u,
		S = m,
		E = v,
		T = 64 + f;
	for (let k = 0; k < p; k++) {
		const e = r.getUint32(T, i);
		let n = T + 4;
		for (let r = 0; r < h; r++) {
			let e = g[r];
			e || (e = g[r] = new Array(p)), (e[k] = { levelID: k, levelWidth: p > 1 || 0 !== s ? w : S, levelHeight: p > 1 || 0 !== s ? C : E, levelBuffer: new Uint8Array(t, n, _) }), (n += _);
		}
		(T += e + 4), (T = T % 4 != 0 ? T + 4 - (T % 4) : T), (w = w >> 1 || 1), (C = C >> 1 || 1), (S = (w + 4 - 1) & -4), (E = (C + 4 - 1) & -4), (_ = S * E * y);
	}
	return 0 !== s
		? {
				uncompressed: g.map((e) => {
					let t = e[0].levelBuffer,
						n = !1;
					return (
						s === Tl.FLOAT
							? (t = new Float32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4))
							: s === Tl.UNSIGNED_INT
							? ((n = !0), (t = new Uint32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4)))
							: s === Tl.INT && ((n = !0), (t = new Int32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4))),
						{ resource: new Ph(t, { width: e[0].levelWidth, height: e[0].levelHeight }), type: s, format: n ? Sg(o) : o }
					);
				}),
				kvData: x
		  }
		: { compressed: g.map((e) => new Kv(null, { format: a, width: l, height: u, levels: p, levelBuffers: e })), kvData: x };
}
function Sg(e) {
	switch (e) {
		case Sl.RGBA:
			return Sl.RGBA_INTEGER;
		case Sl.RGB:
			return Sl.RGB_INTEGER;
		case Sl.RG:
			return Sl.RG_INTEGER;
		case Sl.RED:
			return Sl.RED_INTEGER;
		default:
			return e;
	}
}
const Eg = {
	extension: { type: _h.LoadParser, priority: dv.High },
	name: "loadDDS",
	test: (e) => iv(e, ".dds"),
	async load(e, t, n) {
		const r = await Vl.ADAPTER.fetch(e),
			i = ag(await r.arrayBuffer()).map((r) => kv(new Bh(r, u({ mipmap: Il.OFF, alphaMode: Rl.NO_PREMULTIPLIED_ALPHA, resolution: bh(e) }, t.data)), n, e));
		return 1 === i.length ? i[0] : i;
	},
	unload(e) {
		Array.isArray(e) ? e.forEach((e) => e.destroy(!0)) : e.destroy(!0);
	}
};
Sh.add(Eg);
const Tg = {
	extension: { type: _h.LoadParser, priority: dv.High },
	name: "loadKTX",
	test: (e) => iv(e, ".ktx"),
	async load(e, t, n) {
		const r = await Vl.ADAPTER.fetch(e),
			i = await r.arrayBuffer(),
			{ compressed: s, uncompressed: o, kvData: a } = Cg(e, i),
			l = null != s ? s : o,
			c = u({ mipmap: Il.OFF, alphaMode: Rl.NO_PREMULTIPLIED_ALPHA, resolution: bh(e) }, t.data),
			h = l.map((t) => {
				l === o && Object.assign(c, { type: t.type, format: t.format });
				const r = new Bh(t, c);
				return (r.ktxKeyValueData = a), kv(r, n, e);
			});
		return 1 === h.length ? h[0] : h;
	},
	unload(e) {
		Array.isArray(e) ? e.forEach((e) => e.destroy(!0)) : e.destroy(!0);
	}
};
Sh.add(Tg);
const kg = {
	extension: _h.ResolveParser,
	test: (e) => {
		const t = e.split("?")[0].split(".").pop();
		return ["basis", "ktx", "dds"].includes(t);
	},
	parse: (e) => {
		var t, n, r, i;
		if ("ktx" === e.split("?")[0].split(".").pop()) {
			const r = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
			if (r.some((t) => e.endsWith(t))) return { resolution: parseFloat(null != (n = null == (t = Vl.RETINA_PREFIX.exec(e)) ? void 0 : t[1]) ? n : "1"), format: r.find((t) => e.endsWith(t)), src: e };
		}
		return { resolution: parseFloat(null != (i = null == (r = Vl.RETINA_PREFIX.exec(e)) ? void 0 : r[1]) ? i : "1"), format: e.split(".").pop(), src: e };
	}
};
Sh.add(kg);
const Ag = new ed(),
	Mg = class {
		constructor(e) {
			this.renderer = e;
		}
		async image(e, t, n) {
			const r = new Image();
			return (r.src = await this.base64(e, t, n)), r;
		}
		async base64(e, t, n) {
			const r = this.canvas(e);
			if (void 0 !== r.toBlob)
				return new Promise((e, i) => {
					r.toBlob(
						(t) => {
							if (!t) return void i(new Error("ICanvas.toBlob failed!"));
							const n = new FileReader();
							(n.onload = () => e(n.result)), (n.onerror = i), n.readAsDataURL(t);
						},
						t,
						n
					);
				});
			if (void 0 !== r.toDataURL) return r.toDataURL(t, n);
			if (void 0 !== r.convertToBlob) {
				const e = await r.convertToBlob({ type: t, quality: n });
				return new Promise((t, n) => {
					const r = new FileReader();
					(r.onload = () => t(r.result)), (r.onerror = n), r.readAsDataURL(e);
				});
			}
			throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
		}
		canvas(e, t) {
			const { pixels: n, width: r, height: i, flipY: s } = this._rawPixels(e, t);
			s && Mg._flipY(n, r, i), Mg._unpremultiplyAlpha(n);
			const o = new dh(r, i, 1),
				a = new ImageData(new Uint8ClampedArray(n.buffer), r, i);
			return o.context.putImageData(a, 0, 0), o.canvas;
		}
		pixels(e, t) {
			const { pixels: n, width: r, height: i, flipY: s } = this._rawPixels(e, t);
			return s && Mg._flipY(n, r, i), Mg._unpremultiplyAlpha(n), n;
		}
		_rawPixels(e, t) {
			const n = this.renderer;
			if (!n) throw new Error("The Extract has already been destroyed");
			let r,
				i,
				s = !1,
				o = !1;
			if ((e && (e instanceof up ? (i = e) : ((i = n.generateTexture(e, { resolution: n.resolution, multisample: n.multisample })), (o = !0))), i)) {
				if (((r = i.baseTexture.resolution), (t = null != t ? t : i.frame), (s = !1), !o)) {
					n.renderTexture.bind(i);
					const e = i.framebuffer.glFramebuffers[n.CONTEXT_UID];
					e.blitFramebuffer && n.framebuffer.bind(e.blitFramebuffer);
				}
			} else (r = n.resolution), t || (((t = Ag).width = n.width / r), (t.height = n.height / r)), (s = !0), n.renderTexture.bind();
			const a = Math.round(t.width * r),
				l = Math.round(t.height * r),
				u = new Uint8Array(4 * a * l),
				c = n.gl;
			return c.readPixels(Math.round(t.x * r), Math.round(t.y * r), a, l, c.RGBA, c.UNSIGNED_BYTE, u), o && (null == i || i.destroy(!0)), { pixels: u, width: a, height: l, flipY: s };
		}
		destroy() {
			this.renderer = null;
		}
		static _flipY(e, t, n) {
			const r = t << 2,
				i = n >> 1,
				s = new Uint8Array(r);
			for (let o = 0; o < i; o++) {
				const t = o * r,
					i = (n - o - 1) * r;
				s.set(e.subarray(t, t + r)), e.copyWithin(t, i, i + r), e.set(s, i);
			}
		}
		static _unpremultiplyAlpha(e) {
			e instanceof Uint8ClampedArray && (e = new Uint8Array(e.buffer));
			const t = e.length;
			for (let n = 0; n < t; n += 4) {
				const t = e[n + 3];
				if (0 !== t) {
					const r = 255.001 / t;
					(e[n] = e[n] * r + 0.5), (e[n + 1] = e[n + 1] * r + 0.5), (e[n + 2] = e[n + 2] * r + 0.5);
				}
			}
		}
	};
let Ig = Mg;
(Ig.extension = { name: "extract", type: _h.RendererSystem }), Sh.add(Ig);
const Rg = {
	build(e) {
		const t = e.points;
		let n, r, i, s, o, a;
		if (e.type === Zh.CIRC) {
			const t = e.shape;
			(n = t.x), (r = t.y), (o = a = t.radius), (i = s = 0);
		} else if (e.type === Zh.ELIP) {
			const t = e.shape;
			(n = t.x), (r = t.y), (o = t.width), (a = t.height), (i = s = 0);
		} else {
			const t = e.shape,
				l = t.width / 2,
				u = t.height / 2;
			(n = t.x + l), (r = t.y + u), (o = a = Math.max(0, Math.min(t.radius, Math.min(l, u)))), (i = l - o), (s = u - a);
		}
		if (!(o >= 0 && a >= 0 && i >= 0 && s >= 0)) return void (t.length = 0);
		const l = Math.ceil(2.3 * Math.sqrt(o + a)),
			u = 8 * l + (i ? 4 : 0) + (s ? 4 : 0);
		if (((t.length = u), 0 === u)) return;
		if (0 === l) return (t.length = 8), (t[0] = t[6] = n + i), (t[1] = t[3] = r + s), (t[2] = t[4] = n - i), void (t[5] = t[7] = r - s);
		let c = 0,
			h = 4 * l + (i ? 2 : 0) + 2,
			d = h,
			p = u;
		{
			const e = i + o,
				a = s,
				l = n + e,
				u = n - e,
				f = r + a;
			if (((t[c++] = l), (t[c++] = f), (t[--h] = f), (t[--h] = u), s)) {
				const e = r - a;
				(t[d++] = u), (t[d++] = e), (t[--p] = e), (t[--p] = l);
			}
		}
		for (let f = 1; f < l; f++) {
			const e = (Math.PI / 2) * (f / l),
				u = i + Math.cos(e) * o,
				m = s + Math.sin(e) * a,
				v = n + u,
				g = n - u,
				y = r + m,
				b = r - m;
			(t[c++] = v), (t[c++] = y), (t[--h] = y), (t[--h] = g), (t[d++] = g), (t[d++] = b), (t[--p] = b), (t[--p] = v);
		}
		{
			const e = s + a,
				o = n + i,
				l = n - i,
				u = r + e,
				h = r - e;
			(t[c++] = o), (t[c++] = u), (t[--p] = h), (t[--p] = o), i && ((t[c++] = l), (t[c++] = u), (t[--p] = h), (t[--p] = l));
		}
	},
	triangulate(e, t) {
		const n = e.points,
			r = t.points,
			i = t.indices;
		if (0 === n.length) return;
		let s = r.length / 2;
		const o = s;
		let a, l;
		if (e.type !== Zh.RREC) {
			const t = e.shape;
			(a = t.x), (l = t.y);
		} else {
			const t = e.shape;
			(a = t.x + t.width / 2), (l = t.y + t.height / 2);
		}
		const u = e.matrix;
		r.push(e.matrix ? u.a * a + u.c * l + u.tx : a, e.matrix ? u.b * a + u.d * l + u.ty : l), s++, r.push(n[0], n[1]);
		for (let c = 2; c < n.length; c += 2) r.push(n[c], n[c + 1]), i.push(s++, o, s);
		i.push(o + 1, o, s);
	}
};
function Lg(e, t = !1) {
	const n = e.length;
	if (n < 6) return;
	let r = 0;
	for (let i = 0, s = e[n - 2], o = e[n - 1]; i < n; i += 2) {
		const t = e[i],
			n = e[i + 1];
		(r += (t - s) * (n + o)), (s = t), (o = n);
	}
	if ((!t && r > 0) || (t && r <= 0)) {
		const t = n / 2;
		for (let r = t + (t % 2); r < n; r += 2) {
			const t = n - r - 2,
				i = n - r - 1,
				s = r,
				o = r + 1;
			([e[t], e[s]] = [e[s], e[t]]), ([e[i], e[o]] = [e[o], e[i]]);
		}
	}
}
const Og = {
		build(e) {
			e.points = e.shape.points.slice();
		},
		triangulate(e, t) {
			let n = e.points;
			const r = e.holes,
				i = t.points,
				s = t.indices;
			if (n.length >= 6) {
				Lg(n, !1);
				const e = [];
				for (let i = 0; i < r.length; i++) {
					const t = r[i];
					Lg(t.points, !0), e.push(n.length / 2), (n = n.concat(t.points));
				}
				const t = Fu(n, e, 2);
				if (!t) return;
				const o = i.length / 2;
				for (let n = 0; n < t.length; n += 3) s.push(t[n] + o), s.push(t[n + 1] + o), s.push(t[n + 2] + o);
				for (let r = 0; r < n.length; r++) i.push(n[r]);
			}
		}
	},
	Pg = {
		build(e) {
			const t = e.shape,
				n = t.x,
				r = t.y,
				i = t.width,
				s = t.height,
				o = e.points;
			(o.length = 0), i >= 0 && s >= 0 && o.push(n, r, n + i, r, n + i, r + s, n, r + s);
		},
		triangulate(e, t) {
			const n = e.points,
				r = t.points;
			if (0 === n.length) return;
			const i = r.length / 2;
			r.push(n[0], n[1], n[2], n[3], n[6], n[7], n[4], n[5]), t.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3);
		}
	},
	Ng = {
		build(e) {
			Rg.build(e);
		},
		triangulate(e, t) {
			Rg.triangulate(e, t);
		}
	};
var Dg = ((e) => ((e.MITER = "miter"), (e.BEVEL = "bevel"), (e.ROUND = "round"), e))(Dg || {}),
	Bg = ((e) => ((e.BUTT = "butt"), (e.ROUND = "round"), (e.SQUARE = "square"), e))(Bg || {});
const Fg = {
		adaptive: !0,
		maxLength: 10,
		minSegments: 8,
		maxSegments: 2048,
		epsilon: 1e-4,
		_segmentsCount(e, t = 20) {
			if (!this.adaptive || !e || isNaN(e)) return t;
			let n = Math.ceil(e / this.maxLength);
			return n < this.minSegments ? (n = this.minSegments) : n > this.maxSegments && (n = this.maxSegments), n;
		}
	},
	Hg = Fg;
class Vg {
	static curveTo(e, t, n, r, i, s) {
		const o = s[s.length - 2],
			a = s[s.length - 1] - t,
			l = o - e,
			u = r - t,
			c = n - e,
			h = Math.abs(a * c - l * u);
		if (h < 1e-8 || 0 === i) return (s[s.length - 2] === e && s[s.length - 1] === t) || s.push(e, t), null;
		const d = a * a + l * l,
			p = u * u + c * c,
			f = a * u + l * c,
			m = (i * Math.sqrt(d)) / h,
			v = (i * Math.sqrt(p)) / h,
			g = (m * f) / d,
			y = (v * f) / p,
			b = m * c + v * l,
			x = m * u + v * a,
			_ = l * (v + g),
			w = a * (v + g),
			C = c * (m + y),
			S = u * (m + y);
		return { cx: b + e, cy: x + t, radius: i, startAngle: Math.atan2(w - x, _ - b), endAngle: Math.atan2(S - x, C - b), anticlockwise: l * u > c * a };
	}
	static arc(e, t, n, r, i, s, o, a, l) {
		const u = o - s,
			c = Fg._segmentsCount(Math.abs(u) * i, 40 * Math.ceil(Math.abs(u) / Xh)),
			h = u / (2 * c),
			d = 2 * h,
			p = Math.cos(h),
			f = Math.sin(h),
			m = c - 1,
			v = (m % 1) / m;
		for (let g = 0; g <= m; ++g) {
			const e = h + s + d * (g + v * g),
				t = Math.cos(e),
				o = -Math.sin(e);
			l.push((p * t + f * o) * i + n, (p * -o + f * t) * i + r);
		}
	}
}
class Ug {
	constructor() {
		this.reset();
	}
	begin(e, t, n) {
		this.reset(), (this.style = e), (this.start = t), (this.attribStart = n);
	}
	end(e, t) {
		(this.attribSize = t - this.attribStart), (this.size = e - this.start);
	}
	reset() {
		(this.style = null), (this.size = 0), (this.start = 0), (this.attribStart = 0), (this.attribSize = 0);
	}
}
class zg {
	static curveLength(e, t, n, r, i, s, o, a) {
		let l = 0,
			u = 0,
			c = 0,
			h = 0,
			d = 0,
			p = 0,
			f = 0,
			m = 0,
			v = 0,
			g = 0,
			y = 0,
			b = e,
			x = t;
		for (let _ = 1; _ <= 10; ++_) (u = _ / 10), (c = u * u), (h = c * u), (d = 1 - u), (p = d * d), (f = p * d), (m = f * e + 3 * p * u * n + 3 * d * c * i + h * o), (v = f * t + 3 * p * u * r + 3 * d * c * s + h * a), (g = b - m), (y = x - v), (b = m), (x = v), (l += Math.sqrt(g * g + y * y));
		return l;
	}
	static curveTo(e, t, n, r, i, s, o) {
		const a = o[o.length - 2],
			l = o[o.length - 1];
		o.length -= 2;
		const u = Fg._segmentsCount(zg.curveLength(a, l, e, t, n, r, i, s));
		let c = 0,
			h = 0,
			d = 0,
			p = 0,
			f = 0;
		o.push(a, l);
		for (let m = 1, v = 0; m <= u; ++m) (v = m / u), (c = 1 - v), (h = c * c), (d = h * c), (p = v * v), (f = p * v), o.push(d * a + 3 * h * v * e + 3 * c * p * n + f * i, d * l + 3 * h * v * t + 3 * c * p * r + f * s);
	}
}
function $g(e, t, n, r, i, s, o, a) {
	let l, u;
	o ? ((l = r), (u = -n)) : ((l = -r), (u = n));
	const c = e - n * i + l,
		h = t - r * i + u,
		d = e + n * s + l,
		p = t + r * s + u;
	return a.push(c, h, d, p), 2;
}
function jg(e, t, n, r, i, s, o, a) {
	const l = n - e,
		u = r - t;
	let c = Math.atan2(l, u),
		h = Math.atan2(i - e, s - t);
	a && c < h ? (c += 2 * Math.PI) : !a && c > h && (h += 2 * Math.PI);
	let d = c;
	const p = h - c,
		f = Math.abs(p),
		m = Math.sqrt(l * l + u * u),
		v = 1 + (((15 * f * Math.sqrt(m)) / Math.PI) >> 0),
		g = p / v;
	if (((d += g), a)) {
		o.push(e, t, n, r);
		for (let n = 1, r = d; n < v; n++, r += g) o.push(e, t, e + Math.sin(r) * m, t + Math.cos(r) * m);
		o.push(e, t, i, s);
	} else {
		o.push(n, r, e, t);
		for (let n = 1, r = d; n < v; n++, r += g) o.push(e + Math.sin(r) * m, t + Math.cos(r) * m, e, t);
		o.push(i, s, e, t);
	}
	return 2 * v;
}
function Wg(e, t) {
	e.lineStyle.native
		? (function (e, t) {
				let n = 0;
				const r = e.shape,
					i = e.points || r.points,
					s = r.type !== Zh.POLY || r.closeStroke;
				if (0 === i.length) return;
				const o = t.points,
					a = t.indices,
					l = i.length / 2,
					u = o.length / 2;
				let c = u;
				for (o.push(i[0], i[1]), n = 1; n < l; n++) o.push(i[2 * n], i[2 * n + 1]), a.push(c, c + 1), c++;
				s && a.push(c, u);
		  })(e, t)
		: (function (e, t) {
				const n = e.shape;
				let r = e.points || n.points.slice();
				const i = t.closePointEps;
				if (0 === r.length) return;
				const s = e.lineStyle,
					o = new Jh(r[0], r[1]),
					a = new Jh(r[r.length - 2], r[r.length - 1]),
					l = n.type !== Zh.POLY || n.closeStroke,
					u = Math.abs(o.x - a.x) < i && Math.abs(o.y - a.y) < i;
				if (l) {
					(r = r.slice()), u && (r.pop(), r.pop(), a.set(r[r.length - 2], r[r.length - 1]));
					const e = 0.5 * (o.x + a.x),
						t = 0.5 * (a.y + o.y);
					r.unshift(e, t), r.push(e, t);
				}
				const c = t.points,
					h = r.length / 2;
				let d = r.length;
				const p = c.length / 2,
					f = s.width / 2,
					m = f * f,
					v = s.miterLimit * s.miterLimit;
				let g = r[0],
					y = r[1],
					b = r[2],
					x = r[3],
					_ = 0,
					w = 0,
					C = -(y - x),
					S = g - b,
					E = 0,
					T = 0,
					k = Math.sqrt(C * C + S * S);
				(C /= k), (S /= k), (C *= f), (S *= f);
				const A = s.alignment,
					M = 2 * (1 - A),
					I = 2 * A;
				l || (s.cap === Bg.ROUND ? (d += jg(g - C * (M - I) * 0.5, y - S * (M - I) * 0.5, g - C * M, y - S * M, g + C * I, y + S * I, c, !0) + 2) : s.cap === Bg.SQUARE && (d += $g(g, y, C, S, M, I, !0, c))), c.push(g - C * M, y - S * M, g + C * I, y + S * I);
				for (let O = 1; O < h - 1; ++O) {
					(g = r[2 * (O - 1)]),
						(y = r[2 * (O - 1) + 1]),
						(b = r[2 * O]),
						(x = r[2 * O + 1]),
						(_ = r[2 * (O + 1)]),
						(w = r[2 * (O + 1) + 1]),
						(C = -(y - x)),
						(S = g - b),
						(k = Math.sqrt(C * C + S * S)),
						(C /= k),
						(S /= k),
						(C *= f),
						(S *= f),
						(E = -(x - w)),
						(T = b - _),
						(k = Math.sqrt(E * E + T * T)),
						(E /= k),
						(T /= k),
						(E *= f),
						(T *= f);
					const e = b - g,
						t = y - x,
						n = b - _,
						i = w - x,
						o = e * n + t * i,
						a = t * n - i * e,
						l = a < 0;
					if (Math.abs(a) < 0.001 * Math.abs(o)) {
						c.push(b - C * M, x - S * M, b + C * I, x + S * I), o >= 0 && (s.join === Dg.ROUND ? (d += jg(b, x, b - C * M, x - S * M, b - E * M, x - T * M, c, !1) + 4) : (d += 2), c.push(b - E * I, x - T * I, b + E * M, x + T * M));
						continue;
					}
					const u = (-C + g) * (-S + x) - (-C + b) * (-S + y),
						h = (-E + _) * (-T + x) - (-E + b) * (-T + w),
						p = (e * h - n * u) / a,
						A = (i * u - t * h) / a,
						R = (p - b) * (p - b) + (A - x) * (A - x),
						L = b + (p - b) * M,
						P = x + (A - x) * M,
						N = b - (p - b) * I,
						D = x - (A - x) * I,
						B = l ? M : I,
						F = R <= Math.min(e * e + t * t, n * n + i * i) + B * B * m;
					let H = s.join;
					if ((H === Dg.MITER && R / m > v && (H = Dg.BEVEL), F))
						switch (H) {
							case Dg.MITER:
								c.push(L, P, N, D);
								break;
							case Dg.BEVEL:
								l ? c.push(L, P, b + C * I, x + S * I, L, P, b + E * I, x + T * I) : c.push(b - C * M, x - S * M, N, D, b - E * M, x - T * M, N, D), (d += 2);
								break;
							case Dg.ROUND:
								l
									? (c.push(L, P, b + C * I, x + S * I), (d += jg(b, x, b + C * I, x + S * I, b + E * I, x + T * I, c, !0) + 4), c.push(L, P, b + E * I, x + T * I))
									: (c.push(b - C * M, x - S * M, N, D), (d += jg(b, x, b - C * M, x - S * M, b - E * M, x - T * M, c, !1) + 4), c.push(b - E * M, x - T * M, N, D));
						}
					else {
						switch ((c.push(b - C * M, x - S * M, b + C * I, x + S * I), H)) {
							case Dg.MITER:
								l ? c.push(N, D, N, D) : c.push(L, P, L, P), (d += 2);
								break;
							case Dg.ROUND:
								d += l ? jg(b, x, b + C * I, x + S * I, b + E * I, x + T * I, c, !0) + 2 : jg(b, x, b - C * M, x - S * M, b - E * M, x - T * M, c, !1) + 2;
						}
						c.push(b - E * M, x - T * M, b + E * I, x + T * I), (d += 2);
					}
				}
				(g = r[2 * (h - 2)]),
					(y = r[2 * (h - 2) + 1]),
					(b = r[2 * (h - 1)]),
					(x = r[2 * (h - 1) + 1]),
					(C = -(y - x)),
					(S = g - b),
					(k = Math.sqrt(C * C + S * S)),
					(C /= k),
					(S /= k),
					(C *= f),
					(S *= f),
					c.push(b - C * M, x - S * M, b + C * I, x + S * I),
					l || (s.cap === Bg.ROUND ? (d += jg(b - C * (M - I) * 0.5, x - S * (M - I) * 0.5, b - C * M, x - S * M, b + C * I, x + S * I, c, !1) + 2) : s.cap === Bg.SQUARE && (d += $g(b, x, C, S, M, I, !1, c)));
				const R = t.indices,
					L = Fg.epsilon * Fg.epsilon;
				for (let O = p; O < d + p - 2; ++O) (g = c[2 * O]), (y = c[2 * O + 1]), (b = c[2 * (O + 1)]), (x = c[2 * (O + 1) + 1]), (_ = c[2 * (O + 2)]), (w = c[2 * (O + 2) + 1]), Math.abs(g * (x - w) + b * (w - y) + _ * (y - x)) < L || R.push(O, O + 1, O + 2);
		  })(e, t);
}
class Gg {
	static curveLength(e, t, n, r, i, s) {
		const o = e - 2 * n + i,
			a = t - 2 * r + s,
			l = 2 * n - 2 * e,
			u = 2 * r - 2 * t,
			c = 4 * (o * o + a * a),
			h = 4 * (o * l + a * u),
			d = l * l + u * u,
			p = 2 * Math.sqrt(c + h + d),
			f = Math.sqrt(c),
			m = 2 * c * f,
			v = 2 * Math.sqrt(d),
			g = h / f;
		return (m * p + f * h * (p - v) + (4 * d * c - h * h) * Math.log((2 * f + g + p) / (g + v))) / (4 * m);
	}
	static curveTo(e, t, n, r, i) {
		const s = i[i.length - 2],
			o = i[i.length - 1],
			a = Fg._segmentsCount(Gg.curveLength(s, o, e, t, n, r));
		let l = 0,
			u = 0;
		for (let c = 1; c <= a; ++c) {
			const h = c / a;
			(l = s + (e - s) * h), (u = o + (t - o) * h), i.push(l + (e + (n - e) * h - l) * h, u + (t + (r - t) * h - u) * h);
		}
	}
}
const Yg = { [Zh.POLY]: Og, [Zh.CIRC]: Rg, [Zh.ELIP]: Rg, [Zh.RECT]: Pg, [Zh.RREC]: Ng },
	Xg = [],
	Kg = [];
class qg {
	constructor(e, t = null, n = null, r = null) {
		(this.points = []), (this.holes = []), (this.shape = e), (this.lineStyle = n), (this.fillStyle = t), (this.matrix = r), (this.type = e.type);
	}
	clone() {
		return new qg(this.shape, this.fillStyle, this.lineStyle, this.matrix);
	}
	destroy() {
		(this.shape = null), (this.holes.length = 0), (this.holes = null), (this.points.length = 0), (this.points = null), (this.lineStyle = null), (this.fillStyle = null);
	}
}
const Zg = new Jh(),
	Jg = class extends Yh {
		constructor() {
			super(),
				(this.closePointEps = 1e-4),
				(this.boundsPadding = 0),
				(this.uvsFloat32 = null),
				(this.indicesUint16 = null),
				(this.batchable = !1),
				(this.points = []),
				(this.colors = []),
				(this.uvs = []),
				(this.indices = []),
				(this.textureIds = []),
				(this.graphicsData = []),
				(this.drawCalls = []),
				(this.batchDirty = -1),
				(this.batches = []),
				(this.dirty = 0),
				(this.cacheDirty = -1),
				(this.clearDirty = 0),
				(this.shapeIndex = 0),
				(this._bounds = new Gf()),
				(this.boundsDirty = -1);
		}
		get bounds() {
			return this.updateBatches(), this.boundsDirty !== this.dirty && ((this.boundsDirty = this.dirty), this.calculateBounds()), this._bounds;
		}
		invalidate() {
			(this.boundsDirty = -1), this.dirty++, this.batchDirty++, (this.shapeIndex = 0), (this.points.length = 0), (this.colors.length = 0), (this.uvs.length = 0), (this.indices.length = 0), (this.textureIds.length = 0);
			for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Kg.push(this.drawCalls[e]);
			this.drawCalls.length = 0;
			for (let e = 0; e < this.batches.length; e++) {
				const t = this.batches[e];
				t.reset(), Xg.push(t);
			}
			this.batches.length = 0;
		}
		clear() {
			return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, (this.graphicsData.length = 0)), this;
		}
		drawShape(e, t = null, n = null, r = null) {
			const i = new qg(e, t, n, r);
			return this.graphicsData.push(i), this.dirty++, this;
		}
		drawHole(e, t = null) {
			if (!this.graphicsData.length) return null;
			const n = new qg(e, null, null, t),
				r = this.graphicsData[this.graphicsData.length - 1];
			return (n.lineStyle = r.lineStyle), r.holes.push(n), this.dirty++, this;
		}
		destroy() {
			super.destroy();
			for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
			(this.points.length = 0),
				(this.points = null),
				(this.colors.length = 0),
				(this.colors = null),
				(this.uvs.length = 0),
				(this.uvs = null),
				(this.indices.length = 0),
				(this.indices = null),
				this.indexBuffer.destroy(),
				(this.indexBuffer = null),
				(this.graphicsData.length = 0),
				(this.graphicsData = null),
				(this.drawCalls.length = 0),
				(this.drawCalls = null),
				(this.batches.length = 0),
				(this.batches = null),
				(this._bounds = null);
		}
		containsPoint(e) {
			const t = this.graphicsData;
			for (let n = 0; n < t.length; ++n) {
				const r = t[n];
				if (r.fillStyle.visible && r.shape && (r.matrix ? r.matrix.applyInverse(e, Zg) : Zg.copyFrom(e), r.shape.contains(Zg.x, Zg.y))) {
					let e = !1;
					if (r.holes)
						for (let t = 0; t < r.holes.length; t++) {
							if (r.holes[t].shape.contains(Zg.x, Zg.y)) {
								e = !0;
								break;
							}
						}
					if (!e) return !0;
				}
			}
			return !1;
		}
		updateBatches() {
			if (!this.graphicsData.length) return void (this.batchable = !0);
			if (!this.validateBatching()) return;
			this.cacheDirty = this.dirty;
			const e = this.uvs,
				t = this.graphicsData;
			let n = null,
				r = null;
			this.batches.length > 0 && ((n = this.batches[this.batches.length - 1]), (r = n.style));
			for (let a = this.shapeIndex; a < t.length; a++) {
				this.shapeIndex++;
				const i = t[a],
					s = i.fillStyle,
					o = i.lineStyle;
				Yg[i.type].build(i), i.matrix && this.transformPoints(i.points, i.matrix), (s.visible || o.visible) && this.processHoles(i.holes);
				for (let t = 0; t < 2; t++) {
					const a = 0 === t ? s : o;
					if (!a.visible) continue;
					const l = a.texture.baseTexture,
						u = this.indices.length,
						c = this.points.length / 2;
					(l.wrapMode = Ml.REPEAT), 0 === t ? this.processFill(i) : this.processLine(i);
					const h = this.points.length / 2 - c;
					0 !== h && (n && !this._compareStyles(r, a) && (n.end(u, c), (n = null)), n || ((n = Xg.pop() || new Ug()), n.begin(a, u, c), this.batches.push(n), (r = a)), this.addUvs(this.points, e, a.texture, c, h, a.matrix));
				}
			}
			const i = this.indices.length,
				s = this.points.length / 2;
			if ((n && n.end(i, s), 0 === this.batches.length)) return void (this.batchable = !0);
			const o = s > 65535;
			this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : (this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices)),
				(this.batchable = this.isBatchable()),
				this.batchable ? this.packBatches() : this.buildDrawCalls();
		}
		_compareStyles(e, t) {
			return !(!e || !t) && e.texture.baseTexture === t.texture.baseTexture && e.color + e.alpha === t.color + t.alpha && !!e.native == !!t.native;
		}
		validateBatching() {
			if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
			for (let e = 0, t = this.graphicsData.length; e < t; e++) {
				const t = this.graphicsData[e],
					n = t.fillStyle,
					r = t.lineStyle;
				if (n && !n.texture.baseTexture.valid) return !1;
				if (r && !r.texture.baseTexture.valid) return !1;
			}
			return !0;
		}
		packBatches() {
			this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs));
			const e = this.batches;
			for (let t = 0, n = e.length; t < n; t++) {
				const n = e[t];
				for (let e = 0; e < n.size; e++) {
					const t = n.start + e;
					this.indicesUint16[t] = this.indicesUint16[t] - n.attribStart;
				}
			}
		}
		isBatchable() {
			if (this.points.length > 131070) return !1;
			const e = this.batches;
			for (let t = 0; t < e.length; t++) if (e[t].style.native) return !1;
			return this.points.length < 2 * Jg.BATCHABLE_SIZE;
		}
		buildDrawCalls() {
			let e = ++Bh._globalBatch;
			for (let c = 0; c < this.drawCalls.length; c++) this.drawCalls[c].texArray.clear(), Kg.push(this.drawCalls[c]);
			this.drawCalls.length = 0;
			const t = this.colors,
				n = this.textureIds;
			let r = Kg.pop();
			r || ((r = new Fh()), (r.texArray = new jd())), (r.texArray.count = 0), (r.start = 0), (r.size = 0), (r.type = Cl.TRIANGLES);
			let i = 0,
				s = null,
				o = 0,
				a = !1,
				l = Cl.TRIANGLES,
				u = 0;
			this.drawCalls.push(r);
			for (let c = 0; c < this.batches.length; c++) {
				const h = this.batches[c],
					d = 8,
					p = h.style,
					f = p.texture.baseTexture;
				a !== !!p.native && ((a = !!p.native), (l = a ? Cl.LINES : Cl.TRIANGLES), (s = null), (i = d), e++),
					s !== f &&
						((s = f),
						f._batchEnabled !== e &&
							(i === d && (e++, (i = 0), r.size > 0 && ((r = Kg.pop()), r || ((r = new Fh()), (r.texArray = new jd())), this.drawCalls.push(r)), (r.start = u), (r.size = 0), (r.texArray.count = 0), (r.type = l)),
							(f.touched = 1),
							(f._batchEnabled = e),
							(f._batchLocation = i),
							(f.wrapMode = Ml.REPEAT),
							(r.texArray.elements[r.texArray.count++] = f),
							i++)),
					(r.size += h.size),
					(u += h.size),
					(o = f._batchLocation),
					this.addColors(t, p.color, p.alpha, h.attribSize, h.attribStart),
					this.addTextureIds(n, o, h.attribSize, h.attribStart);
			}
			(Bh._globalBatch = e), this.packAttributes();
		}
		packAttributes() {
			const e = this.points,
				t = this.uvs,
				n = this.colors,
				r = this.textureIds,
				i = new ArrayBuffer(3 * e.length * 4),
				s = new Float32Array(i),
				o = new Uint32Array(i);
			let a = 0;
			for (let l = 0; l < e.length / 2; l++) (s[a++] = e[2 * l]), (s[a++] = e[2 * l + 1]), (s[a++] = t[2 * l]), (s[a++] = t[2 * l + 1]), (o[a++] = n[l]), (s[a++] = r[l]);
			this._buffer.update(i), this._indexBuffer.update(this.indicesUint16);
		}
		processFill(e) {
			if (e.holes.length) Og.triangulate(e, this);
			else {
				Yg[e.type].triangulate(e, this);
			}
		}
		processLine(e) {
			Wg(e, this);
			for (let t = 0; t < e.holes.length; t++) Wg(e.holes[t], this);
		}
		processHoles(e) {
			for (let t = 0; t < e.length; t++) {
				const n = e[t];
				Yg[n.type].build(n), n.matrix && this.transformPoints(n.points, n.matrix);
			}
		}
		calculateBounds() {
			const e = this._bounds;
			e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
		}
		transformPoints(e, t) {
			for (let n = 0; n < e.length / 2; n++) {
				const r = e[2 * n],
					i = e[2 * n + 1];
				(e[2 * n] = t.a * r + t.c * i + t.tx), (e[2 * n + 1] = t.b * r + t.d * i + t.ty);
			}
		}
		addColors(e, t, n, r, i = 0) {
			const s = Wc.shared.setValue(t).toLittleEndianNumber(),
				o = Wc.shared.setValue(s).toPremultiplied(n);
			e.length = Math.max(e.length, i + r);
			for (let a = 0; a < r; a++) e[i + a] = o;
		}
		addTextureIds(e, t, n, r = 0) {
			e.length = Math.max(e.length, r + n);
			for (let i = 0; i < n; i++) e[r + i] = t;
		}
		addUvs(e, t, n, r, i, s = null) {
			let o = 0;
			const a = t.length,
				l = n.frame;
			for (; o < i; ) {
				let n = e[2 * (r + o)],
					i = e[2 * (r + o) + 1];
				if (s) {
					const e = s.a * n + s.c * i + s.tx;
					(i = s.b * n + s.d * i + s.ty), (n = e);
				}
				o++, t.push(n / l.width, i / l.height);
			}
			const u = n.baseTexture;
			(l.width < u.width || l.height < u.height) && this.adjustUvs(t, n, a, i);
		}
		adjustUvs(e, t, n, r) {
			const i = t.baseTexture,
				s = 1e-6,
				o = n + 2 * r,
				a = t.frame,
				l = a.width / i.width,
				u = a.height / i.height;
			let c = a.x / a.width,
				h = a.y / a.height,
				d = Math.floor(e[n] + s),
				p = Math.floor(e[n + 1] + s);
			for (let f = n + 2; f < o; f += 2) (d = Math.min(d, Math.floor(e[f] + s))), (p = Math.min(p, Math.floor(e[f + 1] + s)));
			(c -= d), (h -= p);
			for (let f = n; f < o; f += 2) (e[f] = (e[f] + c) * l), (e[f + 1] = (e[f + 1] + h) * u);
		}
	};
let Qg = Jg;
Qg.BATCHABLE_SIZE = 100;
class ey {
	constructor() {
		(this.color = 16777215), (this.alpha = 1), (this.texture = lp.WHITE), (this.matrix = null), (this.visible = !1), this.reset();
	}
	clone() {
		const e = new ey();
		return (e.color = this.color), (e.alpha = this.alpha), (e.texture = this.texture), (e.matrix = this.matrix), (e.visible = this.visible), e;
	}
	reset() {
		(this.color = 16777215), (this.alpha = 1), (this.texture = lp.WHITE), (this.matrix = null), (this.visible = !1);
	}
	destroy() {
		(this.texture = null), (this.matrix = null);
	}
}
class ty extends ey {
	constructor() {
		super(...arguments), (this.width = 0), (this.alignment = 0.5), (this.native = !1), (this.cap = Bg.BUTT), (this.join = Dg.MITER), (this.miterLimit = 10);
	}
	clone() {
		const e = new ty();
		return (
			(e.color = this.color),
			(e.alpha = this.alpha),
			(e.texture = this.texture),
			(e.matrix = this.matrix),
			(e.visible = this.visible),
			(e.width = this.width),
			(e.alignment = this.alignment),
			(e.native = this.native),
			(e.cap = this.cap),
			(e.join = this.join),
			(e.miterLimit = this.miterLimit),
			e
		);
	}
	reset() {
		super.reset(), (this.color = 0), (this.alignment = 0.5), (this.width = 0), (this.native = !1);
	}
}
const ny = {},
	ry = class extends Jf {
		constructor(e = null) {
			super(),
				(this.shader = null),
				(this.pluginName = "batch"),
				(this.currentPath = null),
				(this.batches = []),
				(this.batchTint = -1),
				(this.batchDirty = -1),
				(this.vertexData = null),
				(this._fillStyle = new ey()),
				(this._lineStyle = new ty()),
				(this._matrix = null),
				(this._holeMode = !1),
				(this.state = Mh.for2d()),
				(this._geometry = e || new Qg()),
				this._geometry.refCount++,
				(this._transformID = -1),
				(this._tintColor = new Wc(16777215)),
				(this.blendMode = wl.NORMAL);
		}
		get geometry() {
			return this._geometry;
		}
		clone() {
			return this.finishPoly(), new ry(this._geometry);
		}
		set blendMode(e) {
			this.state.blendMode = e;
		}
		get blendMode() {
			return this.state.blendMode;
		}
		get tint() {
			return this._tintColor.value;
		}
		set tint(e) {
			this._tintColor.setValue(e);
		}
		get fill() {
			return this._fillStyle;
		}
		get line() {
			return this._lineStyle;
		}
		lineStyle(e = null, t = 0, n, r = 0.5, i = !1) {
			return "number" == typeof e && (e = { width: e, color: t, alpha: n, alignment: r, native: i }), this.lineTextureStyle(e);
		}
		lineTextureStyle(e) {
			const t = { width: 0, texture: lp.WHITE, color: (null == e ? void 0 : e.texture) ? 16777215 : 0, matrix: null, alignment: 0.5, native: !1, cap: Bg.BUTT, join: Dg.MITER, miterLimit: 10 };
			(e = Object.assign(t, e)), this.normalizeColor(e), this.currentPath && this.startPoly();
			const n = e.width > 0 && e.alpha > 0;
			return n ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()), Object.assign(this._lineStyle, { visible: n }, e)) : this._lineStyle.reset(), this;
		}
		startPoly() {
			if (this.currentPath) {
				const e = this.currentPath.points,
					t = this.currentPath.points.length;
				t > 2 && (this.drawShape(this.currentPath), (this.currentPath = new rd()), (this.currentPath.closeStroke = !1), this.currentPath.points.push(e[t - 2], e[t - 1]));
			} else (this.currentPath = new rd()), (this.currentPath.closeStroke = !1);
		}
		finishPoly() {
			this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), (this.currentPath = null)) : (this.currentPath.points.length = 0));
		}
		moveTo(e, t) {
			return this.startPoly(), (this.currentPath.points[0] = e), (this.currentPath.points[1] = t), this;
		}
		lineTo(e, t) {
			this.currentPath || this.moveTo(0, 0);
			const n = this.currentPath.points,
				r = n[n.length - 2],
				i = n[n.length - 1];
			return (r === e && i === t) || n.push(e, t), this;
		}
		_initCurve(e = 0, t = 0) {
			this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [e, t]) : this.moveTo(e, t);
		}
		quadraticCurveTo(e, t, n, r) {
			this._initCurve();
			const i = this.currentPath.points;
			return 0 === i.length && this.moveTo(0, 0), Gg.curveTo(e, t, n, r, i), this;
		}
		bezierCurveTo(e, t, n, r, i, s) {
			return this._initCurve(), zg.curveTo(e, t, n, r, i, s, this.currentPath.points), this;
		}
		arcTo(e, t, n, r, i) {
			this._initCurve(e, t);
			const s = this.currentPath.points,
				o = Vg.curveTo(e, t, n, r, i, s);
			if (o) {
				const { cx: e, cy: t, radius: n, startAngle: r, endAngle: i, anticlockwise: s } = o;
				this.arc(e, t, n, r, i, s);
			}
			return this;
		}
		arc(e, t, n, r, i, s = !1) {
			if (r === i) return this;
			!s && i <= r ? (i += Xh) : s && r <= i && (r += Xh);
			if (0 === i - r) return this;
			const o = e + Math.cos(r) * n,
				a = t + Math.sin(r) * n,
				l = this._geometry.closePointEps;
			let u = this.currentPath ? this.currentPath.points : null;
			if (u) {
				const e = Math.abs(u[u.length - 2] - o),
					t = Math.abs(u[u.length - 1] - a);
				(e < l && t < l) || u.push(o, a);
			} else this.moveTo(o, a), (u = this.currentPath.points);
			return Vg.arc(o, a, e, t, n, r, i, s, u), this;
		}
		beginFill(e = 0, t) {
			return this.beginTextureFill({ texture: lp.WHITE, color: e, alpha: t });
		}
		normalizeColor(e) {
			var t;
			const n = Wc.shared.setValue(null != (t = e.color) ? t : 0);
			(e.color = n.toNumber()), null != e.alpha || (e.alpha = n.alpha);
		}
		beginTextureFill(e) {
			const t = { texture: lp.WHITE, color: 16777215, matrix: null };
			(e = Object.assign(t, e)), this.normalizeColor(e), this.currentPath && this.startPoly();
			const n = e.alpha > 0;
			return n ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()), Object.assign(this._fillStyle, { visible: n }, e)) : this._fillStyle.reset(), this;
		}
		endFill() {
			return this.finishPoly(), this._fillStyle.reset(), this;
		}
		drawRect(e, t, n, r) {
			return this.drawShape(new ed(e, t, n, r));
		}
		drawRoundedRect(e, t, n, r, i) {
			return this.drawShape(new id(e, t, n, r, i));
		}
		drawCircle(e, t, n) {
			return this.drawShape(new td(e, t, n));
		}
		drawEllipse(e, t, n, r) {
			return this.drawShape(new nd(e, t, n, r));
		}
		drawPolygon(...e) {
			let t,
				n = !0;
			const r = e[0];
			r.points ? ((n = r.closeStroke), (t = r.points)) : (t = Array.isArray(e[0]) ? e[0] : e);
			const i = new rd(t);
			return (i.closeStroke = n), this.drawShape(i), this;
		}
		drawShape(e) {
			return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
		}
		clear() {
			return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, (this._matrix = null), (this._holeMode = !1), (this.currentPath = null), this;
		}
		isFastRect() {
			const e = this._geometry.graphicsData;
			return !(1 !== e.length || e[0].shape.type !== Zh.RECT || e[0].matrix || e[0].holes.length || (e[0].lineStyle.visible && e[0].lineStyle.width));
		}
		_render(e) {
			this.finishPoly();
			const t = this._geometry;
			t.updateBatches(), t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
		}
		_populateBatches() {
			const e = this._geometry,
				t = this.blendMode,
				n = e.batches.length;
			(this.batchTint = -1), (this._transformID = -1), (this.batchDirty = e.batchDirty), (this.batches.length = n), (this.vertexData = new Float32Array(e.points));
			for (let r = 0; r < n; r++) {
				const n = e.batches[r],
					i = n.style.color,
					s = new Float32Array(this.vertexData.buffer, 4 * n.attribStart * 2, 2 * n.attribSize),
					o = new Float32Array(e.uvsFloat32.buffer, 4 * n.attribStart * 2, 2 * n.attribSize),
					a = { vertexData: s, blendMode: t, indices: new Uint16Array(e.indicesUint16.buffer, 2 * n.start, n.size), uvs: o, _batchRGB: Wc.shared.setValue(i).toRgbArray(), _tintRGB: i, _texture: n.style.texture, alpha: n.style.alpha, worldAlpha: 1 };
				this.batches[r] = a;
			}
		}
		_renderBatched(e) {
			if (this.batches.length) {
				e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
				for (let t = 0, n = this.batches.length; t < n; t++) {
					const n = this.batches[t];
					(n.worldAlpha = this.worldAlpha * n.alpha), e.plugins[this.pluginName].render(n);
				}
			}
		}
		_renderDirect(e) {
			const t = this._resolveDirectShader(e),
				n = this._geometry,
				r = this.worldAlpha,
				i = t.uniforms,
				s = n.drawCalls;
			(i.translationMatrix = this.transform.worldTransform), Wc.shared.setValue(this._tintColor).premultiply(r).toArray(i.tint), e.shader.bind(t), e.geometry.bind(n, t), e.state.set(this.state);
			for (let o = 0, a = s.length; o < a; o++) this._renderDrawCallDirect(e, n.drawCalls[o]);
		}
		_renderDrawCallDirect(e, t) {
			const { texArray: n, type: r, size: i, start: s } = t,
				o = n.count;
			for (let a = 0; a < o; a++) e.texture.bind(n.elements[a], a);
			e.geometry.draw(r, i, s);
		}
		_resolveDirectShader(e) {
			let t = this.shader;
			const n = this.pluginName;
			if (!t) {
				if (!ny[n]) {
					const { maxTextures: t } = e.plugins[n],
						r = new Int32Array(t);
					for (let e = 0; e < t; e++) r[e] = e;
					const i = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new sd(), default: Ud.from({ uSamplers: r }, !0) },
						s = e.plugins[n]._shader.program;
					ny[n] = new zd(s, i);
				}
				t = ny[n];
			}
			return t;
		}
		_calculateBounds() {
			this.finishPoly();
			const e = this._geometry;
			if (!e.graphicsData.length) return;
			const { minX: t, minY: n, maxX: r, maxY: i } = e.bounds;
			this._bounds.addFrame(this.transform, t, n, r, i);
		}
		containsPoint(e) {
			return this.worldTransform.applyInverse(e, ry._TEMP_POINT), this._geometry.containsPoint(ry._TEMP_POINT);
		}
		calculateTints() {
			if (this.batchTint !== this.tint) {
				this.batchTint = this._tintColor.toNumber();
				for (let e = 0; e < this.batches.length; e++) {
					const t = this.batches[e];
					t._tintRGB = Wc.shared.setValue(this._tintColor).multiply(t._batchRGB).toLittleEndianNumber();
				}
			}
		}
		calculateVertices() {
			const e = this.transform._worldID;
			if (this._transformID === e) return;
			this._transformID = e;
			const t = this.transform.worldTransform,
				n = t.a,
				r = t.b,
				i = t.c,
				s = t.d,
				o = t.tx,
				a = t.ty,
				l = this._geometry.points,
				u = this.vertexData;
			let c = 0;
			for (let h = 0; h < l.length; h += 2) {
				const e = l[h],
					t = l[h + 1];
				(u[c++] = n * e + i * t + o), (u[c++] = s * t + r * e + a);
			}
		}
		closePath() {
			const e = this.currentPath;
			return e && ((e.closeStroke = !0), this.finishPoly()), this;
		}
		setMatrix(e) {
			return (this._matrix = e), this;
		}
		beginHole() {
			return this.finishPoly(), (this._holeMode = !0), this;
		}
		endHole() {
			return this.finishPoly(), (this._holeMode = !1), this;
		}
		destroy(e) {
			this._geometry.refCount--,
				0 === this._geometry.refCount && this._geometry.dispose(),
				(this._matrix = null),
				(this.currentPath = null),
				this._lineStyle.destroy(),
				(this._lineStyle = null),
				this._fillStyle.destroy(),
				(this._fillStyle = null),
				(this._geometry = null),
				(this.shader = null),
				(this.vertexData = null),
				(this.batches.length = 0),
				(this.batches = null),
				super.destroy(e);
		}
	};
let iy = ry;
(iy.curves = Fg), (iy._TEMP_POINT = new Jh());
const sy = { buildPoly: Og, buildCircle: Rg, buildRectangle: Pg, buildRoundedRectangle: Ng, buildLine: Wg, ArcUtils: Vg, BezierUtils: zg, QuadraticUtils: Gg, BatchPart: Ug, FILL_COMMANDS: Yg, BATCH_POOL: Xg, DRAW_CALL_POOL: Kg };
class oy {
	constructor(e, t) {
		(this.uvBuffer = e), (this.uvMatrix = t), (this.data = null), (this._bufferUpdateId = -1), (this._textureUpdateId = -1), (this._updateID = 0);
	}
	update(e) {
		if (!e && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
		(this._bufferUpdateId = this.uvBuffer._updateID), (this._textureUpdateId = this.uvMatrix._updateID);
		const t = this.uvBuffer.data;
		(this.data && this.data.length === t.length) || (this.data = new Float32Array(t.length)), this.uvMatrix.multiplyUvs(t, this.data), this._updateID++;
	}
}
const ay = new Jh(),
	ly = new rd(),
	uy = class extends Jf {
		constructor(e, t, n, r = Cl.TRIANGLES) {
			super(),
				(this.geometry = e),
				(this.shader = t),
				(this.state = n || Mh.for2d()),
				(this.drawMode = r),
				(this.start = 0),
				(this.size = 0),
				(this.uvs = null),
				(this.indices = null),
				(this.vertexData = new Float32Array(1)),
				(this.vertexDirty = -1),
				(this._transformID = -1),
				(this._roundPixels = Vl.ROUND_PIXELS),
				(this.batchUvs = null);
		}
		get geometry() {
			return this._geometry;
		}
		set geometry(e) {
			this._geometry !== e && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), (this._geometry = e), this._geometry && this._geometry.refCount++, (this.vertexDirty = -1));
		}
		get uvBuffer() {
			return this.geometry.buffers[1];
		}
		get verticesBuffer() {
			return this.geometry.buffers[0];
		}
		set material(e) {
			this.shader = e;
		}
		get material() {
			return this.shader;
		}
		set blendMode(e) {
			this.state.blendMode = e;
		}
		get blendMode() {
			return this.state.blendMode;
		}
		set roundPixels(e) {
			this._roundPixels !== e && (this._transformID = -1), (this._roundPixels = e);
		}
		get roundPixels() {
			return this._roundPixels;
		}
		get tint() {
			return "tint" in this.shader ? this.shader.tint : null;
		}
		set tint(e) {
			this.shader.tint = e;
		}
		get tintValue() {
			return this.shader.tintValue;
		}
		get texture() {
			return "texture" in this.shader ? this.shader.texture : null;
		}
		set texture(e) {
			this.shader.texture = e;
		}
		_render(e) {
			const t = this.geometry.buffers[0].data;
			this.shader.batchable && this.drawMode === Cl.TRIANGLES && t.length < 2 * uy.BATCHABLE_SIZE ? this._renderToBatch(e) : this._renderDefault(e);
		}
		_renderDefault(e) {
			const t = this.shader;
			(t.alpha = this.worldAlpha),
				t.update && t.update(),
				e.batch.flush(),
				(t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)),
				e.shader.bind(t),
				e.state.set(this.state),
				e.geometry.bind(this.geometry, t),
				e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
		}
		_renderToBatch(e) {
			const t = this.geometry,
				n = this.shader;
			n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), (this.indices = t.indexBuffer.data), (this._tintRGB = n._tintRGB), (this._texture = n.texture);
			const r = this.material.pluginName;
			e.batch.setObjectRenderer(e.plugins[r]), e.plugins[r].render(this);
		}
		calculateVertices() {
			const e = this.geometry.buffers[0],
				t = e.data,
				n = e._updateID;
			if (n === this.vertexDirty && this._transformID === this.transform._worldID) return;
			(this._transformID = this.transform._worldID), this.vertexData.length !== t.length && (this.vertexData = new Float32Array(t.length));
			const r = this.transform.worldTransform,
				i = r.a,
				s = r.b,
				o = r.c,
				a = r.d,
				l = r.tx,
				u = r.ty,
				c = this.vertexData;
			for (let h = 0; h < c.length / 2; h++) {
				const e = t[2 * h],
					n = t[2 * h + 1];
				(c[2 * h] = i * e + o * n + l), (c[2 * h + 1] = s * e + a * n + u);
			}
			if (this._roundPixels) {
				const e = Vl.RESOLUTION;
				for (let t = 0; t < c.length; ++t) c[t] = Math.round(c[t] * e) / e;
			}
			this.vertexDirty = n;
		}
		calculateUvs() {
			const e = this.geometry.buffers[1],
				t = this.shader;
			t.uvMatrix.isSimple ? (this.uvs = e.data) : (this.batchUvs || (this.batchUvs = new oy(e, t.uvMatrix)), this.batchUvs.update(), (this.uvs = this.batchUvs.data));
		}
		_calculateBounds() {
			this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
		}
		containsPoint(e) {
			if (!this.getBounds().contains(e.x, e.y)) return !1;
			this.worldTransform.applyInverse(e, ay);
			const t = this.geometry.getBuffer("aVertexPosition").data,
				n = ly.points,
				r = this.geometry.getIndex().data,
				i = r.length,
				s = 4 === this.drawMode ? 3 : 1;
			for (let o = 0; o + 2 < i; o += s) {
				const e = 2 * r[o],
					i = 2 * r[o + 1],
					s = 2 * r[o + 2];
				if (((n[0] = t[e]), (n[1] = t[e + 1]), (n[2] = t[i]), (n[3] = t[i + 1]), (n[4] = t[s]), (n[5] = t[s + 1]), ly.contains(ay.x, ay.y))) return !0;
			}
			return !1;
		}
		destroy(e) {
			super.destroy(e), this._cachedTexture && (this._cachedTexture.destroy(), (this._cachedTexture = null)), (this.geometry = null), (this.shader = null), (this.state = null), (this.uvs = null), (this.indices = null), (this.vertexData = null);
		}
	};
let cy = uy;
cy.BATCHABLE_SIZE = 100;
class hy extends Gh {
	constructor(e, t, n) {
		super();
		const r = new Vh(e),
			i = new Vh(t, !0),
			s = new Vh(n, !0, !0);
		this.addAttribute("aVertexPosition", r, 2, !1, Tl.FLOAT).addAttribute("aTextureCoord", i, 2, !1, Tl.FLOAT).addIndex(s), (this._updateId = -1);
	}
	get vertexDirtyId() {
		return this.buffers[0]._updateID;
	}
}
class dy extends zd {
	constructor(e, t) {
		const n = { uSampler: e, alpha: 1, uTextureMatrix: sd.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) };
		(t = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, t)).uniforms && Object.assign(n, t.uniforms),
			super(
				t.program ||
					Hd.from(
						"attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n        vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n",
						"varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n        gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"
					),
				n
			),
			(this._colorDirty = !1),
			(this.uvMatrix = new Cp(e)),
			(this.batchable = void 0 === t.program),
			(this.pluginName = t.pluginName),
			(this._tintColor = new Wc(t.tint)),
			(this._tintRGB = this._tintColor.toLittleEndianNumber()),
			(this._colorDirty = !0),
			(this.alpha = t.alpha);
	}
	get texture() {
		return this.uniforms.uSampler;
	}
	set texture(e) {
		this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), (this.uniforms.uSampler = e), (this.uvMatrix.texture = e));
	}
	set alpha(e) {
		e !== this._alpha && ((this._alpha = e), (this._colorDirty = !0));
	}
	get alpha() {
		return this._alpha;
	}
	set tint(e) {
		e !== this.tint && (this._tintColor.setValue(e), (this._tintRGB = this._tintColor.toLittleEndianNumber()), (this._colorDirty = !0));
	}
	get tint() {
		return this._tintColor.value;
	}
	get tintValue() {
		return this._tintColor.toNumber();
	}
	update() {
		if (this._colorDirty) {
			this._colorDirty = !1;
			const e = this.texture.baseTexture.alphaMode;
			Wc.shared.setValue(this._tintColor).premultiply(this._alpha, e).toArray(this.uniforms.uColor);
		}
		this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
	}
}
class py extends hy {
	constructor(e = 100, t = 100, n = 10, r = 10) {
		super(), (this.segWidth = n), (this.segHeight = r), (this.width = e), (this.height = t), this.build();
	}
	build() {
		const e = this.segWidth * this.segHeight,
			t = [],
			n = [],
			r = [],
			i = this.segWidth - 1,
			s = this.segHeight - 1,
			o = this.width / i,
			a = this.height / s;
		for (let u = 0; u < e; u++) {
			const e = u % this.segWidth,
				r = (u / this.segWidth) | 0;
			t.push(e * o, r * a), n.push(e / i, r / s);
		}
		const l = i * s;
		for (let u = 0; u < l; u++) {
			const e = u % i,
				t = (u / i) | 0,
				n = t * this.segWidth + e,
				s = t * this.segWidth + e + 1,
				o = (t + 1) * this.segWidth + e,
				a = (t + 1) * this.segWidth + e + 1;
			r.push(n, s, o, s, a, o);
		}
		(this.buffers[0].data = new Float32Array(t)), (this.buffers[1].data = new Float32Array(n)), (this.indexBuffer.data = new Uint16Array(r)), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
	}
}
class fy extends hy {
	constructor(e = 200, t, n = 0) {
		super(new Float32Array(4 * t.length), new Float32Array(4 * t.length), new Uint16Array(6 * (t.length - 1))), (this.points = t), (this._width = e), (this.textureScale = n), this.build();
	}
	get width() {
		return this._width;
	}
	build() {
		const e = this.points;
		if (!e) return;
		const t = this.getBuffer("aVertexPosition"),
			n = this.getBuffer("aTextureCoord"),
			r = this.getIndex();
		if (e.length < 1) return;
		t.data.length / 4 !== e.length && ((t.data = new Float32Array(4 * e.length)), (n.data = new Float32Array(4 * e.length)), (r.data = new Uint16Array(6 * (e.length - 1))));
		const i = n.data,
			s = r.data;
		(i[0] = 0), (i[1] = 0), (i[2] = 0), (i[3] = 1);
		let o = 0,
			a = e[0];
		const l = this._width * this.textureScale,
			u = e.length;
		for (let h = 0; h < u; h++) {
			const t = 4 * h;
			if (this.textureScale > 0) {
				const t = a.x - e[h].x,
					n = a.y - e[h].y,
					r = Math.sqrt(t * t + n * n);
				(a = e[h]), (o += r / l);
			} else o = h / (u - 1);
			(i[t] = o), (i[t + 1] = 0), (i[t + 2] = o), (i[t + 3] = 1);
		}
		let c = 0;
		for (let h = 0; h < u - 1; h++) {
			const e = 2 * h;
			(s[c++] = e), (s[c++] = e + 1), (s[c++] = e + 2), (s[c++] = e + 2), (s[c++] = e + 1), (s[c++] = e + 3);
		}
		n.update(), r.update(), this.updateVertices();
	}
	updateVertices() {
		const e = this.points;
		if (e.length < 1) return;
		let t,
			n = e[0],
			r = 0,
			i = 0;
		const s = this.buffers[0].data,
			o = e.length,
			a = this.textureScale > 0 ? (this.textureScale * this._width) / 2 : this._width / 2;
		for (let l = 0; l < o; l++) {
			const o = e[l],
				u = 4 * l;
			(t = l < e.length - 1 ? e[l + 1] : o), (i = -(t.x - n.x)), (r = t.y - n.y);
			const c = Math.sqrt(r * r + i * i);
			c < 1e-6 ? ((r = 0), (i = 0)) : ((r /= c), (i /= c), (r *= a), (i *= a)), (s[u] = o.x + r), (s[u + 1] = o.y + i), (s[u + 2] = o.x - r), (s[u + 3] = o.y - i), (n = o);
		}
		this.buffers[0].update();
	}
	update() {
		this.textureScale > 0 ? this.build() : this.updateVertices();
	}
}
class my extends cy {
	constructor(e, t, n) {
		super(new py(e.width, e.height, t, n), new dy(lp.WHITE)), (this.texture = e), (this.autoResize = !0);
	}
	textureUpdated() {
		this._textureID = this.shader.texture._updateID;
		const e = this.geometry,
			{ width: t, height: n } = this.shader.texture;
		!this.autoResize || (e.width === t && e.height === n) || ((e.width = this.shader.texture.width), (e.height = this.shader.texture.height), e.build());
	}
	set texture(e) {
		this.shader.texture !== e && ((this.shader.texture = e), (this._textureID = -1), e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
	}
	get texture() {
		return this.shader.texture;
	}
	_render(e) {
		this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(e);
	}
	destroy(e) {
		this.shader.texture.off("update", this.textureUpdated, this), super.destroy(e);
	}
}
class vy extends my {
	constructor(e, t, n, r, i) {
		var s, o, a, l, u, c, h, d;
		super(lp.WHITE, 4, 4),
			(this._origWidth = e.orig.width),
			(this._origHeight = e.orig.height),
			(this._width = this._origWidth),
			(this._height = this._origHeight),
			(this._leftWidth = null != (o = null != t ? t : null == (s = e.defaultBorders) ? void 0 : s.left) ? o : 10),
			(this._rightWidth = null != (l = null != r ? r : null == (a = e.defaultBorders) ? void 0 : a.right) ? l : 10),
			(this._topHeight = null != (c = null != n ? n : null == (u = e.defaultBorders) ? void 0 : u.top) ? c : 10),
			(this._bottomHeight = null != (d = null != i ? i : null == (h = e.defaultBorders) ? void 0 : h.bottom) ? d : 10),
			(this.texture = e);
	}
	textureUpdated() {
		(this._textureID = this.shader.texture._updateID), this._refresh();
	}
	get vertices() {
		return this.geometry.getBuffer("aVertexPosition").data;
	}
	set vertices(e) {
		this.geometry.getBuffer("aVertexPosition").data = e;
	}
	updateHorizontalVertices() {
		const e = this.vertices,
			t = this._getMinScale();
		(e[9] = e[11] = e[13] = e[15] = this._topHeight * t), (e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * t), (e[25] = e[27] = e[29] = e[31] = this._height);
	}
	updateVerticalVertices() {
		const e = this.vertices,
			t = this._getMinScale();
		(e[2] = e[10] = e[18] = e[26] = this._leftWidth * t), (e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * t), (e[6] = e[14] = e[22] = e[30] = this._width);
	}
	_getMinScale() {
		const e = this._leftWidth + this._rightWidth,
			t = this._width > e ? 1 : this._width / e,
			n = this._topHeight + this._bottomHeight,
			r = this._height > n ? 1 : this._height / n;
		return Math.min(t, r);
	}
	get width() {
		return this._width;
	}
	set width(e) {
		(this._width = e), this._refresh();
	}
	get height() {
		return this._height;
	}
	set height(e) {
		(this._height = e), this._refresh();
	}
	get leftWidth() {
		return this._leftWidth;
	}
	set leftWidth(e) {
		(this._leftWidth = e), this._refresh();
	}
	get rightWidth() {
		return this._rightWidth;
	}
	set rightWidth(e) {
		(this._rightWidth = e), this._refresh();
	}
	get topHeight() {
		return this._topHeight;
	}
	set topHeight(e) {
		(this._topHeight = e), this._refresh();
	}
	get bottomHeight() {
		return this._bottomHeight;
	}
	set bottomHeight(e) {
		(this._bottomHeight = e), this._refresh();
	}
	_refresh() {
		const e = this.texture,
			t = this.geometry.buffers[1].data;
		(this._origWidth = e.orig.width), (this._origHeight = e.orig.height);
		const n = 1 / this._origWidth,
			r = 1 / this._origHeight;
		(t[0] = t[8] = t[16] = t[24] = 0),
			(t[1] = t[3] = t[5] = t[7] = 0),
			(t[6] = t[14] = t[22] = t[30] = 1),
			(t[25] = t[27] = t[29] = t[31] = 1),
			(t[2] = t[10] = t[18] = t[26] = n * this._leftWidth),
			(t[4] = t[12] = t[20] = t[28] = 1 - n * this._rightWidth),
			(t[9] = t[11] = t[13] = t[15] = r * this._topHeight),
			(t[17] = t[19] = t[21] = t[23] = 1 - r * this._bottomHeight),
			this.updateHorizontalVertices(),
			this.updateVerticalVertices(),
			this.geometry.buffers[0].update(),
			this.geometry.buffers[1].update();
	}
}
class gy extends cy {
	constructor(e = lp.EMPTY, t, n, r, i) {
		const s = new hy(t, n, r);
		s.getBuffer("aVertexPosition").static = !1;
		super(s, new dy(e), null, i), (this.autoUpdate = !0);
	}
	get vertices() {
		return this.geometry.getBuffer("aVertexPosition").data;
	}
	set vertices(e) {
		this.geometry.getBuffer("aVertexPosition").data = e;
	}
	_render(e) {
		this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(e);
	}
}
class yy extends cy {
	constructor(e, t, n = 0) {
		const r = new fy(e.height, t, n),
			i = new dy(e);
		n > 0 && (e.baseTexture.wrapMode = Ml.REPEAT), super(r, i), (this.autoUpdate = !0);
	}
	_render(e) {
		const t = this.geometry;
		(this.autoUpdate || t._width !== this.shader.texture.height) && ((t._width = this.shader.texture.height), t.update()), super._render(e);
	}
}
class by {
	constructor(e) {
		(this.maxItemsPerFrame = e), (this.itemsLeft = 0);
	}
	beginFrame() {
		this.itemsLeft = this.maxItemsPerFrame;
	}
	allowedToUpload() {
		return this.itemsLeft-- > 0;
	}
}
function xy(e, t) {
	var n;
	let r = !1;
	if (null == (n = null == e ? void 0 : e._textures) ? void 0 : n.length)
		for (let i = 0; i < e._textures.length; i++)
			if (e._textures[i] instanceof lp) {
				const n = e._textures[i].baseTexture;
				t.includes(n) || (t.push(n), (r = !0));
			}
	return r;
}
function _y(e, t) {
	if (e.baseTexture instanceof Bh) {
		const n = e.baseTexture;
		return t.includes(n) || t.push(n), !0;
	}
	return !1;
}
function wy(e, t) {
	if (e._texture && e._texture instanceof lp) {
		const n = e._texture.baseTexture;
		return t.includes(n) || t.push(n), !0;
	}
	return !1;
}
function Cy(e, t) {
	return t instanceof Sm && (t.updateText(!0), !0);
}
function Sy(e, t) {
	if (t instanceof bm) {
		const e = t.toFontString();
		return vm.measureFont(e), !0;
	}
	return !1;
}
function Ey(e, t) {
	if (e instanceof Sm) {
		t.includes(e.style) || t.push(e.style), t.includes(e) || t.push(e);
		const n = e._texture.baseTexture;
		return t.includes(n) || t.push(n), !0;
	}
	return !1;
}
function Ty(e, t) {
	return e instanceof bm && (t.includes(e) || t.push(e), !0);
}
const ky = class {
	constructor(e) {
		(this.limiter = new by(ky.uploadsPerFrame)),
			(this.renderer = e),
			(this.uploadHookHelper = null),
			(this.queue = []),
			(this.addHooks = []),
			(this.uploadHooks = []),
			(this.completes = []),
			(this.ticking = !1),
			(this.delayedTick = () => {
				this.queue && this.prepareItems();
			}),
			this.registerFindHook(Ey),
			this.registerFindHook(Ty),
			this.registerFindHook(xy),
			this.registerFindHook(_y),
			this.registerFindHook(wy),
			this.registerUploadHook(Cy),
			this.registerUploadHook(Sy);
	}
	upload(e) {
		return new Promise((t) => {
			e && this.add(e), this.queue.length ? (this.completes.push(t), this.ticking || ((this.ticking = !0), df.system.addOnce(this.tick, this, uf.UTILITY))) : t();
		});
	}
	tick() {
		setTimeout(this.delayedTick, 0);
	}
	prepareItems() {
		for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
			const e = this.queue[0];
			let t = !1;
			if (e && !e._destroyed)
				for (let n = 0, r = this.uploadHooks.length; n < r; n++)
					if (this.uploadHooks[n](this.uploadHookHelper, e)) {
						this.queue.shift(), (t = !0);
						break;
					}
			t || this.queue.shift();
		}
		if (this.queue.length) df.system.addOnce(this.tick, this, uf.UTILITY);
		else {
			this.ticking = !1;
			const e = this.completes.slice(0);
			this.completes.length = 0;
			for (let t = 0, n = e.length; t < n; t++) e[t]();
		}
	}
	registerFindHook(e) {
		return e && this.addHooks.push(e), this;
	}
	registerUploadHook(e) {
		return e && this.uploadHooks.push(e), this;
	}
	add(e) {
		for (let t = 0, n = this.addHooks.length; t < n && !this.addHooks[t](e, this.queue); t++);
		if (e instanceof Jf) for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
		return this;
	}
	destroy() {
		this.ticking && df.system.remove(this.tick, this), (this.ticking = !1), (this.addHooks = null), (this.uploadHooks = null), (this.renderer = null), (this.completes = null), (this.queue = null), (this.limiter = null), (this.uploadHookHelper = null);
	}
};
let Ay = ky;
function My(e, t) {
	return t instanceof Bh && (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t), !0);
}
function Iy(e, t) {
	if (!(t instanceof iy)) return !1;
	const { geometry: n } = t;
	t.finishPoly(), n.updateBatches();
	const { batches: r } = n;
	for (let i = 0; i < r.length; i++) {
		const { texture: t } = r[i].style;
		t && My(e, t.baseTexture);
	}
	return n.batchable || e.geometry.bind(n, t._resolveDirectShader(e)), !0;
}
function Ry(e, t) {
	return e instanceof iy && (t.push(e), !0);
}
(Ay.uploadsPerFrame = 4),
	Object.defineProperties(Vl, {
		UPLOADS_PER_FRAME: {
			get: () => Ay.uploadsPerFrame,
			set(e) {
				fc("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), (Ay.uploadsPerFrame = e);
			}
		}
	});
class Ly extends Ay {
	constructor(e) {
		super(e), (this.uploadHookHelper = this.renderer), this.registerFindHook(Ry), this.registerUploadHook(My), this.registerUploadHook(Iy);
	}
}
(Ly.extension = { name: "prepare", type: _h.RendererSystem }), Sh.add(Ly);
class Oy {
	constructor(e) {
		(this.maxMilliseconds = e), (this.frameStart = 0);
	}
	beginFrame() {
		this.frameStart = Date.now();
	}
	allowedToUpload() {
		return Date.now() - this.frameStart < this.maxMilliseconds;
	}
}
class Py extends tm {
	constructor(e, t = !0) {
		super(e[0] instanceof lp ? e[0] : e[0].texture),
			(this._textures = null),
			(this._durations = null),
			(this._autoUpdate = t),
			(this._isConnectedToTicker = !1),
			(this.animationSpeed = 1),
			(this.loop = !0),
			(this.updateAnchor = !1),
			(this.onComplete = null),
			(this.onFrameChange = null),
			(this.onLoop = null),
			(this._currentTime = 0),
			(this._playing = !1),
			(this._previousFrame = null),
			(this.textures = e);
	}
	stop() {
		this._playing && ((this._playing = !1), this._autoUpdate && this._isConnectedToTicker && (df.shared.remove(this.update, this), (this._isConnectedToTicker = !1)));
	}
	play() {
		this._playing || ((this._playing = !0), this._autoUpdate && !this._isConnectedToTicker && (df.shared.add(this.update, this, uf.HIGH), (this._isConnectedToTicker = !0)));
	}
	gotoAndStop(e) {
		this.stop(), (this.currentFrame = e);
	}
	gotoAndPlay(e) {
		(this.currentFrame = e), this.play();
	}
	update(e) {
		if (!this._playing) return;
		const t = this.animationSpeed * e,
			n = this.currentFrame;
		if (null !== this._durations) {
			let n = (this._currentTime % 1) * this._durations[this.currentFrame];
			for (n += (t / 60) * 1e3; n < 0; ) this._currentTime--, (n += this._durations[this.currentFrame]);
			const r = Math.sign(this.animationSpeed * e);
			for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame]; ) (n -= this._durations[this.currentFrame] * r), (this._currentTime += r);
			this._currentTime += n / this._durations[this.currentFrame];
		} else this._currentTime += t;
		this._currentTime < 0 && !this.loop
			? (this.gotoAndStop(0), this.onComplete && this.onComplete())
			: this._currentTime >= this._textures.length && !this.loop
			? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete())
			: n !== this.currentFrame && (this.loop && this.onLoop && ((this.animationSpeed > 0 && this.currentFrame < n) || (this.animationSpeed < 0 && this.currentFrame > n)) && this.onLoop(), this.updateTexture());
	}
	updateTexture() {
		const e = this.currentFrame;
		this._previousFrame !== e &&
			((this._previousFrame = e),
			(this._texture = this._textures[e]),
			(this._textureID = -1),
			(this._textureTrimmedID = -1),
			(this._cachedTint = 16777215),
			(this.uvs = this._texture._uvs.uvsFloat32),
			this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor),
			this.onFrameChange && this.onFrameChange(this.currentFrame));
	}
	destroy(e) {
		this.stop(), super.destroy(e), (this.onComplete = null), (this.onFrameChange = null), (this.onLoop = null);
	}
	static fromFrames(e) {
		const t = [];
		for (let n = 0; n < e.length; ++n) t.push(lp.from(e[n]));
		return new Py(t);
	}
	static fromImages(e) {
		const t = [];
		for (let n = 0; n < e.length; ++n) t.push(lp.from(e[n]));
		return new Py(t);
	}
	get totalFrames() {
		return this._textures.length;
	}
	get textures() {
		return this._textures;
	}
	set textures(e) {
		if (e[0] instanceof lp) (this._textures = e), (this._durations = null);
		else {
			(this._textures = []), (this._durations = []);
			for (let t = 0; t < e.length; t++) this._textures.push(e[t].texture), this._durations.push(e[t].time);
		}
		(this._previousFrame = null), this.gotoAndStop(0), this.updateTexture();
	}
	get currentFrame() {
		let e = Math.floor(this._currentTime) % this._textures.length;
		return e < 0 && (e += this._textures.length), e;
	}
	set currentFrame(e) {
		if (e < 0 || e > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${e}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
		const t = this.currentFrame;
		(this._currentTime = e), t !== this.currentFrame && this.updateTexture();
	}
	get playing() {
		return this._playing;
	}
	get autoUpdate() {
		return this._autoUpdate;
	}
	set autoUpdate(e) {
		e !== this._autoUpdate &&
			((this._autoUpdate = e), !this._autoUpdate && this._isConnectedToTicker ? (df.shared.remove(this.update, this), (this._isConnectedToTicker = !1)) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (df.shared.add(this.update, this), (this._isConnectedToTicker = !0)));
	}
}
const Ny = class {
	constructor(e, t, n = null) {
		(this.linkedSheets = []), (this._texture = e instanceof lp ? e : null), (this.baseTexture = e instanceof Bh ? e : this._texture.baseTexture), (this.textures = {}), (this.animations = {}), (this.data = t);
		const r = this.baseTexture.resource;
		(this.resolution = this._updateResolution(n || (r ? r.url : null))), (this._frames = this.data.frames), (this._frameKeys = Object.keys(this._frames)), (this._batchIndex = 0), (this._callback = null);
	}
	_updateResolution(e = null) {
		const { scale: t } = this.data.meta;
		let n = bh(e, null);
		return null === n && (n = parseFloat(null != t ? t : "1")), 1 !== n && this.baseTexture.setResolution(n), n;
	}
	parse() {
		return new Promise((e) => {
			(this._callback = e), (this._batchIndex = 0), this._frameKeys.length <= Ny.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
		});
	}
	_processFrames(e) {
		let t = e;
		const n = Ny.BATCH_SIZE;
		for (; t - e < n && t < this._frameKeys.length; ) {
			const e = this._frameKeys[t],
				n = this._frames[e],
				r = n.frame;
			if (r) {
				let t = null,
					i = null;
				const s = !1 !== n.trimmed && n.sourceSize ? n.sourceSize : n.frame,
					o = new ed(0, 0, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution);
				(t = n.rotated
					? new ed(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.h) / this.resolution, Math.floor(r.w) / this.resolution)
					: new ed(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution)),
					!1 !== n.trimmed && n.spriteSourceSize && (i = new ed(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution)),
					(this.textures[e] = new lp(this.baseTexture, t, o, i, n.rotated ? 2 : 0, n.anchor, n.borders)),
					lp.addToCache(this.textures[e], e);
			}
			t++;
		}
	}
	_processAnimations() {
		const e = this.data.animations || {};
		for (const t in e) {
			this.animations[t] = [];
			for (let n = 0; n < e[t].length; n++) {
				const r = e[t][n];
				this.animations[t].push(this.textures[r]);
			}
		}
	}
	_parseComplete() {
		const e = this._callback;
		(this._callback = null), (this._batchIndex = 0), e.call(this, this.textures);
	}
	_nextBatch() {
		this._processFrames(this._batchIndex * Ny.BATCH_SIZE),
			this._batchIndex++,
			setTimeout(() => {
				this._batchIndex * Ny.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
			}, 0);
	}
	destroy(e = !1) {
		var t;
		for (const n in this.textures) this.textures[n].destroy();
		(this._frames = null), (this._frameKeys = null), (this.data = null), (this.textures = null), e && (null == (t = this._texture) || t.destroy(), this.baseTexture.destroy()), (this._texture = null), (this.baseTexture = null), (this.linkedSheets = []);
	}
};
let Dy = Ny;
Dy.BATCH_SIZE = 1e3;
const By = ["jpg", "png", "jpeg", "avif", "webp"];
function Fy(e, t, n) {
	const r = {};
	if (
		(e.forEach((e) => {
			r[e] = t;
		}),
		Object.keys(t.textures).forEach((e) => {
			r[e] = t.textures[e];
		}),
		!n)
	) {
		const n = dc.dirname(e[0]);
		t.linkedSheets.forEach((e, i) => {
			const s = Fy([`${n}/${t.data.meta.related_multi_packs[i]}`], e, !0);
			Object.assign(r, s);
		});
	}
	return r;
}
const Hy = {
	extension: _h.Asset,
	cache: { test: (e) => e instanceof Dy, getCacheableAssets: (e, t) => Fy(e, t, !1) },
	resolver: {
		test: (e) => {
			const t = e.split("?")[0].split("."),
				n = t.pop(),
				r = t.pop();
			return "json" === n && By.includes(r);
		},
		parse: (e) => {
			var t, n;
			const r = e.split(".");
			return { resolution: parseFloat(null != (n = null == (t = Vl.RETINA_PREFIX.exec(e)) ? void 0 : t[1]) ? n : "1"), format: r[r.length - 2], src: e };
		}
	},
	loader: {
		name: "spritesheetLoader",
		extension: { type: _h.LoadParser, priority: dv.Normal },
		testParse: async (e, t) => ".json" === dc.extname(t.src).toLowerCase() && !!e.frames,
		async parse(e, t, n) {
			var r, i;
			let s = dc.dirname(t.src);
			s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
			let o = s + e.meta.image;
			o = ov(o, t.src);
			const a = (await n.load([o]))[o],
				l = new Dy(a.baseTexture, e, t.src);
			await l.parse();
			const u = null == (r = null == e ? void 0 : e.meta) ? void 0 : r.related_multi_packs;
			if (Array.isArray(u)) {
				const e = [];
				for (const o of u) {
					if ("string" != typeof o) continue;
					let r = s + o;
					(null == (i = t.data) ? void 0 : i.ignoreMultiPack) || ((r = ov(r, t.src)), e.push(n.load({ src: r, data: { ignoreMultiPack: !0 } })));
				}
				const r = await Promise.all(e);
				(l.linkedSheets = r),
					r.forEach((e) => {
						e.linkedSheets = [l].concat(l.linkedSheets.filter((t) => t !== e));
					});
			}
			return l;
		},
		unload(e) {
			e.destroy(!0);
		}
	}
};
Sh.add(Hy);
class Vy {
	constructor() {
		(this.info = []), (this.common = []), (this.page = []), (this.char = []), (this.kerning = []), (this.distanceField = []);
	}
}
class Uy {
	static test(e) {
		return "string" == typeof e && e.startsWith("info face=");
	}
	static parse(e) {
		const t = e.match(/^[a-z]+\s+.+$/gm),
			n = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
		for (const i in t) {
			const e = t[i].match(/^[a-z]+/gm)[0],
				r = t[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
				s = {};
			for (const t in r) {
				const e = r[t].split("="),
					n = e[0],
					i = e[1].replace(/"/gm, ""),
					o = parseFloat(i),
					a = isNaN(o) ? i : o;
				s[n] = a;
			}
			n[e].push(s);
		}
		const r = new Vy();
		return (
			n.info.forEach((e) => r.info.push({ face: e.face, size: parseInt(e.size, 10) })),
			n.common.forEach((e) => r.common.push({ lineHeight: parseInt(e.lineHeight, 10) })),
			n.page.forEach((e) => r.page.push({ id: parseInt(e.id, 10), file: e.file })),
			n.char.forEach((e) =>
				r.char.push({ id: parseInt(e.id, 10), page: parseInt(e.page, 10), x: parseInt(e.x, 10), y: parseInt(e.y, 10), width: parseInt(e.width, 10), height: parseInt(e.height, 10), xoffset: parseInt(e.xoffset, 10), yoffset: parseInt(e.yoffset, 10), xadvance: parseInt(e.xadvance, 10) })
			),
			n.kerning.forEach((e) => r.kerning.push({ first: parseInt(e.first, 10), second: parseInt(e.second, 10), amount: parseInt(e.amount, 10) })),
			n.distanceField.forEach((e) => r.distanceField.push({ distanceRange: parseInt(e.distanceRange, 10), fieldType: e.fieldType })),
			r
		);
	}
}
class zy {
	static test(e) {
		const t = e;
		return "getElementsByTagName" in t && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face");
	}
	static parse(e) {
		const t = new Vy(),
			n = e.getElementsByTagName("info"),
			r = e.getElementsByTagName("common"),
			i = e.getElementsByTagName("page"),
			s = e.getElementsByTagName("char"),
			o = e.getElementsByTagName("kerning"),
			a = e.getElementsByTagName("distanceField");
		for (let l = 0; l < n.length; l++) t.info.push({ face: n[l].getAttribute("face"), size: parseInt(n[l].getAttribute("size"), 10) });
		for (let l = 0; l < r.length; l++) t.common.push({ lineHeight: parseInt(r[l].getAttribute("lineHeight"), 10) });
		for (let l = 0; l < i.length; l++) t.page.push({ id: parseInt(i[l].getAttribute("id"), 10) || 0, file: i[l].getAttribute("file") });
		for (let l = 0; l < s.length; l++) {
			const e = s[l];
			t.char.push({
				id: parseInt(e.getAttribute("id"), 10),
				page: parseInt(e.getAttribute("page"), 10) || 0,
				x: parseInt(e.getAttribute("x"), 10),
				y: parseInt(e.getAttribute("y"), 10),
				width: parseInt(e.getAttribute("width"), 10),
				height: parseInt(e.getAttribute("height"), 10),
				xoffset: parseInt(e.getAttribute("xoffset"), 10),
				yoffset: parseInt(e.getAttribute("yoffset"), 10),
				xadvance: parseInt(e.getAttribute("xadvance"), 10)
			});
		}
		for (let l = 0; l < o.length; l++) t.kerning.push({ first: parseInt(o[l].getAttribute("first"), 10), second: parseInt(o[l].getAttribute("second"), 10), amount: parseInt(o[l].getAttribute("amount"), 10) });
		for (let l = 0; l < a.length; l++) t.distanceField.push({ fieldType: a[l].getAttribute("fieldType"), distanceRange: parseInt(a[l].getAttribute("distanceRange"), 10) });
		return t;
	}
}
class $y {
	static test(e) {
		return !("string" != typeof e || !e.includes("<font>")) && zy.test(Vl.ADAPTER.parseXML(e));
	}
	static parse(e) {
		return zy.parse(Vl.ADAPTER.parseXML(e));
	}
}
const jy = [Uy, zy, $y];
function Wy(e) {
	for (let t = 0; t < jy.length; t++) if (jy[t].test(e)) return jy[t];
	return null;
}
function Gy(e, t, n, r, i, s, o) {
	const a = n.text,
		l = n.fontProperties;
	t.translate(r, i), t.scale(s, s);
	const u = o.strokeThickness / 2,
		c = -o.strokeThickness / 2;
	if (
		((t.font = o.toFontString()),
		(t.lineWidth = o.strokeThickness),
		(t.textBaseline = o.textBaseline),
		(t.lineJoin = o.lineJoin),
		(t.miterLimit = o.miterLimit),
		(t.fillStyle = (function (e, t, n, r, i, s) {
			const o = n.fill;
			if (!Array.isArray(o)) return o;
			if (1 === o.length) return o[0];
			let a;
			const l = n.dropShadow ? n.dropShadowDistance : 0,
				u = n.padding || 0,
				c = e.width / r - l - 2 * u,
				h = e.height / r - l - 2 * u,
				d = o.slice(),
				p = n.fillGradientStops.slice();
			if (!p.length) {
				const e = d.length + 1;
				for (let t = 1; t < e; ++t) p.push(t / e);
			}
			if ((d.unshift(o[0]), p.unshift(0), d.push(o[o.length - 1]), p.push(1), n.fillGradientType === pm.LINEAR_VERTICAL)) {
				a = t.createLinearGradient(c / 2, u, c / 2, h + u);
				let e = 0;
				const r = (s.fontProperties.fontSize + n.strokeThickness) / h;
				for (let t = 0; t < i.length; t++) {
					const n = s.lineHeight * t;
					for (let t = 0; t < d.length; t++) {
						let i = 0;
						i = "number" == typeof p[t] ? p[t] : t / d.length;
						const s = n / h + i * r;
						let o = Math.max(e, s);
						(o = Math.min(o, 1)), a.addColorStop(o, d[t]), (e = o);
					}
				}
			} else {
				a = t.createLinearGradient(u, h / 2, c + u, h / 2);
				const e = d.length + 1;
				let n = 1;
				for (let t = 0; t < d.length; t++) {
					let r;
					(r = "number" == typeof p[t] ? p[t] : n / e), a.addColorStop(r, d[t]), n++;
				}
			}
			return a;
		})(e, t, o, s, [a], n)),
		(t.strokeStyle = o.stroke),
		o.dropShadow)
	) {
		const e = o.dropShadowColor,
			n = o.dropShadowBlur * s,
			r = o.dropShadowDistance * s;
		(t.shadowColor = Wc.shared.setValue(e).setAlpha(o.dropShadowAlpha).toRgbaString()), (t.shadowBlur = n), (t.shadowOffsetX = Math.cos(o.dropShadowAngle) * r), (t.shadowOffsetY = Math.sin(o.dropShadowAngle) * r);
	} else (t.shadowColor = "black"), (t.shadowBlur = 0), (t.shadowOffsetX = 0), (t.shadowOffsetY = 0);
	o.stroke && o.strokeThickness && t.strokeText(a, u, c + n.lineHeight - l.descent), o.fill && t.fillText(a, u, c + n.lineHeight - l.descent), t.setTransform(1, 0, 0, 1, 0, 0), (t.fillStyle = "rgba(0, 0, 0, 0)");
}
function Yy(e) {
	return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0);
}
function Xy(e) {
	return Array.from ? Array.from(e) : e.split("");
}
const Ky = class {
	constructor(e, t, n) {
		var r, i;
		const [s] = e.info,
			[o] = e.common,
			[a] = e.page,
			[l] = e.distanceField,
			u = bh(a.file),
			c = {};
		(this._ownsTextures = n), (this.font = s.face), (this.size = s.size), (this.lineHeight = o.lineHeight / u), (this.chars = {}), (this.pageTextures = c);
		for (let h = 0; h < e.page.length; h++) {
			const { id: n, file: r } = e.page[h];
			(c[n] = t instanceof Array ? t[h] : t[r]), (null == l ? void 0 : l.fieldType) && "none" !== l.fieldType && ((c[n].baseTexture.alphaMode = Rl.NO_PREMULTIPLIED_ALPHA), (c[n].baseTexture.mipmap = Il.OFF));
		}
		for (let h = 0; h < e.char.length; h++) {
			const { id: t, page: n } = e.char[h];
			let { x: r, y: i, width: s, height: o, xoffset: a, yoffset: l, xadvance: d } = e.char[h];
			(r /= u), (i /= u), (s /= u), (o /= u), (a /= u), (l /= u), (d /= u);
			const p = new ed(r + c[n].frame.x / u, i + c[n].frame.y / u, s, o);
			this.chars[t] = { xOffset: a, yOffset: l, xAdvance: d, kerning: {}, texture: new lp(c[n].baseTexture, p), page: n };
		}
		for (let h = 0; h < e.kerning.length; h++) {
			let { first: t, second: n, amount: r } = e.kerning[h];
			(t /= u), (n /= u), (r /= u), this.chars[n] && (this.chars[n].kerning[t] = r);
		}
		(this.distanceFieldRange = null == l ? void 0 : l.distanceRange), (this.distanceFieldType = null != (i = null == (r = null == l ? void 0 : l.fieldType) ? void 0 : r.toLowerCase()) ? i : "none");
	}
	destroy() {
		for (const e in this.chars) this.chars[e].texture.destroy(), (this.chars[e].texture = null);
		for (const e in this.pageTextures) this._ownsTextures && this.pageTextures[e].destroy(!0), (this.pageTextures[e] = null);
		(this.chars = null), (this.pageTextures = null);
	}
	static install(e, t, n) {
		let r;
		if (e instanceof Vy) r = e;
		else {
			const t = Wy(e);
			if (!t) throw new Error("Unrecognized data format for font.");
			r = t.parse(e);
		}
		t instanceof lp && (t = [t]);
		const i = new Ky(r, t, n);
		return (Ky.available[i.font] = i), i;
	}
	static uninstall(e) {
		const t = Ky.available[e];
		if (!t) throw new Error(`No font found named '${e}'`);
		t.destroy(), delete Ky.available[e];
	}
	static from(e, t, n) {
		if (!e) throw new Error("[BitmapFont] Property `name` is required.");
		const r = Object.assign({}, Ky.defaultOptions, n),
			{ chars: i, padding: s, resolution: o, textureWidth: a, textureHeight: l } = r,
			c = h(r, ["chars", "padding", "resolution", "textureWidth", "textureHeight"]),
			d = (function (e) {
				"string" == typeof e && (e = [e]);
				const t = [];
				for (let n = 0, r = e.length; n < r; n++) {
					const r = e[n];
					if (Array.isArray(r)) {
						if (2 !== r.length) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
						const e = r[0].charCodeAt(0),
							n = r[1].charCodeAt(0);
						if (n < e) throw new Error("[BitmapFont]: Invalid character range.");
						for (let r = e, i = n; r <= i; r++) t.push(String.fromCharCode(r));
					} else t.push(...Xy(r));
				}
				if (0 === t.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
				return t;
			})(i),
			p = t instanceof bm ? t : new bm(t),
			f = a,
			m = new Vy();
		(m.info[0] = { face: p.fontFamily, size: p.fontSize }), (m.common[0] = { lineHeight: p.fontSize });
		let v,
			g,
			y,
			b = 0,
			x = 0,
			_ = 0;
		const w = [];
		for (let h = 0; h < d.length; h++) {
			v || ((v = Vl.ADAPTER.createCanvas()), (v.width = a), (v.height = l), (g = v.getContext("2d")), (y = new Bh(v, u({ resolution: o }, c))), w.push(new lp(y)), m.page.push({ id: w.length - 1, file: "" }));
			const e = d[h],
				t = vm.measureText(e, p, !1, v),
				n = t.width,
				r = Math.ceil(t.height),
				i = Math.ceil(("italic" === p.fontStyle ? 2 : 1) * n);
			if (x >= l - r * o) {
				if (0 === x) throw new Error(`[BitmapFont] textureHeight ${l}px is too small (fontFamily: '${p.fontFamily}', fontSize: ${p.fontSize}px, char: '${e}')`);
				--h, (v = null), (g = null), (y = null), (x = 0), (b = 0), (_ = 0);
				continue;
			}
			if (((_ = Math.max(r + t.fontProperties.descent, _)), i * o + b >= f)) {
				if (0 === b) throw new Error(`[BitmapFont] textureWidth ${a}px is too small (fontFamily: '${p.fontFamily}', fontSize: ${p.fontSize}px, char: '${e}')`);
				--h, (x += _ * o), (x = Math.ceil(x)), (b = 0), (_ = 0);
				continue;
			}
			Gy(v, g, t, b, x, o, p);
			const C = Yy(t.text);
			m.char.push({ id: C, page: w.length - 1, x: b / o, y: x / o, width: i, height: r, xoffset: 0, yoffset: 0, xadvance: n - (p.dropShadow ? p.dropShadowDistance : 0) - (p.stroke ? p.strokeThickness : 0) }), (b += (i + 2 * s) * o), (b = Math.ceil(b));
		}
		for (let u = 0, h = d.length; u < h; u++) {
			const e = d[u];
			for (let t = 0; t < h; t++) {
				const n = d[t],
					r = g.measureText(e).width,
					i = g.measureText(n).width,
					s = g.measureText(e + n).width - (r + i);
				s && m.kerning.push({ first: Yy(e), second: Yy(n), amount: s });
			}
		}
		const C = new Ky(m, w, !0);
		return void 0 !== Ky.available[e] && Ky.uninstall(e), (Ky.available[e] = C), C;
	}
};
let qy = Ky;
(qy.ALPHA = [["a", "z"], ["A", "Z"], " "]), (qy.NUMERIC = [["0", "9"]]), (qy.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]), (qy.ASCII = [[" ", "~"]]), (qy.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: Ky.ALPHANUMERIC }), (qy.available = {});
const Zy = [],
	Jy = [],
	Qy = [],
	eb = class extends Jf {
		constructor(e, t = {}) {
			super();
			const { align: n, tint: r, maxWidth: i, letterSpacing: s, fontName: o, fontSize: a } = Object.assign({}, eb.styleDefaults, t);
			if (!qy.available[o]) throw new Error(`Missing BitmapFont "${o}"`);
			(this._activePagesMeshData = []),
				(this._textWidth = 0),
				(this._textHeight = 0),
				(this._align = n),
				(this._tintColor = new Wc(r)),
				(this._font = void 0),
				(this._fontName = o),
				(this._fontSize = a),
				(this.text = e),
				(this._maxWidth = i),
				(this._maxLineHeight = 0),
				(this._letterSpacing = s),
				(this._anchor = new fd(
					() => {
						this.dirty = !0;
					},
					this,
					0,
					0
				)),
				(this._roundPixels = Vl.ROUND_PIXELS),
				(this.dirty = !0),
				(this._resolution = Vl.RESOLUTION),
				(this._autoResolution = !0),
				(this._textureCache = {});
		}
		updateText() {
			var e;
			const t = qy.available[this._fontName],
				n = this.fontSize,
				r = n / t.size,
				i = new Jh(),
				s = [],
				o = [],
				a = [],
				l = Xy(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "),
				u = (this._maxWidth * t.size) / n,
				c = "none" === t.distanceFieldType ? Zy : Jy;
			let h = null,
				d = 0,
				p = 0,
				f = 0,
				m = -1,
				v = 0,
				g = 0,
				y = 0,
				b = 0;
			for (let T = 0; T < l.length; T++) {
				const e = l[T],
					n = Yy(e);
				if ((/(?:\s)/.test(e) && ((m = T), (v = d), b++), "\r" === e || "\n" === e)) {
					o.push(d), a.push(-1), (p = Math.max(p, d)), ++f, ++g, (i.x = 0), (i.y += t.lineHeight), (h = null), (b = 0);
					continue;
				}
				const r = t.chars[n];
				if (!r) continue;
				h && r.kerning[h] && (i.x += r.kerning[h]);
				const c = Qy.pop() || { texture: lp.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new Jh() };
				(c.texture = r.texture),
					(c.line = f),
					(c.charCode = n),
					(c.position.x = Math.round(i.x + r.xOffset + this._letterSpacing / 2)),
					(c.position.y = Math.round(i.y + r.yOffset)),
					(c.prevSpaces = b),
					s.push(c),
					(d = c.position.x + Math.max(r.xAdvance - r.xOffset, r.texture.orig.width)),
					(i.x += r.xAdvance + this._letterSpacing),
					(y = Math.max(y, r.yOffset + r.texture.height)),
					(h = n),
					-1 !== m && u > 0 && i.x > u && (++g, rh(s, 1 + m - g, 1 + T - m), (T = m), (m = -1), o.push(v), a.push(s.length > 0 ? s[s.length - 1].prevSpaces : 0), (p = Math.max(p, v)), f++, (i.x = 0), (i.y += t.lineHeight), (h = null), (b = 0));
			}
			const x = l[l.length - 1];
			"\r" !== x && "\n" !== x && (/(?:\s)/.test(x) && (d = v), o.push(d), (p = Math.max(p, d)), a.push(-1));
			const _ = [];
			for (let T = 0; T <= f; T++) {
				let e = 0;
				"right" === this._align ? (e = p - o[T]) : "center" === this._align ? (e = (p - o[T]) / 2) : "justify" === this._align && (e = a[T] < 0 ? 0 : (p - o[T]) / a[T]), _.push(e);
			}
			const w = s.length,
				C = {},
				S = [],
				E = this._activePagesMeshData;
			c.push(...E);
			for (let T = 0; T < w; T++) {
				const e = s[T].texture,
					n = e.baseTexture.uid;
				if (!C[n]) {
					let r = c.pop();
					if (!r) {
						const e = new hy();
						let n, i;
						"none" === t.distanceFieldType
							? ((n = new dy(lp.EMPTY)), (i = wl.NORMAL))
							: ((n = new dy(lp.EMPTY, {
									program: Hd.from(
										"// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n        vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n",
										"// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n    // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n    vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n    // MSDF\r\n    float median = texColor.r + texColor.g + texColor.b -\r\n                                    min(texColor.r, min(texColor.g, texColor.b)) -\r\n                                    max(texColor.r, max(texColor.g, texColor.b));\r\n    // SDF\r\n    median = min(median, texColor.a);\r\n\r\n    float screenPxDistance = uFWidth * (median - 0.5);\r\n    float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n    if (median < 0.01) {\r\n        alpha = 0.0;\r\n    } else if (median > 0.99) {\r\n        alpha = 1.0;\r\n    }\r\n\r\n    // Gamma correction for coverage-like alpha\r\n    float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n    float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n    float coverage = pow(uColor.a * alpha, gamma);    \r\n\r\n    // NPM Textures, NPM outputs\r\n    gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"
									),
									uniforms: { uFWidth: 0 }
							  })),
							  (i = wl.NORMAL_NPM));
						const s = new cy(e, n);
						(s.blendMode = i), (r = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: s, vertices: null, uvs: null, indices: null });
					}
					(r.index = 0), (r.indexCount = 0), (r.vertexCount = 0), (r.uvsCount = 0), (r.total = 0);
					const { _textureCache: i } = this;
					(i[n] = i[n] || new lp(e.baseTexture)), (r.mesh.texture = i[n]), (r.mesh.tint = this._tintColor.value), S.push(r), (C[n] = r);
				}
				C[n].total++;
			}
			for (let T = 0; T < E.length; T++) S.includes(E[T]) || this.removeChild(E[T].mesh);
			for (let T = 0; T < S.length; T++) S[T].mesh.parent !== this && this.addChild(S[T].mesh);
			this._activePagesMeshData = S;
			for (const T in C) {
				const t = C[T],
					n = t.total;
				if (!((null == (e = t.indices) ? void 0 : e.length) > 6 * n) || t.vertices.length < 2 * cy.BATCHABLE_SIZE) (t.vertices = new Float32Array(8 * n)), (t.uvs = new Float32Array(8 * n)), (t.indices = new Uint16Array(6 * n));
				else {
					const e = t.total,
						n = t.vertices;
					for (let t = 4 * e * 2; t < n.length; t++) n[t] = 0;
				}
				t.mesh.size = 6 * n;
			}
			for (let T = 0; T < w; T++) {
				const e = s[T];
				let t = e.position.x + _[e.line] * ("justify" === this._align ? e.prevSpaces : 1);
				this._roundPixels && (t = Math.round(t));
				const n = t * r,
					i = e.position.y * r,
					o = e.texture,
					a = C[o.baseTexture.uid],
					l = o.frame,
					u = o._uvs,
					c = a.index++;
				(a.indices[6 * c + 0] = 0 + 4 * c),
					(a.indices[6 * c + 1] = 1 + 4 * c),
					(a.indices[6 * c + 2] = 2 + 4 * c),
					(a.indices[6 * c + 3] = 0 + 4 * c),
					(a.indices[6 * c + 4] = 2 + 4 * c),
					(a.indices[6 * c + 5] = 3 + 4 * c),
					(a.vertices[8 * c + 0] = n),
					(a.vertices[8 * c + 1] = i),
					(a.vertices[8 * c + 2] = n + l.width * r),
					(a.vertices[8 * c + 3] = i),
					(a.vertices[8 * c + 4] = n + l.width * r),
					(a.vertices[8 * c + 5] = i + l.height * r),
					(a.vertices[8 * c + 6] = n),
					(a.vertices[8 * c + 7] = i + l.height * r),
					(a.uvs[8 * c + 0] = u.x0),
					(a.uvs[8 * c + 1] = u.y0),
					(a.uvs[8 * c + 2] = u.x1),
					(a.uvs[8 * c + 3] = u.y1),
					(a.uvs[8 * c + 4] = u.x2),
					(a.uvs[8 * c + 5] = u.y2),
					(a.uvs[8 * c + 6] = u.x3),
					(a.uvs[8 * c + 7] = u.y3);
			}
			(this._textWidth = p * r), (this._textHeight = (i.y + t.lineHeight) * r);
			for (const T in C) {
				const e = C[T];
				if (0 !== this.anchor.x || 0 !== this.anchor.y) {
					let t = 0;
					const n = this._textWidth * this.anchor.x,
						r = this._textHeight * this.anchor.y;
					for (let i = 0; i < e.total; i++) (e.vertices[t++] -= n), (e.vertices[t++] -= r), (e.vertices[t++] -= n), (e.vertices[t++] -= r), (e.vertices[t++] -= n), (e.vertices[t++] -= r), (e.vertices[t++] -= n), (e.vertices[t++] -= r);
				}
				this._maxLineHeight = y * r;
				const t = e.mesh.geometry.getBuffer("aVertexPosition"),
					n = e.mesh.geometry.getBuffer("aTextureCoord"),
					i = e.mesh.geometry.getIndex();
				(t.data = e.vertices), (n.data = e.uvs), (i.data = e.indices), t.update(), n.update(), i.update();
			}
			for (let T = 0; T < s.length; T++) Qy.push(s[T]);
			(this._font = t), (this.dirty = !1);
		}
		updateTransform() {
			this.validate(), this.containerUpdateTransform();
		}
		_render(e) {
			this._autoResolution && this._resolution !== e.resolution && ((this._resolution = e.resolution), (this.dirty = !0));
			const { distanceFieldRange: t, distanceFieldType: n, size: r } = qy.available[this._fontName];
			if ("none" !== n) {
				const { a: n, b: i, c: s, d: o } = this.worldTransform,
					a = Math.sqrt(n * n + i * i),
					l = Math.sqrt(s * s + o * o),
					u = (Math.abs(a) + Math.abs(l)) / 2,
					c = this.fontSize / r,
					h = e._view.resolution;
				for (const e of this._activePagesMeshData) e.mesh.shader.uniforms.uFWidth = u * t * c * h;
			}
			super._render(e);
		}
		getLocalBounds() {
			return this.validate(), super.getLocalBounds();
		}
		validate() {
			const e = qy.available[this._fontName];
			if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
			this._font !== e && (this.dirty = !0), this.dirty && this.updateText();
		}
		get tint() {
			return this._tintColor.value;
		}
		set tint(e) {
			if (this.tint !== e) {
				this._tintColor.setValue(e);
				for (let t = 0; t < this._activePagesMeshData.length; t++) this._activePagesMeshData[t].mesh.tint = e;
			}
		}
		get align() {
			return this._align;
		}
		set align(e) {
			this._align !== e && ((this._align = e), (this.dirty = !0));
		}
		get fontName() {
			return this._fontName;
		}
		set fontName(e) {
			if (!qy.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
			this._fontName !== e && ((this._fontName = e), (this.dirty = !0));
		}
		get fontSize() {
			var e;
			return null != (e = this._fontSize) ? e : qy.available[this._fontName].size;
		}
		set fontSize(e) {
			this._fontSize !== e && ((this._fontSize = e), (this.dirty = !0));
		}
		get anchor() {
			return this._anchor;
		}
		set anchor(e) {
			"number" == typeof e ? this._anchor.set(e) : this._anchor.copyFrom(e);
		}
		get text() {
			return this._text;
		}
		set text(e) {
			(e = String(null == e ? "" : e)), this._text !== e && ((this._text = e), (this.dirty = !0));
		}
		get maxWidth() {
			return this._maxWidth;
		}
		set maxWidth(e) {
			this._maxWidth !== e && ((this._maxWidth = e), (this.dirty = !0));
		}
		get maxLineHeight() {
			return this.validate(), this._maxLineHeight;
		}
		get textWidth() {
			return this.validate(), this._textWidth;
		}
		get letterSpacing() {
			return this._letterSpacing;
		}
		set letterSpacing(e) {
			this._letterSpacing !== e && ((this._letterSpacing = e), (this.dirty = !0));
		}
		get roundPixels() {
			return this._roundPixels;
		}
		set roundPixels(e) {
			e !== this._roundPixels && ((this._roundPixels = e), (this.dirty = !0));
		}
		get textHeight() {
			return this.validate(), this._textHeight;
		}
		get resolution() {
			return this._resolution;
		}
		set resolution(e) {
			(this._autoResolution = !1), this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
		}
		destroy(e) {
			const { _textureCache: t } = this,
				n = "none" === qy.available[this._fontName].distanceFieldType ? Zy : Jy;
			n.push(...this._activePagesMeshData);
			for (const r of this._activePagesMeshData) this.removeChild(r.mesh);
			(this._activePagesMeshData = []),
				n
					.filter((e) => t[e.mesh.texture.baseTexture.uid])
					.forEach((e) => {
						e.mesh.texture = lp.EMPTY;
					});
			for (const r in t) {
				t[r].destroy(), delete t[r];
			}
			(this._font = null), (this._tintColor = null), (this._textureCache = null), super.destroy(e);
		}
	};
let tb = eb;
tb.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 };
const nb = [".xml", ".fnt"],
	rb = {
		extension: { type: _h.LoadParser, priority: dv.Normal },
		name: "loadBitmapFont",
		test: (e) => nb.includes(dc.extname(e).toLowerCase()),
		testParse: async (e) => Uy.test(e) || $y.test(e),
		async parse(e, t, n) {
			const r = Uy.test(e) ? Uy.parse(e) : $y.parse(e),
				{ src: i } = t,
				{ page: s } = r,
				o = [];
			for (let u = 0; u < s.length; ++u) {
				const e = s[u].file;
				let t = dc.join(dc.dirname(i), e);
				(t = ov(t, i)), o.push(t);
			}
			const a = await n.load(o),
				l = o.map((e) => a[e]);
			return qy.install(r, l, !0);
		},
		load: async (e, t) => (await Vl.ADAPTER.fetch(e)).text(),
		unload(e) {
			e.destroy();
		}
	};
Sh.add(rb);
const ib = class extends bm {
	constructor() {
		super(...arguments), (this._fonts = []), (this._overrides = []), (this._stylesheet = ""), (this.fontsDirty = !1);
	}
	static from(e) {
		return new ib(Object.keys(ib.defaultOptions).reduce((t, n) => c(u({}, t), { [n]: e[n] }), {}));
	}
	cleanFonts() {
		this._fonts.length > 0 &&
			(this._fonts.forEach((e) => {
				URL.revokeObjectURL(e.src), e.refs--, 0 === e.refs && (e.fontFace && document.fonts.delete(e.fontFace), delete ib.availableFonts[e.originalUrl]);
			}),
			(this.fontFamily = "Arial"),
			(this._fonts.length = 0),
			this.styleID++,
			(this.fontsDirty = !0));
	}
	loadFont(e, t = {}) {
		const { availableFonts: n } = ib;
		if (n[e]) {
			const t = n[e];
			return this._fonts.push(t), t.refs++, this.styleID++, (this.fontsDirty = !0), Promise.resolve();
		}
		return Vl.ADAPTER.fetch(e)
			.then((e) => e.blob())
			.then(
				async (e) =>
					new Promise((t, n) => {
						const r = URL.createObjectURL(e),
							i = new FileReader();
						(i.onload = () => t([r, i.result])), (i.onerror = n), i.readAsDataURL(e);
					})
			)
			.then(async ([r, i]) => {
				const s = Object.assign({ family: dc.basename(e, dc.extname(e)), weight: "normal", style: "normal", src: r, dataSrc: i, refs: 1, originalUrl: e, fontFace: null }, t);
				(n[e] = s), this._fonts.push(s), this.styleID++;
				const o = new FontFace(s.family, `url(${s.src})`, { weight: s.weight, style: s.style });
				(s.fontFace = o), await o.load(), document.fonts.add(o), await document.fonts.ready, this.styleID++, (this.fontsDirty = !0);
			});
	}
	addOverride(...e) {
		const t = e.filter((e) => !this._overrides.includes(e));
		t.length > 0 && (this._overrides.push(...t), this.styleID++);
	}
	removeOverride(...e) {
		const t = e.filter((e) => this._overrides.includes(e));
		t.length > 0 && ((this._overrides = this._overrides.filter((e) => !t.includes(e))), this.styleID++);
	}
	toCSS(e) {
		return [
			`transform: scale(${e})`,
			"transform-origin: top left",
			"display: inline-block",
			`color: ${this.normalizeColor(this.fill)}`,
			`font-size: ${this.fontSize}px`,
			`font-family: ${this.fontFamily}`,
			`font-weight: ${this.fontWeight}`,
			`font-style: ${this.fontStyle}`,
			`font-variant: ${this.fontVariant}`,
			`letter-spacing: ${this.letterSpacing}px`,
			`text-align: ${this.align}`,
			`padding: ${this.padding}px`,
			`white-space: ${this.whiteSpace}`,
			...(this.lineHeight ? [`line-height: ${this.lineHeight}px`] : []),
			...(this.wordWrap ? ["word-wrap: " + (this.breakWords ? "break-all" : "break-word"), `max-width: ${this.wordWrapWidth}px`] : []),
			...(this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : []),
			...(this.dropShadow ? [this.dropShadowToCSS()] : []),
			...this._overrides
		].join(";");
	}
	toGlobalCSS() {
		return this._fonts.reduce(
			(e, t) =>
				`${e}\n                        @font-face {\n                                font-family: "${t.family}";\n                                src: url('${t.dataSrc}');\n                                font-weight: ${t.weight};\n                                font-style: ${t.style}; \n                        }`,
			this._stylesheet
		);
	}
	get stylesheet() {
		return this._stylesheet;
	}
	set stylesheet(e) {
		this._stylesheet !== e && ((this._stylesheet = e), this.styleID++);
	}
	normalizeColor(e) {
		return Array.isArray(e) && (e = Yc(e)), "number" == typeof e ? Gc(e) : e;
	}
	dropShadowToCSS() {
		let e = this.normalizeColor(this.dropShadowColor);
		const t = this.dropShadowAlpha,
			n = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance),
			r = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
		e.startsWith("#") && t < 1 && (e += ((255 * t) | 0).toString(16).padStart(2, "0"));
		const i = `${n}px ${r}px`;
		return this.dropShadowBlur > 0 ? `text-shadow: ${i} ${this.dropShadowBlur}px ${e}` : `text-shadow: ${i} ${e}`;
	}
	reset() {
		Object.assign(this, ib.defaultOptions);
	}
	onBeforeDraw() {
		const { fontsDirty: e } = this;
		return (this.fontsDirty = !1), this.isSafari && this._fonts.length > 0 && e ? new Promise((e) => setTimeout(e, 100)) : Promise.resolve();
	}
	get isSafari() {
		const { userAgent: e } = Vl.ADAPTER.getNavigator();
		return /^((?!chrome|android).)*safari/i.test(e);
	}
	set fillGradientStops(e) {
		console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
	}
	get fillGradientStops() {
		return super.fillGradientStops;
	}
	set fillGradientType(e) {
		console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
	}
	get fillGradientType() {
		return super.fillGradientType;
	}
	set miterLimit(e) {
		console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
	}
	get miterLimit() {
		return super.miterLimit;
	}
	set trim(e) {
		console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
	}
	get trim() {
		return super.trim;
	}
	set textBaseline(e) {
		console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
	}
	get textBaseline() {
		return super.textBaseline;
	}
	set leading(e) {
		console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
	}
	get leading() {
		return super.leading;
	}
	set lineJoin(e) {
		console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
	}
	get lineJoin() {
		return super.lineJoin;
	}
};
let sb = ib;
(sb.availableFonts = {}),
	(sb.defaultOptions = {
		align: "left",
		breakWords: !1,
		dropShadow: !1,
		dropShadowAlpha: 1,
		dropShadowAngle: Math.PI / 6,
		dropShadowBlur: 0,
		dropShadowColor: "black",
		dropShadowDistance: 5,
		fill: "black",
		fontFamily: "Arial",
		fontSize: 26,
		fontStyle: "normal",
		fontVariant: "normal",
		fontWeight: "normal",
		letterSpacing: 0,
		lineHeight: 0,
		padding: 0,
		stroke: "black",
		strokeThickness: 0,
		whiteSpace: "normal",
		wordWrap: !1,
		wordWrapWidth: 100
	});
const ob = class extends tm {
	constructor(e = "", t = {}) {
		var n;
		super(lp.EMPTY), (this._text = null), (this._style = null), (this._autoResolution = !0), (this._loading = !1), (this.localStyleID = -1), (this.dirty = !1), (this.ownsStyle = !1);
		const r = new Image(),
			i = lp.from(r, { scaleMode: Vl.SCALE_MODE, resourceOptions: { autoLoad: !1 } });
		(i.orig = new ed()), (i.trim = new ed()), (this.texture = i);
		const s = "http://www.w3.org/2000/svg",
			o = "http://www.w3.org/1999/xhtml",
			a = document.createElementNS(s, "svg"),
			l = document.createElementNS(s, "foreignObject"),
			u = document.createElementNS(o, "div"),
			c = document.createElementNS(o, "style");
		l.setAttribute("width", "10000"),
			l.setAttribute("height", "10000"),
			(l.style.overflow = "hidden"),
			a.appendChild(l),
			(this.maxWidth = ob.defaultMaxWidth),
			(this.maxHeight = ob.defaultMaxHeight),
			(this._domElement = u),
			(this._styleElement = c),
			(this._svgRoot = a),
			(this._foreignObject = l),
			this._foreignObject.appendChild(c),
			this._foreignObject.appendChild(u),
			(this._image = r),
			(this._loadImage = new Image()),
			(this._autoResolution = ob.defaultAutoResolution),
			(this._resolution = null != (n = ob.defaultResolution) ? n : Vl.RESOLUTION),
			(this.text = e),
			(this.style = t);
	}
	measureText(e) {
		var t, n;
		const { text: r, style: i, resolution: s } = Object.assign({ text: this._text, style: this._style, resolution: this._resolution }, e);
		Object.assign(this._domElement, { innerHTML: r, style: i.toCSS(s) }), (this._styleElement.textContent = i.toGlobalCSS()), document.body.appendChild(this._svgRoot);
		const o = this._domElement.getBoundingClientRect();
		this._svgRoot.remove();
		const a = Math.min(this.maxWidth, Math.ceil(o.width)),
			l = Math.min(this.maxHeight, Math.ceil(o.height));
		return (
			this._svgRoot.setAttribute("width", a.toString()),
			this._svgRoot.setAttribute("height", l.toString()),
			r !== this._text && (this._domElement.innerHTML = this._text),
			i !== this._style && (Object.assign(this._domElement, { style: null == (t = this._style) ? void 0 : t.toCSS(s) }), (this._styleElement.textContent = null == (n = this._style) ? void 0 : n.toGlobalCSS())),
			{ width: a + 2 * i.padding, height: l + 2 * i.padding }
		);
	}
	async updateText(e = !0) {
		const { style: t, _image: n, _loadImage: r } = this;
		if ((this.localStyleID !== t.styleID && ((this.dirty = !0), (this.localStyleID = t.styleID)), !this.dirty && e)) return;
		const { width: i, height: s } = this.measureText();
		(n.width = r.width = Math.ceil(Math.max(1, i))),
			(n.height = r.height = Math.ceil(Math.max(1, s))),
			this._loading ||
				((this._loading = !0),
				await new Promise((e) => {
					r.onload = async () => {
						await t.onBeforeDraw(), (this._loading = !1), (n.src = r.src), (r.onload = null), (r.src = ""), this.updateTexture(), e();
					};
					const i = new XMLSerializer().serializeToString(this._svgRoot);
					r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(i)}`;
				}));
	}
	get source() {
		return this._image;
	}
	updateTexture() {
		const { style: e, texture: t, _image: n, resolution: r } = this,
			{ padding: i } = e,
			{ baseTexture: s } = t;
		(t.trim.width = t._frame.width = n.width / r),
			(t.trim.height = t._frame.height = n.height / r),
			(t.trim.x = -i),
			(t.trim.y = -i),
			(t.orig.width = t._frame.width - 2 * i),
			(t.orig.height = t._frame.height - 2 * i),
			this._onTextureUpdate(),
			s.setRealSize(n.width, n.height, r),
			(this.dirty = !1);
	}
	_render(e) {
		this._autoResolution && this._resolution !== e.resolution && ((this._resolution = e.resolution), (this.dirty = !0)), this.updateText(!0), super._render(e);
	}
	_renderCanvas(e) {
		this._autoResolution && this._resolution !== e.resolution && ((this._resolution = e.resolution), (this.dirty = !0)), this.updateText(!0), super._renderCanvas(e);
	}
	getLocalBounds(e) {
		return this.updateText(!0), super.getLocalBounds(e);
	}
	_calculateBounds() {
		this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
	}
	_onStyleChange() {
		this.dirty = !0;
	}
	destroy(e) {
		var t, n, r, i, s;
		"boolean" == typeof e && (e = { children: e }), (e = Object.assign({}, ob.defaultDestroyOptions, e)), super.destroy(e);
		const o = null;
		this.ownsStyle && (null == (t = this._style) || t.cleanFonts()),
			(this._style = o),
			null == (n = this._svgRoot) || n.remove(),
			(this._svgRoot = o),
			null == (r = this._domElement) || r.remove(),
			(this._domElement = o),
			null == (i = this._foreignObject) || i.remove(),
			(this._foreignObject = o),
			null == (s = this._styleElement) || s.remove(),
			(this._styleElement = o),
			(this._loadImage.src = ""),
			(this._loadImage.onload = null),
			(this._loadImage = o),
			(this._image.src = ""),
			(this._image = o);
	}
	get width() {
		return this.updateText(!0), (Math.abs(this.scale.x) * this._image.width) / this.resolution;
	}
	set width(e) {
		this.updateText(!0);
		const t = ih(this.scale.x) || 1;
		(this.scale.x = (t * e) / this._image.width / this.resolution), (this._width = e);
	}
	get height() {
		return this.updateText(!0), (Math.abs(this.scale.y) * this._image.height) / this.resolution;
	}
	set height(e) {
		this.updateText(!0);
		const t = ih(this.scale.y) || 1;
		(this.scale.y = (t * e) / this._image.height / this.resolution), (this._height = e);
	}
	get style() {
		return this._style;
	}
	set style(e) {
		this._style !== e &&
			((e = e || {}) instanceof sb
				? ((this.ownsStyle = !1), (this._style = e))
				: e instanceof bm
				? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), (this.ownsStyle = !0), (this._style = sb.from(e)))
				: ((this.ownsStyle = !0), (this._style = new sb(e))),
			(this.localStyleID = -1),
			(this.dirty = !0));
	}
	get text() {
		return this._text;
	}
	set text(e) {
		(e = String("" === e || null == e ? " " : e)), (e = this.sanitiseText(e)), this._text !== e && ((this._text = e), (this.dirty = !0));
	}
	get resolution() {
		return this._resolution;
	}
	set resolution(e) {
		(this._autoResolution = !1), this._resolution !== e && ((this._resolution = e), (this.dirty = !0));
	}
	sanitiseText(e) {
		return e
			.replace(/<br>/gi, "<br/>")
			.replace(/<hr>/gi, "<hr/>")
			.replace(/&nbsp;/gi, "&#160;");
	}
};
let ab = ob;
(ab.defaultDestroyOptions = { texture: !0, children: !1, baseTexture: !0 }), (ab.defaultMaxWidth = 2024), (ab.defaultMaxHeight = 2024), (ab.defaultAutoResolution = !0);
var lb = Object.freeze(
	Object.defineProperty(
		{
			__proto__: null,
			filters: Dm,
			AccessibilityManager: Zm,
			accessibleTarget: qm,
			Application: Qm,
			ResizePlugin: ev,
			Assets: Nv,
			AssetsClass: Pv,
			Cache: cv,
			cacheTextureArray: Dv,
			detectAvif: Bv,
			detectWebp: Fv,
			detectDefaults: Vv,
			LoaderParserPriority: dv,
			loadJson: pv,
			loadTxt: fv,
			getFontFamilyName: bv,
			loadWebFont: xv,
			loadSVG: Lv,
			loadImageBitmap: Iv,
			loadTextures: Rv,
			createTexture: kv,
			resolveTextureUrl: Uv,
			checkDataUrl: rv,
			checkExtension: iv,
			convertToList: sv,
			copySearchParams: ov,
			createStringVariations: lv,
			isSingleItem: uv,
			INTERNAL_FORMATS: zv,
			INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: $v,
			detectCompressedTextures: Yv,
			loadDDS: Eg,
			loadKTX: Tg,
			resolveCompressedTextureUrl: kg,
			parseDDS: ag,
			FORMATS_TO_COMPONENTS: _g,
			TYPES_TO_BYTES_PER_COMPONENT: xg,
			TYPES_TO_BYTES_PER_PIXEL: wg,
			parseKTX: Cg,
			BlobResource: Xv,
			CompressedTextureResource: Kv,
			autoDetectRenderer: mf,
			BackgroundSystem: qd,
			BatchDrawCall: Fh,
			BatchGeometry: Yh,
			BatchRenderer: Yd,
			BatchShaderGenerator: $d,
			BatchSystem: Zd,
			BatchTextureArray: jd,
			ObjectRenderer: Wd,
			ContextSystem: Qd,
			Filter: Kd,
			FilterState: pp,
			FilterSystem: vp,
			SpriteMaskFilter: Sp,
			defaultFilterVertex: gf,
			defaultVertex: vf,
			Framebuffer: tp,
			FramebufferSystem: bp,
			GLFramebuffer: gp,
			MultisampleSystem: yf,
			Attribute: Uh,
			Buffer: Vh,
			BufferSystem: xf,
			Geometry: Gh,
			GeometrySystem: _p,
			ViewableBuffer: Eh,
			MaskData: Ep,
			MaskSystem: Tp,
			ScissorSystem: Rp,
			StencilSystem: Lp,
			PluginSystem: Op,
			ProjectionSystem: Pp,
			ObjectRendererSystem: _f,
			Renderer: Cf,
			BaseRenderTexture: np,
			GenerateTextureSystem: Dp,
			RenderTexture: up,
			RenderTexturePool: cp,
			RenderTextureSystem: Hp,
			GLProgram: Up,
			IGLUniformData: Vp,
			Program: Hd,
			Shader: zd,
			ShaderSystem: Zp,
			UniformGroup: Ud,
			checkMaxIfStatementsInShader: Ah,
			generateProgram: zp,
			createUBOElements: Gp,
			generateUniformBufferSync: Xp,
			getUBOData: Yp,
			getTestContext: Td,
			uniformParsers: xd,
			unsafeEvalSupported: Nd,
			StartupSystem: Jp,
			State: Mh,
			StateSystem: ef,
			BaseTexture: Bh,
			GLTexture: sf,
			Texture: lp,
			TextureGCSystem: rf,
			TextureMatrix: Cp,
			TextureSystem: of,
			TextureUvs: sp,
			TransformFeedback: Pf,
			TransformFeedbackSystem: af,
			Quad: hp,
			QuadUv: dp,
			ViewSystem: lf,
			SystemManager: tf,
			BaseImageResource: rp,
			Resource: Oh,
			AbstractMultiResource: Sf,
			ArrayResource: Ef,
			INSTALLED: Ih,
			autoDetectResource: Rh,
			BufferResource: Ph,
			CanvasResource: Tf,
			CubeResource: Af,
			ImageBitmapResource: Mf,
			ImageResource: ip,
			SVGResource: Rf,
			VideoResource: Of,
			Color: Wc,
			ALPHA_MODES: Rl,
			BLEND_MODES: wl,
			BUFFER_BITS: _l,
			BUFFER_TYPE: Fl,
			CLEAR_MODES: Ll,
			COLOR_MASK_BITS: Dl,
			DRAW_MODES: Cl,
			ENV: bl,
			FORMATS: Sl,
			GC_MODES: Ol,
			MASK_TYPES: Nl,
			MIPMAP_MODES: Il,
			MSAA_QUALITY: Bl,
			PRECISION: Pl,
			RENDERER_TYPE: xl,
			SAMPLER_TYPES: kl,
			SCALE_MODES: Al,
			TARGETS: El,
			TYPES: Tl,
			WRAP_MODES: Ml,
			ExtensionType: _h,
			extensions: Sh,
			Circle: td,
			Ellipse: nd,
			Polygon: rd,
			Rectangle: ed,
			RoundedRectangle: id,
			groupD8: pd,
			Matrix: sd,
			ObservablePoint: fd,
			Point: Jh,
			Transform: vd,
			DEG_TO_RAD: qh,
			PI_2: Xh,
			RAD_TO_DEG: Kh,
			SHAPES: Zh,
			Runner: Lh,
			BrowserAdapter: Hl,
			settings: Vl,
			isMobile: iu,
			UPDATE_PRIORITY: uf,
			Ticker: df,
			TickerPlugin: pf,
			utils: xh,
			VERSION: "7.2.4",
			Bounds: Gf,
			Container: Jf,
			DisplayObject: Yf,
			TemporaryDisplayObject: Xf,
			EventBoundary: jm,
			EventSystem: Ym,
			FederatedEvent: Fm,
			FederatedDisplayObject: Km,
			FederatedMouseEvent: Hm,
			FederatedPointerEvent: Vm,
			FederatedWheelEvent: Um,
			Extract: Ig,
			AlphaFilter: km,
			BlurFilter: Rm,
			BlurFilterPass: Im,
			ColorMatrixFilter: Lm,
			DisplacementFilter: Om,
			FXAAFilter: Pm,
			NoiseFilter: Nm,
			GRAPHICS_CURVES: Hg,
			LINE_CAP: Bg,
			LINE_JOIN: Dg,
			curves: Fg,
			Graphics: iy,
			GraphicsData: qg,
			GraphicsGeometry: Qg,
			FillStyle: ey,
			LineStyle: ty,
			graphicsUtils: sy,
			Mesh: cy,
			MeshBatchUvs: oy,
			MeshGeometry: hy,
			MeshMaterial: dy,
			PlaneGeometry: py,
			RopeGeometry: fy,
			NineSlicePlane: vy,
			SimpleMesh: gy,
			SimplePlane: my,
			SimpleRope: yy,
			ParticleContainer: cm,
			ParticleRenderer: dm,
			BasePrepare: Ay,
			CountLimiter: by,
			Prepare: Ly,
			TimeLimiter: Oy,
			Sprite: tm,
			AnimatedSprite: Py,
			TilingSprite: rm,
			TilingSpriteRenderer: om,
			Spritesheet: Dy,
			spritesheetAsset: Hy,
			TEXT_GRADIENT: pm,
			Text: Sm,
			TextMetrics: vm,
			TextStyle: bm,
			BitmapFont: qy,
			BitmapFontData: Vy,
			BitmapText: tb,
			autoDetectFormat: Wy,
			loadBitmapFont: rb,
			TextFormat: Uy,
			XMLFormat: zy,
			XMLStringFormat: $y,
			HTMLText: ab,
			HTMLTextStyle: sb
		},
		Symbol.toStringTag,
		{ value: "Module" }
	)
);
const ub = new ed();
class cb {
	constructor(e) {
		this.renderer = e;
	}
	async image(e, t, n) {
		const r = new Image();
		return (r.src = await this.base64(e, t, n)), r;
	}
	async base64(e, t, n) {
		const r = this.canvas(e);
		if (void 0 !== r.toBlob)
			return new Promise((e, i) => {
				r.toBlob(
					(t) => {
						if (!t) return void i(new Error("ICanvas.toBlob failed!"));
						const n = new FileReader();
						(n.onload = () => e(n.result)), (n.onerror = i), n.readAsDataURL(t);
					},
					t,
					n
				);
			});
		if (void 0 !== r.toDataURL) return r.toDataURL(t, n);
		if (void 0 !== r.convertToBlob) {
			const e = await r.convertToBlob({ type: t, quality: n });
			return new Promise((t, n) => {
				const r = new FileReader();
				(r.onload = () => t(r.result)), (r.onerror = n), r.readAsDataURL(e);
			});
		}
		throw new Error("CanvasExtract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
	}
	canvas(e, t) {
		const n = this.renderer;
		if (!n) throw new Error("The CanvasExtract has already been destroyed");
		let r, i, s;
		e && (s = e instanceof up ? e : n.generateTexture(e, { resolution: n.resolution })),
			s ? ((r = s.baseTexture._canvasRenderTarget.context), (i = s.baseTexture._canvasRenderTarget.resolution), (t = null != t ? t : s.frame)) : ((r = n.canvasContext.rootContext), (i = n._view.resolution), t || (((t = ub).width = n.width / i), (t.height = n.height / i)));
		const o = Math.round(t.x * i),
			a = Math.round(t.y * i),
			l = Math.round(t.width * i),
			u = Math.round(t.height * i),
			c = new dh(l, u, 1),
			h = r.getImageData(o, a, l, u);
		return c.context.putImageData(h, 0, 0), c.canvas;
	}
	pixels(e, t) {
		const n = this.renderer;
		if (!n) throw new Error("The CanvasExtract has already been destroyed");
		let r, i, s;
		e && (s = e instanceof up ? e : n.generateTexture(e, { resolution: n.resolution })),
			s ? ((r = s.baseTexture._canvasRenderTarget.context), (i = s.baseTexture._canvasRenderTarget.resolution), (t = null != t ? t : s.frame)) : ((r = n.canvasContext.rootContext), (i = n.resolution), t || (((t = ub).width = n.width / i), (t.height = n.height / i)));
		const o = Math.round(t.x * i),
			a = Math.round(t.y * i),
			l = Math.round(t.width * i),
			u = Math.round(t.height * i);
		return r.getImageData(o, a, l, u).data;
	}
	destroy() {
		this.renderer = null;
	}
}
let hb;
(cb.extension = { name: "extract", type: _h.CanvasRendererSystem }), Sh.add(cb);
const db = new sd();
(iy.prototype.generateCanvasTexture = function (e, t = 1) {
	const n = this.getLocalBounds(),
		r = up.create({ width: n.width, height: n.height, scaleMode: e, resolution: t });
	hb || (hb = new jf()), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(db), db.invert(), (db.tx -= n.x), (db.ty -= n.y), hb.render(this, { renderTexture: r, clear: !0, transform: db });
	const i = lp.from(r.baseTexture._canvasRenderTarget.canvas, { scaleMode: e });
	return i.baseTexture.setResolution(t), i;
}),
	(iy.prototype.cachedGraphicsData = []),
	(iy.prototype._renderCanvas = function (e) {
		!0 !== this.isMask && (this.finishPoly(), e.plugins.graphics.render(this));
	});
class pb {
	static offsetPolygon(e, t) {
		const n = [],
			r = e.length;
		t = pb.isPolygonClockwise(e) ? t : -1 * t;
		for (let i = 0; i < r; i += 2) {
			let s = i - 2;
			s < 0 && (s += r);
			const o = (i + 2) % r;
			let a = e[i] - e[s],
				l = e[i + 1] - e[s + 1],
				u = Math.sqrt(a * a + l * l);
			(a /= u), (l /= u), (a *= t), (l *= t);
			const c = -l,
				h = a,
				d = [e[s] + c, e[s + 1] + h],
				p = [e[i] + c, e[i + 1] + h];
			let f = e[o] - e[i],
				m = e[o + 1] - e[i + 1];
			(u = Math.sqrt(f * f + m * m)), (f /= u), (m /= u), (f *= t), (m *= t);
			const v = -m,
				g = f,
				y = [e[i] + v, e[i + 1] + g],
				b = [e[o] + v, e[o + 1] + g],
				x = pb.findIntersection(d[0], d[1], p[0], p[1], y[0], y[1], b[0], b[1]);
			x && n.push(...x);
		}
		return n;
	}
	static findIntersection(e, t, n, r, i, s, o, a) {
		const l = (a - s) * (n - e) - (o - i) * (r - t),
			u = (o - i) * (t - s) - (a - s) * (e - i);
		if (0 === l) return 0 === u && 0 === (n - e) * (t - s) - (r - t) * (e - i) ? [(e + n) / 2, (t + r) / 2] : null;
		const c = u / l;
		return [e + c * (n - e), t + c * (r - t)];
	}
	static isPolygonClockwise(e) {
		let t = 0;
		for (let n = 0, r = e.length - 2; n < e.length; r = n, n += 2) t += (e[n] - e[r]) * (e[n + 1] + e[r + 1]);
		return t > 0;
	}
}
class fb {
	constructor(e) {
		(this._svgMatrix = null), (this._tempMatrix = new sd()), (this.renderer = e);
	}
	_calcCanvasStyle(e, t) {
		let n;
		return e.texture && e.texture.baseTexture !== lp.WHITE.baseTexture ? (e.texture.valid ? ((n = Wf.getTintedPattern(e.texture, t)), this.setPatternTransform(n, e.matrix || sd.IDENTITY)) : (n = "#808080")) : (n = `#${`00000${(0 | t).toString(16)}`.slice(-6)}`), n;
	}
	render(e) {
		const t = this.renderer,
			n = t.canvasContext.activeContext,
			r = e.worldAlpha,
			i = e.transform.worldTransform;
		t.canvasContext.setContextTransform(i), t.canvasContext.setBlendMode(e.blendMode);
		const s = e.geometry.graphicsData;
		let o, a;
		const l = Wc.shared.setValue(e.tint).toArray();
		for (let u = 0; u < s.length; u++) {
			const e = s[u],
				c = e.shape,
				h = e.fillStyle,
				d = e.lineStyle,
				p = 0 | e.fillStyle.color,
				f = 0 | e.lineStyle.color;
			if (
				(e.matrix && t.canvasContext.setContextTransform(i.copyTo(this._tempMatrix).append(e.matrix)),
				h.visible && (o = this._calcCanvasStyle(h, Wc.shared.setValue(p).multiply(l).toNumber())),
				d.visible && (a = this._calcCanvasStyle(d, Wc.shared.setValue(f).multiply(l).toNumber())),
				(n.lineWidth = d.width),
				(n.lineCap = d.cap),
				(n.lineJoin = d.join),
				(n.miterLimit = d.miterLimit),
				e.type === Zh.POLY)
			) {
				n.beginPath();
				const t = c;
				let i = t.points;
				const s = e.holes;
				let l, u, p, f, m;
				n.moveTo(i[0], i[1]);
				for (let e = 2; e < i.length; e += 2) n.lineTo(i[e], i[e + 1]);
				if ((t.closeStroke && n.closePath(), s.length > 0)) {
					(m = []), (l = 0), (p = i[0]), (f = i[1]);
					for (let e = 2; e + 2 < i.length; e += 2) l += (i[e] - p) * (i[e + 3] - f) - (i[e + 2] - p) * (i[e + 1] - f);
					for (let e = 0; e < s.length; e++)
						if (((i = s[e].shape.points), i)) {
							(u = 0), (p = i[0]), (f = i[1]);
							for (let e = 2; e + 2 < i.length; e += 2) u += (i[e] - p) * (i[e + 3] - f) - (i[e + 2] - p) * (i[e + 1] - f);
							if (u * l < 0) {
								n.moveTo(i[0], i[1]);
								for (let e = 2; e < i.length; e += 2) n.lineTo(i[e], i[e + 1]);
							} else {
								n.moveTo(i[i.length - 2], i[i.length - 1]);
								for (let e = i.length - 4; e >= 0; e -= 2) n.lineTo(i[e], i[e + 1]);
							}
							s[e].shape.closeStroke && n.closePath(), (m[e] = u * l < 0);
						}
				}
				h.visible && ((n.globalAlpha = h.alpha * r), (n.fillStyle = o), n.fill()), d.visible && this.paintPolygonStroke(t, d, a, s, m, r, n);
			} else if (e.type === Zh.RECT) {
				const e = c;
				if ((h.visible && ((n.globalAlpha = h.alpha * r), (n.fillStyle = o), n.fillRect(e.x, e.y, e.width, e.height)), d.visible)) {
					const t = d.width * (0.5 - (1 - d.alignment)),
						i = e.width + 2 * t,
						s = e.height + 2 * t;
					(n.globalAlpha = d.alpha * r), (n.strokeStyle = a), n.strokeRect(e.x - t, e.y - t, i, s);
				}
			} else if (e.type === Zh.CIRC) {
				const e = c;
				if ((n.beginPath(), n.arc(e.x, e.y, e.radius, 0, 2 * Math.PI), n.closePath(), h.visible && ((n.globalAlpha = h.alpha * r), (n.fillStyle = o), n.fill()), d.visible)) {
					if (0.5 !== d.alignment) {
						const t = d.width * (0.5 - (1 - d.alignment));
						n.beginPath(), n.arc(e.x, e.y, e.radius + t, 0, 2 * Math.PI), n.closePath();
					}
					(n.globalAlpha = d.alpha * r), (n.strokeStyle = a), n.stroke();
				}
			} else if (e.type === Zh.ELIP) {
				const e = c,
					t = 1 === d.alignment;
				if ((t || this.paintEllipse(e, h, d, o, r, n), d.visible)) {
					if (0.5 !== d.alignment) {
						const t = 0.5522848,
							r = d.width * (0.5 - (1 - d.alignment)),
							i = 2 * (e.width + r),
							s = 2 * (e.height + r),
							o = e.x - i / 2,
							a = e.y - s / 2,
							l = (i / 2) * t,
							u = (s / 2) * t,
							c = o + i,
							h = a + s,
							p = o + i / 2,
							f = a + s / 2;
						n.beginPath(), n.moveTo(o, f), n.bezierCurveTo(o, f - u, p - l, a, p, a), n.bezierCurveTo(p + l, a, c, f - u, c, f), n.bezierCurveTo(c, f + u, p + l, h, p, h), n.bezierCurveTo(p - l, h, o, f + u, o, f), n.closePath();
					}
					(n.globalAlpha = d.alpha * r), (n.strokeStyle = a), n.stroke();
				}
				t && this.paintEllipse(e, h, d, o, r, n);
			} else if (e.type === Zh.RREC) {
				const e = c,
					t = 1 === d.alignment;
				if ((t || this.paintRoundedRectangle(e, h, d, o, r, n), d.visible)) {
					if (0.5 !== d.alignment) {
						const t = e.width,
							r = e.height,
							i = d.width * (0.5 - (1 - d.alignment)),
							s = e.x - i,
							o = e.y - i,
							a = e.width + 2 * i,
							l = e.height + 2 * i,
							u = i * (d.alignment >= 1 ? Math.min(a / t, l / r) : Math.min(t / a, r / l));
						let c = e.radius + u;
						const h = Math.min(a, l) / 2;
						(c = c > h ? h : c),
							n.beginPath(),
							n.moveTo(s, o + c),
							n.lineTo(s, o + l - c),
							n.quadraticCurveTo(s, o + l, s + c, o + l),
							n.lineTo(s + a - c, o + l),
							n.quadraticCurveTo(s + a, o + l, s + a, o + l - c),
							n.lineTo(s + a, o + c),
							n.quadraticCurveTo(s + a, o, s + a - c, o),
							n.lineTo(s + c, o),
							n.quadraticCurveTo(s, o, s, o + c),
							n.closePath();
					}
					(n.globalAlpha = d.alpha * r), (n.strokeStyle = a), n.stroke();
				}
				t && this.paintRoundedRectangle(e, h, d, o, r, n);
			}
		}
	}
	paintPolygonStroke(e, t, n, r, i, s, o) {
		if (0.5 !== t.alignment) {
			const n = t.width * (0.5 - (1 - t.alignment));
			let s,
				a = pb.offsetPolygon(e.points, n);
			o.beginPath(), o.moveTo(a[0], a[1]);
			for (let e = 2; e < a.length; e += 2) o.lineTo(a[e], a[e + 1]);
			e.closeStroke && o.closePath();
			for (let e = 0; e < r.length; e++) {
				if (((s = r[e].shape.points), (a = pb.offsetPolygon(s, n)), i[e])) {
					o.moveTo(a[0], a[1]);
					for (let e = 2; e < a.length; e += 2) o.lineTo(a[e], a[e + 1]);
				} else {
					o.moveTo(a[a.length - 2], a[a.length - 1]);
					for (let e = a.length - 4; e >= 0; e -= 2) o.lineTo(a[e], a[e + 1]);
				}
				r[e].shape.closeStroke && o.closePath();
			}
		}
		(o.globalAlpha = t.alpha * s), (o.strokeStyle = n), o.stroke();
	}
	paintEllipse(e, t, n, r, i, s) {
		const o = 2 * e.width,
			a = 2 * e.height,
			l = e.x - o / 2,
			u = e.y - a / 2,
			c = 0.5522848,
			h = (o / 2) * c,
			d = (a / 2) * c,
			p = l + o,
			f = u + a,
			m = l + o / 2,
			v = u + a / 2;
		0 === n.alignment && s.save(),
			s.beginPath(),
			s.moveTo(l, v),
			s.bezierCurveTo(l, v - d, m - h, u, m, u),
			s.bezierCurveTo(m + h, u, p, v - d, p, v),
			s.bezierCurveTo(p, v + d, m + h, f, m, f),
			s.bezierCurveTo(m - h, f, l, v + d, l, v),
			s.closePath(),
			0 === n.alignment && s.clip(),
			t.visible && ((s.globalAlpha = t.alpha * i), (s.fillStyle = r), s.fill()),
			0 === n.alignment && s.restore();
	}
	paintRoundedRectangle(e, t, n, r, i, s) {
		const o = e.x,
			a = e.y,
			l = e.width,
			u = e.height;
		let c = e.radius;
		const h = Math.min(l, u) / 2;
		(c = c > h ? h : c),
			0 === n.alignment && s.save(),
			s.beginPath(),
			s.moveTo(o, a + c),
			s.lineTo(o, a + u - c),
			s.quadraticCurveTo(o, a + u, o + c, a + u),
			s.lineTo(o + l - c, a + u),
			s.quadraticCurveTo(o + l, a + u, o + l, a + u - c),
			s.lineTo(o + l, a + c),
			s.quadraticCurveTo(o + l, a, o + l - c, a),
			s.lineTo(o + c, a),
			s.quadraticCurveTo(o, a, o, a + c),
			s.closePath(),
			0 === n.alignment && s.clip(),
			t.visible && ((s.globalAlpha = t.alpha * i), (s.fillStyle = r), s.fill()),
			0 === n.alignment && s.restore();
	}
	setPatternTransform(e, t) {
		if (!1 !== this._svgMatrix) {
			if (!this._svgMatrix) {
				const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				if (((null == t ? void 0 : t.createSVGMatrix) && (this._svgMatrix = t.createSVGMatrix()), !this._svgMatrix || !e.setTransform)) return void (this._svgMatrix = !1);
			}
			(this._svgMatrix.a = t.a), (this._svgMatrix.b = t.b), (this._svgMatrix.c = t.c), (this._svgMatrix.d = t.d), (this._svgMatrix.e = t.tx), (this._svgMatrix.f = t.ty), e.setTransform(this._svgMatrix.inverse());
		}
	}
	destroy() {
		(this.renderer = null), (this._svgMatrix = null), (this._tempMatrix = null);
	}
}
(fb.extension = { name: "graphics", type: _h.CanvasRendererPlugin }),
	Sh.add(fb),
	Object.defineProperties(Vl, {
		MESH_CANVAS_PADDING: {
			get: () => cy.defaultCanvasPadding,
			set(e) {
				fc("7.1.0", "settings.MESH_CANVAS_PADDING is deprecated, use Mesh.defaultCanvasPadding"), (cy.defaultCanvasPadding = e);
			}
		}
	}),
	(dy.prototype._renderCanvas = function (e, t) {
		e.plugins.mesh.render(t);
	}),
	(vy.prototype._cachedTint = 16777215),
	(vy.prototype._tintedCanvas = null),
	(vy.prototype._canvasUvs = null),
	(vy.prototype._renderCanvas = function (e) {
		const t = e.canvasContext.activeContext,
			n = this.worldTransform,
			r = 16777215 !== this.tintValue,
			i = this.texture;
		if (!i.valid) return;
		r && this._cachedTint !== this.tintValue && ((this._cachedTint = this.tintValue), (this._tintedCanvas = Wf.getTintedCanvas(this, this.tintValue)));
		const s = r ? this._tintedCanvas : i.baseTexture.getDrawableSource();
		this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
		const o = this.vertices,
			a = this._canvasUvs,
			l = r ? 0 : i.frame.x,
			u = r ? 0 : i.frame.y,
			c = l + i.frame.width,
			h = u + i.frame.height;
		(a[0] = l), (a[1] = l + this._leftWidth), (a[2] = c - this._rightWidth), (a[3] = c), (a[4] = u), (a[5] = u + this._topHeight), (a[6] = h - this._bottomHeight), (a[7] = h);
		for (let d = 0; d < 8; d++) a[d] *= i.baseTexture.resolution;
		(t.globalAlpha = this.worldAlpha), e.canvasContext.setBlendMode(this.blendMode), e.canvasContext.setContextTransform(n, this.roundPixels);
		for (let d = 0; d < 3; d++)
			for (let e = 0; e < 3; e++) {
				const n = 2 * e + 8 * d,
					r = Math.max(1, a[e + 1] - a[e]),
					i = Math.max(1, a[d + 5] - a[d + 4]),
					l = Math.max(1, o[n + 10] - o[n]),
					u = Math.max(1, o[n + 11] - o[n + 1]);
				t.drawImage(s, a[e], a[d + 4], r, i, o[n], o[n + 1], l, u);
			}
	});
let mb = !1;
(cy.prototype._cachedTint = 16777215),
	(cy.prototype._tintedCanvas = null),
	(cy.prototype._cachedTexture = null),
	(cy.prototype._renderCanvas = function (e) {
		this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(e, this) : mb || ((mb = !0), globalThis.console.warn("Mesh with custom shaders are not supported in CanvasRenderer."));
	}),
	(cy.prototype._canvasPadding = null),
	(cy.defaultCanvasPadding = 0),
	Object.defineProperty(cy.prototype, "canvasPadding", {
		get() {
			var e;
			return null != (e = this._canvasPadding) ? e : cy.defaultCanvasPadding;
		},
		set(e) {
			this._canvasPadding = e;
		}
	}),
	(gy.prototype._renderCanvas = function (e) {
		this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(e, this);
	}),
	(yy.prototype._renderCanvas = function (e) {
		(this.autoUpdate || this.geometry._width !== this.shader.texture.height) && ((this.geometry._width = this.shader.texture.height), this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(e, this);
	});
class vb {
	constructor(e) {
		this.renderer = e;
	}
	render(e) {
		const t = this.renderer,
			n = e.worldTransform;
		(t.canvasContext.activeContext.globalAlpha = e.worldAlpha), t.canvasContext.setBlendMode(e.blendMode), t.canvasContext.setContextTransform(n, e.roundPixels), e.drawMode !== Cl.TRIANGLES ? this._renderTriangleMesh(e) : this._renderTriangles(e);
	}
	_renderTriangleMesh(e) {
		const t = e.geometry.buffers[0].data.length;
		for (let n = 0; n < t - 2; n++) {
			const t = 2 * n;
			this._renderDrawTriangle(e, t, t + 2, t + 4);
		}
	}
	_renderTriangles(e) {
		const t = e.geometry.getIndex().data,
			n = t.length;
		for (let r = 0; r < n; r += 3) {
			const n = 2 * t[r],
				i = 2 * t[r + 1],
				s = 2 * t[r + 2];
			this._renderDrawTriangle(e, n, i, s);
		}
	}
	_renderDrawTriangle(e, t, n, r) {
		var i;
		const s = this.renderer.canvasContext.activeContext,
			o = e.geometry.buffers[0].data,
			{ uvs: a, texture: l } = e;
		if (!l.valid) return;
		const u = 16777215 !== e.tintValue,
			c = l.baseTexture,
			h = c.width,
			d = c.height;
		e._cachedTexture && e._cachedTexture.baseTexture !== c && ((e._cachedTint = 16777215), null == (i = e._cachedTexture) || i.destroy(), (e._cachedTexture = null), (e._tintedCanvas = null)),
			u && e._cachedTint !== e.tintValue && ((e._cachedTint = e.tintValue), (e._cachedTexture = e._cachedTexture || new lp(c)), (e._tintedCanvas = Wf.getTintedCanvas({ texture: e._cachedTexture }, e.tintValue)));
		const p = u ? e._tintedCanvas : c.getDrawableSource(),
			f = a[t] * c.width,
			m = a[n] * c.width,
			v = a[r] * c.width,
			g = a[t + 1] * c.height,
			y = a[n + 1] * c.height,
			b = a[r + 1] * c.height;
		let x = o[t],
			_ = o[n],
			w = o[r],
			C = o[t + 1],
			S = o[n + 1],
			E = o[r + 1];
		const T = e.canvasPadding / this.renderer.canvasContext.activeResolution;
		if (T > 0) {
			const { a: t, b: n, c: r, d: i } = e.worldTransform,
				s = (x + _ + w) / 3,
				o = (C + S + E) / 3;
			let a = x - s,
				l = C - o,
				u = t * a + r * l,
				c = n * a + i * l,
				h = Math.sqrt(u * u + c * c),
				d = 1 + T / h;
			(x = s + a * d),
				(C = o + l * d),
				(a = _ - s),
				(l = S - o),
				(u = t * a + r * l),
				(c = n * a + i * l),
				(h = Math.sqrt(u * u + c * c)),
				(d = 1 + T / h),
				(_ = s + a * d),
				(S = o + l * d),
				(a = w - s),
				(l = E - o),
				(u = t * a + r * l),
				(c = n * a + i * l),
				(h = Math.sqrt(u * u + c * c)),
				(d = 1 + T / h),
				(w = s + a * d),
				(E = o + l * d);
		}
		s.save(), s.beginPath(), s.moveTo(x, C), s.lineTo(_, S), s.lineTo(w, E), s.closePath(), s.clip();
		const k = f * y + g * v + m * b - y * v - g * m - f * b,
			A = x * y + g * w + _ * b - y * w - g * _ - x * b,
			M = f * _ + x * v + m * w - _ * v - x * m - f * w,
			I = f * y * w + g * _ * v + x * m * b - x * y * v - g * m * w - f * _ * b,
			R = C * y + g * E + S * b - y * E - g * S - C * b,
			L = f * S + C * v + m * E - S * v - C * m - f * E,
			O = f * y * E + g * S * v + C * m * b - C * y * v - g * m * E - f * S * b;
		s.transform(A / k, R / k, M / k, L / k, I / k, O / k), s.drawImage(p, 0, 0, h * c.resolution, d * c.resolution, 0, 0, h, d), s.restore(), this.renderer.canvasContext.invalidateBlendMode();
	}
	renderMeshFlat(e) {
		const t = this.renderer.canvasContext.activeContext,
			n = e.geometry.getBuffer("aVertexPosition").data,
			r = n.length / 2;
		t.beginPath();
		for (let i = 1; i < r - 2; ++i) {
			const e = 2 * i,
				r = n[e],
				s = n[e + 1],
				o = n[e + 2],
				a = n[e + 3],
				l = n[e + 4],
				u = n[e + 5];
			t.moveTo(r, s), t.lineTo(o, a), t.lineTo(l, u);
		}
		(t.fillStyle = "#FF0000"), t.fill(), t.closePath();
	}
	destroy() {
		this.renderer = null;
	}
}
(vb.extension = { name: "mesh", type: _h.CanvasRendererPlugin }), Sh.add(vb);
function gb(e, t) {
	const n = e;
	if (t instanceof Bh) {
		const e = t.source,
			r = 0 === e.width ? n.canvas.width : Math.min(n.canvas.width, e.width),
			i = 0 === e.height ? n.canvas.height : Math.min(n.canvas.height, e.height);
		return n.ctx.drawImage(e, 0, 0, r, i, 0, 0, n.canvas.width, n.canvas.height), !0;
	}
	return !1;
}
class yb extends Ay {
	constructor(e) {
		super(e), (this.uploadHookHelper = this), (this.canvas = Vl.ADAPTER.createCanvas(16, 16)), (this.ctx = this.canvas.getContext("2d")), this.registerUploadHook(gb);
	}
	destroy() {
		super.destroy(), (this.ctx = null), (this.canvas = null);
	}
}
(yb.extension = { name: "prepare", type: _h.CanvasRendererSystem }),
	Sh.add(yb),
	(tm.prototype._tintedCanvas = null),
	(tm.prototype._renderCanvas = function (e) {
		e.plugins.sprite.render(this);
	});
const bb = new sd();
class xb {
	constructor(e) {
		this.renderer = e;
	}
	render(e) {
		const t = e._texture,
			n = this.renderer,
			r = n.canvasContext.activeContext,
			i = n.canvasContext.activeResolution;
		if (!t.valid) return;
		const s = t._frame.width,
			o = t._frame.height;
		let a = t._frame.width,
			l = t._frame.height;
		t.trim && ((a = t.trim.width), (l = t.trim.height));
		let u = e.transform.worldTransform,
			c = 0,
			h = 0;
		const d = t.baseTexture.getDrawableSource();
		if (t.orig.width <= 0 || t.orig.height <= 0 || !t.valid || !d) return;
		n.canvasContext.setBlendMode(e.blendMode, !0), (r.globalAlpha = e.worldAlpha);
		const p = t.baseTexture.scaleMode === Al.LINEAR,
			f = n.canvasContext.smoothProperty;
		f && r[f] !== p && (r[f] = p),
			t.trim ? ((c = t.trim.width / 2 + t.trim.x - e.anchor.x * t.orig.width), (h = t.trim.height / 2 + t.trim.y - e.anchor.y * t.orig.height)) : ((c = (0.5 - e.anchor.x) * t.orig.width), (h = (0.5 - e.anchor.y) * t.orig.height)),
			t.rotate && (u.copyTo(bb), (u = bb), pd.matrixAppendRotationInv(u, t.rotate, c, h), (c = 0), (h = 0)),
			(c -= a / 2),
			(h -= l / 2),
			n.canvasContext.setContextTransform(u, e.roundPixels, 1),
			e.roundPixels && ((c |= 0), (h |= 0));
		const m = t.baseTexture.resolution,
			v = n.canvasContext._outerBlend;
		v && (r.save(), r.beginPath(), r.rect(c * i, h * i, a * i, l * i), r.clip()),
			16777215 !== e.tint
				? ((e._cachedTint === e.tintValue && e._tintedCanvas.tintId === e._texture._updateID) || ((e._cachedTint = e.tintValue), (e._tintedCanvas = Wf.getTintedCanvas(e, e.tintValue))),
				  r.drawImage(e._tintedCanvas, 0, 0, Math.floor(s * m), Math.floor(o * m), Math.floor(c * i), Math.floor(h * i), Math.floor(a * i), Math.floor(l * i)))
				: r.drawImage(d, t._frame.x * m, t._frame.y * m, Math.floor(s * m), Math.floor(o * m), Math.floor(c * i), Math.floor(h * i), Math.floor(a * i), Math.floor(l * i)),
			v && r.restore(),
			n.canvasContext.setBlendMode(wl.NORMAL);
	}
	destroy() {
		this.renderer = null;
	}
}
(xb.extension = { name: "sprite", type: _h.CanvasRendererPlugin }), Sh.add(xb);
var _b = Object.freeze(
	Object.defineProperty(
		{
			__proto__: null,
			filters: Dm,
			AccessibilityManager: Zm,
			accessibleTarget: qm,
			Application: Qm,
			ResizePlugin: ev,
			Assets: Nv,
			AssetsClass: Pv,
			Cache: cv,
			cacheTextureArray: Dv,
			detectAvif: Bv,
			detectWebp: Fv,
			detectDefaults: Vv,
			LoaderParserPriority: dv,
			loadJson: pv,
			loadTxt: fv,
			getFontFamilyName: bv,
			loadWebFont: xv,
			loadSVG: Lv,
			loadImageBitmap: Iv,
			loadTextures: Rv,
			createTexture: kv,
			resolveTextureUrl: Uv,
			checkDataUrl: rv,
			checkExtension: iv,
			convertToList: sv,
			copySearchParams: ov,
			createStringVariations: lv,
			isSingleItem: uv,
			INTERNAL_FORMATS: zv,
			INTERNAL_FORMAT_TO_BYTES_PER_PIXEL: $v,
			detectCompressedTextures: Yv,
			loadDDS: Eg,
			loadKTX: Tg,
			resolveCompressedTextureUrl: kg,
			parseDDS: ag,
			FORMATS_TO_COMPONENTS: _g,
			TYPES_TO_BYTES_PER_COMPONENT: xg,
			TYPES_TO_BYTES_PER_PIXEL: wg,
			parseKTX: Cg,
			BlobResource: Xv,
			CompressedTextureResource: Kv,
			autoDetectRenderer: mf,
			BackgroundSystem: qd,
			BatchDrawCall: Fh,
			BatchGeometry: Yh,
			BatchRenderer: Yd,
			BatchShaderGenerator: $d,
			BatchSystem: Zd,
			BatchTextureArray: jd,
			ObjectRenderer: Wd,
			ContextSystem: Qd,
			Filter: Kd,
			FilterState: pp,
			FilterSystem: vp,
			SpriteMaskFilter: Sp,
			defaultFilterVertex: gf,
			defaultVertex: vf,
			Framebuffer: tp,
			FramebufferSystem: bp,
			GLFramebuffer: gp,
			MultisampleSystem: yf,
			Attribute: Uh,
			Buffer: Vh,
			BufferSystem: xf,
			Geometry: Gh,
			GeometrySystem: _p,
			ViewableBuffer: Eh,
			MaskData: Ep,
			MaskSystem: Tp,
			ScissorSystem: Rp,
			StencilSystem: Lp,
			PluginSystem: Op,
			ProjectionSystem: Pp,
			ObjectRendererSystem: _f,
			Renderer: Cf,
			BaseRenderTexture: np,
			GenerateTextureSystem: Dp,
			RenderTexture: up,
			RenderTexturePool: cp,
			RenderTextureSystem: Hp,
			GLProgram: Up,
			IGLUniformData: Vp,
			Program: Hd,
			Shader: zd,
			ShaderSystem: Zp,
			UniformGroup: Ud,
			checkMaxIfStatementsInShader: Ah,
			generateProgram: zp,
			createUBOElements: Gp,
			generateUniformBufferSync: Xp,
			getUBOData: Yp,
			getTestContext: Td,
			uniformParsers: xd,
			unsafeEvalSupported: Nd,
			StartupSystem: Jp,
			State: Mh,
			StateSystem: ef,
			BaseTexture: Bh,
			GLTexture: sf,
			Texture: lp,
			TextureGCSystem: rf,
			TextureMatrix: Cp,
			TextureSystem: of,
			TextureUvs: sp,
			TransformFeedback: Pf,
			TransformFeedbackSystem: af,
			Quad: hp,
			QuadUv: dp,
			ViewSystem: lf,
			SystemManager: tf,
			BaseImageResource: rp,
			Resource: Oh,
			AbstractMultiResource: Sf,
			ArrayResource: Ef,
			INSTALLED: Ih,
			autoDetectResource: Rh,
			BufferResource: Ph,
			CanvasResource: Tf,
			CubeResource: Af,
			ImageBitmapResource: Mf,
			ImageResource: ip,
			SVGResource: Rf,
			VideoResource: Of,
			Color: Wc,
			ALPHA_MODES: Rl,
			BLEND_MODES: wl,
			BUFFER_BITS: _l,
			BUFFER_TYPE: Fl,
			CLEAR_MODES: Ll,
			COLOR_MASK_BITS: Dl,
			DRAW_MODES: Cl,
			ENV: bl,
			FORMATS: Sl,
			GC_MODES: Ol,
			MASK_TYPES: Nl,
			MIPMAP_MODES: Il,
			MSAA_QUALITY: Bl,
			PRECISION: Pl,
			RENDERER_TYPE: xl,
			SAMPLER_TYPES: kl,
			SCALE_MODES: Al,
			TARGETS: El,
			TYPES: Tl,
			WRAP_MODES: Ml,
			ExtensionType: _h,
			extensions: Sh,
			Circle: td,
			Ellipse: nd,
			Polygon: rd,
			Rectangle: ed,
			RoundedRectangle: id,
			groupD8: pd,
			Matrix: sd,
			ObservablePoint: fd,
			Point: Jh,
			Transform: vd,
			DEG_TO_RAD: qh,
			PI_2: Xh,
			RAD_TO_DEG: Kh,
			SHAPES: Zh,
			Runner: Lh,
			BrowserAdapter: Hl,
			settings: Vl,
			isMobile: iu,
			UPDATE_PRIORITY: uf,
			Ticker: df,
			TickerPlugin: pf,
			utils: xh,
			VERSION: "7.2.4",
			Bounds: Gf,
			Container: Jf,
			DisplayObject: Yf,
			TemporaryDisplayObject: Xf,
			EventBoundary: jm,
			EventSystem: Ym,
			FederatedEvent: Fm,
			FederatedDisplayObject: Km,
			FederatedMouseEvent: Hm,
			FederatedPointerEvent: Vm,
			FederatedWheelEvent: Um,
			Extract: Ig,
			AlphaFilter: km,
			BlurFilter: Rm,
			BlurFilterPass: Im,
			ColorMatrixFilter: Lm,
			DisplacementFilter: Om,
			FXAAFilter: Pm,
			NoiseFilter: Nm,
			GRAPHICS_CURVES: Hg,
			LINE_CAP: Bg,
			LINE_JOIN: Dg,
			curves: Fg,
			Graphics: iy,
			GraphicsData: qg,
			GraphicsGeometry: Qg,
			FillStyle: ey,
			LineStyle: ty,
			graphicsUtils: sy,
			Mesh: cy,
			MeshBatchUvs: oy,
			MeshGeometry: hy,
			MeshMaterial: dy,
			PlaneGeometry: py,
			RopeGeometry: fy,
			NineSlicePlane: vy,
			SimpleMesh: gy,
			SimplePlane: my,
			SimpleRope: yy,
			ParticleContainer: cm,
			ParticleRenderer: dm,
			BasePrepare: Ay,
			CountLimiter: by,
			Prepare: Ly,
			TimeLimiter: Oy,
			Sprite: tm,
			AnimatedSprite: Py,
			TilingSprite: rm,
			TilingSpriteRenderer: om,
			Spritesheet: Dy,
			spritesheetAsset: Hy,
			TEXT_GRADIENT: pm,
			Text: Sm,
			TextMetrics: vm,
			TextStyle: bm,
			BitmapFont: qy,
			BitmapFontData: Vy,
			BitmapText: tb,
			autoDetectFormat: Wy,
			loadBitmapFont: rb,
			TextFormat: Uy,
			XMLFormat: zy,
			XMLStringFormat: $y,
			HTMLText: ab,
			HTMLTextStyle: sb,
			CanvasExtract: cb,
			CanvasGraphicsRenderer: fb,
			CanvasMeshRenderer: vb,
			CanvasPrepare: yb,
			CanvasContextSystem: Hf,
			CanvasMaskSystem: Vf,
			CanvasObjectRendererSystem: Uf,
			CanvasRenderer: jf,
			canvasUtils: Wf,
			canUseNewCanvasBlendModes: Bf,
			CanvasSpriteRenderer: xb
		},
		Symbol.toStringTag,
		{ value: "Module" }
	)
);
/*!
 * vue-router v4.0.6
 * (c) 2021 Eduardo San Martin Morote
 * @license MIT
 */ const wb = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
	Cb = (e) => (wb ? Symbol(e) : "_vr_" + e),
	Sb = Cb("rvlm"),
	Eb = Cb("rvd"),
	Tb = Cb("r"),
	kb = Cb("rl"),
	Ab = Cb("rvl"),
	Mb = "undefined" != typeof window;
const Ib = Object.assign;
function Rb(e, t) {
	const n = {};
	for (const r in t) {
		const i = t[r];
		n[r] = Array.isArray(i) ? i.map(e) : e(i);
	}
	return n;
}
let Lb = () => {};
const Ob = /\/$/;
function Pb(e, t, n = "/") {
	let r,
		i = {},
		s = "",
		o = "";
	const a = t.indexOf("?"),
		l = t.indexOf("#", a > -1 ? a : 0);
	return (
		a > -1 && ((r = t.slice(0, a)), (s = t.slice(a + 1, l > -1 ? l : t.length)), (i = e(s))),
		l > -1 && ((r = r || t.slice(0, l)), (o = t.slice(l, t.length))),
		(r = (function (e, t) {
			if (e.startsWith("/")) return e;
			if (!e) return t;
			const n = t.split("/"),
				r = e.split("/");
			let i,
				s,
				o = n.length - 1;
			for (i = 0; i < r.length; i++)
				if (((s = r[i]), 1 !== o && "." !== s)) {
					if (".." !== s) break;
					o--;
				}
			return n.slice(0, o).join("/") + "/" + r.slice(i - (i === r.length ? 1 : 0)).join("/");
		})(null != r ? r : t, n)),
		{ fullPath: r + (s && "?") + s + o, path: r, query: i, hash: o }
	);
}
function Nb(e, t) {
	return !t || e.toLowerCase().indexOf(t.toLowerCase()) ? e : e.slice(t.length) || "/";
}
function Db(e, t) {
	return (e.aliasOf || e) === (t.aliasOf || t);
}
function Bb(e, t) {
	if (Object.keys(e).length !== Object.keys(t).length) return !1;
	for (let n in e) if (!Fb(e[n], t[n])) return !1;
	return !0;
}
function Fb(e, t) {
	return Array.isArray(e) ? Hb(e, t) : Array.isArray(t) ? Hb(t, e) : e === t;
}
function Hb(e, t) {
	return Array.isArray(t) ? e.length === t.length && e.every((e, n) => e === t[n]) : 1 === e.length && e[0] === t;
}
var Vb, Ub, zb, $b;
function jb(e) {
	if (!e)
		if (Mb) {
			const t = document.querySelector("base");
			e = (e = (t && t.getAttribute("href")) || "/").replace(/^\w+:\/\/[^\/]+/, "");
		} else e = "/";
	return "/" !== e[0] && "#" !== e[0] && (e = "/" + e), e.replace(Ob, "");
}
((Ub = Vb || (Vb = {})).pop = "pop"), (Ub.push = "push"), (($b = zb || (zb = {})).back = "back"), ($b.forward = "forward"), ($b.unknown = "");
const Wb = /^[^#]+#/;
function Gb(e, t) {
	return e.replace(Wb, "#") + t;
}
const Yb = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function Xb(e) {
	let t;
	if ("el" in e) {
		let n = e.el;
		const r = "string" == typeof n && n.startsWith("#"),
			i = "string" == typeof n ? (r ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n;
		if (!i) return;
		t = (function (e, t) {
			const n = document.documentElement.getBoundingClientRect(),
				r = e.getBoundingClientRect();
			return { behavior: t.behavior, left: r.left - n.left - (t.left || 0), top: r.top - n.top - (t.top || 0) };
		})(i, e);
	} else t = e;
	"scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.pageXOffset, null != t.top ? t.top : window.pageYOffset);
}
function Kb(e, t) {
	return (history.state ? history.state.position - t : -1) + e;
}
const qb = new Map();
function Zb(e, t) {
	const { pathname: n, search: r, hash: i } = t;
	if (e.indexOf("#") > -1) {
		let e = i.slice(1);
		return "/" !== e[0] && (e = "/" + e), Nb(e, "");
	}
	return Nb(n, e) + r + i;
}
function Jb(e, t, n, r = !1, i = !1) {
	return { back: e, current: t, forward: n, replaced: r, position: window.history.length, scroll: i ? Yb() : null };
}
function Qb(e) {
	const { history: t, location: n } = window;
	let r = { value: Zb(e, n) },
		i = { value: t.state };
	function s(r, s, o) {
		const a = e.indexOf("#"),
			l = a > -1 ? (n.host && document.querySelector("base") ? e : e.slice(a)) + r : location.protocol + "//" + location.host + e + r;
		try {
			t[o ? "replaceState" : "pushState"](s, "", l), (i.value = s);
		} catch (u) {
			console.error(u), n[o ? "replace" : "assign"](l);
		}
	}
	return (
		i.value || s(r.value, { back: null, current: r.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0),
		{
			location: r,
			state: i,
			push: function (e, n) {
				const o = Ib({}, i.value, t.state, { forward: e, scroll: Yb() });
				s(o.current, o, !0), s(e, Ib({}, Jb(r.value, e, null), { position: o.position + 1 }, n), !1), (r.value = e);
			},
			replace: function (e, n) {
				s(e, Ib({}, t.state, Jb(i.value.back, e, i.value.forward, !0), n, { position: i.value.position }), !0), (r.value = e);
			}
		}
	);
}
function ex(e) {
	const t = Qb((e = jb(e))),
		n = (function (e, t, n, r) {
			let i = [],
				s = [],
				o = null;
			const a = ({ state: s }) => {
				const a = Zb(e, location),
					l = n.value,
					u = t.value;
				let c = 0;
				if (s) {
					if (((n.value = a), (t.value = s), o && o === l)) return void (o = null);
					c = u ? s.position - u.position : 0;
				} else r(a);
				i.forEach((e) => {
					e(n.value, l, { delta: c, type: Vb.pop, direction: c ? (c > 0 ? zb.forward : zb.back) : zb.unknown });
				});
			};
			function l() {
				const { history: e } = window;
				e.state && e.replaceState(Ib({}, e.state, { scroll: Yb() }), "");
			}
			return (
				window.addEventListener("popstate", a),
				window.addEventListener("beforeunload", l),
				{
					pauseListeners: function () {
						o = n.value;
					},
					listen: function (e) {
						i.push(e);
						const t = () => {
							const t = i.indexOf(e);
							t > -1 && i.splice(t, 1);
						};
						return s.push(t), t;
					},
					destroy: function () {
						for (const e of s) e();
						(s = []), window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", l);
					}
				}
			);
		})(e, t.state, t.location, t.replace);
	const r = Ib(
		{
			location: "",
			base: e,
			go: function (e, t = !0) {
				t || n.pauseListeners(), history.go(e);
			},
			createHref: Gb.bind(null, e)
		},
		t,
		n
	);
	return Object.defineProperty(r, "location", { get: () => t.location.value }), Object.defineProperty(r, "state", { get: () => t.state.value }), r;
}
function tx(e) {
	return "string" == typeof e || "symbol" == typeof e;
}
const nx = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 },
	rx = Cb("nf");
var ix, sx;
function ox(e, t) {
	return Ib(new Error(), { type: e, [rx]: !0 }, t);
}
function ax(e, t) {
	return e instanceof Error && rx in e && (null == t || !!(e.type & t));
}
((sx = ix || (ix = {}))[(sx.aborted = 4)] = "aborted"), (sx[(sx.cancelled = 8)] = "cancelled"), (sx[(sx.duplicated = 16)] = "duplicated");
const lx = { sensitive: !1, strict: !1, start: !0, end: !0 },
	ux = /[.+*?^${}()[\]/\\]/g;
function cx(e, t) {
	let n = 0;
	for (; n < e.length && n < t.length; ) {
		const r = t[n] - e[n];
		if (r) return r;
		n++;
	}
	return e.length < t.length ? (1 === e.length && 80 === e[0] ? -1 : 1) : e.length > t.length ? (1 === t.length && 80 === t[0] ? 1 : -1) : 0;
}
function hx(e, t) {
	let n = 0;
	const r = e.score,
		i = t.score;
	for (; n < r.length && n < i.length; ) {
		const e = cx(r[n], i[n]);
		if (e) return e;
		n++;
	}
	return i.length - r.length;
}
const dx = { type: 0, value: "" },
	px = /[a-zA-Z0-9_]/;
function fx(e, t, n) {
	const r = (function (e, t) {
			const n = Ib({}, lx, t);
			let r = [],
				i = n.start ? "^" : "";
			const s = [];
			for (const l of e) {
				const e = l.length ? [] : [90];
				n.strict && !l.length && (i += "/");
				for (let t = 0; t < l.length; t++) {
					const r = l[t];
					let o = 40 + (n.sensitive ? 0.25 : 0);
					if (0 === r.type) t || (i += "/"), (i += r.value.replace(ux, "\\$&")), (o += 40);
					else if (1 === r.type) {
						const { value: e, repeatable: n, optional: u, regexp: c } = r;
						s.push({ name: e, repeatable: n, optional: u });
						const h = c || "[^/]+?";
						if ("[^/]+?" !== h) {
							o += 10;
							try {
								new RegExp(`(${h})`);
							} catch (a) {
								throw new Error(`Invalid custom RegExp for param "${e}" (${h}): ` + a.message);
							}
						}
						let d = n ? `((?:${h})(?:/(?:${h}))*)` : `(${h})`;
						t || (d = u && l.length < 2 ? `(?:/${d})` : "/" + d), u && (d += "?"), (i += d), (o += 20), u && (o += -8), n && (o += -20), ".*" === h && (o += -50);
					}
					e.push(o);
				}
				r.push(e);
			}
			if (n.strict && n.end) {
				const e = r.length - 1;
				r[e][r[e].length - 1] += 0.7000000000000001;
			}
			n.strict || (i += "/?"), n.end ? (i += "$") : n.strict && (i += "(?:/|$)");
			const o = new RegExp(i, n.sensitive ? "" : "i");
			return {
				re: o,
				score: r,
				keys: s,
				parse: function (e) {
					const t = e.match(o),
						n = {};
					if (!t) return null;
					for (let r = 1; r < t.length; r++) {
						const e = t[r] || "",
							i = s[r - 1];
						n[i.name] = e && i.repeatable ? e.split("/") : e;
					}
					return n;
				},
				stringify: function (t) {
					let n = "",
						r = !1;
					for (const i of e) {
						(r && n.endsWith("/")) || (n += "/"), (r = !1);
						for (const e of i)
							if (0 === e.type) n += e.value;
							else if (1 === e.type) {
								const { value: s, repeatable: o, optional: a } = e,
									l = s in t ? t[s] : "";
								if (Array.isArray(l) && !o) throw new Error(`Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`);
								const u = Array.isArray(l) ? l.join("/") : l;
								if (!u) {
									if (!a) throw new Error(`Missing required param "${s}"`);
									i.length < 2 && (n.endsWith("/") ? (n = n.slice(0, -1)) : (r = !0));
								}
								n += u;
							}
					}
					return n;
				}
			};
		})(
			(function (e) {
				if (!e) return [[]];
				if ("/" === e) return [[dx]];
				if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);
				function t(e) {
					throw new Error(`ERR (${n})/"${u}": ${e}`);
				}
				let n = 0,
					r = n;
				const i = [];
				let s;
				function o() {
					s && i.push(s), (s = []);
				}
				let a,
					l = 0,
					u = "",
					c = "";
				function h() {
					u &&
						(0 === n
							? s.push({ type: 0, value: u })
							: 1 === n || 2 === n || 3 === n
							? (s.length > 1 && ("*" === a || "+" === a) && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`), s.push({ type: 1, value: u, regexp: c, repeatable: "*" === a || "+" === a, optional: "*" === a || "?" === a }))
							: t("Invalid state to consume buffer"),
						(u = ""));
				}
				function d() {
					u += a;
				}
				for (; l < e.length; )
					if (((a = e[l++]), "\\" !== a || 2 === n))
						switch (n) {
							case 0:
								"/" === a ? (u && h(), o()) : ":" === a ? (h(), (n = 1)) : d();
								break;
							case 4:
								d(), (n = r);
								break;
							case 1:
								"(" === a ? (n = 2) : px.test(a) ? d() : (h(), (n = 0), "*" !== a && "?" !== a && "+" !== a && l--);
								break;
							case 2:
								")" === a ? ("\\" == c[c.length - 1] ? (c = c.slice(0, -1) + a) : (n = 3)) : (c += a);
								break;
							case 3:
								h(), (n = 0), "*" !== a && "?" !== a && "+" !== a && l--, (c = "");
								break;
							default:
								t("Unknown state");
						}
					else (r = n), (n = 4);
				return 2 === n && t(`Unfinished custom RegExp for param "${u}"`), h(), o(), i;
			})(e.path),
			n
		),
		i = Ib(r, { record: e, parent: t, children: [], alias: [] });
	return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i), i;
}
function mx(e, t) {
	const n = [],
		r = new Map();
	function i(e, n, r) {
		let a = !r,
			l = (function (e) {
				return {
					path: e.path,
					redirect: e.redirect,
					name: e.name,
					meta: e.meta || {},
					aliasOf: void 0,
					beforeEnter: e.beforeEnter,
					props: vx(e),
					children: e.children || [],
					instances: {},
					leaveGuards: new Set(),
					updateGuards: new Set(),
					enterCallbacks: {},
					components: "components" in e ? e.components || {} : { default: e.component }
				};
			})(e);
		l.aliasOf = r && r.record;
		const u = bx(t, e),
			c = [l];
		if ("alias" in e) {
			const t = "string" == typeof e.alias ? [e.alias] : e.alias;
			for (const e of t) c.push(Ib({}, l, { components: r ? r.record.components : l.components, path: e, aliasOf: r ? r.record : l }));
		}
		let h, d;
		for (const t of c) {
			let { path: c } = t;
			if (n && "/" !== c[0]) {
				let e = n.record.path,
					r = "/" === e[e.length - 1] ? "" : "/";
				t.path = n.record.path + (c && r + c);
			}
			if (((h = fx(t, n, u)), r ? r.alias.push(h) : ((d = d || h), d !== h && d.alias.push(h), a && e.name && !gx(h) && s(e.name)), "children" in l)) {
				let e = l.children;
				for (let t = 0; t < e.length; t++) i(e[t], h, r && r.children[t]);
			}
			(r = r || h), o(h);
		}
		return d
			? () => {
					s(d);
			  }
			: Lb;
	}
	function s(e) {
		if (tx(e)) {
			const t = r.get(e);
			t && (r.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(s), t.alias.forEach(s));
		} else {
			let t = n.indexOf(e);
			t > -1 && (n.splice(t, 1), e.record.name && r.delete(e.record.name), e.children.forEach(s), e.alias.forEach(s));
		}
	}
	function o(e) {
		let t = 0;
		for (; t < n.length && hx(e, n[t]) >= 0; ) t++;
		n.splice(t, 0, e), e.record.name && !gx(e) && r.set(e.record.name, e);
	}
	return (
		(t = bx({ strict: !1, end: !0, sensitive: !1 }, t)),
		e.forEach((e) => i(e)),
		{
			addRoute: i,
			resolve: function (e, t) {
				let i,
					s,
					o,
					a = {};
				if ("name" in e && e.name) {
					if (((i = r.get(e.name)), !i)) throw ox(1, { location: e });
					(o = i.record.name),
						(a = Ib(
							(function (e, t) {
								let n = {};
								for (let r of t) r in e && (n[r] = e[r]);
								return n;
							})(
								t.params,
								i.keys.filter((e) => !e.optional).map((e) => e.name)
							),
							e.params
						)),
						(s = i.stringify(a));
				} else if ("path" in e) (s = e.path), (i = n.find((e) => e.re.test(s))), i && ((a = i.parse(s)), (o = i.record.name));
				else {
					if (((i = t.name ? r.get(t.name) : n.find((e) => e.re.test(t.path))), !i)) throw ox(1, { location: e, currentLocation: t });
					(o = i.record.name), (a = Ib({}, t.params, e.params)), (s = i.stringify(a));
				}
				const l = [];
				let u = i;
				for (; u; ) l.unshift(u.record), (u = u.parent);
				return { name: o, path: s, params: a, matched: l, meta: yx(l) };
			},
			removeRoute: s,
			getRoutes: function () {
				return n;
			},
			getRecordMatcher: function (e) {
				return r.get(e);
			}
		}
	);
}
function vx(e) {
	const t = {},
		n = e.props || !1;
	if ("component" in e) t.default = n;
	else for (let r in e.components) t[r] = "boolean" == typeof n ? n : n[r];
	return t;
}
function gx(e) {
	for (; e; ) {
		if (e.record.aliasOf) return !0;
		e = e.parent;
	}
	return !1;
}
function yx(e) {
	return e.reduce((e, t) => Ib(e, t.meta), {});
}
function bx(e, t) {
	let n = {};
	for (let r in e) n[r] = r in t ? t[r] : e[r];
	return n;
}
const xx = /#/g,
	_x = /&/g,
	wx = /\//g,
	Cx = /=/g,
	Sx = /\?/g,
	Ex = /\+/g,
	Tx = /%5B/g,
	kx = /%5D/g,
	Ax = /%5E/g,
	Mx = /%60/g,
	Ix = /%7B/g,
	Rx = /%7C/g,
	Lx = /%7D/g,
	Ox = /%20/g;
function Px(e) {
	return encodeURI("" + e)
		.replace(Rx, "|")
		.replace(Tx, "[")
		.replace(kx, "]");
}
function Nx(e) {
	return Px(e).replace(Ex, "%2B").replace(Ox, "+").replace(xx, "%23").replace(_x, "%26").replace(Mx, "`").replace(Ix, "{").replace(Lx, "}").replace(Ax, "^");
}
function Dx(e) {
	return (function (e) {
		return Px(e).replace(xx, "%23").replace(Sx, "%3F");
	})(e).replace(wx, "%2F");
}
function Bx(e) {
	try {
		return decodeURIComponent("" + e);
	} catch (t) {}
	return "" + e;
}
function Fx(e) {
	const t = {};
	if ("" === e || "?" === e) return t;
	const n = ("?" === e[0] ? e.slice(1) : e).split("&");
	for (let r = 0; r < n.length; ++r) {
		const e = n[r].replace(Ex, " ");
		let i = e.indexOf("="),
			s = Bx(i < 0 ? e : e.slice(0, i)),
			o = i < 0 ? null : Bx(e.slice(i + 1));
		if (s in t) {
			let e = t[s];
			Array.isArray(e) || (e = t[s] = [e]), e.push(o);
		} else t[s] = o;
	}
	return t;
}
function Hx(e) {
	let t = "";
	for (let n in e) {
		t.length && (t += "&");
		const r = e[n];
		if (((n = Nx(n).replace(Cx, "%3D")), null == r)) {
			void 0 !== r && (t += n);
			continue;
		}
		let i = Array.isArray(r) ? r.map((e) => e && Nx(e)) : [r && Nx(r)];
		for (let e = 0; e < i.length; e++) (t += (e ? "&" : "") + n), null != i[e] && (t += "=" + i[e]);
	}
	return t;
}
function Vx(e) {
	const t = {};
	for (let n in e) {
		let r = e[n];
		void 0 !== r && (t[n] = Array.isArray(r) ? r.map((e) => (null == e ? null : "" + e)) : null == r ? r : "" + r);
	}
	return t;
}
function Ux() {
	let e = [];
	return {
		add: function (t) {
			return (
				e.push(t),
				() => {
					const n = e.indexOf(t);
					n > -1 && e.splice(n, 1);
				}
			);
		},
		list: () => e,
		reset: function () {
			e = [];
		}
	};
}
function zx(e, t, n, r, i) {
	const s = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
	return () =>
		new Promise((o, a) => {
			const l = (e) => {
					var l;
					!1 === e ? a(ox(4, { from: n, to: t })) : e instanceof Error ? a(e) : "string" == typeof (l = e) || (l && "object" == typeof l) ? a(ox(2, { from: t, to: e })) : (s && r.enterCallbacks[i] === s && "function" == typeof e && s.push(e), o());
				},
				u = e.call(r && r.instances[i], t, n, l);
			let c = Promise.resolve(u);
			e.length < 3 && (c = c.then(l)), c.catch((e) => a(e));
		});
}
function $x(e, t, n, r) {
	const i = [];
	for (const o of e)
		for (const e in o.components) {
			let a = o.components[e];
			if ("beforeRouteEnter" === t || o.instances[e])
				if ("object" == typeof (s = a) || "displayName" in s || "props" in s || "__vccOpts" in s) {
					const s = (a.__vccOpts || a)[t];
					s && i.push(zx(s, n, r, o, e));
				} else {
					let s = a();
					(s = s.catch(console.error)),
						i.push(() =>
							s.then((i) => {
								if (!i) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${o.path}"`));
								const s = (a = i).__esModule || (wb && "Module" === a[Symbol.toStringTag]) ? i.default : i;
								var a;
								o.components[e] = s;
								const l = (s.__vccOpts || s)[t];
								return l && zx(l, n, r, o, e)();
							})
						);
				}
		}
	var s;
	return i;
}
function jx(e) {
	const t = vn(Tb),
		n = vn(kb),
		r = ht(() => t.resolve(it(e.to))),
		i = ht(() => {
			let { matched: e } = r.value,
				{ length: t } = e;
			const i = e[t - 1];
			let s = n.matched;
			if (!i || !s.length) return -1;
			let o = s.findIndex(Db.bind(null, i));
			if (o > -1) return o;
			let a = Gx(e[t - 2]);
			return t > 1 && Gx(i) === a && s[s.length - 1].path !== a ? s.findIndex(Db.bind(null, e[t - 2])) : o;
		}),
		s = ht(
			() =>
				i.value > -1 &&
				(function (e, t) {
					for (let n in t) {
						let r = t[n],
							i = e[n];
						if ("string" == typeof r) {
							if (r !== i) return !1;
						} else if (!Array.isArray(i) || i.length !== r.length || r.some((e, t) => e !== i[t])) return !1;
					}
					return !0;
				})(n.params, r.value.params)
		),
		o = ht(() => i.value > -1 && i.value === n.matched.length - 1 && Bb(n.params, r.value.params));
	return {
		route: r,
		href: ht(() => r.value.href),
		isActive: s,
		isExactActive: o,
		navigate: function (n = {}) {
			return (function (e) {
				if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
				if (e.defaultPrevented) return;
				if (void 0 !== e.button && 0 !== e.button) return;
				if (e.currentTarget && e.currentTarget.getAttribute) {
					const t = e.currentTarget.getAttribute("target");
					if (/\b_blank\b/i.test(t)) return;
				}
				e.preventDefault && e.preventDefault();
				return !0;
			})(n)
				? t[it(e.replace) ? "replace" : "push"](it(e.to))
				: Promise.resolve();
		}
	};
}
const Wx = Tn({
	name: "RouterLink",
	props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } },
	setup(e, { slots: t }) {
		const n = Fe(jx(e)),
			{ options: r } = vn(Tb),
			i = ht(() => ({ [Yx(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive, [Yx(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive }));
		return () => {
			const r = t.default && t.default(n);
			return e.custom ? r : xs("a", { "aria-current": n.isExactActive ? e.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: i.value }, r);
		};
	}
});
function Gx(e) {
	return e ? (e.aliasOf ? e.aliasOf.path : e.path) : "";
}
const Yx = (e, t, n) => (null != e ? e : null != t ? t : n);
function Xx(e, t) {
	if (!e) return null;
	const n = e(t);
	return 1 === n.length ? n[0] : n;
}
const Kx = Tn({
	name: "RouterView",
	inheritAttrs: !1,
	props: { name: { type: String, default: "default" }, route: Object },
	setup(e, { attrs: t, slots: n }) {
		const r = vn(Ab),
			i = ht(() => e.route || r.value),
			s = vn(Eb, 0),
			o = ht(() => i.value.matched[s]);
		mn(Eb, s + 1), mn(Sb, o), mn(Ab, i);
		const a = Qe();
		return (
			ds(
				() => [a.value, o.value, e.name],
				([e, t, n], [r, i, s]) => {
					t && ((t.instances[n] = e), i && i !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = i.leaveGuards), t.updateGuards.size || (t.updateGuards = i.updateGuards))), !e || !t || (i && Db(t, i) && r) || (t.enterCallbacks[n] || []).forEach((t) => t(e));
				},
				{ flush: "post" }
			),
			() => {
				const r = i.value,
					s = o.value,
					l = s && s.components[e.name],
					u = e.name;
				if (!l) return Xx(n.default, { Component: l, route: r });
				const c = s.props[e.name],
					h = c ? (!0 === c ? r.params : "function" == typeof c ? c(r) : c) : null,
					d = xs(
						l,
						Ib({}, h, t, {
							onVnodeUnmounted: (e) => {
								e.component.isUnmounted && (s.instances[u] = null);
							},
							ref: a
						})
					);
				return Xx(n.default, { Component: d, route: r }) || d;
			}
		);
	}
});
function qx(e) {
	const t = mx(e.routes, e);
	let n = e.parseQuery || Fx,
		r = e.stringifyQuery || Hx,
		i = e.history;
	const s = Ux(),
		o = Ux(),
		a = Ux(),
		l = et(nx);
	let u = nx;
	Mb && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
	const c = Rb.bind(null, (e) => "" + e),
		h = Rb.bind(null, Dx),
		d = Rb.bind(null, Bx);
	function p(e, s) {
		if (((s = Ib({}, s || l.value)), "string" == typeof e)) {
			let r = Pb(n, e, s.path),
				o = t.resolve({ path: r.path }, s),
				a = i.createHref(r.fullPath);
			return Ib(r, o, { params: d(o.params), hash: Bx(r.hash), redirectedFrom: void 0, href: a });
		}
		let o;
		"path" in e ? (o = Ib({}, e, { path: Pb(n, e.path, s.path).path })) : ((o = Ib({}, e, { params: h(e.params) })), (s.params = h(s.params)));
		let a = t.resolve(o, s);
		const u = e.hash || "";
		a.params = c(d(a.params));
		const p = (function (e, t) {
			let n = t.query ? e(t.query) : "";
			return t.path + (n && "?") + n + (t.hash || "");
		})(r, Ib({}, e, { hash: ((f = u), Px(f).replace(Ix, "{").replace(Lx, "}").replace(Ax, "^")), path: a.path }));
		var f;
		let m = i.createHref(p);
		return Ib({ fullPath: p, hash: u, query: r === Hx ? Vx(e.query) : e.query }, a, { redirectedFrom: void 0, href: m });
	}
	function f(e) {
		return "string" == typeof e ? Pb(n, e, l.value.path) : Ib({}, e);
	}
	function m(e, t) {
		if (u !== e) return ox(8, { from: t, to: e });
	}
	function v(e) {
		return y(e);
	}
	function g(e) {
		const t = e.matched[e.matched.length - 1];
		if (t && t.redirect) {
			const { redirect: n } = t;
			let r = "function" == typeof n ? n(e) : n;
			return "string" == typeof r && (r = r.indexOf("?") > -1 || r.indexOf("#") > -1 ? (r = f(r)) : { path: r }), Ib({ query: e.query, hash: e.hash, params: e.params }, r);
		}
	}
	function y(e, t) {
		const n = (u = p(e)),
			i = l.value,
			s = e.state,
			o = e.force,
			a = !0 === e.replace,
			c = g(n);
		if (c) return y(Ib(f(c), { state: s, force: o, replace: a }), t || n);
		const h = n;
		let d;
		return (
			(h.redirectedFrom = t),
			!o &&
				(function (e, t, n) {
					let r = t.matched.length - 1,
						i = n.matched.length - 1;
					return r > -1 && r === i && Db(t.matched[r], n.matched[i]) && Bb(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash;
				})(r, i, n) &&
				((d = ox(16, { to: h, from: i })), I(i, i, !0, !1)),
			(d ? Promise.resolve(d) : x(h, i))
				.catch((e) => (ax(e) ? e : A(e)))
				.then((e) => {
					if (e) {
						if (ax(e, 2)) return y(Ib(f(e.to), { state: s, force: o, replace: a }), t || h);
					} else e = w(h, i, !0, a, s);
					return _(h, i, e), e;
				})
		);
	}
	function b(e, t) {
		const n = m(e, t);
		return n ? Promise.reject(n) : Promise.resolve();
	}
	function x(e, t) {
		let n;
		const [r, i, a] = (function (e, t) {
			const n = [],
				r = [],
				i = [],
				s = Math.max(t.matched.length, e.matched.length);
			for (let o = 0; o < s; o++) {
				const s = t.matched[o];
				s && (e.matched.find((e) => Db(e, s)) ? r.push(s) : n.push(s));
				const a = e.matched[o];
				a && (t.matched.find((e) => Db(e, a)) || i.push(a));
			}
			return [n, r, i];
		})(e, t);
		n = $x(r.reverse(), "beforeRouteLeave", e, t);
		for (const s of r)
			s.leaveGuards.forEach((r) => {
				n.push(zx(r, e, t));
			});
		const l = b.bind(null, e, t);
		return (
			n.push(l),
			Zx(n)
				.then(() => {
					n = [];
					for (const r of s.list()) n.push(zx(r, e, t));
					return n.push(l), Zx(n);
				})
				.then(() => {
					n = $x(i, "beforeRouteUpdate", e, t);
					for (const r of i)
						r.updateGuards.forEach((r) => {
							n.push(zx(r, e, t));
						});
					return n.push(l), Zx(n);
				})
				.then(() => {
					n = [];
					for (const r of e.matched)
						if (r.beforeEnter && t.matched.indexOf(r) < 0)
							if (Array.isArray(r.beforeEnter)) for (const i of r.beforeEnter) n.push(zx(i, e, t));
							else n.push(zx(r.beforeEnter, e, t));
					return n.push(l), Zx(n);
				})
				.then(() => (e.matched.forEach((e) => (e.enterCallbacks = {})), (n = $x(a, "beforeRouteEnter", e, t)), n.push(l), Zx(n)))
				.then(() => {
					n = [];
					for (const r of o.list()) n.push(zx(r, e, t));
					return n.push(l), Zx(n);
				})
				.catch((e) => (ax(e, 8) ? e : Promise.reject(e)))
		);
	}
	function _(e, t, n) {
		for (const r of a.list()) r(e, t, n);
	}
	function w(e, t, n, r, s) {
		const o = m(e, t);
		if (o) return o;
		const a = t === nx,
			u = Mb ? history.state : {};
		n && (r || a ? i.replace(e.fullPath, Ib({ scroll: a && u && u.scroll }, s)) : i.push(e.fullPath, s)), (l.value = e), I(e, t, n, a), M();
	}
	let C;
	function S() {
		C = i.listen((e, t, n) => {
			let r = p(e);
			const s = g(r);
			if (s) return void y(Ib(s, { replace: !0 }), r).catch(Lb);
			u = r;
			const o = l.value;
			var a, c;
			Mb && ((a = Kb(o.fullPath, n.delta)), (c = Yb()), qb.set(a, c)),
				x(r, o)
					.catch((e) => (ax(e, 12) ? e : ax(e, 2) ? (y(e.to, r).catch(Lb), Promise.reject()) : (n.delta && i.go(-n.delta, !1), A(e))))
					.then((e) => {
						(e = e || w(r, o, !1)) && n.delta && i.go(-n.delta, !1), _(r, o, e);
					})
					.catch(Lb);
		});
	}
	let E,
		T = Ux(),
		k = Ux();
	function A(e) {
		return M(e), k.list().forEach((t) => t(e)), Promise.reject(e);
	}
	function M(e) {
		E || ((E = !0), S(), T.list().forEach(([t, n]) => (e ? n(e) : t())), T.reset());
	}
	function I(t, n, r, i) {
		const { scrollBehavior: s } = e;
		if (!Mb || !s) return Promise.resolve();
		let o =
			(!r &&
				(function (e) {
					const t = qb.get(e);
					return qb.delete(e), t;
				})(Kb(t.fullPath, 0))) ||
			((i || !r) && history.state && history.state.scroll) ||
			null;
		return ns()
			.then(() => s(t, n, o))
			.then((e) => e && Xb(e))
			.catch(A);
	}
	const R = (e) => i.go(e);
	let L;
	const O = new Set();
	return {
		currentRoute: l,
		addRoute: function (e, n) {
			let r, i;
			return tx(e) ? ((r = t.getRecordMatcher(e)), (i = n)) : (i = e), t.addRoute(i, r);
		},
		removeRoute: function (e) {
			let n = t.getRecordMatcher(e);
			n && t.removeRoute(n);
		},
		hasRoute: function (e) {
			return !!t.getRecordMatcher(e);
		},
		getRoutes: function () {
			return t.getRoutes().map((e) => e.record);
		},
		resolve: p,
		options: e,
		push: v,
		replace: function (e) {
			return v(Ib(f(e), { replace: !0 }));
		},
		go: R,
		back: () => R(-1),
		forward: () => R(1),
		beforeEach: s.add,
		beforeResolve: o.add,
		afterEach: a.add,
		onError: k.add,
		isReady: function () {
			return E && l.value !== nx
				? Promise.resolve()
				: new Promise((e, t) => {
						T.add([e, t]);
				  });
		},
		install(e) {
			e.component("RouterLink", Wx), e.component("RouterView", Kx), (e.config.globalProperties.$router = this), Object.defineProperty(e.config.globalProperties, "$route", { get: () => it(l) }), Mb && !L && l.value === nx && ((L = !0), v(i.location).catch((e) => {}));
			const t = {};
			for (let r in nx) t[r] = ht(() => l.value[r]);
			e.provide(Tb, this), e.provide(kb, Fe(t)), e.provide(Ab, l);
			let n = e.unmount;
			O.add(e),
				(e.unmount = function () {
					O.delete(e), O.size < 1 && (C(), (l.value = nx), (L = !1), (E = !1)), n();
				});
		}
	};
}
function Zx(e) {
	return e.reduce((e, t) => e.then(() => t()), Promise.resolve());
}
function Jx() {
	return vn(Tb);
}
function Qx() {
	return vn(kb);
}
const e_ = { mdi: { size: 24, viewbox: "0 0 24 24" }, "simple-icons": { size: 24, viewbox: "0 0 24 24" }, default: { size: 0, viewbox: "0 0 0 0" } },
	t_ = {
		name: "icon",
		props: { type: String, path: { type: String, required: !0 }, size: { type: Number, default: 24 }, viewbox: String, flip: { type: String, validator: () => ["horizontal", "vertical", "both"].includes(value) }, rotate: { type: Number, default: 0 } },
		computed: {
			styles() {
				return { "--sx": ["both", "horizontal"].includes(this.flip) ? "-1" : "1", "--sy": ["both", "vertical"].includes(this.flip) ? "-1" : "1", "--r": isNaN(this.rotate) ? this.rotate : this.rotate + "deg" };
			},
			defaults() {
				return e_[this.type] || e_.default;
			},
			sizeValue() {
				return this.size || this.defaults.size;
			},
			viewboxValue() {
				return this.viewbox || this.defaults.viewbox;
			}
		}
	},
	n_ = ["width", "height", "viewBox"],
	r_ = ["d"];
(t_.render = function (e, t, n, r, i, s) {
	return Wr(), Kr("svg", { width: s.sizeValue, height: s.sizeValue, viewBox: s.viewboxValue, style: pt(s.styles) }, [ni("path", { d: n.path }, null, 8, r_)], 12, n_);
}),
	(t_.__scopeId = "data-v-35f7fcad");
var i_ = "M12,4A4,4 0 0,1 16,8A4,4 0 0,1 12,12A4,4 0 0,1 8,8A4,4 0 0,1 12,4M12,14C16.42,14 20,15.79 20,18V20H4V18C4,15.79 7.58,14 12,14Z",
	s_ = "M21.1,12.5L22.5,13.91L15.97,20.5L12.5,17L13.9,15.59L15.97,17.67L21.1,12.5M10,17L13,20H3V18C3,15.79 6.58,14 11,14L12.89,14.11L10,17M11,4A4,4 0 0,1 15,8A4,4 0 0,1 11,12A4,4 0 0,1 7,8A4,4 0 0,1 11,4Z",
	o_ =
		"M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z",
	a_ = "M16 17V19H2V17S2 13 9 13 16 17 16 17M12.5 7.5A3.5 3.5 0 1 0 9 11A3.5 3.5 0 0 0 12.5 7.5M15.94 13A5.32 5.32 0 0 1 18 17V19H22V17S22 13.37 15.94 13M15 4A3.39 3.39 0 0 0 13.07 4.59A5 5 0 0 1 13.07 10.41A3.39 3.39 0 0 0 15 11A3.5 3.5 0 0 0 15 4Z",
	l_ = "M12,4A4,4 0 0,1 16,8C16,9.95 14.6,11.58 12.75,11.93L8.07,7.25C8.42,5.4 10.05,4 12,4M12.28,14L18.28,20L20,21.72L18.73,23L15.73,20H4V18C4,16.16 6.5,14.61 9.87,14.14L2.78,7.05L4.05,5.78L12.28,14M20,18V19.18L15.14,14.32C18,14.93 20,16.35 20,18Z",
	u_ = "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z",
	c_ = "M13 13H11V7H13M11 15H13V17H11M15.73 3H8.27L3 8.27V15.73L8.27 21H15.73L21 15.73V8.27L15.73 3Z",
	h_ = "M11,4H13V16L18.5,10.5L19.92,11.92L12,19.84L4.08,11.92L5.5,10.5L11,16V4Z",
	d_ = "M9,4H15V12H19.84L12,19.84L4.16,12H9V4Z",
	p_ = "M10,21V19H6.41L10.91,14.5L9.5,13.09L5,17.59V14H3V21H10M14.5,10.91L19,6.41V10H21V3H14V5H17.59L13.09,9.5L14.5,10.91Z",
	f_ = "M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z",
	m_ = "M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z",
	v_ = "M15,20H9V12H4.16L12,4.16L19.84,12H15V20Z",
	g_ = "M21,19V20H3V19L5,17V11C5,7.9 7.03,5.17 10,4.29C10,4.19 10,4.1 10,4A2,2 0 0,1 12,2A2,2 0 0,1 14,4C14,4.1 14,4.19 14,4.29C16.97,5.17 19,7.9 19,11V17L21,19M14,21A2,2 0 0,1 12,23A2,2 0 0,1 10,21",
	y_ =
		"M21.33,12.91C21.42,14.46 20.71,15.95 19.44,16.86L20.21,18.35C20.44,18.8 20.47,19.33 20.27,19.8C20.08,20.27 19.69,20.64 19.21,20.8L18.42,21.05C18.25,21.11 18.06,21.14 17.88,21.14C17.37,21.14 16.89,20.91 16.56,20.5L14.44,18C13.55,17.85 12.71,17.47 12,16.9C11.5,17.05 11,17.13 10.5,17.13C9.62,17.13 8.74,16.86 8,16.34C7.47,16.5 6.93,16.57 6.38,16.56C5.59,16.57 4.81,16.41 4.08,16.11C2.65,15.47 1.7,14.07 1.65,12.5C1.57,11.78 1.69,11.05 2,10.39C1.71,9.64 1.68,8.82 1.93,8.06C2.3,7.11 3,6.32 3.87,5.82C4.45,4.13 6.08,3 7.87,3.12C9.47,1.62 11.92,1.46 13.7,2.75C14.12,2.64 14.56,2.58 15,2.58C16.36,2.55 17.65,3.15 18.5,4.22C20.54,4.75 22,6.57 22.08,8.69C22.13,9.8 21.83,10.89 21.22,11.82C21.29,12.18 21.33,12.54 21.33,12.91M16.33,11.5C16.9,11.57 17.35,12 17.35,12.57A1,1 0 0,1 16.35,13.57H15.72C15.4,14.47 14.84,15.26 14.1,15.86C14.35,15.95 14.61,16 14.87,16.07C20,16 19.4,12.87 19.4,12.82C19.34,11.39 18.14,10.27 16.71,10.33A1,1 0 0,1 15.71,9.33A1,1 0 0,1 16.71,8.33C17.94,8.36 19.12,8.82 20.04,9.63C20.09,9.34 20.12,9.04 20.12,8.74C20.06,7.5 19.5,6.42 17.25,6.21C16,3.25 12.85,4.89 12.85,5.81V5.81C12.82,6.04 13.06,6.53 13.1,6.56A1,1 0 0,1 14.1,7.56C14.1,8.11 13.65,8.56 13.1,8.56V8.56C12.57,8.54 12.07,8.34 11.67,8C11.19,8.31 10.64,8.5 10.07,8.56V8.56C9.5,8.61 9.03,8.21 9,7.66C8.92,7.1 9.33,6.61 9.88,6.56C10.04,6.54 10.82,6.42 10.82,5.79V5.79C10.82,5.13 11.07,4.5 11.5,4C10.58,3.75 9.59,4.08 8.59,5.29C6.75,5 6,5.25 5.45,7.2C4.5,7.67 4,8 3.78,9C4.86,8.78 5.97,8.87 7,9.25C7.5,9.44 7.78,10 7.59,10.54C7.4,11.06 6.82,11.32 6.3,11.13C5.57,10.81 4.75,10.79 4,11.07C3.68,11.34 3.68,11.9 3.68,12.34C3.68,13.08 4.05,13.77 4.68,14.17C5.21,14.44 5.8,14.58 6.39,14.57C6.24,14.31 6.11,14.04 6,13.76C5.81,13.22 6.1,12.63 6.64,12.44C7.18,12.25 7.77,12.54 7.96,13.08C8.36,14.22 9.38,15 10.58,15.13C11.95,15.06 13.17,14.25 13.77,13C14,11.62 15.11,11.5 16.33,11.5M18.33,18.97L17.71,17.67L17,17.83L18,19.08L18.33,18.97M13.68,10.36C13.7,9.83 13.3,9.38 12.77,9.33C12.06,9.29 11.37,9.53 10.84,10C10.27,10.58 9.97,11.38 10,12.19A1,1 0 0,0 11,13.19C11.57,13.19 12,12.74 12,12.19C12,11.92 12.07,11.65 12.23,11.43C12.35,11.33 12.5,11.28 12.66,11.28C13.21,11.31 13.68,10.9 13.68,10.36Z",
	b_ = "M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z",
	x_ =
		"M11.5,0.5C12,0.75 13,2.4 13,3.5C13,4.6 12.33,5 11.5,5C10.67,5 10,4.85 10,3.75C10,2.65 11,2 11.5,0.5M18.5,9C21,9 23,11 23,13.5C23,15.06 22.21,16.43 21,17.24V23H12L3,23V17.24C1.79,16.43 1,15.06 1,13.5C1,11 3,9 5.5,9H10V6H13V9H18.5M12,16A2.5,2.5 0 0,0 14.5,13.5H16A2.5,2.5 0 0,0 18.5,16A2.5,2.5 0 0,0 21,13.5A2.5,2.5 0 0,0 18.5,11H5.5A2.5,2.5 0 0,0 3,13.5A2.5,2.5 0 0,0 5.5,16A2.5,2.5 0 0,0 8,13.5H9.5A2.5,2.5 0 0,0 12,16Z",
	__ = "M19,19H5V8H19M16,1V3H8V1H6V3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3H18V1M17,12H12V17H17V12Z",
	w_ = "M12,3C17.5,3 22,6.58 22,11C22,15.42 17.5,19 12,19C10.76,19 9.57,18.82 8.47,18.5C5.55,21 2,21 2,21C4.33,18.67 4.7,17.1 4.75,16.5C3.05,15.07 2,13.13 2,11C2,6.58 6.5,3 12,3Z",
	C_ = "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z",
	S_ = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z",
	E_ = "M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
	T_ = "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z",
	k_ = "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
	A_ = "M16.59,9.42L12,4.83L7.41,9.42L6,8L12,2L18,8L16.59,9.42M16.59,15.42L12,10.83L7.41,15.42L6,14L12,8L18,14L16.59,15.42M16.59,21.42L12,16.83L7.41,21.42L6,20L12,14L18,20L16.59,21.42Z",
	M_ = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
	I_ =
		"M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z",
	R_ =
		"M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10M10,22C9.75,22 9.54,21.82 9.5,21.58L9.13,18.93C8.5,18.68 7.96,18.34 7.44,17.94L4.95,18.95C4.73,19.03 4.46,18.95 4.34,18.73L2.34,15.27C2.21,15.05 2.27,14.78 2.46,14.63L4.57,12.97L4.5,12L4.57,11L2.46,9.37C2.27,9.22 2.21,8.95 2.34,8.73L4.34,5.27C4.46,5.05 4.73,4.96 4.95,5.05L7.44,6.05C7.96,5.66 8.5,5.32 9.13,5.07L9.5,2.42C9.54,2.18 9.75,2 10,2H14C14.25,2 14.46,2.18 14.5,2.42L14.87,5.07C15.5,5.32 16.04,5.66 16.56,6.05L19.05,5.05C19.27,4.96 19.54,5.05 19.66,5.27L21.66,8.73C21.79,8.95 21.73,9.22 21.54,9.37L19.43,11L19.5,12L19.43,13L21.54,14.63C21.73,14.78 21.79,15.05 21.66,15.27L19.66,18.73C19.54,18.95 19.27,19.04 19.05,18.95L16.56,17.95C16.04,18.34 15.5,18.68 14.87,18.93L14.5,21.58C14.46,21.82 14.25,22 14,22H10M11.25,4L10.88,6.61C9.68,6.86 8.62,7.5 7.85,8.39L5.44,7.35L4.69,8.65L6.8,10.2C6.4,11.37 6.4,12.64 6.8,13.8L4.68,15.36L5.43,16.66L7.86,15.62C8.63,16.5 9.68,17.14 10.87,17.38L11.24,20H12.76L13.13,17.39C14.32,17.14 15.37,16.5 16.14,15.62L18.57,16.66L19.32,15.36L17.2,13.81C17.6,12.64 17.6,11.37 17.2,10.2L19.31,8.65L18.56,7.35L16.15,8.39C15.38,7.5 14.32,6.86 13.12,6.62L12.75,4H11.25Z",
	L_ = "M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z",
	O_ =
		"M6,7H18A5,5 0 0,1 23,12A5,5 0 0,1 18,17C16.36,17 14.91,16.21 14,15H10C9.09,16.21 7.64,17 6,17A5,5 0 0,1 1,12A5,5 0 0,1 6,7M19.75,9.5A1.25,1.25 0 0,0 18.5,10.75A1.25,1.25 0 0,0 19.75,12A1.25,1.25 0 0,0 21,10.75A1.25,1.25 0 0,0 19.75,9.5M17.25,12A1.25,1.25 0 0,0 16,13.25A1.25,1.25 0 0,0 17.25,14.5A1.25,1.25 0 0,0 18.5,13.25A1.25,1.25 0 0,0 17.25,12M5,9V11H3V13H5V15H7V13H9V11H7V9H5Z",
	P_ =
		"M9,3V5H7A2,2 0 0,0 5,7V9H3V11H5V13H3V15H5V17A2,2 0 0,0 7,19H9V21H11V19H13V21H15V19H17A2,2 0 0,0 19,17V15H21V13H19V11H21V9H19V7A2,2 0 0,0 17,5H15V3H13V5H11V3M8,9H11.5V10.5H8.5V11.25H10.5A1,1 0 0,1 11.5,12.25V14A1,1 0 0,1 10.5,15H8A1,1 0 0,1 7,14V10A1,1 0 0,1 8,9M12.5,9H14V11H15.5V9H17V15H15.5V12.5H12.5M8.5,12.75V13.5H10V12.75",
	N_ = "M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16H5M19 19C19 19.6 18.6 20 18 20H6C5.4 20 5 19.6 5 19V18H19V19Z",
	D_ =
		"M9.38,8.38L11.5,9.34L13.62,8.38L12.66,10.5L13.62,12.62L11.5,11.66L9.38,12.62L10.34,10.5L9.38,8.38M16.5,2.5L17.59,5.41L20.5,6.5L17.59,7.59L16.5,10.5L15.41,7.59L12.5,6.5L15.41,5.41L16.5,2.5M6,19H7V18A1,1 0 0,1 8,17H8.26C6,15.7 4.5,13.28 4.5,10.5A7.5,7.5 0 0,1 12,3C13.05,3 14.05,3.22 14.96,3.61L14.59,4.59L13.17,5.12C12.79,5.04 12.4,5 12,5A5.5,5.5 0 0,0 6.5,10.5A5.5,5.5 0 0,0 12,16C14.91,16 17.3,13.73 17.5,10.87L18.41,8.41L19.12,8.14C19.37,8.88 19.5,9.68 19.5,10.5C19.5,13.28 18,15.7 15.74,17H16A1,1 0 0,1 17,18V19H18A2,2 0 0,1 20,21V22H4V21A2,2 0 0,1 6,19Z",
	B_ = "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z",
	F_ =
		"M22,24L16.75,19L17.38,21H4.5A2.5,2.5 0 0,1 2,18.5V3.5A2.5,2.5 0 0,1 4.5,1H19.5A2.5,2.5 0 0,1 22,3.5V24M12,6.8C9.32,6.8 7.44,7.95 7.44,7.95C8.47,7.03 10.27,6.5 10.27,6.5L10.1,6.33C8.41,6.36 6.88,7.53 6.88,7.53C5.16,11.12 5.27,14.22 5.27,14.22C6.67,16.03 8.75,15.9 8.75,15.9L9.46,15C8.21,14.73 7.42,13.62 7.42,13.62C7.42,13.62 9.3,14.9 12,14.9C14.7,14.9 16.58,13.62 16.58,13.62C16.58,13.62 15.79,14.73 14.54,15L15.25,15.9C15.25,15.9 17.33,16.03 18.73,14.22C18.73,14.22 18.84,11.12 17.12,7.53C17.12,7.53 15.59,6.36 13.9,6.33L13.73,6.5C13.73,6.5 15.53,7.03 16.56,7.95C16.56,7.95 14.68,6.8 12,6.8M9.93,10.59C10.58,10.59 11.11,11.16 11.1,11.86C11.1,12.55 10.58,13.13 9.93,13.13C9.29,13.13 8.77,12.55 8.77,11.86C8.77,11.16 9.28,10.59 9.93,10.59M14.1,10.59C14.75,10.59 15.27,11.16 15.27,11.86C15.27,12.55 14.75,13.13 14.1,13.13C13.46,13.13 12.94,12.55 12.94,11.86C12.94,11.16 13.45,10.59 14.1,10.59Z",
	H_ = "M16,12A2,2 0 0,1 18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12M10,12A2,2 0 0,1 12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12M4,12A2,2 0 0,1 6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12Z",
	V_ =
		"M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
	U_ =
		"M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M15.5,8A1.5,1.5 0 0,1 17,9.5A1.5,1.5 0 0,1 15.5,11A1.5,1.5 0 0,1 14,9.5A1.5,1.5 0 0,1 15.5,8M8.5,8A1.5,1.5 0 0,1 10,9.5A1.5,1.5 0 0,1 8.5,11A1.5,1.5 0 0,1 7,9.5A1.5,1.5 0 0,1 8.5,8M12,17.5C9.67,17.5 7.69,16.04 6.89,14H17.11C16.3,16.04 14.33,17.5 12,17.5Z",
	z_ =
		"M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2M6.76,8.82L7.82,7.76L8.88,8.82L9.94,7.76L11,8.82L9.94,9.88L11,10.94L9.94,12L8.88,10.94L7.82,12L6.76,10.94L7.82,9.88L6.76,8.82M6.89,17.5C7.69,15.46 9.67,14 12,14C14.33,14 16.31,15.46 17.11,17.5H6.89M17.24,10.94L16.18,12L15.12,10.94L14.06,12L13,10.94L14.06,9.88L13,8.82L14.06,7.76L15.12,8.82L16.18,7.76L17.24,8.82L16.18,9.88L17.24,10.94Z",
	$_ =
		"M12,2C6.47,2 2,6.47 2,12C2,17.53 6.47,22 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M16.18,7.76L15.12,8.82L14.06,7.76L13,8.82L14.06,9.88L13,10.94L14.06,12L15.12,10.94L16.18,12L17.24,10.94L16.18,9.88L17.24,8.82L16.18,7.76M7.82,12L8.88,10.94L9.94,12L11,10.94L9.94,9.88L11,8.82L9.94,7.76L8.88,8.82L7.82,7.76L6.76,8.82L7.82,9.88L6.76,10.94L7.82,12M12,14C9.67,14 7.69,15.46 6.89,17.5H17.11C16.31,15.46 14.33,14 12,14Z",
	j_ =
		"M12,17.5C14.33,17.5 16.3,16.04 17.11,14H6.89C7.69,16.04 9.67,17.5 12,17.5M8.5,11A1.5,1.5 0 0,0 10,9.5A1.5,1.5 0 0,0 8.5,8A1.5,1.5 0 0,0 7,9.5A1.5,1.5 0 0,0 8.5,11M15.5,11A1.5,1.5 0 0,0 17,9.5A1.5,1.5 0 0,0 15.5,8A1.5,1.5 0 0,0 14,9.5A1.5,1.5 0 0,0 15.5,11M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",
	W_ = "M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z",
	G_ =
		"M11.83,9L15,12.16C15,12.11 15,12.05 15,12A3,3 0 0,0 12,9C11.94,9 11.89,9 11.83,9M7.53,9.8L9.08,11.35C9.03,11.56 9,11.77 9,12A3,3 0 0,0 12,15C12.22,15 12.44,14.97 12.65,14.92L14.2,16.47C13.53,16.8 12.79,17 12,17A5,5 0 0,1 7,12C7,11.21 7.2,10.47 7.53,9.8M2,4.27L4.28,6.55L4.73,7C3.08,8.3 1.78,10 1,12C2.73,16.39 7,19.5 12,19.5C13.55,19.5 15.03,19.2 16.38,18.66L16.81,19.08L19.73,22L21,20.73L3.27,3M12,7A5,5 0 0,1 17,12C17,12.64 16.87,13.26 16.64,13.82L19.57,16.75C21.07,15.5 22.27,13.86 23,12C21.27,7.61 17,4.5 12,4.5C10.6,4.5 9.26,4.75 8,5.2L10.17,7.35C10.74,7.13 11.35,7 12,7Z",
	Y_ =
		"M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9M12,4.5C17,4.5 21.27,7.61 23,12C21.27,16.39 17,19.5 12,19.5C7,19.5 2.73,16.39 1,12C2.73,7.61 7,4.5 12,4.5M3.18,12C4.83,15.36 8.24,17.5 12,17.5C15.76,17.5 19.17,15.36 20.82,12C19.17,8.64 15.76,6.5 12,6.5C8.24,6.5 4.83,8.64 3.18,12Z",
	X_ = "M12 2.04C6.5 2.04 2 6.53 2 12.06C2 17.06 5.66 21.21 10.44 21.96V14.96H7.9V12.06H10.44V9.85C10.44 7.34 11.93 5.96 14.22 5.96C15.31 5.96 16.45 6.15 16.45 6.15V8.62H15.19C13.95 8.62 13.56 9.39 13.56 10.18V12.06H16.34L15.89 14.96H13.56V21.96A10 10 0 0 0 22 12.06C22 6.53 17.5 2.04 12 2.04Z",
	K_ = "M6,16.5L3,19.44V11H6M11,14.66L9.43,13.32L8,14.64V7H11M16,13L13,16V3H16M18.81,12.81L17,11H22V16L20.21,14.21L13,21.36L9.53,18.34L5.75,22H3L9.47,15.66L13,18.64",
	q_ =
		"M17.66 11.2C17.43 10.9 17.15 10.64 16.89 10.38C16.22 9.78 15.46 9.35 14.82 8.72C13.33 7.26 13 4.85 13.95 3C13 3.23 12.17 3.75 11.46 4.32C8.87 6.4 7.85 10.07 9.07 13.22C9.11 13.32 9.15 13.42 9.15 13.55C9.15 13.77 9 13.97 8.8 14.05C8.57 14.15 8.33 14.09 8.14 13.93C8.08 13.88 8.04 13.83 8 13.76C6.87 12.33 6.69 10.28 7.45 8.64C5.78 10 4.87 12.3 5 14.47C5.06 14.97 5.12 15.47 5.29 15.97C5.43 16.57 5.7 17.17 6 17.7C7.08 19.43 8.95 20.67 10.96 20.92C13.1 21.19 15.39 20.8 17.03 19.32C18.86 17.66 19.5 15 18.56 12.72L18.43 12.46C18.22 12 17.66 11.2 17.66 11.2M14.5 17.5C14.22 17.74 13.76 18 13.4 18.1C12.28 18.5 11.16 17.94 10.5 17.28C11.69 17 12.4 16.12 12.61 15.23C12.78 14.43 12.46 13.77 12.33 13C12.21 12.26 12.23 11.63 12.5 10.94C12.69 11.32 12.89 11.7 13.13 12C13.9 13 15.11 13.44 15.37 14.8C15.41 14.94 15.43 15.08 15.43 15.23C15.46 16.05 15.1 16.95 14.5 17.5H14.5Z",
	Z_ = "M7,13V11H21V13H7M7,19V17H21V19H7M7,7V5H21V7H7M3,8V5H2V4H4V8H3M2,17V16H5V20H2V19H4V18.5H3V17.5H4V17H2M4.25,10A0.75,0.75 0 0,1 5,10.75C5,10.95 4.92,11.14 4.79,11.27L3.12,13H5V14H2V13.08L4,11H2V10H4.25Z",
	J_ = "M17,12V3A1,1 0 0,0 16,2H3A1,1 0 0,0 2,3V17L6,13H16A1,1 0 0,0 17,12M21,6H19V15H6V17A1,1 0 0,0 7,18H18L22,22V7A1,1 0 0,0 21,6Z",
	Q_ = "M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z",
	ew =
		"M21.35,11.1H12.18V13.83H18.69C18.36,17.64 15.19,19.27 12.19,19.27C8.36,19.27 5,16.25 5,12C5,7.9 8.2,4.73 12.2,4.73C15.29,4.73 17.1,6.7 17.1,6.7L19,4.72C19,4.72 16.56,2 12.1,2C6.42,2 2.03,6.8 2.03,12C2.03,17.05 6.16,22 12.25,22C17.6,22 21.5,18.33 21.5,12.91C21.5,11.76 21.35,11.1 21.35,11.1V11.1Z",
	tw =
		"M7.97,16L5,19C4.67,19.3 4.23,19.5 3.75,19.5A1.75,1.75 0 0,1 2,17.75V17.5L3,10.12C3.21,7.81 5.14,6 7.5,6H16.5C18.86,6 20.79,7.81 21,10.12L22,17.5V17.75A1.75,1.75 0 0,1 20.25,19.5C19.77,19.5 19.33,19.3 19,19L16.03,16H7.97M7,8V10H5V11H7V13H8V11H10V10H8V8H7M16.5,8A0.75,0.75 0 0,0 15.75,8.75A0.75,0.75 0 0,0 16.5,9.5A0.75,0.75 0 0,0 17.25,8.75A0.75,0.75 0 0,0 16.5,8M14.75,9.75A0.75,0.75 0 0,0 14,10.5A0.75,0.75 0 0,0 14.75,11.25A0.75,0.75 0 0,0 15.5,10.5A0.75,0.75 0 0,0 14.75,9.75M18.25,9.75A0.75,0.75 0 0,0 17.5,10.5A0.75,0.75 0 0,0 18.25,11.25A0.75,0.75 0 0,0 19,10.5A0.75,0.75 0 0,0 18.25,9.75M16.5,11.5A0.75,0.75 0 0,0 15.75,12.25A0.75,0.75 0 0,0 16.5,13A0.75,0.75 0 0,0 17.25,12.25A0.75,0.75 0 0,0 16.5,11.5Z",
	nw =
		"M13.5,4A1.5,1.5 0 0,0 12,5.5A1.5,1.5 0 0,0 13.5,7A1.5,1.5 0 0,0 15,5.5A1.5,1.5 0 0,0 13.5,4M13.14,8.77C11.95,8.87 8.7,11.46 8.7,11.46C8.5,11.61 8.56,11.6 8.72,11.88C8.88,12.15 8.86,12.17 9.05,12.04C9.25,11.91 9.58,11.7 10.13,11.36C12.25,10 10.47,13.14 9.56,18.43C9.2,21.05 11.56,19.7 12.17,19.3C12.77,18.91 14.38,17.8 14.54,17.69C14.76,17.54 14.6,17.42 14.43,17.17C14.31,17 14.19,17.12 14.19,17.12C13.54,17.55 12.35,18.45 12.19,17.88C12,17.31 13.22,13.4 13.89,10.71C14,10.07 14.3,8.67 13.14,8.77Z",
	rw = "M19,7V11H5.83L9.41,7.41L8,6L2,12L8,18L9.41,16.58L5.83,13H21V7H19Z",
	iw = "M4,1C2.89,1 2,1.89 2,3V7C2,8.11 2.89,9 4,9H1V11H13V9H10C11.11,9 12,8.11 12,7V3C12,1.89 11.11,1 10,1H4M4,3H10V7H4V3M3,13V18L3,20H10V18H5V13H3M14,13C12.89,13 12,13.89 12,15V19C12,20.11 12.89,21 14,21H11V23H23V21H20C21.11,21 22,20.11 22,19V15C22,13.89 21.11,13 20,13H14M14,15H20V19H14V15Z",
	sw = "M3.9,12C3.9,10.29 5.29,8.9 7,8.9H11V7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H11V15.1H7C5.29,15.1 3.9,13.71 3.9,12M8,13H16V11H8V13M17,7H13V8.9H17C18.71,8.9 20.1,10.29 20.1,12C20.1,13.71 18.71,15.1 17,15.1H13V17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7Z",
	ow = "M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z",
	aw = "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z",
	lw = "M9,2A7,7 0 0,1 16,9C16,10.57 15.5,12 14.61,13.19L15.41,14H16L22,20L20,22L14,16V15.41L13.19,14.61C12,15.5 10.57,16 9,16A7,7 0 0,1 2,9A7,7 0 0,1 9,2M5,8V10H13V8H5Z",
	uw = "M15.5,14H14.71L14.43,13.73C15.41,12.59 16,11.11 16,9.5A6.5,6.5 0 0,0 9.5,3A6.5,6.5 0 0,0 3,9.5A6.5,6.5 0 0,0 9.5,16C11.11,16 12.59,15.41 13.73,14.43L14,14.71V15.5L19,20.5L20.5,19L15.5,14M9.5,14C7,14 5,12 5,9.5C5,7 7,5 9.5,5C12,5 14,7 14,9.5C14,12 12,14 9.5,14M7,9H12V10H7V9Z",
	cw = "M9,2A7,7 0 0,1 16,9C16,10.57 15.5,12 14.61,13.19L15.41,14H16L22,20L20,22L14,16V15.41L13.19,14.61C12,15.5 10.57,16 9,16A7,7 0 0,1 2,9A7,7 0 0,1 9,2M8,5V8H5V10H8V13H10V10H13V8H10V5H8Z",
	hw =
		"M15.5,14L20.5,19L19,20.5L14,15.5V14.71L13.73,14.43C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.43,13.73L14.71,14H15.5M9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14M12,10H10V12H9V10H7V9H9V7H10V9H12V10Z",
	dw =
		"M15.5,12C18,12 20,14 20,16.5C20,17.38 19.75,18.21 19.31,18.9L22.39,22L21,23.39L17.88,20.32C17.19,20.75 16.37,21 15.5,21C13,21 11,19 11,16.5C11,14 13,12 15.5,12M15.5,14A2.5,2.5 0 0,0 13,16.5A2.5,2.5 0 0,0 15.5,19A2.5,2.5 0 0,0 18,16.5A2.5,2.5 0 0,0 15.5,14M14,6.11L8,4V15.89L9,16.24V16.5C9,17.14 9.09,17.76 9.26,18.34L8,17.9L2.66,19.97L2.5,20A0.5,0.5 0 0,1 2,19.5V4.38C2,4.15 2.15,3.97 2.36,3.9L8,2L14,4.1L19.34,2H19.5A0.5,0.5 0 0,1 20,2.5V11.81C18.83,10.69 17.25,10 15.5,10C15,10 14.5,10.06 14,10.17V6.11Z",
	pw = "M7,10L12,15L17,10H7Z",
	fw = "M7,15L12,10L17,15H7Z",
	mw = "M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4C22,2.89 21.1,2 20,2Z",
	vw = "M20 2H4C2.9 2 2 2.9 2 4V22L6 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2M20 16H5.2L4 17.2V4H20V16Z",
	gw =
		"M20,4C21.11,4 22,4.89 22,6V18C22,19.11 21.11,20 20,20H4C2.89,20 2,19.11 2,18V6C2,4.89 2.89,4 4,4H20M8.5,15V9H7.25V12.5L4.75,9H3.5V15H4.75V11.5L7.3,15H8.5M13.5,10.26V9H9.5V15H13.5V13.75H11V12.64H13.5V11.38H11V10.26H13.5M20.5,14V9H19.25V13.5H18.13V10H16.88V13.5H15.75V9H14.5V14A1,1 0 0,0 15.5,15H19.5A1,1 0 0,0 20.5,14Z",
	yw = "M20,11H4V8H20M20,15H13V13H20M20,19H13V17H20M11,19H4V13H11M20.33,4.67L18.67,3L17,4.67L15.33,3L13.67,4.67L12,3L10.33,4.67L8.67,3L7,4.67L5.33,3L3.67,4.67L2,3V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V3L20.33,4.67Z",
	bw = "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
	xw =
		"M3 17.25V21H6.75L17.81 9.93L14.06 6.18L3 17.25M22.61 18.36L18.36 22.61L13.16 17.41L14.93 15.64L15.93 16.64L18.4 14.16L19.82 15.58L18.36 17L19.42 18L20.84 16.6L22.61 18.36M6.61 10.83L1.39 5.64L5.64 1.39L7.4 3.16L4.93 5.64L6 6.7L8.46 4.22L9.88 5.64L8.46 7.05L9.46 8.05L6.61 10.83M20.71 7C21.1 6.61 21.1 6 20.71 5.59L18.37 3.29C18 2.9 17.35 2.9 16.96 3.29L15.12 5.12L18.87 8.87L20.71 7Z",
	_w = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12Z",
	ww = "M2,5.27L3.28,4L20,20.72L18.73,22L12.8,16.07V22H11.2V16H6V14L8,12V11.27L2,5.27M16,12L18,14V16H17.82L8,6.18V4H7V2H17V4H16V12Z",
	Cw = "M8,6.2V4H7V2H17V4H16V12L18,14V16H17.8L14,12.2V4H10V8.2L8,6.2M20,20.7L18.7,22L12.8,16.1V22H11.2V16H6V14L8,12V11.3L2,5.3L3.3,4L20,20.7M8.8,14H10.6L9.7,13.1L8.8,14Z",
	Sw = "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12M8.8,14L10,12.8V4H14V12.8L15.2,14H8.8Z",
	Ew = "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z",
	Tw =
		"M20.5,11H19V7C19,5.89 18.1,5 17,5H13V3.5A2.5,2.5 0 0,0 10.5,1A2.5,2.5 0 0,0 8,3.5V5H4A2,2 0 0,0 2,7V10.8H3.5C5,10.8 6.2,12 6.2,13.5C6.2,15 5,16.2 3.5,16.2H2V20A2,2 0 0,0 4,22H7.8V20.5C7.8,19 9,17.8 10.5,17.8C12,17.8 13.2,19 13.2,20.5V22H17A2,2 0 0,0 19,20V16H20.5A2.5,2.5 0 0,0 23,13.5A2.5,2.5 0 0,0 20.5,11Z",
	kw =
		"M14.5 15.41C14.58 15.5 14.58 15.69 14.5 15.8C13.77 16.5 12.41 16.56 12 16.56C11.61 16.56 10.25 16.5 9.54 15.8C9.44 15.69 9.44 15.5 9.54 15.41C9.65 15.31 9.82 15.31 9.92 15.41C10.38 15.87 11.33 16 12 16C12.69 16 13.66 15.87 14.1 15.41C14.21 15.31 14.38 15.31 14.5 15.41M10.75 13.04C10.75 12.47 10.28 12 9.71 12C9.14 12 8.67 12.47 8.67 13.04C8.67 13.61 9.14 14.09 9.71 14.08C10.28 14.08 10.75 13.61 10.75 13.04M14.29 12C13.72 12 13.25 12.5 13.25 13.05S13.72 14.09 14.29 14.09C14.86 14.09 15.33 13.61 15.33 13.05C15.33 12.5 14.86 12 14.29 12M22 12C22 17.5 17.5 22 12 22S2 17.5 2 12C2 6.5 6.5 2 12 2S22 6.5 22 12M18.67 12C18.67 11.19 18 10.54 17.22 10.54C16.82 10.54 16.46 10.7 16.2 10.95C15.2 10.23 13.83 9.77 12.3 9.71L12.97 6.58L15.14 7.05C15.16 7.6 15.62 8.04 16.18 8.04C16.75 8.04 17.22 7.57 17.22 7C17.22 6.43 16.75 5.96 16.18 5.96C15.77 5.96 15.41 6.2 15.25 6.55L12.82 6.03C12.75 6 12.68 6.03 12.63 6.07C12.57 6.11 12.54 6.17 12.53 6.24L11.79 9.72C10.24 9.77 8.84 10.23 7.82 10.96C7.56 10.71 7.2 10.56 6.81 10.56C6 10.56 5.35 11.21 5.35 12C5.35 12.61 5.71 13.11 6.21 13.34C6.19 13.5 6.18 13.62 6.18 13.78C6.18 16 8.79 17.85 12 17.85C15.23 17.85 17.85 16.03 17.85 13.78C17.85 13.64 17.84 13.5 17.81 13.34C18.31 13.11 18.67 12.6 18.67 12Z",
	Aw = "M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z",
	Mw = "M12 1L3 5V11C3 16.55 6.84 21.74 12 23C17.16 21.74 21 16.55 21 11V5L12 1M15.08 16L12 14.15L8.93 16L9.74 12.5L7.03 10.16L10.61 9.85L12 6.55L13.39 9.84L16.97 10.15L14.26 12.5L15.08 16Z",
	Iw = "M3,21H6V18H3M8,21H11V14H8M13,21H16V9H13M18,21H21V3H18V21Z",
	Rw = "M19.5,5.5V18.5H17.5V5.5H19.5M12.5,10.5V18.5H10.5V10.5H12.5M21,4H16V20H21V4M14,9H9V20H14V9M7,14H2V20H7V14Z",
	Lw = "M19.5,5.5V18.5H17.5V5.5H19.5M21,4H16V20H21V4M14,9H9V20H14V9M7,14H2V20H7V14Z",
	Ow = "M21,4H16V20H21V4M14,9H9V20H14V9M7,14H2V20H7V14Z",
	Pw = "M19.5,5.5V18.5H17.5V5.5H19.5M12.5,10.5V18.5H10.5V10.5H12.5M5.5,15.5V18.5H3.5V15.5H5.5M21,4H16V20H21V4M14,9H9V20H14V9M7,14H2V20H7V14Z",
	Nw = "M18,3V16.18L21,19.18V3H18M4.28,5L3,6.27L10.73,14H8V21H11V14.27L13,16.27V21H16V19.27L19.73,23L21,21.72L4.28,5M13,9V11.18L16,14.18V9H13M3,18V21H6V18H3Z",
	Dw = "M12,18H6V14H12M21,14V12L20,7H4L3,12V14H4V20H14V14H18V20H20V14M20,4H4V6H20V4Z",
	Bw = "M23,10C23,8.89 22.1,8 21,8H14.68L15.64,3.43C15.66,3.33 15.67,3.22 15.67,3.11C15.67,2.7 15.5,2.32 15.23,2.05L14.17,1L7.59,7.58C7.22,7.95 7,8.45 7,9V19A2,2 0 0,0 9,21H18C18.83,21 19.54,20.5 19.84,19.78L22.86,12.73C22.95,12.5 23,12.26 23,12V10M1,21H5V9H1V21Z",
	Fw = "M19.03 7.39L20.45 5.97C20 5.46 19.55 5 19.04 4.56L17.62 6C16.07 4.74 14.12 4 12 4C7.03 4 3 8.03 3 13S7.03 22 12 22C17 22 21 17.97 21 13C21 10.88 20.26 8.93 19.03 7.39M13 14H11V7H13V14M15 1H9V3H15V1Z",
	Hw =
		"M15.07 2H8.93C3.33 2 2 3.33 2 8.93V15.07C2 20.67 3.33 22 8.93 22H15.07C20.67 22 22 20.67 22 15.07V8.93C22 3.33 20.67 2 15.07 2M18.15 16.27H16.69C16.14 16.27 15.97 15.82 15 14.83C14.12 14 13.74 13.88 13.53 13.88C13.24 13.88 13.15 13.96 13.15 14.38V15.69C13.15 16.04 13.04 16.26 12.11 16.26C10.57 16.26 8.86 15.32 7.66 13.59C5.85 11.05 5.36 9.13 5.36 8.75C5.36 8.54 5.43 8.34 5.85 8.34H7.32C7.69 8.34 7.83 8.5 7.97 8.9C8.69 11 9.89 12.8 10.38 12.8C10.57 12.8 10.65 12.71 10.65 12.25V10.1C10.6 9.12 10.07 9.03 10.07 8.68C10.07 8.5 10.21 8.34 10.44 8.34H12.73C13.04 8.34 13.15 8.5 13.15 8.88V11.77C13.15 12.08 13.28 12.19 13.38 12.19C13.56 12.19 13.72 12.08 14.05 11.74C15.1 10.57 15.85 8.76 15.85 8.76C15.95 8.55 16.11 8.35 16.5 8.35H17.93C18.37 8.35 18.47 8.58 18.37 8.89C18.19 9.74 16.41 12.25 16.43 12.25C16.27 12.5 16.21 12.61 16.43 12.9C16.58 13.11 17.09 13.55 17.43 13.94C18.05 14.65 18.53 15.24 18.66 15.65C18.77 16.06 18.57 16.27 18.15 16.27Z",
	Vw = "M6 19H8V21H6V19M12 3L2 8V21H4V13H20V21H22V8L12 3M8 11H4V9H8V11M14 11H10V9H14V11M20 11H16V9H20V11M6 15H8V17H6V15M10 15H12V17H10V15M10 19H12V21H10V19M14 19H16V21H14V19Z",
	Uw =
		"M10,15L15.19,12L10,9V15M21.56,7.17C21.69,7.64 21.78,8.27 21.84,9.07C21.91,9.87 21.94,10.56 21.94,11.16L22,12C22,14.19 21.84,15.8 21.56,16.83C21.31,17.73 20.73,18.31 19.83,18.56C19.36,18.69 18.5,18.78 17.18,18.84C15.88,18.91 14.69,18.94 13.59,18.94L12,19C7.81,19 5.2,18.84 4.17,18.56C3.27,18.31 2.69,17.73 2.44,16.83C2.31,16.36 2.22,15.73 2.16,14.93C2.09,14.13 2.06,13.44 2.06,12.84L2,12C2,9.81 2.16,8.2 2.44,7.17C2.69,6.27 3.27,5.69 4.17,5.44C4.64,5.31 5.5,5.22 6.82,5.16C8.12,5.09 9.31,5.06 10.41,5.06L12,5C16.19,5 18.8,5.16 19.83,5.44C20.73,5.69 21.31,6.27 21.56,7.17Z",
	zw = "object" == typeof global && global && global.Object === Object && global,
	$w = "object" == typeof self && self && self.Object === Object && self,
	jw = zw || $w || Function("return this")(),
	Ww = jw.Symbol,
	Gw = Object.prototype,
	Yw = Gw.hasOwnProperty,
	Xw = Gw.toString,
	Kw = Ww ? Ww.toStringTag : void 0;
var qw = Object.prototype.toString;
var Zw = Ww ? Ww.toStringTag : void 0;
function Jw(e) {
	return null == e
		? void 0 === e
			? "[object Undefined]"
			: "[object Null]"
		: Zw && Zw in Object(e)
		? (function (e) {
				var t = Yw.call(e, Kw),
					n = e[Kw];
				try {
					e[Kw] = void 0;
					var r = !0;
				} catch (Kj) {}
				var i = Xw.call(e);
				return r && (t ? (e[Kw] = n) : delete e[Kw]), i;
		  })(e)
		: (function (e) {
				return qw.call(e);
		  })(e);
}
function Qw(e) {
	return null != e && "object" == typeof e;
}
function eC(e) {
	return "symbol" == typeof e || (Qw(e) && "[object Symbol]" == Jw(e));
}
function tC(e, t) {
	for (var n = -1, r = null == e ? 0 : e.length, i = Array(r); ++n < r; ) i[n] = t(e[n], n, e);
	return i;
}
var nC = Array.isArray,
	rC = Ww ? Ww.prototype : void 0,
	iC = rC ? rC.toString : void 0;
function sC(e) {
	if ("string" == typeof e) return e;
	if (nC(e)) return tC(e, sC) + "";
	if (eC(e)) return iC ? iC.call(e) : "";
	var t = e + "";
	return "0" == t && 1 / e == -Infinity ? "-0" : t;
}
var oC = /\s/;
var aC = /^\s+/;
function lC(e) {
	return e
		? e
				.slice(
					0,
					(function (e) {
						for (var t = e.length; t-- && oC.test(e.charAt(t)); );
						return t;
					})(e) + 1
				)
				.replace(aC, "")
		: e;
}
function uC(e) {
	var t = typeof e;
	return null != e && ("object" == t || "function" == t);
}
var cC = /^[-+]0x[0-9a-f]+$/i,
	hC = /^0b[01]+$/i,
	dC = /^0o[0-7]+$/i,
	pC = parseInt;
function fC(e) {
	if ("number" == typeof e) return e;
	if (eC(e)) return NaN;
	if (uC(e)) {
		var t = "function" == typeof e.valueOf ? e.valueOf() : e;
		e = uC(t) ? t + "" : t;
	}
	if ("string" != typeof e) return 0 === e ? e : +e;
	e = lC(e);
	var n = hC.test(e);
	return n || dC.test(e) ? pC(e.slice(2), n ? 2 : 8) : cC.test(e) ? NaN : +e;
}
function mC(e) {
	return e;
}
function vC(e) {
	if (!uC(e)) return !1;
	var t = Jw(e);
	return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t;
}
var gC,
	yC = jw["__core-js_shared__"],
	bC = (gC = /[^.]+$/.exec((yC && yC.keys && yC.keys.IE_PROTO) || "")) ? "Symbol(src)_1." + gC : "";
var xC = Function.prototype.toString;
function _C(e) {
	if (null != e) {
		try {
			return xC.call(e);
		} catch (Kj) {}
		try {
			return e + "";
		} catch (Kj) {}
	}
	return "";
}
var wC = /^\[object .+?Constructor\]$/,
	CC = Function.prototype,
	SC = Object.prototype,
	EC = CC.toString,
	TC = SC.hasOwnProperty,
	kC = RegExp(
		"^" +
			EC.call(TC)
				.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
				.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
			"$"
	);
function AC(e) {
	return !(!uC(e) || ((t = e), bC && bC in t)) && (vC(e) ? kC : wC).test(_C(e));
	var t;
}
function MC(e, t) {
	var n = (function (e, t) {
		return null == e ? void 0 : e[t];
	})(e, t);
	return AC(n) ? n : void 0;
}
var IC = MC(jw, "WeakMap"),
	RC = Object.create,
	LC = (function () {
		function e() {}
		return function (t) {
			if (!uC(t)) return {};
			if (RC) return RC(t);
			e.prototype = t;
			var n = new e();
			return (e.prototype = void 0), n;
		};
	})();
function OC(e, t, n) {
	switch (n.length) {
		case 0:
			return e.call(t);
		case 1:
			return e.call(t, n[0]);
		case 2:
			return e.call(t, n[0], n[1]);
		case 3:
			return e.call(t, n[0], n[1], n[2]);
	}
	return e.apply(t, n);
}
var PC = Date.now;
var NC,
	DC,
	BC,
	FC = (function () {
		try {
			var e = MC(Object, "defineProperty");
			return e({}, "", {}), e;
		} catch (Kj) {}
	})(),
	HC =
		((NC = FC
			? function (e, t) {
					return FC(e, "toString", {
						configurable: !0,
						enumerable: !1,
						value:
							((n = t),
							function () {
								return n;
							}),
						writable: !0
					});
					var n;
			  }
			: mC),
		(DC = 0),
		(BC = 0),
		function () {
			var e = PC(),
				t = 16 - (e - BC);
			if (((BC = e), t > 0)) {
				if (++DC >= 800) return arguments[0];
			} else DC = 0;
			return NC.apply(void 0, arguments);
		});
function VC(e) {
	return e != e;
}
function UC(e, t) {
	return (
		!!(null == e ? 0 : e.length) &&
		(function (e, t, n) {
			return t == t
				? (function (e, t, n) {
						for (var r = n - 1, i = e.length; ++r < i; ) if (e[r] === t) return r;
						return -1;
				  })(e, t, n)
				: (function (e, t, n, r) {
						for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; ) if (t(e[s], s, e)) return s;
						return -1;
				  })(e, VC, n);
		})(e, t, 0) > -1
	);
}
var zC = /^(?:0|[1-9]\d*)$/;
function $C(e, t) {
	var n = typeof e;
	return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || ("symbol" != n && zC.test(e))) && e > -1 && e % 1 == 0 && e < t;
}
function jC(e, t, n) {
	"__proto__" == t && FC ? FC(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : (e[t] = n);
}
function WC(e, t) {
	return e === t || (e != e && t != t);
}
var GC = Object.prototype.hasOwnProperty;
function YC(e, t, n) {
	var r = e[t];
	(GC.call(e, t) && WC(r, n) && (void 0 !== n || t in e)) || jC(e, t, n);
}
function XC(e, t, n, r) {
	var i = !n;
	n || (n = {});
	for (var s = -1, o = t.length; ++s < o; ) {
		var a = t[s],
			l = r ? r(n[a], e[a], a, n, e) : void 0;
		void 0 === l && (l = e[a]), i ? jC(n, a, l) : YC(n, a, l);
	}
	return n;
}
var KC = Math.max;
function qC(e, t, n) {
	return (
		(t = KC(void 0 === t ? e.length - 1 : t, 0)),
		function () {
			for (var r = arguments, i = -1, s = KC(r.length - t, 0), o = Array(s); ++i < s; ) o[i] = r[t + i];
			i = -1;
			for (var a = Array(t + 1); ++i < t; ) a[i] = r[i];
			return (a[t] = n(o)), OC(e, this, a);
		}
	);
}
function ZC(e) {
	return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;
}
function JC(e) {
	return null != e && ZC(e.length) && !vC(e);
}
var QC = Object.prototype;
function eS(e) {
	var t = e && e.constructor;
	return e === (("function" == typeof t && t.prototype) || QC);
}
function tS(e) {
	return Qw(e) && "[object Arguments]" == Jw(e);
}
var nS = Object.prototype,
	rS = nS.hasOwnProperty,
	iS = nS.propertyIsEnumerable,
	sS = tS(
		(function () {
			return arguments;
		})()
	)
		? tS
		: function (e) {
				return Qw(e) && rS.call(e, "callee") && !iS.call(e, "callee");
		  };
var oS = "object" == typeof exports && exports && !exports.nodeType && exports,
	aS = oS && "object" == typeof module && module && !module.nodeType && module,
	lS = aS && aS.exports === oS ? jw.Buffer : void 0,
	uS =
		(lS ? lS.isBuffer : void 0) ||
		function () {
			return !1;
		},
	cS = {};
function hS(e) {
	return function (t) {
		return e(t);
	};
}
(cS["[object Float32Array]"] = cS["[object Float64Array]"] = cS["[object Int8Array]"] = cS["[object Int16Array]"] = cS["[object Int32Array]"] = cS["[object Uint8Array]"] = cS["[object Uint8ClampedArray]"] = cS["[object Uint16Array]"] = cS["[object Uint32Array]"] = !0),
	(cS["[object Arguments]"] =
		cS["[object Array]"] =
		cS["[object ArrayBuffer]"] =
		cS["[object Boolean]"] =
		cS["[object DataView]"] =
		cS["[object Date]"] =
		cS["[object Error]"] =
		cS["[object Function]"] =
		cS["[object Map]"] =
		cS["[object Number]"] =
		cS["[object Object]"] =
		cS["[object RegExp]"] =
		cS["[object Set]"] =
		cS["[object String]"] =
		cS["[object WeakMap]"] =
			!1);
var dS = "object" == typeof exports && exports && !exports.nodeType && exports,
	pS = dS && "object" == typeof module && module && !module.nodeType && module,
	fS = pS && pS.exports === dS && zw.process,
	mS = (function () {
		try {
			var e = pS && pS.require && pS.require("util").types;
			return e || (fS && fS.binding && fS.binding("util"));
		} catch (Kj) {}
	})(),
	vS = mS && mS.isTypedArray,
	gS = vS
		? hS(vS)
		: function (e) {
				return Qw(e) && ZC(e.length) && !!cS[Jw(e)];
		  },
	yS = Object.prototype.hasOwnProperty;
function bS(e, t) {
	var n = nC(e),
		r = !n && sS(e),
		i = !n && !r && uS(e),
		s = !n && !r && !i && gS(e),
		o = n || r || i || s,
		a = o
			? (function (e, t) {
					for (var n = -1, r = Array(e); ++n < e; ) r[n] = t(n);
					return r;
			  })(e.length, String)
			: [],
		l = a.length;
	for (var u in e) (!t && !yS.call(e, u)) || (o && ("length" == u || (i && ("offset" == u || "parent" == u)) || (s && ("buffer" == u || "byteLength" == u || "byteOffset" == u)) || $C(u, l))) || a.push(u);
	return a;
}
function xS(e, t) {
	return function (n) {
		return e(t(n));
	};
}
var _S = xS(Object.keys, Object),
	wS = Object.prototype.hasOwnProperty;
function CS(e) {
	return JC(e)
		? bS(e)
		: (function (e) {
				if (!eS(e)) return _S(e);
				var t = [];
				for (var n in Object(e)) wS.call(e, n) && "constructor" != n && t.push(n);
				return t;
		  })(e);
}
var SS = Object.prototype.hasOwnProperty;
function ES(e) {
	if (!uC(e))
		return (function (e) {
			var t = [];
			if (null != e) for (var n in Object(e)) t.push(n);
			return t;
		})(e);
	var t = eS(e),
		n = [];
	for (var r in e) ("constructor" != r || (!t && SS.call(e, r))) && n.push(r);
	return n;
}
function TS(e) {
	return JC(e) ? bS(e, !0) : ES(e);
}
var kS = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	AS = /^\w*$/;
function MS(e, t) {
	if (nC(e)) return !1;
	var n = typeof e;
	return !("number" != n && "symbol" != n && "boolean" != n && null != e && !eC(e)) || AS.test(e) || !kS.test(e) || (null != t && e in Object(t));
}
var IS = MC(Object, "create");
var RS = Object.prototype.hasOwnProperty;
var LS = Object.prototype.hasOwnProperty;
function OS(e) {
	var t = -1,
		n = null == e ? 0 : e.length;
	for (this.clear(); ++t < n; ) {
		var r = e[t];
		this.set(r[0], r[1]);
	}
}
function PS(e, t) {
	for (var n = e.length; n--; ) if (WC(e[n][0], t)) return n;
	return -1;
}
(OS.prototype.clear = function () {
	(this.__data__ = IS ? IS(null) : {}), (this.size = 0);
}),
	(OS.prototype.delete = function (e) {
		var t = this.has(e) && delete this.__data__[e];
		return (this.size -= t ? 1 : 0), t;
	}),
	(OS.prototype.get = function (e) {
		var t = this.__data__;
		if (IS) {
			var n = t[e];
			return "__lodash_hash_undefined__" === n ? void 0 : n;
		}
		return RS.call(t, e) ? t[e] : void 0;
	}),
	(OS.prototype.has = function (e) {
		var t = this.__data__;
		return IS ? void 0 !== t[e] : LS.call(t, e);
	}),
	(OS.prototype.set = function (e, t) {
		var n = this.__data__;
		return (this.size += this.has(e) ? 0 : 1), (n[e] = IS && void 0 === t ? "__lodash_hash_undefined__" : t), this;
	});
var NS = Array.prototype.splice;
function DS(e) {
	var t = -1,
		n = null == e ? 0 : e.length;
	for (this.clear(); ++t < n; ) {
		var r = e[t];
		this.set(r[0], r[1]);
	}
}
(DS.prototype.clear = function () {
	(this.__data__ = []), (this.size = 0);
}),
	(DS.prototype.delete = function (e) {
		var t = this.__data__,
			n = PS(t, e);
		return !(n < 0) && (n == t.length - 1 ? t.pop() : NS.call(t, n, 1), --this.size, !0);
	}),
	(DS.prototype.get = function (e) {
		var t = this.__data__,
			n = PS(t, e);
		return n < 0 ? void 0 : t[n][1];
	}),
	(DS.prototype.has = function (e) {
		return PS(this.__data__, e) > -1;
	}),
	(DS.prototype.set = function (e, t) {
		var n = this.__data__,
			r = PS(n, e);
		return r < 0 ? (++this.size, n.push([e, t])) : (n[r][1] = t), this;
	});
var BS = MC(jw, "Map");
function FS(e, t) {
	var n,
		r,
		i = e.__data__;
	return ("string" == (r = typeof (n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof t ? "string" : "hash"] : i.map;
}
function HS(e) {
	var t = -1,
		n = null == e ? 0 : e.length;
	for (this.clear(); ++t < n; ) {
		var r = e[t];
		this.set(r[0], r[1]);
	}
}
(HS.prototype.clear = function () {
	(this.size = 0), (this.__data__ = { hash: new OS(), map: new (BS || DS)(), string: new OS() });
}),
	(HS.prototype.delete = function (e) {
		var t = FS(this, e).delete(e);
		return (this.size -= t ? 1 : 0), t;
	}),
	(HS.prototype.get = function (e) {
		return FS(this, e).get(e);
	}),
	(HS.prototype.has = function (e) {
		return FS(this, e).has(e);
	}),
	(HS.prototype.set = function (e, t) {
		var n = FS(this, e),
			r = n.size;
		return n.set(e, t), (this.size += n.size == r ? 0 : 1), this;
	});
function VS(e, t) {
	if ("function" != typeof e || (null != t && "function" != typeof t)) throw new TypeError("Expected a function");
	var n = function () {
		var r = arguments,
			i = t ? t.apply(this, r) : r[0],
			s = n.cache;
		if (s.has(i)) return s.get(i);
		var o = e.apply(this, r);
		return (n.cache = s.set(i, o) || s), o;
	};
	return (n.cache = new (VS.Cache || HS)()), n;
}
VS.Cache = HS;
var US = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
	zS = /\\(\\)?/g,
	$S = (function (e) {
		var t = VS(e, function (e) {
				return 500 === n.size && n.clear(), e;
			}),
			n = t.cache;
		return t;
	})(function (e) {
		var t = [];
		return (
			46 === e.charCodeAt(0) && t.push(""),
			e.replace(US, function (e, n, r, i) {
				t.push(r ? i.replace(zS, "$1") : n || e);
			}),
			t
		);
	});
function jS(e) {
	return null == e ? "" : sC(e);
}
function WS(e, t) {
	return nC(e) ? e : MS(e, t) ? [e] : $S(jS(e));
}
function GS(e) {
	if ("string" == typeof e || eC(e)) return e;
	var t = e + "";
	return "0" == t && 1 / e == -Infinity ? "-0" : t;
}
function YS(e, t) {
	for (var n = 0, r = (t = WS(t, e)).length; null != e && n < r; ) e = e[GS(t[n++])];
	return n && n == r ? e : void 0;
}
function XS(e, t, n) {
	var r = null == e ? void 0 : YS(e, t);
	return void 0 === r ? n : r;
}
function KS(e, t) {
	for (var n = -1, r = t.length, i = e.length; ++n < r; ) e[i + n] = t[n];
	return e;
}
var qS = Ww ? Ww.isConcatSpreadable : void 0;
function ZS(e) {
	return nC(e) || sS(e) || !!(qS && e && e[qS]);
}
function JS(e, t, n, r, i) {
	var s = -1,
		o = e.length;
	for (n || (n = ZS), i || (i = []); ++s < o; ) {
		var a = e[s];
		t > 0 && n(a) ? (t > 1 ? JS(a, t - 1, n, r, i) : KS(i, a)) : r || (i[i.length] = a);
	}
	return i;
}
function QS(e) {
	return (null == e ? 0 : e.length) ? JS(e, 1) : [];
}
var eE = xS(Object.getPrototypeOf, Object);
function tE(e, t, n) {
	var r = e.length;
	return (
		(n = void 0 === n ? r : n),
		!t && n >= r
			? e
			: (function (e, t, n) {
					var r = -1,
						i = e.length;
					t < 0 && (t = -t > i ? 0 : i + t), (n = n > i ? i : n) < 0 && (n += i), (i = t > n ? 0 : (n - t) >>> 0), (t >>>= 0);
					for (var s = Array(i); ++r < i; ) s[r] = e[r + t];
					return s;
			  })(e, t, n)
	);
}
var nE = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
function rE(e) {
	return nE.test(e);
}
var iE = "[\\ud800-\\udfff]",
	sE = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
	oE = "\\ud83c[\\udffb-\\udfff]",
	aE = "[^\\ud800-\\udfff]",
	lE = "(?:\\ud83c[\\udde6-\\uddff]){2}",
	uE = "[\\ud800-\\udbff][\\udc00-\\udfff]",
	cE = "(?:" + sE + "|" + oE + ")" + "?",
	hE = "[\\ufe0e\\ufe0f]?" + cE + ("(?:\\u200d(?:" + [aE, lE, uE].join("|") + ")[\\ufe0e\\ufe0f]?" + cE + ")*"),
	dE = "(?:" + [aE + sE + "?", sE, lE, uE, iE].join("|") + ")",
	pE = RegExp(oE + "(?=" + oE + ")|" + dE + hE, "g");
function fE(e) {
	return rE(e)
		? (function (e) {
				return e.match(pE) || [];
		  })(e)
		: (function (e) {
				return e.split("");
		  })(e);
}
var mE,
	vE =
		((mE = "toUpperCase"),
		function (e) {
			var t = rE((e = jS(e))) ? fE(e) : void 0,
				n = t ? t[0] : e.charAt(0),
				r = t ? tE(t, 1).join("") : e.slice(1);
			return n[mE]() + r;
		});
var gE,
	yE =
		((gE = {
			À: "A",
			Á: "A",
			Â: "A",
			Ã: "A",
			Ä: "A",
			Å: "A",
			à: "a",
			á: "a",
			â: "a",
			ã: "a",
			ä: "a",
			å: "a",
			Ç: "C",
			ç: "c",
			Ð: "D",
			ð: "d",
			È: "E",
			É: "E",
			Ê: "E",
			Ë: "E",
			è: "e",
			é: "e",
			ê: "e",
			ë: "e",
			Ì: "I",
			Í: "I",
			Î: "I",
			Ï: "I",
			ì: "i",
			í: "i",
			î: "i",
			ï: "i",
			Ñ: "N",
			ñ: "n",
			Ò: "O",
			Ó: "O",
			Ô: "O",
			Õ: "O",
			Ö: "O",
			Ø: "O",
			ò: "o",
			ó: "o",
			ô: "o",
			õ: "o",
			ö: "o",
			ø: "o",
			Ù: "U",
			Ú: "U",
			Û: "U",
			Ü: "U",
			ù: "u",
			ú: "u",
			û: "u",
			ü: "u",
			Ý: "Y",
			ý: "y",
			ÿ: "y",
			Æ: "Ae",
			æ: "ae",
			Þ: "Th",
			þ: "th",
			ß: "ss",
			Ā: "A",
			Ă: "A",
			Ą: "A",
			ā: "a",
			ă: "a",
			ą: "a",
			Ć: "C",
			Ĉ: "C",
			Ċ: "C",
			Č: "C",
			ć: "c",
			ĉ: "c",
			ċ: "c",
			č: "c",
			Ď: "D",
			Đ: "D",
			ď: "d",
			đ: "d",
			Ē: "E",
			Ĕ: "E",
			Ė: "E",
			Ę: "E",
			Ě: "E",
			ē: "e",
			ĕ: "e",
			ė: "e",
			ę: "e",
			ě: "e",
			Ĝ: "G",
			Ğ: "G",
			Ġ: "G",
			Ģ: "G",
			ĝ: "g",
			ğ: "g",
			ġ: "g",
			ģ: "g",
			Ĥ: "H",
			Ħ: "H",
			ĥ: "h",
			ħ: "h",
			Ĩ: "I",
			Ī: "I",
			Ĭ: "I",
			Į: "I",
			İ: "I",
			ĩ: "i",
			ī: "i",
			ĭ: "i",
			į: "i",
			ı: "i",
			Ĵ: "J",
			ĵ: "j",
			Ķ: "K",
			ķ: "k",
			ĸ: "k",
			Ĺ: "L",
			Ļ: "L",
			Ľ: "L",
			Ŀ: "L",
			Ł: "L",
			ĺ: "l",
			ļ: "l",
			ľ: "l",
			ŀ: "l",
			ł: "l",
			Ń: "N",
			Ņ: "N",
			Ň: "N",
			Ŋ: "N",
			ń: "n",
			ņ: "n",
			ň: "n",
			ŋ: "n",
			Ō: "O",
			Ŏ: "O",
			Ő: "O",
			ō: "o",
			ŏ: "o",
			ő: "o",
			Ŕ: "R",
			Ŗ: "R",
			Ř: "R",
			ŕ: "r",
			ŗ: "r",
			ř: "r",
			Ś: "S",
			Ŝ: "S",
			Ş: "S",
			Š: "S",
			ś: "s",
			ŝ: "s",
			ş: "s",
			š: "s",
			Ţ: "T",
			Ť: "T",
			Ŧ: "T",
			ţ: "t",
			ť: "t",
			ŧ: "t",
			Ũ: "U",
			Ū: "U",
			Ŭ: "U",
			Ů: "U",
			Ű: "U",
			Ų: "U",
			ũ: "u",
			ū: "u",
			ŭ: "u",
			ů: "u",
			ű: "u",
			ų: "u",
			Ŵ: "W",
			ŵ: "w",
			Ŷ: "Y",
			ŷ: "y",
			Ÿ: "Y",
			Ź: "Z",
			Ż: "Z",
			Ž: "Z",
			ź: "z",
			ż: "z",
			ž: "z",
			Ĳ: "IJ",
			ĳ: "ij",
			Œ: "Oe",
			œ: "oe",
			ŉ: "'n",
			ſ: "s"
		}),
		function (e) {
			return null == gE ? void 0 : gE[e];
		}),
	bE = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
	xE = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g");
var _E = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
var wE = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
var CE = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
	SE = "[" + CE + "]",
	EE = "\\d+",
	TE = "[\\u2700-\\u27bf]",
	kE = "[a-z\\xdf-\\xf6\\xf8-\\xff]",
	AE = "[^\\ud800-\\udfff" + CE + EE + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",
	ME = "(?:\\ud83c[\\udde6-\\uddff]){2}",
	IE = "[\\ud800-\\udbff][\\udc00-\\udfff]",
	RE = "[A-Z\\xc0-\\xd6\\xd8-\\xde]",
	LE = "(?:" + kE + "|" + AE + ")",
	OE = "(?:" + RE + "|" + AE + ")",
	PE = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?",
	NE = "[\\ufe0e\\ufe0f]?" + PE + ("(?:\\u200d(?:" + ["[^\\ud800-\\udfff]", ME, IE].join("|") + ")[\\ufe0e\\ufe0f]?" + PE + ")*"),
	DE = "(?:" + [TE, ME, IE].join("|") + ")" + NE,
	BE = RegExp(
		[
			RE + "?" + kE + "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" + [SE, RE, "$"].join("|") + ")",
			OE + "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" + [SE, RE + LE, "$"].join("|") + ")",
			RE + "?" + LE + "+(?:['’](?:d|ll|m|re|s|t|ve))?",
			RE + "+(?:['’](?:D|LL|M|RE|S|T|VE))?",
			"\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
			"\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
			EE,
			DE
		].join("|"),
		"g"
	);
function FE(e, t, n) {
	return (
		(e = jS(e)),
		void 0 === (t = n ? void 0 : t)
			? (function (e) {
					return wE.test(e);
			  })(e)
				? (function (e) {
						return e.match(BE) || [];
				  })(e)
				: (function (e) {
						return e.match(_E) || [];
				  })(e)
			: e.match(t) || []
	);
}
var HE = RegExp("['’]", "g");
var VE,
	UE =
		((VE = function (e, t, n) {
			return (t = t.toLowerCase()), e + (n ? vE(jS(t).toLowerCase()) : t);
		}),
		function (e) {
			return (function (e, t, n, r) {
				var i = -1,
					s = null == e ? 0 : e.length;
				for (r && s && (n = e[++i]); ++i < s; ) n = t(n, e[i], i, e);
				return n;
			})(
				FE(
					(function (e) {
						return (e = jS(e)) && e.replace(bE, yE).replace(xE, "");
					})(e).replace(HE, "")
				),
				VE,
				""
			);
		});
function zE() {
	if (!arguments.length) return [];
	var e = arguments[0];
	return nC(e) ? e : [e];
}
function $E(e) {
	var t = (this.__data__ = new DS(e));
	this.size = t.size;
}
($E.prototype.clear = function () {
	(this.__data__ = new DS()), (this.size = 0);
}),
	($E.prototype.delete = function (e) {
		var t = this.__data__,
			n = t.delete(e);
		return (this.size = t.size), n;
	}),
	($E.prototype.get = function (e) {
		return this.__data__.get(e);
	}),
	($E.prototype.has = function (e) {
		return this.__data__.has(e);
	}),
	($E.prototype.set = function (e, t) {
		var n = this.__data__;
		if (n instanceof DS) {
			var r = n.__data__;
			if (!BS || r.length < 199) return r.push([e, t]), (this.size = ++n.size), this;
			n = this.__data__ = new HS(r);
		}
		return n.set(e, t), (this.size = n.size), this;
	});
var jE = "object" == typeof exports && exports && !exports.nodeType && exports,
	WE = jE && "object" == typeof module && module && !module.nodeType && module,
	GE = WE && WE.exports === jE ? jw.Buffer : void 0,
	YE = GE ? GE.allocUnsafe : void 0;
function XE() {
	return [];
}
var KE = Object.prototype.propertyIsEnumerable,
	qE = Object.getOwnPropertySymbols,
	ZE = qE
		? function (e) {
				return null == e
					? []
					: ((e = Object(e)),
					  (function (e, t) {
							for (var n = -1, r = null == e ? 0 : e.length, i = 0, s = []; ++n < r; ) {
								var o = e[n];
								t(o, n, e) && (s[i++] = o);
							}
							return s;
					  })(qE(e), function (t) {
							return KE.call(e, t);
					  }));
		  }
		: XE;
var JE = Object.getOwnPropertySymbols
	? function (e) {
			for (var t = []; e; ) KS(t, ZE(e)), (e = eE(e));
			return t;
	  }
	: XE;
function QE(e, t, n) {
	var r = t(e);
	return nC(e) ? r : KS(r, n(e));
}
function eT(e) {
	return QE(e, CS, ZE);
}
function tT(e) {
	return QE(e, TS, JE);
}
var nT = MC(jw, "DataView"),
	rT = MC(jw, "Promise"),
	iT = MC(jw, "Set"),
	sT = _C(nT),
	oT = _C(BS),
	aT = _C(rT),
	lT = _C(iT),
	uT = _C(IC),
	cT = Jw;
((nT && "[object DataView]" != cT(new nT(new ArrayBuffer(1)))) || (BS && "[object Map]" != cT(new BS())) || (rT && "[object Promise]" != cT(rT.resolve())) || (iT && "[object Set]" != cT(new iT())) || (IC && "[object WeakMap]" != cT(new IC()))) &&
	(cT = function (e) {
		var t = Jw(e),
			n = "[object Object]" == t ? e.constructor : void 0,
			r = n ? _C(n) : "";
		if (r)
			switch (r) {
				case sT:
					return "[object DataView]";
				case oT:
					return "[object Map]";
				case aT:
					return "[object Promise]";
				case lT:
					return "[object Set]";
				case uT:
					return "[object WeakMap]";
			}
		return t;
	});
var hT = cT,
	dT = Object.prototype.hasOwnProperty;
var pT = jw.Uint8Array;
function fT(e) {
	var t = new e.constructor(e.byteLength);
	return new pT(t).set(new pT(e)), t;
}
var mT = /\w*$/;
var vT = Ww ? Ww.prototype : void 0,
	gT = vT ? vT.valueOf : void 0;
function yT(e, t, n) {
	var r,
		i,
		s,
		o = e.constructor;
	switch (t) {
		case "[object ArrayBuffer]":
			return fT(e);
		case "[object Boolean]":
		case "[object Date]":
			return new o(+e);
		case "[object DataView]":
			return (function (e, t) {
				var n = t ? fT(e.buffer) : e.buffer;
				return new e.constructor(n, e.byteOffset, e.byteLength);
			})(e, n);
		case "[object Float32Array]":
		case "[object Float64Array]":
		case "[object Int8Array]":
		case "[object Int16Array]":
		case "[object Int32Array]":
		case "[object Uint8Array]":
		case "[object Uint8ClampedArray]":
		case "[object Uint16Array]":
		case "[object Uint32Array]":
			return (function (e, t) {
				var n = t ? fT(e.buffer) : e.buffer;
				return new e.constructor(n, e.byteOffset, e.length);
			})(e, n);
		case "[object Map]":
			return new o();
		case "[object Number]":
		case "[object String]":
			return new o(e);
		case "[object RegExp]":
			return ((s = new (i = e).constructor(i.source, mT.exec(i))).lastIndex = i.lastIndex), s;
		case "[object Set]":
			return new o();
		case "[object Symbol]":
			return (r = e), gT ? Object(gT.call(r)) : {};
	}
}
var bT = mS && mS.isMap,
	xT = bT
		? hS(bT)
		: function (e) {
				return Qw(e) && "[object Map]" == hT(e);
		  };
var _T = mS && mS.isSet,
	wT = _T
		? hS(_T)
		: function (e) {
				return Qw(e) && "[object Set]" == hT(e);
		  },
	CT = {};
function ST(e, t, n, r, i, s) {
	var o,
		a = 1 & t,
		l = 2 & t,
		u = 4 & t;
	if ((n && (o = i ? n(e, r, i, s) : n(e)), void 0 !== o)) return o;
	if (!uC(e)) return e;
	var c = nC(e);
	if (c) {
		if (
			((o = (function (e) {
				var t = e.length,
					n = new e.constructor(t);
				return t && "string" == typeof e[0] && dT.call(e, "index") && ((n.index = e.index), (n.input = e.input)), n;
			})(e)),
			!a)
		)
			return (function (e, t) {
				var n = -1,
					r = e.length;
				for (t || (t = Array(r)); ++n < r; ) t[n] = e[n];
				return t;
			})(e, o);
	} else {
		var h = hT(e),
			d = "[object Function]" == h || "[object GeneratorFunction]" == h;
		if (uS(e))
			return (function (e, t) {
				if (t) return e.slice();
				var n = e.length,
					r = YE ? YE(n) : new e.constructor(n);
				return e.copy(r), r;
			})(e, a);
		if ("[object Object]" == h || "[object Arguments]" == h || (d && !i)) {
			if (
				((o =
					l || d
						? {}
						: (function (e) {
								return "function" != typeof e.constructor || eS(e) ? {} : LC(eE(e));
						  })(e)),
				!a)
			)
				return l
					? (function (e, t) {
							return XC(e, JE(e), t);
					  })(
							e,
							(function (e, t) {
								return e && XC(t, TS(t), e);
							})(o, e)
					  )
					: (function (e, t) {
							return XC(e, ZE(e), t);
					  })(
							e,
							(function (e, t) {
								return e && XC(t, CS(t), e);
							})(o, e)
					  );
		} else {
			if (!CT[h]) return i ? e : {};
			o = yT(e, h, a);
		}
	}
	s || (s = new $E());
	var p = s.get(e);
	if (p) return p;
	s.set(e, o),
		wT(e)
			? e.forEach(function (r) {
					o.add(ST(r, t, n, r, e, s));
			  })
			: xT(e) &&
			  e.forEach(function (r, i) {
					o.set(i, ST(r, t, n, i, e, s));
			  });
	var f = c ? void 0 : (u ? (l ? tT : eT) : l ? TS : CS)(e);
	return (
		(function (e, t) {
			for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e); );
		})(f || e, function (r, i) {
			f && (r = e[(i = r)]), YC(o, i, ST(r, t, n, i, e, s));
		}),
		o
	);
}
(CT["[object Arguments]"] =
	CT["[object Array]"] =
	CT["[object ArrayBuffer]"] =
	CT["[object DataView]"] =
	CT["[object Boolean]"] =
	CT["[object Date]"] =
	CT["[object Float32Array]"] =
	CT["[object Float64Array]"] =
	CT["[object Int8Array]"] =
	CT["[object Int16Array]"] =
	CT["[object Int32Array]"] =
	CT["[object Map]"] =
	CT["[object Number]"] =
	CT["[object Object]"] =
	CT["[object RegExp]"] =
	CT["[object Set]"] =
	CT["[object String]"] =
	CT["[object Symbol]"] =
	CT["[object Uint8Array]"] =
	CT["[object Uint8ClampedArray]"] =
	CT["[object Uint16Array]"] =
	CT["[object Uint32Array]"] =
		!0),
	(CT["[object Error]"] = CT["[object Function]"] = CT["[object WeakMap]"] = !1);
function ET(e) {
	return ST(e, 4);
}
function TT(e) {
	return ST(e, 5);
}
function kT(e) {
	var t = -1,
		n = null == e ? 0 : e.length;
	for (this.__data__ = new HS(); ++t < n; ) this.add(e[t]);
}
function AT(e, t) {
	for (var n = -1, r = null == e ? 0 : e.length; ++n < r; ) if (t(e[n], n, e)) return !0;
	return !1;
}
function MT(e, t) {
	return e.has(t);
}
(kT.prototype.add = kT.prototype.push =
	function (e) {
		return this.__data__.set(e, "__lodash_hash_undefined__"), this;
	}),
	(kT.prototype.has = function (e) {
		return this.__data__.has(e);
	});
function IT(e, t, n, r, i, s) {
	var o = 1 & n,
		a = e.length,
		l = t.length;
	if (a != l && !(o && l > a)) return !1;
	var u = s.get(e),
		c = s.get(t);
	if (u && c) return u == t && c == e;
	var h = -1,
		d = !0,
		p = 2 & n ? new kT() : void 0;
	for (s.set(e, t), s.set(t, e); ++h < a; ) {
		var f = e[h],
			m = t[h];
		if (r) var v = o ? r(m, f, h, t, e, s) : r(f, m, h, e, t, s);
		if (void 0 !== v) {
			if (v) continue;
			d = !1;
			break;
		}
		if (p) {
			if (
				!AT(t, function (e, t) {
					if (!MT(p, t) && (f === e || i(f, e, n, r, s))) return p.push(t);
				})
			) {
				d = !1;
				break;
			}
		} else if (f !== m && !i(f, m, n, r, s)) {
			d = !1;
			break;
		}
	}
	return s.delete(e), s.delete(t), d;
}
function RT(e) {
	var t = -1,
		n = Array(e.size);
	return (
		e.forEach(function (e, r) {
			n[++t] = [r, e];
		}),
		n
	);
}
function LT(e) {
	var t = -1,
		n = Array(e.size);
	return (
		e.forEach(function (e) {
			n[++t] = e;
		}),
		n
	);
}
var OT = Ww ? Ww.prototype : void 0,
	PT = OT ? OT.valueOf : void 0;
var NT = Object.prototype.hasOwnProperty;
var DT = "[object Object]",
	BT = Object.prototype.hasOwnProperty;
function FT(e, t, n, r, i, s) {
	var o = nC(e),
		a = nC(t),
		l = o ? "[object Array]" : hT(e),
		u = a ? "[object Array]" : hT(t),
		c = (l = "[object Arguments]" == l ? DT : l) == DT,
		h = (u = "[object Arguments]" == u ? DT : u) == DT,
		d = l == u;
	if (d && uS(e)) {
		if (!uS(t)) return !1;
		(o = !0), (c = !1);
	}
	if (d && !c)
		return (
			s || (s = new $E()),
			o || gS(e)
				? IT(e, t, n, r, i, s)
				: (function (e, t, n, r, i, s, o) {
						switch (n) {
							case "[object DataView]":
								if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
								(e = e.buffer), (t = t.buffer);
							case "[object ArrayBuffer]":
								return !(e.byteLength != t.byteLength || !s(new pT(e), new pT(t)));
							case "[object Boolean]":
							case "[object Date]":
							case "[object Number]":
								return WC(+e, +t);
							case "[object Error]":
								return e.name == t.name && e.message == t.message;
							case "[object RegExp]":
							case "[object String]":
								return e == t + "";
							case "[object Map]":
								var a = RT;
							case "[object Set]":
								var l = 1 & r;
								if ((a || (a = LT), e.size != t.size && !l)) return !1;
								var u = o.get(e);
								if (u) return u == t;
								(r |= 2), o.set(e, t);
								var c = IT(a(e), a(t), r, i, s, o);
								return o.delete(e), c;
							case "[object Symbol]":
								if (PT) return PT.call(e) == PT.call(t);
						}
						return !1;
				  })(e, t, l, n, r, i, s)
		);
	if (!(1 & n)) {
		var p = c && BT.call(e, "__wrapped__"),
			f = h && BT.call(t, "__wrapped__");
		if (p || f) {
			var m = p ? e.value() : e,
				v = f ? t.value() : t;
			return s || (s = new $E()), i(m, v, n, r, s);
		}
	}
	return (
		!!d &&
		(s || (s = new $E()),
		(function (e, t, n, r, i, s) {
			var o = 1 & n,
				a = eT(e),
				l = a.length;
			if (l != eT(t).length && !o) return !1;
			for (var u = l; u--; ) {
				var c = a[u];
				if (!(o ? c in t : NT.call(t, c))) return !1;
			}
			var h = s.get(e),
				d = s.get(t);
			if (h && d) return h == t && d == e;
			var p = !0;
			s.set(e, t), s.set(t, e);
			for (var f = o; ++u < l; ) {
				var m = e[(c = a[u])],
					v = t[c];
				if (r) var g = o ? r(v, m, c, t, e, s) : r(m, v, c, e, t, s);
				if (!(void 0 === g ? m === v || i(m, v, n, r, s) : g)) {
					p = !1;
					break;
				}
				f || (f = "constructor" == c);
			}
			if (p && !f) {
				var y = e.constructor,
					b = t.constructor;
				y == b || !("constructor" in e) || !("constructor" in t) || ("function" == typeof y && y instanceof y && "function" == typeof b && b instanceof b) || (p = !1);
			}
			return s.delete(e), s.delete(t), p;
		})(e, t, n, r, i, s))
	);
}
function HT(e, t, n, r, i) {
	return e === t || (null == e || null == t || (!Qw(e) && !Qw(t)) ? e != e && t != t : FT(e, t, n, r, HT, i));
}
function VT(e) {
	return e == e && !uC(e);
}
function UT(e, t) {
	return function (n) {
		return null != n && n[e] === t && (void 0 !== t || e in Object(n));
	};
}
function zT(e) {
	var t = (function (e) {
		for (var t = CS(e), n = t.length; n--; ) {
			var r = t[n],
				i = e[r];
			t[n] = [r, i, VT(i)];
		}
		return t;
	})(e);
	return 1 == t.length && t[0][2]
		? UT(t[0][0], t[0][1])
		: function (n) {
				return (
					n === e ||
					(function (e, t, n, r) {
						var i = n.length,
							s = i,
							o = !r;
						if (null == e) return !s;
						for (e = Object(e); i--; ) {
							var a = n[i];
							if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e)) return !1;
						}
						for (; ++i < s; ) {
							var l = (a = n[i])[0],
								u = e[l],
								c = a[1];
							if (o && a[2]) {
								if (void 0 === u && !(l in e)) return !1;
							} else {
								var h = new $E();
								if (r) var d = r(u, c, l, e, t, h);
								if (!(void 0 === d ? HT(c, u, 3, r, h) : d)) return !1;
							}
						}
						return !0;
					})(n, e, t)
				);
		  };
}
function $T(e, t) {
	return null != e && t in Object(e);
}
function jT(e, t) {
	return (
		null != e &&
		(function (e, t, n) {
			for (var r = -1, i = (t = WS(t, e)).length, s = !1; ++r < i; ) {
				var o = GS(t[r]);
				if (!(s = null != e && n(e, o))) break;
				e = e[o];
			}
			return s || ++r != i ? s : !!(i = null == e ? 0 : e.length) && ZC(i) && $C(o, i) && (nC(e) || sS(e));
		})(e, t, $T)
	);
}
function WT(e) {
	return MS(e)
		? ((t = GS(e)),
		  function (e) {
				return null == e ? void 0 : e[t];
		  })
		: (function (e) {
				return function (t) {
					return YS(t, e);
				};
		  })(e);
	var t;
}
function GT(e) {
	return "function" == typeof e
		? e
		: null == e
		? mC
		: "object" == typeof e
		? nC(e)
			? ((t = e[0]),
			  (n = e[1]),
			  MS(t) && VT(n)
					? UT(GS(t), n)
					: function (e) {
							var r = XS(e, t);
							return void 0 === r && r === n ? jT(e, t) : HT(n, r, 3);
					  })
			: zT(e)
		: WT(e);
	var t, n;
}
var YT,
	XT = function (e, t, n) {
		for (var r = -1, i = Object(e), s = n(e), o = s.length; o--; ) {
			var a = s[YT ? o : ++r];
			if (!1 === t(i[a], a, i)) break;
		}
		return e;
	};
var KT = (function (e, t) {
		return function (n, r) {
			if (null == n) return n;
			if (!JC(n)) return e(n, r);
			for (var i = n.length, s = t ? i : -1, o = Object(n); (t ? s-- : ++s < i) && !1 !== r(o[s], s, o); );
			return n;
		};
	})(function (e, t) {
		return e && XT(e, t, CS);
	}),
	qT = function () {
		return jw.Date.now();
	},
	ZT = Math.max,
	JT = Math.min;
function QT(e, t, n) {
	var r,
		i,
		s,
		o,
		a,
		l,
		u = 0,
		c = !1,
		h = !1,
		d = !0;
	if ("function" != typeof e) throw new TypeError("Expected a function");
	function p(t) {
		var n = r,
			s = i;
		return (r = i = void 0), (u = t), (o = e.apply(s, n));
	}
	function f(e) {
		return (u = e), (a = setTimeout(v, t)), c ? p(e) : o;
	}
	function m(e) {
		var n = e - l;
		return void 0 === l || n >= t || n < 0 || (h && e - u >= s);
	}
	function v() {
		var e = qT();
		if (m(e)) return g(e);
		a = setTimeout(
			v,
			(function (e) {
				var n = t - (e - l);
				return h ? JT(n, s - (e - u)) : n;
			})(e)
		);
	}
	function g(e) {
		return (a = void 0), d && r ? p(e) : ((r = i = void 0), o);
	}
	function y() {
		var e = qT(),
			n = m(e);
		if (((r = arguments), (i = this), (l = e), n)) {
			if (void 0 === a) return f(l);
			if (h) return clearTimeout(a), (a = setTimeout(v, t)), p(l);
		}
		return void 0 === a && (a = setTimeout(v, t)), o;
	}
	return (
		(t = fC(t) || 0),
		uC(n) && ((c = !!n.leading), (s = (h = "maxWait" in n) ? ZT(fC(n.maxWait) || 0, t) : s), (d = "trailing" in n ? !!n.trailing : d)),
		(y.cancel = function () {
			void 0 !== a && clearTimeout(a), (u = 0), (r = l = i = a = void 0);
		}),
		(y.flush = function () {
			return void 0 === a ? o : g(qT());
		}),
		y
	);
}
function ek(e) {
	return Qw(e) && JC(e);
}
function tk(e, t, n) {
	for (var r = -1, i = null == e ? 0 : e.length; ++r < i; ) if (n(t, e[r])) return !0;
	return !1;
}
function nk(e) {
	for (var t = -1, n = null == e ? 0 : e.length, r = {}; ++t < n; ) {
		var i = e[t];
		r[i[0]] = i[1];
	}
	return r;
}
function rk(e, t) {
	return HT(e, t);
}
function ik(e) {
	return null == e;
}
function sk(e, t, n, r) {
	if (!uC(e)) return e;
	for (var i = -1, s = (t = WS(t, e)).length, o = s - 1, a = e; null != a && ++i < s; ) {
		var l = GS(t[i]),
			u = n;
		if ("__proto__" === l || "constructor" === l || "prototype" === l) return e;
		if (i != o) {
			var c = a[l];
			void 0 === (u = r ? r(c, l, a) : void 0) && (u = uC(c) ? c : $C(t[i + 1]) ? [] : {});
		}
		YC(a, l, u), (a = a[l]);
	}
	return e;
}
function ok(e, t) {
	if (e !== t) {
		var n = void 0 !== e,
			r = null === e,
			i = e == e,
			s = eC(e),
			o = void 0 !== t,
			a = null === t,
			l = t == t,
			u = eC(t);
		if ((!a && !u && !s && e > t) || (s && o && l && !a && !u) || (r && o && l) || (!n && l) || !i) return 1;
		if ((!r && !s && !u && e < t) || (u && n && i && !r && !s) || (a && n && i) || (!o && i) || !l) return -1;
	}
	return 0;
}
function ak(e, t, n) {
	t = t.length
		? tC(t, function (e) {
				return nC(e)
					? function (t) {
							return YS(t, 1 === e.length ? e[0] : e);
					  }
					: e;
		  })
		: [mC];
	var r = -1;
	return (
		(t = tC(t, hS(GT))),
		(function (e, t) {
			var n = e.length;
			for (e.sort(t); n--; ) e[n] = e[n].value;
			return e;
		})(
			(function (e, t) {
				var n = -1,
					r = JC(e) ? Array(e.length) : [];
				return (
					KT(e, function (e, i, s) {
						r[++n] = t(e, i, s);
					}),
					r
				);
			})(e, function (e, n, i) {
				return {
					criteria: tC(t, function (t) {
						return t(e);
					}),
					index: ++r,
					value: e
				};
			}),
			function (e, t) {
				return (function (e, t, n) {
					for (var r = -1, i = e.criteria, s = t.criteria, o = i.length, a = n.length; ++r < o; ) {
						var l = ok(i[r], s[r]);
						if (l) return r >= a ? l : l * ("desc" == n[r] ? -1 : 1);
					}
					return e.index - t.index;
				})(e, t, n);
			}
		)
	);
}
function lk(e, t, n, r) {
	return null == e ? [] : (nC(t) || (t = null == t ? [] : [t]), nC((n = r ? void 0 : n)) || (n = null == n ? [] : [n]), ak(e, t, n));
}
function uk(e, t) {
	return (function (e, t, n) {
		for (var r = -1, i = t.length, s = {}; ++r < i; ) {
			var o = t[r],
				a = YS(e, o);
			n(a, o) && sk(s, WS(o, e), a);
		}
		return s;
	})(e, t, function (t, n) {
		return jT(e, n);
	});
}
var ck = (function (e) {
	return HC(qC(e, void 0, QS), e + "");
})(function (e, t) {
	return null == e ? {} : uk(e, t);
});
function hk(e, t, n) {
	var r = !0,
		i = !0;
	if ("function" != typeof e) throw new TypeError("Expected a function");
	return uC(n) && ((r = "leading" in n ? !!n.leading : r), (i = "trailing" in n ? !!n.trailing : i)), QT(e, t, { leading: r, maxWait: t, trailing: i });
}
var dk =
	iT && 1 / LT(new iT([, -0]))[1] == 1 / 0
		? function (e) {
				return new iT(e);
		  }
		: function () {};
var pk = (function (e, t) {
	return HC(qC(e, t, mC), e + "");
})(function (e) {
	return (function (e, t, n) {
		var r = -1,
			i = UC,
			s = e.length,
			o = !0,
			a = [],
			l = a;
		if (n) (o = !1), (i = tk);
		else if (s >= 200) {
			var u = t ? null : dk(e);
			if (u) return LT(u);
			(o = !1), (i = MT), (l = new kT());
		} else l = t ? [] : a;
		e: for (; ++r < s; ) {
			var c = e[r],
				h = t ? t(c) : c;
			if (((c = n || 0 !== c ? c : 0), o && h == h)) {
				for (var d = l.length; d--; ) if (l[d] === h) continue e;
				t && l.push(h), a.push(c);
			} else i(l, h, n) || (l !== a && l.push(h), a.push(c));
		}
		return a;
	})(JS(e, 1, ek, !0));
});
function fk() {
	return "undefined" != typeof navigator ? window : "undefined" != typeof global ? global : {};
}
function mk(e, t) {
	const n = fk().__VUE_DEVTOOLS_GLOBAL_HOOK__;
	if (n) n.emit("devtools-plugin:setup", e, t);
	else {
		const n = fk();
		(n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []).push({ pluginDescriptor: e, setupFn: t });
	}
}
var vk = Object.entries({ L: /ł/gim, O: /ø/gim, AE: /æ/gim, SS: /ß/gim });
const gk = [
	[/[\u0300-\u036F]/g, ""],
	[/[\u180E\u200B-\u200D\u2060\uFEFF]/g, ""],
	[/[\u2420\u2422\u2423]/g, " "],
	[/[ \u00A0\u1680\u2000-\u200A\u202F\u205F\u3000]/g, " "],
	[/\s+/g, " "]
];
function yk(e) {
	e = e.normalize("NFKD");
	for (const t of gk) e = e.replace(...t);
	for (const [t, n] of vk) e = e.replace(n, (e) => (e === e.toUpperCase() ? t : t.toLowerCase()));
	return e;
}
var bk = { exports: {} };
!(function (e) {
	const t = Symbol("newer"),
		n = Symbol("older");
	class r {
		constructor(e, t) {
			"number" != typeof e && ((t = e), (e = 0)), (this.size = 0), (this.limit = e), (this.oldest = this.newest = void 0), (this._keymap = new Map()), t && (this.assign(t), e < 1 && (this.limit = this.size));
		}
		_markEntryAsUsed(e) {
			e !== this.newest && (e[t] && (e === this.oldest && (this.oldest = e[t]), (e[t][n] = e[n])), e[n] && (e[n][t] = e[t]), (e[t] = void 0), (e[n] = this.newest), this.newest && (this.newest[t] = e), (this.newest = e));
		}
		assign(e) {
			let r,
				s = this.limit || Number.MAX_VALUE;
			this._keymap.clear();
			let o = e[Symbol.iterator]();
			for (let a = o.next(); !a.done; a = o.next()) {
				let e = new i(a.value[0], a.value[1]);
				if ((this._keymap.set(e.key, e), r ? ((r[t] = e), (e[n] = r)) : (this.oldest = e), (r = e), 0 == s--)) throw new Error("overflow");
			}
			(this.newest = r), (this.size = this._keymap.size);
		}
		get(e) {
			var t = this._keymap.get(e);
			return t ? (this._markEntryAsUsed(t), t.value) : void 0;
		}
		set(e, r) {
			var s = this._keymap.get(e);
			return s ? ((s.value = r), this._markEntryAsUsed(s), this) : (this._keymap.set(e, (s = new i(e, r))), this.newest ? ((this.newest[t] = s), (s[n] = this.newest)) : (this.oldest = s), (this.newest = s), ++this.size, this.size > this.limit && this.shift(), this);
		}
		shift() {
			var e = this.oldest;
			if (e) return this.oldest[t] ? ((this.oldest = this.oldest[t]), (this.oldest[n] = void 0)) : ((this.oldest = void 0), (this.newest = void 0)), (e[t] = e[n] = void 0), this._keymap.delete(e.key), --this.size, [e.key, e.value];
		}
		find(e) {
			let t = this._keymap.get(e);
			return t ? t.value : void 0;
		}
		has(e) {
			return this._keymap.has(e);
		}
		delete(e) {
			var r = this._keymap.get(e);
			return r ? (this._keymap.delete(r.key), r[t] && r[n] ? ((r[n][t] = r[t]), (r[t][n] = r[n])) : r[t] ? ((r[t][n] = void 0), (this.oldest = r[t])) : r[n] ? ((r[n][t] = void 0), (this.newest = r[n])) : (this.oldest = this.newest = void 0), this.size--, r.value) : void 0;
		}
		clear() {
			(this.oldest = this.newest = void 0), (this.size = 0), this._keymap.clear();
		}
		keys() {
			return new o(this.oldest);
		}
		values() {
			return new a(this.oldest);
		}
		entries() {
			return this;
		}
		[Symbol.iterator]() {
			return new s(this.oldest);
		}
		forEach(e, n) {
			"object" != typeof n && (n = this);
			let r = this.oldest;
			for (; r; ) e.call(n, r.value, r.key, this), (r = r[t]);
		}
		toJSON() {
			for (var e = new Array(this.size), n = 0, r = this.oldest; r; ) (e[n++] = { key: r.key, value: r.value }), (r = r[t]);
			return e;
		}
		toString() {
			for (var e = "", n = this.oldest; n; ) (e += String(n.key) + ":" + n.value), (n = n[t]) && (e += " < ");
			return e;
		}
	}
	function i(e, r) {
		(this.key = e), (this.value = r), (this[t] = void 0), (this[n] = void 0);
	}
	function s(e) {
		this.entry = e;
	}
	function o(e) {
		this.entry = e;
	}
	function a(e) {
		this.entry = e;
	}
	(e.LRUMap = r),
		(s.prototype[Symbol.iterator] = function () {
			return this;
		}),
		(s.prototype.next = function () {
			let e = this.entry;
			return e ? ((this.entry = e[t]), { done: !1, value: [e.key, e.value] }) : { done: !0, value: void 0 };
		}),
		(o.prototype[Symbol.iterator] = function () {
			return this;
		}),
		(o.prototype.next = function () {
			let e = this.entry;
			return e ? ((this.entry = e[t]), { done: !1, value: e.key }) : { done: !0, value: void 0 };
		}),
		(a.prototype[Symbol.iterator] = function () {
			return this;
		}),
		(a.prototype.next = function () {
			let e = this.entry;
			return e ? ((this.entry = e[t]), { done: !1, value: e.value }) : { done: !0, value: void 0 };
		});
})(bk.exports);
function xk(e) {
	let t = e.length;
	for (; --t >= 0; ) e[t] = 0;
}
const _k = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
	wk = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
	Ck = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
	Sk = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
	Ek = new Array(576);
xk(Ek);
const Tk = new Array(60);
xk(Tk);
const kk = new Array(512);
xk(kk);
const Ak = new Array(256);
xk(Ak);
const Mk = new Array(29);
xk(Mk);
const Ik = new Array(30);
function Rk(e, t, n, r, i) {
	(this.static_tree = e), (this.extra_bits = t), (this.extra_base = n), (this.elems = r), (this.max_length = i), (this.has_stree = e && e.length);
}
let Lk, Ok, Pk;
function Nk(e, t) {
	(this.dyn_tree = e), (this.max_code = 0), (this.stat_desc = t);
}
xk(Ik);
const Dk = (e) => (e < 256 ? kk[e] : kk[256 + (e >>> 7)]),
	Bk = (e, t) => {
		(e.pending_buf[e.pending++] = 255 & t), (e.pending_buf[e.pending++] = (t >>> 8) & 255);
	},
	Fk = (e, t, n) => {
		e.bi_valid > 16 - n ? ((e.bi_buf |= (t << e.bi_valid) & 65535), Bk(e, e.bi_buf), (e.bi_buf = t >> (16 - e.bi_valid)), (e.bi_valid += n - 16)) : ((e.bi_buf |= (t << e.bi_valid) & 65535), (e.bi_valid += n));
	},
	Hk = (e, t, n) => {
		Fk(e, n[2 * t], n[2 * t + 1]);
	},
	Vk = (e, t) => {
		let n = 0;
		do {
			(n |= 1 & e), (e >>>= 1), (n <<= 1);
		} while (--t > 0);
		return n >>> 1;
	},
	Uk = (e, t, n) => {
		const r = new Array(16);
		let i,
			s,
			o = 0;
		for (i = 1; i <= 15; i++) r[i] = o = (o + n[i - 1]) << 1;
		for (s = 0; s <= t; s++) {
			let t = e[2 * s + 1];
			0 !== t && (e[2 * s] = Vk(r[t]++, t));
		}
	},
	zk = (e) => {
		let t;
		for (t = 0; t < 286; t++) e.dyn_ltree[2 * t] = 0;
		for (t = 0; t < 30; t++) e.dyn_dtree[2 * t] = 0;
		for (t = 0; t < 19; t++) e.bl_tree[2 * t] = 0;
		(e.dyn_ltree[512] = 1), (e.opt_len = e.static_len = 0), (e.last_lit = e.matches = 0);
	},
	$k = (e) => {
		e.bi_valid > 8 ? Bk(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), (e.bi_buf = 0), (e.bi_valid = 0);
	},
	jk = (e, t, n, r) => {
		const i = 2 * t,
			s = 2 * n;
		return e[i] < e[s] || (e[i] === e[s] && r[t] <= r[n]);
	},
	Wk = (e, t, n) => {
		const r = e.heap[n];
		let i = n << 1;
		for (; i <= e.heap_len && (i < e.heap_len && jk(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !jk(t, r, e.heap[i], e.depth)); ) (e.heap[n] = e.heap[i]), (n = i), (i <<= 1);
		e.heap[n] = r;
	},
	Gk = (e, t, n) => {
		let r,
			i,
			s,
			o,
			a = 0;
		if (0 !== e.last_lit)
			do {
				(r = (e.pending_buf[e.d_buf + 2 * a] << 8) | e.pending_buf[e.d_buf + 2 * a + 1]),
					(i = e.pending_buf[e.l_buf + a]),
					a++,
					0 === r ? Hk(e, i, t) : ((s = Ak[i]), Hk(e, s + 256 + 1, t), (o = _k[s]), 0 !== o && ((i -= Mk[s]), Fk(e, i, o)), r--, (s = Dk(r)), Hk(e, s, n), (o = wk[s]), 0 !== o && ((r -= Ik[s]), Fk(e, r, o)));
			} while (a < e.last_lit);
		Hk(e, 256, t);
	},
	Yk = (e, t) => {
		const n = t.dyn_tree,
			r = t.stat_desc.static_tree,
			i = t.stat_desc.has_stree,
			s = t.stat_desc.elems;
		let o,
			a,
			l,
			u = -1;
		for (e.heap_len = 0, e.heap_max = 573, o = 0; o < s; o++) 0 !== n[2 * o] ? ((e.heap[++e.heap_len] = u = o), (e.depth[o] = 0)) : (n[2 * o + 1] = 0);
		for (; e.heap_len < 2; ) (l = e.heap[++e.heap_len] = u < 2 ? ++u : 0), (n[2 * l] = 1), (e.depth[l] = 0), e.opt_len--, i && (e.static_len -= r[2 * l + 1]);
		for (t.max_code = u, o = e.heap_len >> 1; o >= 1; o--) Wk(e, n, o);
		l = s;
		do {
			(o = e.heap[1]),
				(e.heap[1] = e.heap[e.heap_len--]),
				Wk(e, n, 1),
				(a = e.heap[1]),
				(e.heap[--e.heap_max] = o),
				(e.heap[--e.heap_max] = a),
				(n[2 * l] = n[2 * o] + n[2 * a]),
				(e.depth[l] = (e.depth[o] >= e.depth[a] ? e.depth[o] : e.depth[a]) + 1),
				(n[2 * o + 1] = n[2 * a + 1] = l),
				(e.heap[1] = l++),
				Wk(e, n, 1);
		} while (e.heap_len >= 2);
		(e.heap[--e.heap_max] = e.heap[1]),
			((e, t) => {
				const n = t.dyn_tree,
					r = t.max_code,
					i = t.stat_desc.static_tree,
					s = t.stat_desc.has_stree,
					o = t.stat_desc.extra_bits,
					a = t.stat_desc.extra_base,
					l = t.stat_desc.max_length;
				let u,
					c,
					h,
					d,
					p,
					f,
					m = 0;
				for (d = 0; d <= 15; d++) e.bl_count[d] = 0;
				for (n[2 * e.heap[e.heap_max] + 1] = 0, u = e.heap_max + 1; u < 573; u++)
					(c = e.heap[u]), (d = n[2 * n[2 * c + 1] + 1] + 1), d > l && ((d = l), m++), (n[2 * c + 1] = d), c > r || (e.bl_count[d]++, (p = 0), c >= a && (p = o[c - a]), (f = n[2 * c]), (e.opt_len += f * (d + p)), s && (e.static_len += f * (i[2 * c + 1] + p)));
				if (0 !== m) {
					do {
						for (d = l - 1; 0 === e.bl_count[d]; ) d--;
						e.bl_count[d]--, (e.bl_count[d + 1] += 2), e.bl_count[l]--, (m -= 2);
					} while (m > 0);
					for (d = l; 0 !== d; d--) for (c = e.bl_count[d]; 0 !== c; ) (h = e.heap[--u]), h > r || (n[2 * h + 1] !== d && ((e.opt_len += (d - n[2 * h + 1]) * n[2 * h]), (n[2 * h + 1] = d)), c--);
				}
			})(e, t),
			Uk(n, u, e.bl_count);
	},
	Xk = (e, t, n) => {
		let r,
			i,
			s = -1,
			o = t[1],
			a = 0,
			l = 7,
			u = 4;
		for (0 === o && ((l = 138), (u = 3)), t[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++)
			(i = o),
				(o = t[2 * (r + 1) + 1]),
				(++a < l && i === o) || (a < u ? (e.bl_tree[2 * i] += a) : 0 !== i ? (i !== s && e.bl_tree[2 * i]++, e.bl_tree[32]++) : a <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, (a = 0), (s = i), 0 === o ? ((l = 138), (u = 3)) : i === o ? ((l = 6), (u = 3)) : ((l = 7), (u = 4)));
	},
	Kk = (e, t, n) => {
		let r,
			i,
			s = -1,
			o = t[1],
			a = 0,
			l = 7,
			u = 4;
		for (0 === o && ((l = 138), (u = 3)), r = 0; r <= n; r++)
			if (((i = o), (o = t[2 * (r + 1) + 1]), !(++a < l && i === o))) {
				if (a < u)
					do {
						Hk(e, i, e.bl_tree);
					} while (0 != --a);
				else 0 !== i ? (i !== s && (Hk(e, i, e.bl_tree), a--), Hk(e, 16, e.bl_tree), Fk(e, a - 3, 2)) : a <= 10 ? (Hk(e, 17, e.bl_tree), Fk(e, a - 3, 3)) : (Hk(e, 18, e.bl_tree), Fk(e, a - 11, 7));
				(a = 0), (s = i), 0 === o ? ((l = 138), (u = 3)) : i === o ? ((l = 6), (u = 3)) : ((l = 7), (u = 4));
			}
	};
let qk = !1;
const Zk = (e, t, n, r) => {
	Fk(e, 0 + (r ? 1 : 0), 3),
		((e, t, n, r) => {
			$k(e), r && (Bk(e, n), Bk(e, ~n)), e.pending_buf.set(e.window.subarray(t, t + n), e.pending), (e.pending += n);
		})(e, t, n, !0);
};
var Jk = {
	_tr_init: (e) => {
		qk ||
			((() => {
				let e, t, n, r, i;
				const s = new Array(16);
				for (n = 0, r = 0; r < 28; r++) for (Mk[r] = n, e = 0; e < 1 << _k[r]; e++) Ak[n++] = r;
				for (Ak[n - 1] = r, i = 0, r = 0; r < 16; r++) for (Ik[r] = i, e = 0; e < 1 << wk[r]; e++) kk[i++] = r;
				for (i >>= 7; r < 30; r++) for (Ik[r] = i << 7, e = 0; e < 1 << (wk[r] - 7); e++) kk[256 + i++] = r;
				for (t = 0; t <= 15; t++) s[t] = 0;
				for (e = 0; e <= 143; ) (Ek[2 * e + 1] = 8), e++, s[8]++;
				for (; e <= 255; ) (Ek[2 * e + 1] = 9), e++, s[9]++;
				for (; e <= 279; ) (Ek[2 * e + 1] = 7), e++, s[7]++;
				for (; e <= 287; ) (Ek[2 * e + 1] = 8), e++, s[8]++;
				for (Uk(Ek, 287, s), e = 0; e < 30; e++) (Tk[2 * e + 1] = 5), (Tk[2 * e] = Vk(e, 5));
				(Lk = new Rk(Ek, _k, 257, 286, 15)), (Ok = new Rk(Tk, wk, 0, 30, 15)), (Pk = new Rk(new Array(0), Ck, 0, 19, 7));
			})(),
			(qk = !0)),
			(e.l_desc = new Nk(e.dyn_ltree, Lk)),
			(e.d_desc = new Nk(e.dyn_dtree, Ok)),
			(e.bl_desc = new Nk(e.bl_tree, Pk)),
			(e.bi_buf = 0),
			(e.bi_valid = 0),
			zk(e);
	},
	_tr_stored_block: Zk,
	_tr_flush_block: (e, t, n, r) => {
		let i,
			s,
			o = 0;
		e.level > 0
			? (2 === e.strm.data_type &&
					(e.strm.data_type = ((e) => {
						let t,
							n = 4093624447;
						for (t = 0; t <= 31; t++, n >>>= 1) if (1 & n && 0 !== e.dyn_ltree[2 * t]) return 0;
						if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1;
						for (t = 32; t < 256; t++) if (0 !== e.dyn_ltree[2 * t]) return 1;
						return 0;
					})(e)),
			  Yk(e, e.l_desc),
			  Yk(e, e.d_desc),
			  (o = ((e) => {
					let t;
					for (Xk(e, e.dyn_ltree, e.l_desc.max_code), Xk(e, e.dyn_dtree, e.d_desc.max_code), Yk(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * Sk[t] + 1]; t--);
					return (e.opt_len += 3 * (t + 1) + 5 + 5 + 4), t;
			  })(e)),
			  (i = (e.opt_len + 3 + 7) >>> 3),
			  (s = (e.static_len + 3 + 7) >>> 3),
			  s <= i && (i = s))
			: (i = s = n + 5),
			n + 4 <= i && -1 !== t
				? Zk(e, t, n, r)
				: 4 === e.strategy || s === i
				? (Fk(e, 2 + (r ? 1 : 0), 3), Gk(e, Ek, Tk))
				: (Fk(e, 4 + (r ? 1 : 0), 3),
				  ((e, t, n, r) => {
						let i;
						for (Fk(e, t - 257, 5), Fk(e, n - 1, 5), Fk(e, r - 4, 4), i = 0; i < r; i++) Fk(e, e.bl_tree[2 * Sk[i] + 1], 3);
						Kk(e, e.dyn_ltree, t - 1), Kk(e, e.dyn_dtree, n - 1);
				  })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1),
				  Gk(e, e.dyn_ltree, e.dyn_dtree)),
			zk(e),
			r && $k(e);
	},
	_tr_tally: (e, t, n) => (
		(e.pending_buf[e.d_buf + 2 * e.last_lit] = (t >>> 8) & 255),
		(e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t),
		(e.pending_buf[e.l_buf + e.last_lit] = 255 & n),
		e.last_lit++,
		0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++, t--, e.dyn_ltree[2 * (Ak[n] + 256 + 1)]++, e.dyn_dtree[2 * Dk(t)]++),
		e.last_lit === e.lit_bufsize - 1
	),
	_tr_align: (e) => {
		Fk(e, 2, 3),
			Hk(e, 256, Ek),
			((e) => {
				16 === e.bi_valid ? (Bk(e, e.bi_buf), (e.bi_buf = 0), (e.bi_valid = 0)) : e.bi_valid >= 8 && ((e.pending_buf[e.pending++] = 255 & e.bi_buf), (e.bi_buf >>= 8), (e.bi_valid -= 8));
			})(e);
	}
};
var Qk = (e, t, n, r) => {
	let i = (65535 & e) | 0,
		s = ((e >>> 16) & 65535) | 0,
		o = 0;
	for (; 0 !== n; ) {
		(o = n > 2e3 ? 2e3 : n), (n -= o);
		do {
			(i = (i + t[r++]) | 0), (s = (s + i) | 0);
		} while (--o);
		(i %= 65521), (s %= 65521);
	}
	return i | (s << 16) | 0;
};
const eA = new Uint32Array(
	(() => {
		let e,
			t = [];
		for (var n = 0; n < 256; n++) {
			e = n;
			for (var r = 0; r < 8; r++) e = 1 & e ? 3988292384 ^ (e >>> 1) : e >>> 1;
			t[n] = e;
		}
		return t;
	})()
);
var tA = (e, t, n, r) => {
		const i = eA,
			s = r + n;
		e ^= -1;
		for (let o = r; o < s; o++) e = (e >>> 8) ^ i[255 & (e ^ t[o])];
		return -1 ^ e;
	},
	nA = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" },
	rA = {
		Z_NO_FLUSH: 0,
		Z_PARTIAL_FLUSH: 1,
		Z_SYNC_FLUSH: 2,
		Z_FULL_FLUSH: 3,
		Z_FINISH: 4,
		Z_BLOCK: 5,
		Z_TREES: 6,
		Z_OK: 0,
		Z_STREAM_END: 1,
		Z_NEED_DICT: 2,
		Z_ERRNO: -1,
		Z_STREAM_ERROR: -2,
		Z_DATA_ERROR: -3,
		Z_MEM_ERROR: -4,
		Z_BUF_ERROR: -5,
		Z_NO_COMPRESSION: 0,
		Z_BEST_SPEED: 1,
		Z_BEST_COMPRESSION: 9,
		Z_DEFAULT_COMPRESSION: -1,
		Z_FILTERED: 1,
		Z_HUFFMAN_ONLY: 2,
		Z_RLE: 3,
		Z_FIXED: 4,
		Z_DEFAULT_STRATEGY: 0,
		Z_BINARY: 0,
		Z_TEXT: 1,
		Z_UNKNOWN: 2,
		Z_DEFLATED: 8
	};
const { _tr_init: iA, _tr_stored_block: sA, _tr_flush_block: oA, _tr_tally: aA, _tr_align: lA } = Jk,
	{
		Z_NO_FLUSH: uA,
		Z_PARTIAL_FLUSH: cA,
		Z_FULL_FLUSH: hA,
		Z_FINISH: dA,
		Z_BLOCK: pA,
		Z_OK: fA,
		Z_STREAM_END: mA,
		Z_STREAM_ERROR: vA,
		Z_DATA_ERROR: gA,
		Z_BUF_ERROR: yA,
		Z_DEFAULT_COMPRESSION: bA,
		Z_FILTERED: xA,
		Z_HUFFMAN_ONLY: _A,
		Z_RLE: wA,
		Z_FIXED: CA,
		Z_DEFAULT_STRATEGY: SA,
		Z_UNKNOWN: EA,
		Z_DEFLATED: TA
	} = rA,
	kA = (e, t) => ((e.msg = nA[t]), t),
	AA = (e) => (e << 1) - (e > 4 ? 9 : 0),
	MA = (e) => {
		let t = e.length;
		for (; --t >= 0; ) e[t] = 0;
	};
let IA = (e, t, n) => ((t << e.hash_shift) ^ n) & e.hash_mask;
const RA = (e) => {
		const t = e.state;
		let n = t.pending;
		n > e.avail_out && (n = e.avail_out), 0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out), (e.next_out += n), (t.pending_out += n), (e.total_out += n), (e.avail_out -= n), (t.pending -= n), 0 === t.pending && (t.pending_out = 0));
	},
	LA = (e, t) => {
		oA(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), (e.block_start = e.strstart), RA(e.strm);
	},
	OA = (e, t) => {
		e.pending_buf[e.pending++] = t;
	},
	PA = (e, t) => {
		(e.pending_buf[e.pending++] = (t >>> 8) & 255), (e.pending_buf[e.pending++] = 255 & t);
	},
	NA = (e, t, n, r) => {
		let i = e.avail_in;
		return i > r && (i = r), 0 === i ? 0 : ((e.avail_in -= i), t.set(e.input.subarray(e.next_in, e.next_in + i), n), 1 === e.state.wrap ? (e.adler = Qk(e.adler, t, i, n)) : 2 === e.state.wrap && (e.adler = tA(e.adler, t, i, n)), (e.next_in += i), (e.total_in += i), i);
	},
	DA = (e, t) => {
		let n,
			r,
			i = e.max_chain_length,
			s = e.strstart,
			o = e.prev_length,
			a = e.nice_match;
		const l = e.strstart > e.w_size - 262 ? e.strstart - (e.w_size - 262) : 0,
			u = e.window,
			c = e.w_mask,
			h = e.prev,
			d = e.strstart + 258;
		let p = u[s + o - 1],
			f = u[s + o];
		e.prev_length >= e.good_match && (i >>= 2), a > e.lookahead && (a = e.lookahead);
		do {
			if (((n = t), u[n + o] === f && u[n + o - 1] === p && u[n] === u[s] && u[++n] === u[s + 1])) {
				(s += 2), n++;
				do {} while (u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && u[++s] === u[++n] && s < d);
				if (((r = 258 - (d - s)), (s = d - 258), r > o)) {
					if (((e.match_start = t), (o = r), r >= a)) break;
					(p = u[s + o - 1]), (f = u[s + o]);
				}
			}
		} while ((t = h[t & c]) > l && 0 != --i);
		return o <= e.lookahead ? o : e.lookahead;
	},
	BA = (e) => {
		const t = e.w_size;
		let n, r, i, s, o;
		do {
			if (((s = e.window_size - e.lookahead - e.strstart), e.strstart >= t + (t - 262))) {
				e.window.set(e.window.subarray(t, t + t), 0), (e.match_start -= t), (e.strstart -= t), (e.block_start -= t), (r = e.hash_size), (n = r);
				do {
					(i = e.head[--n]), (e.head[n] = i >= t ? i - t : 0);
				} while (--r);
				(r = t), (n = r);
				do {
					(i = e.prev[--n]), (e.prev[n] = i >= t ? i - t : 0);
				} while (--r);
				s += t;
			}
			if (0 === e.strm.avail_in) break;
			if (((r = NA(e.strm, e.window, e.strstart + e.lookahead, s)), (e.lookahead += r), e.lookahead + e.insert >= 3))
				for (o = e.strstart - e.insert, e.ins_h = e.window[o], e.ins_h = IA(e, e.ins_h, e.window[o + 1]); e.insert && ((e.ins_h = IA(e, e.ins_h, e.window[o + 3 - 1])), (e.prev[o & e.w_mask] = e.head[e.ins_h]), (e.head[e.ins_h] = o), o++, e.insert--, !(e.lookahead + e.insert < 3)); );
		} while (e.lookahead < 262 && 0 !== e.strm.avail_in);
	},
	FA = (e, t) => {
		let n, r;
		for (;;) {
			if (e.lookahead < 262) {
				if ((BA(e), e.lookahead < 262 && t === uA)) return 1;
				if (0 === e.lookahead) break;
			}
			if (((n = 0), e.lookahead >= 3 && ((e.ins_h = IA(e, e.ins_h, e.window[e.strstart + 3 - 1])), (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]), (e.head[e.ins_h] = e.strstart)), 0 !== n && e.strstart - n <= e.w_size - 262 && (e.match_length = DA(e, n)), e.match_length >= 3))
				if (((r = aA(e, e.strstart - e.match_start, e.match_length - 3)), (e.lookahead -= e.match_length), e.match_length <= e.max_lazy_match && e.lookahead >= 3)) {
					e.match_length--;
					do {
						e.strstart++, (e.ins_h = IA(e, e.ins_h, e.window[e.strstart + 3 - 1])), (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]), (e.head[e.ins_h] = e.strstart);
					} while (0 != --e.match_length);
					e.strstart++;
				} else (e.strstart += e.match_length), (e.match_length = 0), (e.ins_h = e.window[e.strstart]), (e.ins_h = IA(e, e.ins_h, e.window[e.strstart + 1]));
			else (r = aA(e, 0, e.window[e.strstart])), e.lookahead--, e.strstart++;
			if (r && (LA(e, !1), 0 === e.strm.avail_out)) return 1;
		}
		return (e.insert = e.strstart < 2 ? e.strstart : 2), t === dA ? (LA(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (LA(e, !1), 0 === e.strm.avail_out) ? 1 : 2;
	},
	HA = (e, t) => {
		let n, r, i;
		for (;;) {
			if (e.lookahead < 262) {
				if ((BA(e), e.lookahead < 262 && t === uA)) return 1;
				if (0 === e.lookahead) break;
			}
			if (
				((n = 0),
				e.lookahead >= 3 && ((e.ins_h = IA(e, e.ins_h, e.window[e.strstart + 3 - 1])), (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]), (e.head[e.ins_h] = e.strstart)),
				(e.prev_length = e.match_length),
				(e.prev_match = e.match_start),
				(e.match_length = 2),
				0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - 262 && ((e.match_length = DA(e, n)), e.match_length <= 5 && (e.strategy === xA || (3 === e.match_length && e.strstart - e.match_start > 4096)) && (e.match_length = 2)),
				e.prev_length >= 3 && e.match_length <= e.prev_length)
			) {
				(i = e.strstart + e.lookahead - 3), (r = aA(e, e.strstart - 1 - e.prev_match, e.prev_length - 3)), (e.lookahead -= e.prev_length - 1), (e.prev_length -= 2);
				do {
					++e.strstart <= i && ((e.ins_h = IA(e, e.ins_h, e.window[e.strstart + 3 - 1])), (n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h]), (e.head[e.ins_h] = e.strstart));
				} while (0 != --e.prev_length);
				if (((e.match_available = 0), (e.match_length = 2), e.strstart++, r && (LA(e, !1), 0 === e.strm.avail_out))) return 1;
			} else if (e.match_available) {
				if (((r = aA(e, 0, e.window[e.strstart - 1])), r && LA(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out)) return 1;
			} else (e.match_available = 1), e.strstart++, e.lookahead--;
		}
		return e.match_available && ((r = aA(e, 0, e.window[e.strstart - 1])), (e.match_available = 0)), (e.insert = e.strstart < 2 ? e.strstart : 2), t === dA ? (LA(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (LA(e, !1), 0 === e.strm.avail_out) ? 1 : 2;
	};
function VA(e, t, n, r, i) {
	(this.good_length = e), (this.max_lazy = t), (this.nice_length = n), (this.max_chain = r), (this.func = i);
}
const UA = [
	new VA(0, 0, 0, 0, (e, t) => {
		let n = 65535;
		for (n > e.pending_buf_size - 5 && (n = e.pending_buf_size - 5); ; ) {
			if (e.lookahead <= 1) {
				if ((BA(e), 0 === e.lookahead && t === uA)) return 1;
				if (0 === e.lookahead) break;
			}
			(e.strstart += e.lookahead), (e.lookahead = 0);
			const r = e.block_start + n;
			if ((0 === e.strstart || e.strstart >= r) && ((e.lookahead = e.strstart - r), (e.strstart = r), LA(e, !1), 0 === e.strm.avail_out)) return 1;
			if (e.strstart - e.block_start >= e.w_size - 262 && (LA(e, !1), 0 === e.strm.avail_out)) return 1;
		}
		return (e.insert = 0), t === dA ? (LA(e, !0), 0 === e.strm.avail_out ? 3 : 4) : (e.strstart > e.block_start && (LA(e, !1), e.strm.avail_out), 1);
	}),
	new VA(4, 4, 8, 4, FA),
	new VA(4, 5, 16, 8, FA),
	new VA(4, 6, 32, 32, FA),
	new VA(4, 4, 16, 16, HA),
	new VA(8, 16, 32, 32, HA),
	new VA(8, 16, 128, 128, HA),
	new VA(8, 32, 128, 256, HA),
	new VA(32, 128, 258, 1024, HA),
	new VA(32, 258, 258, 4096, HA)
];
function zA() {
	(this.strm = null),
		(this.status = 0),
		(this.pending_buf = null),
		(this.pending_buf_size = 0),
		(this.pending_out = 0),
		(this.pending = 0),
		(this.wrap = 0),
		(this.gzhead = null),
		(this.gzindex = 0),
		(this.method = TA),
		(this.last_flush = -1),
		(this.w_size = 0),
		(this.w_bits = 0),
		(this.w_mask = 0),
		(this.window = null),
		(this.window_size = 0),
		(this.prev = null),
		(this.head = null),
		(this.ins_h = 0),
		(this.hash_size = 0),
		(this.hash_bits = 0),
		(this.hash_mask = 0),
		(this.hash_shift = 0),
		(this.block_start = 0),
		(this.match_length = 0),
		(this.prev_match = 0),
		(this.match_available = 0),
		(this.strstart = 0),
		(this.match_start = 0),
		(this.lookahead = 0),
		(this.prev_length = 0),
		(this.max_chain_length = 0),
		(this.max_lazy_match = 0),
		(this.level = 0),
		(this.strategy = 0),
		(this.good_match = 0),
		(this.nice_match = 0),
		(this.dyn_ltree = new Uint16Array(1146)),
		(this.dyn_dtree = new Uint16Array(122)),
		(this.bl_tree = new Uint16Array(78)),
		MA(this.dyn_ltree),
		MA(this.dyn_dtree),
		MA(this.bl_tree),
		(this.l_desc = null),
		(this.d_desc = null),
		(this.bl_desc = null),
		(this.bl_count = new Uint16Array(16)),
		(this.heap = new Uint16Array(573)),
		MA(this.heap),
		(this.heap_len = 0),
		(this.heap_max = 0),
		(this.depth = new Uint16Array(573)),
		MA(this.depth),
		(this.l_buf = 0),
		(this.lit_bufsize = 0),
		(this.last_lit = 0),
		(this.d_buf = 0),
		(this.opt_len = 0),
		(this.static_len = 0),
		(this.matches = 0),
		(this.insert = 0),
		(this.bi_buf = 0),
		(this.bi_valid = 0);
}
const $A = (e) => {
		if (!e || !e.state) return kA(e, vA);
		(e.total_in = e.total_out = 0), (e.data_type = EA);
		const t = e.state;
		return (t.pending = 0), (t.pending_out = 0), t.wrap < 0 && (t.wrap = -t.wrap), (t.status = t.wrap ? 42 : 113), (e.adler = 2 === t.wrap ? 0 : 1), (t.last_flush = uA), iA(t), fA;
	},
	jA = (e) => {
		const t = $A(e);
		var n;
		return (
			t === fA &&
				(((n = e.state).window_size = 2 * n.w_size),
				MA(n.head),
				(n.max_lazy_match = UA[n.level].max_lazy),
				(n.good_match = UA[n.level].good_length),
				(n.nice_match = UA[n.level].nice_length),
				(n.max_chain_length = UA[n.level].max_chain),
				(n.strstart = 0),
				(n.block_start = 0),
				(n.lookahead = 0),
				(n.insert = 0),
				(n.match_length = n.prev_length = 2),
				(n.match_available = 0),
				(n.ins_h = 0)),
			t
		);
	},
	WA = (e, t, n, r, i, s) => {
		if (!e) return vA;
		let o = 1;
		if ((t === bA && (t = 6), r < 0 ? ((o = 0), (r = -r)) : r > 15 && ((o = 2), (r -= 16)), i < 1 || i > 9 || n !== TA || r < 8 || r > 15 || t < 0 || t > 9 || s < 0 || s > CA)) return kA(e, vA);
		8 === r && (r = 9);
		const a = new zA();
		return (
			(e.state = a),
			(a.strm = e),
			(a.wrap = o),
			(a.gzhead = null),
			(a.w_bits = r),
			(a.w_size = 1 << a.w_bits),
			(a.w_mask = a.w_size - 1),
			(a.hash_bits = i + 7),
			(a.hash_size = 1 << a.hash_bits),
			(a.hash_mask = a.hash_size - 1),
			(a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3)),
			(a.window = new Uint8Array(2 * a.w_size)),
			(a.head = new Uint16Array(a.hash_size)),
			(a.prev = new Uint16Array(a.w_size)),
			(a.lit_bufsize = 1 << (i + 6)),
			(a.pending_buf_size = 4 * a.lit_bufsize),
			(a.pending_buf = new Uint8Array(a.pending_buf_size)),
			(a.d_buf = 1 * a.lit_bufsize),
			(a.l_buf = 3 * a.lit_bufsize),
			(a.level = t),
			(a.strategy = s),
			(a.method = n),
			jA(e)
		);
	};
var GA = {
	deflateInit: (e, t) => WA(e, t, TA, 15, 8, SA),
	deflateInit2: WA,
	deflateReset: jA,
	deflateResetKeep: $A,
	deflateSetHeader: (e, t) => (e && e.state ? (2 !== e.state.wrap ? vA : ((e.state.gzhead = t), fA)) : vA),
	deflate: (e, t) => {
		let n, r;
		if (!e || !e.state || t > pA || t < 0) return e ? kA(e, vA) : vA;
		const i = e.state;
		if (!e.output || (!e.input && 0 !== e.avail_in) || (666 === i.status && t !== dA)) return kA(e, 0 === e.avail_out ? yA : vA);
		i.strm = e;
		const s = i.last_flush;
		if (((i.last_flush = t), 42 === i.status))
			if (2 === i.wrap)
				(e.adler = 0),
					OA(i, 31),
					OA(i, 139),
					OA(i, 8),
					i.gzhead
						? (OA(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)),
						  OA(i, 255 & i.gzhead.time),
						  OA(i, (i.gzhead.time >> 8) & 255),
						  OA(i, (i.gzhead.time >> 16) & 255),
						  OA(i, (i.gzhead.time >> 24) & 255),
						  OA(i, 9 === i.level ? 2 : i.strategy >= _A || i.level < 2 ? 4 : 0),
						  OA(i, 255 & i.gzhead.os),
						  i.gzhead.extra && i.gzhead.extra.length && (OA(i, 255 & i.gzhead.extra.length), OA(i, (i.gzhead.extra.length >> 8) & 255)),
						  i.gzhead.hcrc && (e.adler = tA(e.adler, i.pending_buf, i.pending, 0)),
						  (i.gzindex = 0),
						  (i.status = 69))
						: (OA(i, 0), OA(i, 0), OA(i, 0), OA(i, 0), OA(i, 0), OA(i, 9 === i.level ? 2 : i.strategy >= _A || i.level < 2 ? 4 : 0), OA(i, 3), (i.status = 113));
			else {
				let t = (TA + ((i.w_bits - 8) << 4)) << 8,
					n = -1;
				(n = i.strategy >= _A || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3), (t |= n << 6), 0 !== i.strstart && (t |= 32), (t += 31 - (t % 31)), (i.status = 113), PA(i, t), 0 !== i.strstart && (PA(i, e.adler >>> 16), PA(i, 65535 & e.adler)), (e.adler = 1);
			}
		if (69 === i.status)
			if (i.gzhead.extra) {
				for (n = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), RA(e), (n = i.pending), i.pending !== i.pending_buf_size)); )
					OA(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
				i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex === i.gzhead.extra.length && ((i.gzindex = 0), (i.status = 73));
			} else i.status = 73;
		if (73 === i.status)
			if (i.gzhead.name) {
				n = i.pending;
				do {
					if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), RA(e), (n = i.pending), i.pending === i.pending_buf_size)) {
						r = 1;
						break;
					}
					(r = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0), OA(i, r);
				} while (0 !== r);
				i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), 0 === r && ((i.gzindex = 0), (i.status = 91));
			} else i.status = 91;
		if (91 === i.status)
			if (i.gzhead.comment) {
				n = i.pending;
				do {
					if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), RA(e), (n = i.pending), i.pending === i.pending_buf_size)) {
						r = 1;
						break;
					}
					(r = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0), OA(i, r);
				} while (0 !== r);
				i.gzhead.hcrc && i.pending > n && (e.adler = tA(e.adler, i.pending_buf, i.pending - n, n)), 0 === r && (i.status = 103);
			} else i.status = 103;
		if ((103 === i.status && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && RA(e), i.pending + 2 <= i.pending_buf_size && (OA(i, 255 & e.adler), OA(i, (e.adler >> 8) & 255), (e.adler = 0), (i.status = 113))) : (i.status = 113)), 0 !== i.pending)) {
			if ((RA(e), 0 === e.avail_out)) return (i.last_flush = -1), fA;
		} else if (0 === e.avail_in && AA(t) <= AA(s) && t !== dA) return kA(e, yA);
		if (666 === i.status && 0 !== e.avail_in) return kA(e, yA);
		if (0 !== e.avail_in || 0 !== i.lookahead || (t !== uA && 666 !== i.status)) {
			let n =
				i.strategy === _A
					? ((e, t) => {
							let n;
							for (;;) {
								if (0 === e.lookahead && (BA(e), 0 === e.lookahead)) {
									if (t === uA) return 1;
									break;
								}
								if (((e.match_length = 0), (n = aA(e, 0, e.window[e.strstart])), e.lookahead--, e.strstart++, n && (LA(e, !1), 0 === e.strm.avail_out))) return 1;
							}
							return (e.insert = 0), t === dA ? (LA(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (LA(e, !1), 0 === e.strm.avail_out) ? 1 : 2;
					  })(i, t)
					: i.strategy === wA
					? ((e, t) => {
							let n, r, i, s;
							const o = e.window;
							for (;;) {
								if (e.lookahead <= 258) {
									if ((BA(e), e.lookahead <= 258 && t === uA)) return 1;
									if (0 === e.lookahead) break;
								}
								if (((e.match_length = 0), e.lookahead >= 3 && e.strstart > 0 && ((i = e.strstart - 1), (r = o[i]), r === o[++i] && r === o[++i] && r === o[++i]))) {
									s = e.strstart + 258;
									do {} while (r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && i < s);
									(e.match_length = 258 - (s - i)), e.match_length > e.lookahead && (e.match_length = e.lookahead);
								}
								if ((e.match_length >= 3 ? ((n = aA(e, 1, e.match_length - 3)), (e.lookahead -= e.match_length), (e.strstart += e.match_length), (e.match_length = 0)) : ((n = aA(e, 0, e.window[e.strstart])), e.lookahead--, e.strstart++), n && (LA(e, !1), 0 === e.strm.avail_out)))
									return 1;
							}
							return (e.insert = 0), t === dA ? (LA(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (LA(e, !1), 0 === e.strm.avail_out) ? 1 : 2;
					  })(i, t)
					: UA[i.level].func(i, t);
			if (((3 !== n && 4 !== n) || (i.status = 666), 1 === n || 3 === n)) return 0 === e.avail_out && (i.last_flush = -1), fA;
			if (2 === n && (t === cA ? lA(i) : t !== pA && (sA(i, 0, 0, !1), t === hA && (MA(i.head), 0 === i.lookahead && ((i.strstart = 0), (i.block_start = 0), (i.insert = 0)))), RA(e), 0 === e.avail_out)) return (i.last_flush = -1), fA;
		}
		return t !== dA
			? fA
			: i.wrap <= 0
			? mA
			: (2 === i.wrap
					? (OA(i, 255 & e.adler), OA(i, (e.adler >> 8) & 255), OA(i, (e.adler >> 16) & 255), OA(i, (e.adler >> 24) & 255), OA(i, 255 & e.total_in), OA(i, (e.total_in >> 8) & 255), OA(i, (e.total_in >> 16) & 255), OA(i, (e.total_in >> 24) & 255))
					: (PA(i, e.adler >>> 16), PA(i, 65535 & e.adler)),
			  RA(e),
			  i.wrap > 0 && (i.wrap = -i.wrap),
			  0 !== i.pending ? fA : mA);
	},
	deflateEnd: (e) => {
		if (!e || !e.state) return vA;
		const t = e.state.status;
		return 42 !== t && 69 !== t && 73 !== t && 91 !== t && 103 !== t && 113 !== t && 666 !== t ? kA(e, vA) : ((e.state = null), 113 === t ? kA(e, gA) : fA);
	},
	deflateSetDictionary: (e, t) => {
		let n = t.length;
		if (!e || !e.state) return vA;
		const r = e.state,
			i = r.wrap;
		if (2 === i || (1 === i && 42 !== r.status) || r.lookahead) return vA;
		if ((1 === i && (e.adler = Qk(e.adler, t, n, 0)), (r.wrap = 0), n >= r.w_size)) {
			0 === i && (MA(r.head), (r.strstart = 0), (r.block_start = 0), (r.insert = 0));
			let e = new Uint8Array(r.w_size);
			e.set(t.subarray(n - r.w_size, n), 0), (t = e), (n = r.w_size);
		}
		const s = e.avail_in,
			o = e.next_in,
			a = e.input;
		for (e.avail_in = n, e.next_in = 0, e.input = t, BA(r); r.lookahead >= 3; ) {
			let e = r.strstart,
				t = r.lookahead - 2;
			do {
				(r.ins_h = IA(r, r.ins_h, r.window[e + 3 - 1])), (r.prev[e & r.w_mask] = r.head[r.ins_h]), (r.head[r.ins_h] = e), e++;
			} while (--t);
			(r.strstart = e), (r.lookahead = 2), BA(r);
		}
		return (r.strstart += r.lookahead), (r.block_start = r.strstart), (r.insert = r.lookahead), (r.lookahead = 0), (r.match_length = r.prev_length = 2), (r.match_available = 0), (e.next_in = o), (e.input = a), (e.avail_in = s), (r.wrap = i), fA;
	},
	deflateInfo: "pako deflate (from Nodeca project)"
};
const YA = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var XA = function (e) {
		const t = Array.prototype.slice.call(arguments, 1);
		for (; t.length; ) {
			const n = t.shift();
			if (n) {
				if ("object" != typeof n) throw new TypeError(n + "must be non-object");
				for (const t in n) YA(n, t) && (e[t] = n[t]);
			}
		}
		return e;
	},
	KA = (e) => {
		let t = 0;
		for (let r = 0, i = e.length; r < i; r++) t += e[r].length;
		const n = new Uint8Array(t);
		for (let r = 0, i = 0, s = e.length; r < s; r++) {
			let t = e[r];
			n.set(t, i), (i += t.length);
		}
		return n;
	};
let qA = !0;
try {
	String.fromCharCode.apply(null, new Uint8Array(1));
} catch (cre) {
	qA = !1;
}
const ZA = new Uint8Array(256);
for (let hre = 0; hre < 256; hre++) ZA[hre] = hre >= 252 ? 6 : hre >= 248 ? 5 : hre >= 240 ? 4 : hre >= 224 ? 3 : hre >= 192 ? 2 : 1;
ZA[254] = ZA[254] = 1;
var JA = (e) => {
		let t,
			n,
			r,
			i,
			s,
			o = e.length,
			a = 0;
		for (i = 0; i < o; i++) (n = e.charCodeAt(i)), 55296 == (64512 & n) && i + 1 < o && ((r = e.charCodeAt(i + 1)), 56320 == (64512 & r) && ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), i++)), (a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
		for (t = new Uint8Array(a), s = 0, i = 0; s < a; i++)
			(n = e.charCodeAt(i)),
				55296 == (64512 & n) && i + 1 < o && ((r = e.charCodeAt(i + 1)), 56320 == (64512 & r) && ((n = 65536 + ((n - 55296) << 10) + (r - 56320)), i++)),
				n < 128
					? (t[s++] = n)
					: n < 2048
					? ((t[s++] = 192 | (n >>> 6)), (t[s++] = 128 | (63 & n)))
					: n < 65536
					? ((t[s++] = 224 | (n >>> 12)), (t[s++] = 128 | ((n >>> 6) & 63)), (t[s++] = 128 | (63 & n)))
					: ((t[s++] = 240 | (n >>> 18)), (t[s++] = 128 | ((n >>> 12) & 63)), (t[s++] = 128 | ((n >>> 6) & 63)), (t[s++] = 128 | (63 & n)));
		return t;
	},
	QA = (e, t) => {
		let n, r;
		const i = t || e.length,
			s = new Array(2 * i);
		for (r = 0, n = 0; n < i; ) {
			let t = e[n++];
			if (t < 128) {
				s[r++] = t;
				continue;
			}
			let o = ZA[t];
			if (o > 4) (s[r++] = 65533), (n += o - 1);
			else {
				for (t &= 2 === o ? 31 : 3 === o ? 15 : 7; o > 1 && n < i; ) (t = (t << 6) | (63 & e[n++])), o--;
				o > 1 ? (s[r++] = 65533) : t < 65536 ? (s[r++] = t) : ((t -= 65536), (s[r++] = 55296 | ((t >> 10) & 1023)), (s[r++] = 56320 | (1023 & t)));
			}
		}
		return ((e, t) => {
			if (t < 65534 && e.subarray && qA) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
			let n = "";
			for (let r = 0; r < t; r++) n += String.fromCharCode(e[r]);
			return n;
		})(s, r);
	},
	eM = (e, t) => {
		(t = t || e.length) > e.length && (t = e.length);
		let n = t - 1;
		for (; n >= 0 && 128 == (192 & e[n]); ) n--;
		return n < 0 || 0 === n ? t : n + ZA[e[n]] > t ? n : t;
	};
var tM = function () {
	(this.input = null), (this.next_in = 0), (this.avail_in = 0), (this.total_in = 0), (this.output = null), (this.next_out = 0), (this.avail_out = 0), (this.total_out = 0), (this.msg = ""), (this.state = null), (this.data_type = 2), (this.adler = 0);
};
const nM = Object.prototype.toString,
	{ Z_NO_FLUSH: rM, Z_SYNC_FLUSH: iM, Z_FULL_FLUSH: sM, Z_FINISH: oM, Z_OK: aM, Z_STREAM_END: lM, Z_DEFAULT_COMPRESSION: uM, Z_DEFAULT_STRATEGY: cM, Z_DEFLATED: hM } = rA;
function dM(e) {
	this.options = XA({ level: uM, method: hM, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: cM }, e || {});
	let t = this.options;
	t.raw && t.windowBits > 0 ? (t.windowBits = -t.windowBits) : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), (this.err = 0), (this.msg = ""), (this.ended = !1), (this.chunks = []), (this.strm = new tM()), (this.strm.avail_out = 0);
	let n = GA.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
	if (n !== aM) throw new Error(nA[n]);
	if ((t.header && GA.deflateSetHeader(this.strm, t.header), t.dictionary)) {
		let e;
		if (((e = "string" == typeof t.dictionary ? JA(t.dictionary) : "[object ArrayBuffer]" === nM.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary), (n = GA.deflateSetDictionary(this.strm, e)), n !== aM)) throw new Error(nA[n]);
		this._dict_set = !0;
	}
}
function pM(e, t) {
	const n = new dM(t);
	if ((n.push(e, !0), n.err)) throw n.msg || nA[n.err];
	return n.result;
}
(dM.prototype.push = function (e, t) {
	const n = this.strm,
		r = this.options.chunkSize;
	let i, s;
	if (this.ended) return !1;
	for (s = t === ~~t ? t : !0 === t ? oM : rM, "string" == typeof e ? (n.input = JA(e)) : "[object ArrayBuffer]" === nM.call(e) ? (n.input = new Uint8Array(e)) : (n.input = e), n.next_in = 0, n.avail_in = n.input.length; ; )
		if ((0 === n.avail_out && ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)), (s === iM || s === sM) && n.avail_out <= 6)) this.onData(n.output.subarray(0, n.next_out)), (n.avail_out = 0);
		else {
			if (((i = GA.deflate(n, s)), i === lM)) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), (i = GA.deflateEnd(this.strm)), this.onEnd(i), (this.ended = !0), i === aM;
			if (0 !== n.avail_out) {
				if (s > 0 && n.next_out > 0) this.onData(n.output.subarray(0, n.next_out)), (n.avail_out = 0);
				else if (0 === n.avail_in) break;
			} else this.onData(n.output);
		}
	return !0;
}),
	(dM.prototype.onData = function (e) {
		this.chunks.push(e);
	}),
	(dM.prototype.onEnd = function (e) {
		e === aM && (this.result = KA(this.chunks)), (this.chunks = []), (this.err = e), (this.msg = this.strm.msg);
	});
var fM = {
	Deflate: dM,
	deflate: pM,
	deflateRaw: function (e, t) {
		return ((t = t || {}).raw = !0), pM(e, t);
	},
	gzip: function (e, t) {
		return ((t = t || {}).gzip = !0), pM(e, t);
	},
	constants: rA
};
var mM = function (e, t) {
	let n, r, i, s, o, a, l, u, c, h, d, p, f, m, v, g, y, b, x, _, w, C, S, E;
	const T = e.state;
	(n = e.next_in),
		(S = e.input),
		(r = n + (e.avail_in - 5)),
		(i = e.next_out),
		(E = e.output),
		(s = i - (t - e.avail_out)),
		(o = i + (e.avail_out - 257)),
		(a = T.dmax),
		(l = T.wsize),
		(u = T.whave),
		(c = T.wnext),
		(h = T.window),
		(d = T.hold),
		(p = T.bits),
		(f = T.lencode),
		(m = T.distcode),
		(v = (1 << T.lenbits) - 1),
		(g = (1 << T.distbits) - 1);
	e: do {
		p < 15 && ((d += S[n++] << p), (p += 8), (d += S[n++] << p), (p += 8)), (y = f[d & v]);
		t: for (;;) {
			if (((b = y >>> 24), (d >>>= b), (p -= b), (b = (y >>> 16) & 255), 0 === b)) E[i++] = 65535 & y;
			else {
				if (!(16 & b)) {
					if (0 == (64 & b)) {
						y = f[(65535 & y) + (d & ((1 << b) - 1))];
						continue t;
					}
					if (32 & b) {
						T.mode = 12;
						break e;
					}
					(e.msg = "invalid literal/length code"), (T.mode = 30);
					break e;
				}
				(x = 65535 & y), (b &= 15), b && (p < b && ((d += S[n++] << p), (p += 8)), (x += d & ((1 << b) - 1)), (d >>>= b), (p -= b)), p < 15 && ((d += S[n++] << p), (p += 8), (d += S[n++] << p), (p += 8)), (y = m[d & g]);
				n: for (;;) {
					if (((b = y >>> 24), (d >>>= b), (p -= b), (b = (y >>> 16) & 255), !(16 & b))) {
						if (0 == (64 & b)) {
							y = m[(65535 & y) + (d & ((1 << b) - 1))];
							continue n;
						}
						(e.msg = "invalid distance code"), (T.mode = 30);
						break e;
					}
					if (((_ = 65535 & y), (b &= 15), p < b && ((d += S[n++] << p), (p += 8), p < b && ((d += S[n++] << p), (p += 8))), (_ += d & ((1 << b) - 1)), _ > a)) {
						(e.msg = "invalid distance too far back"), (T.mode = 30);
						break e;
					}
					if (((d >>>= b), (p -= b), (b = i - s), _ > b)) {
						if (((b = _ - b), b > u && T.sane)) {
							(e.msg = "invalid distance too far back"), (T.mode = 30);
							break e;
						}
						if (((w = 0), (C = h), 0 === c)) {
							if (((w += l - b), b < x)) {
								x -= b;
								do {
									E[i++] = h[w++];
								} while (--b);
								(w = i - _), (C = E);
							}
						} else if (c < b) {
							if (((w += l + c - b), (b -= c), b < x)) {
								x -= b;
								do {
									E[i++] = h[w++];
								} while (--b);
								if (((w = 0), c < x)) {
									(b = c), (x -= b);
									do {
										E[i++] = h[w++];
									} while (--b);
									(w = i - _), (C = E);
								}
							}
						} else if (((w += c - b), b < x)) {
							x -= b;
							do {
								E[i++] = h[w++];
							} while (--b);
							(w = i - _), (C = E);
						}
						for (; x > 2; ) (E[i++] = C[w++]), (E[i++] = C[w++]), (E[i++] = C[w++]), (x -= 3);
						x && ((E[i++] = C[w++]), x > 1 && (E[i++] = C[w++]));
					} else {
						w = i - _;
						do {
							(E[i++] = E[w++]), (E[i++] = E[w++]), (E[i++] = E[w++]), (x -= 3);
						} while (x > 2);
						x && ((E[i++] = E[w++]), x > 1 && (E[i++] = E[w++]));
					}
					break;
				}
			}
			break;
		}
	} while (n < r && i < o);
	(x = p >> 3), (n -= x), (p -= x << 3), (d &= (1 << p) - 1), (e.next_in = n), (e.next_out = i), (e.avail_in = n < r ? r - n + 5 : 5 - (n - r)), (e.avail_out = i < o ? o - i + 257 : 257 - (i - o)), (T.hold = d), (T.bits = p);
};
const vM = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
	gM = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
	yM = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
	bM = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var xM = (e, t, n, r, i, s, o, a) => {
	const l = a.bits;
	let u,
		c,
		h,
		d,
		p,
		f,
		m = 0,
		v = 0,
		g = 0,
		y = 0,
		b = 0,
		x = 0,
		_ = 0,
		w = 0,
		C = 0,
		S = 0,
		E = null,
		T = 0;
	const k = new Uint16Array(16),
		A = new Uint16Array(16);
	let M,
		I,
		R,
		L = null,
		O = 0;
	for (m = 0; m <= 15; m++) k[m] = 0;
	for (v = 0; v < r; v++) k[t[n + v]]++;
	for (b = l, y = 15; y >= 1 && 0 === k[y]; y--);
	if ((b > y && (b = y), 0 === y)) return (i[s++] = 20971520), (i[s++] = 20971520), (a.bits = 1), 0;
	for (g = 1; g < y && 0 === k[g]; g++);
	for (b < g && (b = g), w = 1, m = 1; m <= 15; m++) if (((w <<= 1), (w -= k[m]), w < 0)) return -1;
	if (w > 0 && (0 === e || 1 !== y)) return -1;
	for (A[1] = 0, m = 1; m < 15; m++) A[m + 1] = A[m] + k[m];
	for (v = 0; v < r; v++) 0 !== t[n + v] && (o[A[t[n + v]]++] = v);
	if ((0 === e ? ((E = L = o), (f = 19)) : 1 === e ? ((E = vM), (T -= 257), (L = gM), (O -= 257), (f = 256)) : ((E = yM), (L = bM), (f = -1)), (S = 0), (v = 0), (m = g), (p = s), (x = b), (_ = 0), (h = -1), (C = 1 << b), (d = C - 1), (1 === e && C > 852) || (2 === e && C > 592))) return 1;
	for (;;) {
		(M = m - _), o[v] < f ? ((I = 0), (R = o[v])) : o[v] > f ? ((I = L[O + o[v]]), (R = E[T + o[v]])) : ((I = 96), (R = 0)), (u = 1 << (m - _)), (c = 1 << x), (g = c);
		do {
			(c -= u), (i[p + (S >> _) + c] = (M << 24) | (I << 16) | R | 0);
		} while (0 !== c);
		for (u = 1 << (m - 1); S & u; ) u >>= 1;
		if ((0 !== u ? ((S &= u - 1), (S += u)) : (S = 0), v++, 0 == --k[m])) {
			if (m === y) break;
			m = t[n + o[v]];
		}
		if (m > b && (S & d) !== h) {
			for (0 === _ && (_ = b), p += g, x = m - _, w = 1 << x; x + _ < y && ((w -= k[x + _]), !(w <= 0)); ) x++, (w <<= 1);
			if (((C += 1 << x), (1 === e && C > 852) || (2 === e && C > 592))) return 1;
			(h = S & d), (i[h] = (b << 24) | (x << 16) | (p - s) | 0);
		}
	}
	return 0 !== S && (i[p + S] = ((m - _) << 24) | (64 << 16) | 0), (a.bits = b), 0;
};
const { Z_FINISH: _M, Z_BLOCK: wM, Z_TREES: CM, Z_OK: SM, Z_STREAM_END: EM, Z_NEED_DICT: TM, Z_STREAM_ERROR: kM, Z_DATA_ERROR: AM, Z_MEM_ERROR: MM, Z_BUF_ERROR: IM, Z_DEFLATED: RM } = rA,
	LM = (e) => ((e >>> 24) & 255) + ((e >>> 8) & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
function OM() {
	(this.mode = 0),
		(this.last = !1),
		(this.wrap = 0),
		(this.havedict = !1),
		(this.flags = 0),
		(this.dmax = 0),
		(this.check = 0),
		(this.total = 0),
		(this.head = null),
		(this.wbits = 0),
		(this.wsize = 0),
		(this.whave = 0),
		(this.wnext = 0),
		(this.window = null),
		(this.hold = 0),
		(this.bits = 0),
		(this.length = 0),
		(this.offset = 0),
		(this.extra = 0),
		(this.lencode = null),
		(this.distcode = null),
		(this.lenbits = 0),
		(this.distbits = 0),
		(this.ncode = 0),
		(this.nlen = 0),
		(this.ndist = 0),
		(this.have = 0),
		(this.next = null),
		(this.lens = new Uint16Array(320)),
		(this.work = new Uint16Array(288)),
		(this.lendyn = null),
		(this.distdyn = null),
		(this.sane = 0),
		(this.back = 0),
		(this.was = 0);
}
const PM = (e) => {
		if (!e || !e.state) return kM;
		const t = e.state;
		return (
			(e.total_in = e.total_out = t.total = 0),
			(e.msg = ""),
			t.wrap && (e.adler = 1 & t.wrap),
			(t.mode = 1),
			(t.last = 0),
			(t.havedict = 0),
			(t.dmax = 32768),
			(t.head = null),
			(t.hold = 0),
			(t.bits = 0),
			(t.lencode = t.lendyn = new Int32Array(852)),
			(t.distcode = t.distdyn = new Int32Array(592)),
			(t.sane = 1),
			(t.back = -1),
			SM
		);
	},
	NM = (e) => {
		if (!e || !e.state) return kM;
		const t = e.state;
		return (t.wsize = 0), (t.whave = 0), (t.wnext = 0), PM(e);
	},
	DM = (e, t) => {
		let n;
		if (!e || !e.state) return kM;
		const r = e.state;
		return t < 0 ? ((n = 0), (t = -t)) : ((n = 1 + (t >> 4)), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? kM : (null !== r.window && r.wbits !== t && (r.window = null), (r.wrap = n), (r.wbits = t), NM(e));
	},
	BM = (e, t) => {
		if (!e) return kM;
		const n = new OM();
		(e.state = n), (n.window = null);
		const r = DM(e, t);
		return r !== SM && (e.state = null), r;
	};
let FM,
	HM,
	VM = !0;
const UM = (e) => {
		if (VM) {
			(FM = new Int32Array(512)), (HM = new Int32Array(32));
			let t = 0;
			for (; t < 144; ) e.lens[t++] = 8;
			for (; t < 256; ) e.lens[t++] = 9;
			for (; t < 280; ) e.lens[t++] = 7;
			for (; t < 288; ) e.lens[t++] = 8;
			for (xM(1, e.lens, 0, 288, FM, 0, e.work, { bits: 9 }), t = 0; t < 32; ) e.lens[t++] = 5;
			xM(2, e.lens, 0, 32, HM, 0, e.work, { bits: 5 }), (VM = !1);
		}
		(e.lencode = FM), (e.lenbits = 9), (e.distcode = HM), (e.distbits = 5);
	},
	zM = (e, t, n, r) => {
		let i;
		const s = e.state;
		return (
			null === s.window && ((s.wsize = 1 << s.wbits), (s.wnext = 0), (s.whave = 0), (s.window = new Uint8Array(s.wsize))),
			r >= s.wsize
				? (s.window.set(t.subarray(n - s.wsize, n), 0), (s.wnext = 0), (s.whave = s.wsize))
				: ((i = s.wsize - s.wnext), i > r && (i = r), s.window.set(t.subarray(n - r, n - r + i), s.wnext), (r -= i) ? (s.window.set(t.subarray(n - r, n), 0), (s.wnext = r), (s.whave = s.wsize)) : ((s.wnext += i), s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))),
			0
		);
	};
var $M = {
	inflateReset: NM,
	inflateReset2: DM,
	inflateResetKeep: PM,
	inflateInit: (e) => BM(e, 15),
	inflateInit2: BM,
	inflate: (e, t) => {
		let n,
			r,
			i,
			s,
			o,
			a,
			l,
			u,
			c,
			h,
			d,
			p,
			f,
			m,
			v,
			g,
			y,
			b,
			x,
			_,
			w,
			C,
			S = 0;
		const E = new Uint8Array(4);
		let T, k;
		const A = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
		if (!e || !e.state || !e.output || (!e.input && 0 !== e.avail_in)) return kM;
		(n = e.state), 12 === n.mode && (n.mode = 13), (o = e.next_out), (i = e.output), (l = e.avail_out), (s = e.next_in), (r = e.input), (a = e.avail_in), (u = n.hold), (c = n.bits), (h = a), (d = l), (C = SM);
		e: for (;;)
			switch (n.mode) {
				case 1:
					if (0 === n.wrap) {
						n.mode = 13;
						break;
					}
					for (; c < 16; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if (2 & n.wrap && 35615 === u) {
						(n.check = 0), (E[0] = 255 & u), (E[1] = (u >>> 8) & 255), (n.check = tA(n.check, E, 2, 0)), (u = 0), (c = 0), (n.mode = 2);
						break;
					}
					if (((n.flags = 0), n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & u) << 8) + (u >> 8)) % 31)) {
						(e.msg = "incorrect header check"), (n.mode = 30);
						break;
					}
					if ((15 & u) !== RM) {
						(e.msg = "unknown compression method"), (n.mode = 30);
						break;
					}
					if (((u >>>= 4), (c -= 4), (w = 8 + (15 & u)), 0 === n.wbits)) n.wbits = w;
					else if (w > n.wbits) {
						(e.msg = "invalid window size"), (n.mode = 30);
						break;
					}
					(n.dmax = 1 << n.wbits), (e.adler = n.check = 1), (n.mode = 512 & u ? 10 : 12), (u = 0), (c = 0);
					break;
				case 2:
					for (; c < 16; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if (((n.flags = u), (255 & n.flags) !== RM)) {
						(e.msg = "unknown compression method"), (n.mode = 30);
						break;
					}
					if (57344 & n.flags) {
						(e.msg = "unknown header flags set"), (n.mode = 30);
						break;
					}
					n.head && (n.head.text = (u >> 8) & 1), 512 & n.flags && ((E[0] = 255 & u), (E[1] = (u >>> 8) & 255), (n.check = tA(n.check, E, 2, 0))), (u = 0), (c = 0), (n.mode = 3);
				case 3:
					for (; c < 32; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					n.head && (n.head.time = u), 512 & n.flags && ((E[0] = 255 & u), (E[1] = (u >>> 8) & 255), (E[2] = (u >>> 16) & 255), (E[3] = (u >>> 24) & 255), (n.check = tA(n.check, E, 4, 0))), (u = 0), (c = 0), (n.mode = 4);
				case 4:
					for (; c < 16; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					n.head && ((n.head.xflags = 255 & u), (n.head.os = u >> 8)), 512 & n.flags && ((E[0] = 255 & u), (E[1] = (u >>> 8) & 255), (n.check = tA(n.check, E, 2, 0))), (u = 0), (c = 0), (n.mode = 5);
				case 5:
					if (1024 & n.flags) {
						for (; c < 16; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(n.length = u), n.head && (n.head.extra_len = u), 512 & n.flags && ((E[0] = 255 & u), (E[1] = (u >>> 8) & 255), (n.check = tA(n.check, E, 2, 0))), (u = 0), (c = 0);
					} else n.head && (n.head.extra = null);
					n.mode = 6;
				case 6:
					if (
						1024 & n.flags &&
						((p = n.length),
						p > a && (p = a),
						p && (n.head && ((w = n.head.extra_len - n.length), n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(r.subarray(s, s + p), w)), 512 & n.flags && (n.check = tA(n.check, r, p, s)), (a -= p), (s += p), (n.length -= p)),
						n.length)
					)
						break e;
					(n.length = 0), (n.mode = 7);
				case 7:
					if (2048 & n.flags) {
						if (0 === a) break e;
						p = 0;
						do {
							(w = r[s + p++]), n.head && w && n.length < 65536 && (n.head.name += String.fromCharCode(w));
						} while (w && p < a);
						if ((512 & n.flags && (n.check = tA(n.check, r, p, s)), (a -= p), (s += p), w)) break e;
					} else n.head && (n.head.name = null);
					(n.length = 0), (n.mode = 8);
				case 8:
					if (4096 & n.flags) {
						if (0 === a) break e;
						p = 0;
						do {
							(w = r[s + p++]), n.head && w && n.length < 65536 && (n.head.comment += String.fromCharCode(w));
						} while (w && p < a);
						if ((512 & n.flags && (n.check = tA(n.check, r, p, s)), (a -= p), (s += p), w)) break e;
					} else n.head && (n.head.comment = null);
					n.mode = 9;
				case 9:
					if (512 & n.flags) {
						for (; c < 16; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						if (u !== (65535 & n.check)) {
							(e.msg = "header crc mismatch"), (n.mode = 30);
							break;
						}
						(u = 0), (c = 0);
					}
					n.head && ((n.head.hcrc = (n.flags >> 9) & 1), (n.head.done = !0)), (e.adler = n.check = 0), (n.mode = 12);
					break;
				case 10:
					for (; c < 32; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					(e.adler = n.check = LM(u)), (u = 0), (c = 0), (n.mode = 11);
				case 11:
					if (0 === n.havedict) return (e.next_out = o), (e.avail_out = l), (e.next_in = s), (e.avail_in = a), (n.hold = u), (n.bits = c), TM;
					(e.adler = n.check = 1), (n.mode = 12);
				case 12:
					if (t === wM || t === CM) break e;
				case 13:
					if (n.last) {
						(u >>>= 7 & c), (c -= 7 & c), (n.mode = 27);
						break;
					}
					for (; c < 3; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					switch (((n.last = 1 & u), (u >>>= 1), (c -= 1), 3 & u)) {
						case 0:
							n.mode = 14;
							break;
						case 1:
							if ((UM(n), (n.mode = 20), t === CM)) {
								(u >>>= 2), (c -= 2);
								break e;
							}
							break;
						case 2:
							n.mode = 17;
							break;
						case 3:
							(e.msg = "invalid block type"), (n.mode = 30);
					}
					(u >>>= 2), (c -= 2);
					break;
				case 14:
					for (u >>>= 7 & c, c -= 7 & c; c < 32; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if ((65535 & u) != ((u >>> 16) ^ 65535)) {
						(e.msg = "invalid stored block lengths"), (n.mode = 30);
						break;
					}
					if (((n.length = 65535 & u), (u = 0), (c = 0), (n.mode = 15), t === CM)) break e;
				case 15:
					n.mode = 16;
				case 16:
					if (((p = n.length), p)) {
						if ((p > a && (p = a), p > l && (p = l), 0 === p)) break e;
						i.set(r.subarray(s, s + p), o), (a -= p), (s += p), (l -= p), (o += p), (n.length -= p);
						break;
					}
					n.mode = 12;
					break;
				case 17:
					for (; c < 14; ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if (((n.nlen = 257 + (31 & u)), (u >>>= 5), (c -= 5), (n.ndist = 1 + (31 & u)), (u >>>= 5), (c -= 5), (n.ncode = 4 + (15 & u)), (u >>>= 4), (c -= 4), n.nlen > 286 || n.ndist > 30)) {
						(e.msg = "too many length or distance symbols"), (n.mode = 30);
						break;
					}
					(n.have = 0), (n.mode = 18);
				case 18:
					for (; n.have < n.ncode; ) {
						for (; c < 3; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(n.lens[A[n.have++]] = 7 & u), (u >>>= 3), (c -= 3);
					}
					for (; n.have < 19; ) n.lens[A[n.have++]] = 0;
					if (((n.lencode = n.lendyn), (n.lenbits = 7), (T = { bits: n.lenbits }), (C = xM(0, n.lens, 0, 19, n.lencode, 0, n.work, T)), (n.lenbits = T.bits), C)) {
						(e.msg = "invalid code lengths set"), (n.mode = 30);
						break;
					}
					(n.have = 0), (n.mode = 19);
				case 19:
					for (; n.have < n.nlen + n.ndist; ) {
						for (; (S = n.lencode[u & ((1 << n.lenbits) - 1)]), (v = S >>> 24), (g = (S >>> 16) & 255), (y = 65535 & S), !(v <= c); ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						if (y < 16) (u >>>= v), (c -= v), (n.lens[n.have++] = y);
						else {
							if (16 === y) {
								for (k = v + 2; c < k; ) {
									if (0 === a) break e;
									a--, (u += r[s++] << c), (c += 8);
								}
								if (((u >>>= v), (c -= v), 0 === n.have)) {
									(e.msg = "invalid bit length repeat"), (n.mode = 30);
									break;
								}
								(w = n.lens[n.have - 1]), (p = 3 + (3 & u)), (u >>>= 2), (c -= 2);
							} else if (17 === y) {
								for (k = v + 3; c < k; ) {
									if (0 === a) break e;
									a--, (u += r[s++] << c), (c += 8);
								}
								(u >>>= v), (c -= v), (w = 0), (p = 3 + (7 & u)), (u >>>= 3), (c -= 3);
							} else {
								for (k = v + 7; c < k; ) {
									if (0 === a) break e;
									a--, (u += r[s++] << c), (c += 8);
								}
								(u >>>= v), (c -= v), (w = 0), (p = 11 + (127 & u)), (u >>>= 7), (c -= 7);
							}
							if (n.have + p > n.nlen + n.ndist) {
								(e.msg = "invalid bit length repeat"), (n.mode = 30);
								break;
							}
							for (; p--; ) n.lens[n.have++] = w;
						}
					}
					if (30 === n.mode) break;
					if (0 === n.lens[256]) {
						(e.msg = "invalid code -- missing end-of-block"), (n.mode = 30);
						break;
					}
					if (((n.lenbits = 9), (T = { bits: n.lenbits }), (C = xM(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, T)), (n.lenbits = T.bits), C)) {
						(e.msg = "invalid literal/lengths set"), (n.mode = 30);
						break;
					}
					if (((n.distbits = 6), (n.distcode = n.distdyn), (T = { bits: n.distbits }), (C = xM(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, T)), (n.distbits = T.bits), C)) {
						(e.msg = "invalid distances set"), (n.mode = 30);
						break;
					}
					if (((n.mode = 20), t === CM)) break e;
				case 20:
					n.mode = 21;
				case 21:
					if (a >= 6 && l >= 258) {
						(e.next_out = o), (e.avail_out = l), (e.next_in = s), (e.avail_in = a), (n.hold = u), (n.bits = c), mM(e, d), (o = e.next_out), (i = e.output), (l = e.avail_out), (s = e.next_in), (r = e.input), (a = e.avail_in), (u = n.hold), (c = n.bits), 12 === n.mode && (n.back = -1);
						break;
					}
					for (n.back = 0; (S = n.lencode[u & ((1 << n.lenbits) - 1)]), (v = S >>> 24), (g = (S >>> 16) & 255), (y = 65535 & S), !(v <= c); ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if (g && 0 == (240 & g)) {
						for (b = v, x = g, _ = y; (S = n.lencode[_ + ((u & ((1 << (b + x)) - 1)) >> b)]), (v = S >>> 24), (g = (S >>> 16) & 255), (y = 65535 & S), !(b + v <= c); ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(u >>>= b), (c -= b), (n.back += b);
					}
					if (((u >>>= v), (c -= v), (n.back += v), (n.length = y), 0 === g)) {
						n.mode = 26;
						break;
					}
					if (32 & g) {
						(n.back = -1), (n.mode = 12);
						break;
					}
					if (64 & g) {
						(e.msg = "invalid literal/length code"), (n.mode = 30);
						break;
					}
					(n.extra = 15 & g), (n.mode = 22);
				case 22:
					if (n.extra) {
						for (k = n.extra; c < k; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(n.length += u & ((1 << n.extra) - 1)), (u >>>= n.extra), (c -= n.extra), (n.back += n.extra);
					}
					(n.was = n.length), (n.mode = 23);
				case 23:
					for (; (S = n.distcode[u & ((1 << n.distbits) - 1)]), (v = S >>> 24), (g = (S >>> 16) & 255), (y = 65535 & S), !(v <= c); ) {
						if (0 === a) break e;
						a--, (u += r[s++] << c), (c += 8);
					}
					if (0 == (240 & g)) {
						for (b = v, x = g, _ = y; (S = n.distcode[_ + ((u & ((1 << (b + x)) - 1)) >> b)]), (v = S >>> 24), (g = (S >>> 16) & 255), (y = 65535 & S), !(b + v <= c); ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(u >>>= b), (c -= b), (n.back += b);
					}
					if (((u >>>= v), (c -= v), (n.back += v), 64 & g)) {
						(e.msg = "invalid distance code"), (n.mode = 30);
						break;
					}
					(n.offset = y), (n.extra = 15 & g), (n.mode = 24);
				case 24:
					if (n.extra) {
						for (k = n.extra; c < k; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						(n.offset += u & ((1 << n.extra) - 1)), (u >>>= n.extra), (c -= n.extra), (n.back += n.extra);
					}
					if (n.offset > n.dmax) {
						(e.msg = "invalid distance too far back"), (n.mode = 30);
						break;
					}
					n.mode = 25;
				case 25:
					if (0 === l) break e;
					if (((p = d - l), n.offset > p)) {
						if (((p = n.offset - p), p > n.whave && n.sane)) {
							(e.msg = "invalid distance too far back"), (n.mode = 30);
							break;
						}
						p > n.wnext ? ((p -= n.wnext), (f = n.wsize - p)) : (f = n.wnext - p), p > n.length && (p = n.length), (m = n.window);
					} else (m = i), (f = o - n.offset), (p = n.length);
					p > l && (p = l), (l -= p), (n.length -= p);
					do {
						i[o++] = m[f++];
					} while (--p);
					0 === n.length && (n.mode = 21);
					break;
				case 26:
					if (0 === l) break e;
					(i[o++] = n.length), l--, (n.mode = 21);
					break;
				case 27:
					if (n.wrap) {
						for (; c < 32; ) {
							if (0 === a) break e;
							a--, (u |= r[s++] << c), (c += 8);
						}
						if (((d -= l), (e.total_out += d), (n.total += d), d && (e.adler = n.check = n.flags ? tA(n.check, i, d, o - d) : Qk(n.check, i, d, o - d)), (d = l), (n.flags ? u : LM(u)) !== n.check)) {
							(e.msg = "incorrect data check"), (n.mode = 30);
							break;
						}
						(u = 0), (c = 0);
					}
					n.mode = 28;
				case 28:
					if (n.wrap && n.flags) {
						for (; c < 32; ) {
							if (0 === a) break e;
							a--, (u += r[s++] << c), (c += 8);
						}
						if (u !== (4294967295 & n.total)) {
							(e.msg = "incorrect length check"), (n.mode = 30);
							break;
						}
						(u = 0), (c = 0);
					}
					n.mode = 29;
				case 29:
					C = EM;
					break e;
				case 30:
					C = AM;
					break e;
				case 31:
					return MM;
				case 32:
				default:
					return kM;
			}
		return (
			(e.next_out = o),
			(e.avail_out = l),
			(e.next_in = s),
			(e.avail_in = a),
			(n.hold = u),
			(n.bits = c),
			(n.wsize || (d !== e.avail_out && n.mode < 30 && (n.mode < 27 || t !== _M))) && zM(e, e.output, e.next_out, d - e.avail_out),
			(h -= e.avail_in),
			(d -= e.avail_out),
			(e.total_in += h),
			(e.total_out += d),
			(n.total += d),
			n.wrap && d && (e.adler = n.check = n.flags ? tA(n.check, i, d, e.next_out - d) : Qk(n.check, i, d, e.next_out - d)),
			(e.data_type = n.bits + (n.last ? 64 : 0) + (12 === n.mode ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0)),
			((0 === h && 0 === d) || t === _M) && C === SM && (C = IM),
			C
		);
	},
	inflateEnd: (e) => {
		if (!e || !e.state) return kM;
		let t = e.state;
		return t.window && (t.window = null), (e.state = null), SM;
	},
	inflateGetHeader: (e, t) => {
		if (!e || !e.state) return kM;
		const n = e.state;
		return 0 == (2 & n.wrap) ? kM : ((n.head = t), (t.done = !1), SM);
	},
	inflateSetDictionary: (e, t) => {
		const n = t.length;
		let r, i, s;
		return e && e.state ? ((r = e.state), 0 !== r.wrap && 11 !== r.mode ? kM : 11 === r.mode && ((i = 1), (i = Qk(i, t, n, 0)), i !== r.check) ? AM : ((s = zM(e, t, n, n)), s ? ((r.mode = 31), MM) : ((r.havedict = 1), SM))) : kM;
	},
	inflateInfo: "pako inflate (from Nodeca project)"
};
var jM = function () {
	(this.text = 0), (this.time = 0), (this.xflags = 0), (this.os = 0), (this.extra = null), (this.extra_len = 0), (this.name = ""), (this.comment = ""), (this.hcrc = 0), (this.done = !1);
};
const WM = Object.prototype.toString,
	{ Z_NO_FLUSH: GM, Z_FINISH: YM, Z_OK: XM, Z_STREAM_END: KM, Z_NEED_DICT: qM, Z_STREAM_ERROR: ZM, Z_DATA_ERROR: JM, Z_MEM_ERROR: QM } = rA;
function eI(e) {
	this.options = XA({ chunkSize: 65536, windowBits: 15, to: "" }, e || {});
	const t = this.options;
	t.raw && t.windowBits >= 0 && t.windowBits < 16 && ((t.windowBits = -t.windowBits), 0 === t.windowBits && (t.windowBits = -15)),
		!(t.windowBits >= 0 && t.windowBits < 16) || (e && e.windowBits) || (t.windowBits += 32),
		t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15),
		(this.err = 0),
		(this.msg = ""),
		(this.ended = !1),
		(this.chunks = []),
		(this.strm = new tM()),
		(this.strm.avail_out = 0);
	let n = $M.inflateInit2(this.strm, t.windowBits);
	if (n !== XM) throw new Error(nA[n]);
	if (
		((this.header = new jM()),
		$M.inflateGetHeader(this.strm, this.header),
		t.dictionary && ("string" == typeof t.dictionary ? (t.dictionary = JA(t.dictionary)) : "[object ArrayBuffer]" === WM.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && ((n = $M.inflateSetDictionary(this.strm, t.dictionary)), n !== XM)))
	)
		throw new Error(nA[n]);
}
function tI(e, t) {
	const n = new eI(t);
	if ((n.push(e), n.err)) throw n.msg || nA[n.err];
	return n.result;
}
(eI.prototype.push = function (e, t) {
	const n = this.strm,
		r = this.options.chunkSize,
		i = this.options.dictionary;
	let s, o, a;
	if (this.ended) return !1;
	for (o = t === ~~t ? t : !0 === t ? YM : GM, "[object ArrayBuffer]" === WM.call(e) ? (n.input = new Uint8Array(e)) : (n.input = e), n.next_in = 0, n.avail_in = n.input.length; ; ) {
		for (
			0 === n.avail_out && ((n.output = new Uint8Array(r)), (n.next_out = 0), (n.avail_out = r)), s = $M.inflate(n, o), s === qM && i && ((s = $M.inflateSetDictionary(n, i)), s === XM ? (s = $M.inflate(n, o)) : s === JM && (s = qM));
			n.avail_in > 0 && s === KM && n.state.wrap > 0 && 0 !== e[n.next_in];

		)
			$M.inflateReset(n), (s = $M.inflate(n, o));
		switch (s) {
			case ZM:
			case JM:
			case qM:
			case QM:
				return this.onEnd(s), (this.ended = !0), !1;
		}
		if (((a = n.avail_out), n.next_out && (0 === n.avail_out || s === KM)))
			if ("string" === this.options.to) {
				let e = eM(n.output, n.next_out),
					t = n.next_out - e,
					i = QA(n.output, e);
				(n.next_out = t), (n.avail_out = r - t), t && n.output.set(n.output.subarray(e, e + t), 0), this.onData(i);
			} else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
		if (s !== XM || 0 !== a) {
			if (s === KM) return (s = $M.inflateEnd(this.strm)), this.onEnd(s), (this.ended = !0), !0;
			if (0 === n.avail_in) break;
		}
	}
	return !0;
}),
	(eI.prototype.onData = function (e) {
		this.chunks.push(e);
	}),
	(eI.prototype.onEnd = function (e) {
		e === XM && ("string" === this.options.to ? (this.result = this.chunks.join("")) : (this.result = KA(this.chunks))), (this.chunks = []), (this.err = e), (this.msg = this.strm.msg);
	});
var nI = {
	Inflate: eI,
	inflate: tI,
	inflateRaw: function (e, t) {
		return ((t = t || {}).raw = !0), tI(e, t);
	},
	ungzip: tI,
	constants: rA
};
const { Deflate: rI, deflate: iI, deflateRaw: sI, gzip: oI } = fM,
	{ Inflate: aI, inflate: lI, inflateRaw: uI, ungzip: cI } = nI;
var hI = rI,
	dI = iI,
	pI = sI,
	fI = oI,
	mI = aI,
	vI = lI,
	gI = uI,
	yI = cI,
	bI = rA,
	xI = { Deflate: hI, deflate: dI, deflateRaw: pI, gzip: fI, Inflate: mI, inflate: vI, inflateRaw: gI, ungzip: yI, constants: bI },
	_I = Object.freeze(Object.defineProperty({ __proto__: null, default: xI, Deflate: hI, Inflate: mI, constants: bI, deflate: dI, deflateRaw: pI, gzip: fI, inflate: vI, inflateRaw: gI, ungzip: yI }, Symbol.toStringTag, { value: "Module" })),
	wI = { exports: {} };
function CI() {}
(CI.prototype = {
	on: function (e, t, n) {
		var r = this.e || (this.e = {});
		return (r[e] || (r[e] = [])).push({ fn: t, ctx: n }), this;
	},
	once: function (e, t, n) {
		var r = this;
		function i() {
			r.off(e, i), t.apply(n, arguments);
		}
		return (i._ = t), this.on(e, i, n);
	},
	emit: function (e) {
		for (var t = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[e] || []).slice(), r = 0, i = n.length; r < i; r++) n[r].fn.apply(n[r].ctx, t);
		return this;
	},
	off: function (e, t) {
		var n = this.e || (this.e = {}),
			r = n[e],
			i = [];
		if (r && t) for (var s = 0, o = r.length; s < o; s++) r[s].fn !== t && r[s].fn._ !== t && i.push(r[s]);
		return i.length ? (n[e] = i) : delete n[e], this;
	}
}),
	(wI.exports = CI);
var SI = (wI.exports.TinyEmitter = CI);
const EI = (e) =>
		Array.from(e.querySelectorAll('a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])')).filter(
			(e) => TI(e) && ((e) => "fixed" !== getComputedStyle(e).position && null !== e.offsetParent)(e)
		),
	TI = (e) => {
		if (e.tabIndex > 0 || (0 === e.tabIndex && null !== e.getAttribute("tabIndex"))) return !0;
		if (e.disabled) return !1;
		switch (e.nodeName) {
			case "A":
				return !!e.href && "ignore" !== e.rel;
			case "INPUT":
				return !("hidden" === e.type || "file" === e.type);
			case "BUTTON":
			case "SELECT":
			case "TEXTAREA":
				return !0;
			default:
				return !1;
		}
	},
	kI = function (e, t, ...n) {
		let r;
		r = t.includes("mouse") || t.includes("click") ? "MouseEvents" : t.includes("key") ? "KeyboardEvent" : "HTMLEvents";
		const i = document.createEvent(r);
		return i.initEvent(t, ...n), e.dispatchEvent(i), e;
	},
	AI = (e) => !e.getAttribute("aria-owns"),
	MI = (e, t, n) => {
		const { parentNode: r } = e;
		if (!r) return null;
		const i = r.querySelectorAll(n);
		return i[Array.prototype.indexOf.call(i, e) + t] || null;
	},
	II = (e) => {
		e && (e.focus(), !AI(e) && e.click());
	},
	RI = (e, t, n, r = !1) => {
		e && t && n && (null == e || e.addEventListener(t, n, r));
	},
	LI = (e, t, n, r = !1) => {
		e && t && n && (null == e || e.removeEventListener(t, n, r));
	},
	OI = (e, t, n) => {
		const r = function (...i) {
			n && n.apply(this, i), LI(e, t, r);
		};
		RI(e, t, r);
	},
	PI =
		(e, t, { checkForDefaultPrevented: n = !0 } = {}) =>
		(r) => {
			const i = null == e ? void 0 : e(r);
			if (!1 === n || !i) return null == t ? void 0 : t(r);
		},
	NI = (e) => (t) => "mouse" === t.pointerType ? e(t) : void 0;
var DI,
	BI = Object.defineProperty,
	FI = Object.defineProperties,
	HI = Object.getOwnPropertyDescriptors,
	VI = Object.getOwnPropertySymbols,
	UI = Object.prototype.hasOwnProperty,
	zI = Object.prototype.propertyIsEnumerable,
	$I = (e, t, n) => (t in e ? BI(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n));
function jI(e, t) {
	var n;
	const r = et();
	var i, s;
	return (
		cs(
			() => {
				r.value = e();
			},
			((i = ((e, t) => {
				for (var n in t || (t = {})) UI.call(t, n) && $I(e, n, t[n]);
				if (VI) for (var n of VI(t)) zI.call(t, n) && $I(e, n, t[n]);
				return e;
			})({}, t)),
			(s = { flush: null != (n = null == t ? void 0 : t.flush) ? n : "sync" }),
			FI(i, HI(s)))
		),
		Ve(r)
	);
}
function WI(e) {
	return !!A() && (M(e), !0);
}
const GI = "undefined" != typeof window,
	YI = (e) => "boolean" == typeof e,
	XI = (e) => "number" == typeof e,
	KI = () => {};
function qI(e, t) {
	return function (...n) {
		e(() => t.apply(this, n), { fn: t, thisArg: this, args: n });
	};
}
function ZI(e, t = 200, n = {}) {
	return qI(
		(function (e, t = {}) {
			let n, r;
			return (i) => {
				const s = it(e),
					o = it(t.maxWait);
				if ((n && clearTimeout(n), s <= 0 || (void 0 !== o && o <= 0))) return r && (clearTimeout(r), (r = null)), i();
				o &&
					!r &&
					(r = setTimeout(() => {
						n && clearTimeout(n), (r = null), i();
					}, o)),
					(n = setTimeout(() => {
						r && clearTimeout(r), (r = null), i();
					}, s));
			};
		})(t, n),
		e
	);
}
function JI(e, t = 200, n = !0, r = !0) {
	return qI(
		(function (e, t = !0, n = !0) {
			let r,
				i = 0,
				s = !0;
			const o = () => {
				r && (clearTimeout(r), (r = void 0));
			};
			return (a) => {
				const l = it(e),
					u = Date.now() - i;
				if ((o(), l <= 0)) return (i = Date.now()), a();
				u > l && (n || !s)
					? ((i = Date.now()), a())
					: t &&
					  (r = setTimeout(() => {
							(i = Date.now()), (s = !0), o(), a();
					  }, l)),
					n || r || (r = setTimeout(() => (s = !0), l)),
					(s = !1);
			};
		})(t, n, r),
		e
	);
}
function QI(e, t = !0) {
	Si() ? Vn(e) : t ? e() : ns(e);
}
function eR(e, t, n = {}) {
	const { immediate: r = !0 } = n,
		i = Qe(!1);
	let s = null;
	function o() {
		s && (clearTimeout(s), (s = null));
	}
	function a() {
		(i.value = !1), o();
	}
	function l(...n) {
		o(),
			(i.value = !0),
			(s = setTimeout(() => {
				(i.value = !1), (s = null), e(...n);
			}, it(t)));
	}
	return r && ((i.value = !0), GI && l()), WI(a), { isPending: i, start: l, stop: a };
}
function tR(e) {
	var t;
	const n = it(e);
	return null != (t = null == n ? void 0 : n.$el) ? t : n;
}
GI && (null == (DI = null == window ? void 0 : window.navigator) ? void 0 : DI.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const nR = GI ? window : void 0,
	rR = GI ? window.document : void 0;
function iR(...e) {
	let t, n, r, i;
	if (("string" == typeof e[0] ? (([n, r, i] = e), (t = nR)) : ([t, n, r, i] = e), !t)) return KI;
	let s = KI;
	const o = ds(
			() => tR(t),
			(e) => {
				s(),
					e &&
						(e.addEventListener(n, r, i),
						(s = () => {
							e.removeEventListener(n, r, i), (s = KI);
						}));
			},
			{ immediate: !0, flush: "post" }
		),
		a = () => {
			o(), s();
		};
	return WI(a), a;
}
function sR(e, t, n = {}) {
	const { window: r = nR, ignore: i, capture: s = !0 } = n;
	if (!r) return;
	const o = Qe(!0);
	let a;
	const l = (n) => {
			r.clearTimeout(a);
			const s = tR(e),
				l = n.composedPath();
			s &&
				s !== n.target &&
				!l.includes(s) &&
				o.value &&
				((i &&
					i.length > 0 &&
					i.some((e) => {
						const t = tR(e);
						return t && (n.target === t || l.includes(t));
					})) ||
					t(n));
		},
		u = [
			iR(r, "click", l, { passive: !0, capture: s }),
			iR(
				r,
				"pointerdown",
				(t) => {
					const n = tR(e);
					o.value = !!n && !t.composedPath().includes(n);
				},
				{ passive: !0 }
			),
			iR(
				r,
				"pointerup",
				(e) => {
					a = r.setTimeout(() => l(e), 50);
				},
				{ passive: !0 }
			)
		];
	return () => u.forEach((e) => e());
}
const oR = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
	aR = "__vueuse_ssr_handlers__";
(oR[aR] = oR[aR] || {}), oR[aR];
var lR,
	uR,
	cR = Object.getOwnPropertySymbols,
	hR = Object.prototype.hasOwnProperty,
	dR = Object.prototype.propertyIsEnumerable;
function pR(e, t, n = {}) {
	const r = n,
		{ window: i = nR } = r,
		s = ((e, t) => {
			var n = {};
			for (var r in e) hR.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
			if (null != e && cR) for (var r of cR(e)) t.indexOf(r) < 0 && dR.call(e, r) && (n[r] = e[r]);
			return n;
		})(r, ["window"]);
	let o;
	const a = i && "ResizeObserver" in i,
		l = () => {
			o && (o.disconnect(), (o = void 0));
		},
		u = ds(
			() => tR(e),
			(e) => {
				l(), a && i && e && ((o = new ResizeObserver(t)), o.observe(e, s));
			},
			{ immediate: !0, flush: "post" }
		),
		c = () => {
			l(), u();
		};
	return WI(c), { isSupported: a, stop: c };
}
function fR(e, t = {}) {
	const { reset: n = !0, windowResize: r = !0, windowScroll: i = !0, immediate: s = !0 } = t,
		o = Qe(0),
		a = Qe(0),
		l = Qe(0),
		u = Qe(0),
		c = Qe(0),
		h = Qe(0),
		d = Qe(0),
		p = Qe(0);
	function f() {
		const t = tR(e);
		if (!t) return void (n && ((o.value = 0), (a.value = 0), (l.value = 0), (u.value = 0), (c.value = 0), (h.value = 0), (d.value = 0), (p.value = 0)));
		const r = t.getBoundingClientRect();
		(o.value = r.height), (a.value = r.bottom), (l.value = r.left), (u.value = r.right), (c.value = r.top), (h.value = r.width), (d.value = r.x), (p.value = r.y);
	}
	return (
		pR(e, f),
		ds(
			() => tR(e),
			(e) => !e && f()
		),
		i && iR("scroll", f, { passive: !0 }),
		r && iR("resize", f, { passive: !0 }),
		QI(() => {
			s && f();
		}),
		{ height: o, bottom: a, left: l, right: u, top: c, width: h, x: d, y: p, update: f }
	);
}
((uR = lR || (lR = {})).UP = "UP"), (uR.RIGHT = "RIGHT"), (uR.DOWN = "DOWN"), (uR.LEFT = "LEFT"), (uR.NONE = "NONE");
const mR = (e) => {
		let t = 0,
			n = e;
		for (; n; ) (t += n.offsetTop), (n = n.offsetParent);
		return t;
	},
	vR = (e) => {
		let t, n;
		return "touchend" === e.type ? ((n = e.changedTouches[0].clientY), (t = e.changedTouches[0].clientX)) : e.type.startsWith("touch") ? ((n = e.touches[0].clientY), (t = e.touches[0].clientX)) : ((n = e.clientY), (t = e.clientX)), { clientX: t, clientY: n };
	},
	gR = function (e) {
		for (const t of e) {
			const e = t.target.__resizeListeners__ || [];
			e.length &&
				e.forEach((e) => {
					e();
				});
		}
	},
	yR = () => {},
	bR = Object.prototype.hasOwnProperty,
	xR = (e, t) => bR.call(e, t),
	_R = Array.isArray,
	wR = (e) => "[object Date]" === AR(e),
	CR = (e) => "function" == typeof e,
	SR = (e) => "string" == typeof e,
	ER = (e) => null !== e && "object" == typeof e,
	TR = (e) => ER(e) && CR(e.then) && CR(e.catch),
	kR = Object.prototype.toString,
	AR = (e) => kR.call(e),
	MR = (e) => AR(e).slice(8, -1),
	IR = (e) => "[object Object]" === AR(e),
	RR = (e) => {
		const t = Object.create(null);
		return (n) => t[n] || (t[n] = e(n));
	},
	LR = /-(\w)/g,
	OR = RR((e) => e.replace(LR, (e, t) => (t ? t.toUpperCase() : ""))),
	PR = /\B([A-Z])/g,
	NR = RR((e) => e.replace(PR, "-$1").toLowerCase()),
	DR = RR((e) => e.charAt(0).toUpperCase() + e.slice(1)),
	BR = (e) => void 0 === e,
	FR = (e) => (!e && 0 !== e) || (_R(e) && 0 === e.length) || (ER(e) && !Object.keys(e).length),
	HR = (e) => "undefined" != typeof Element && e instanceof Element,
	VR = (e) => Object.keys(e),
	UR = (e, t, n) => ({
		get value() {
			return XS(e, t, n);
		},
		set value(n) {
			!(function (e, t, n) {
				null == e || sk(e, t, n);
			})(e, t, n);
		}
	});
class zR extends Error {
	constructor(e) {
		super(e), (this.name = "ElementPlusError");
	}
}
function $R(e, t) {
	throw new zR(`[${e}] ${t}`);
}
const jR = (e = "") => e.split(" ").filter((e) => !!e.trim()),
	WR = (e, t) => {
		if (!e || !t) return !1;
		if (t.includes(" ")) throw new Error("className should not contain space.");
		return e.classList.contains(t);
	},
	GR = (e, t) => {
		e && t.trim() && e.classList.add(...jR(t));
	},
	YR = (e, t) => {
		e && t.trim() && e.classList.remove(...jR(t));
	},
	XR = (e, t) => {
		var n;
		if (!GI || !e || !t) return "";
		let r = OR(t);
		"float" === r && (r = "cssFloat");
		try {
			const t = e.style[r];
			if (t) return t;
			const i = null == (n = document.defaultView) ? void 0 : n.getComputedStyle(e, "");
			return i ? i[r] : "";
		} catch (Kj) {
			return e.style[r];
		}
	};
function KR(e, t = "px") {
	return e ? (SR(e) ? e : XI(e) ? `${e}${t}` : void 0) : "";
}
const qR = (e, t) => {
		if (!GI) return !1;
		const n = { undefined: "overflow", true: "overflow-y", false: "overflow-x" }[String(t)],
			r = XR(e, n);
		return ["scroll", "auto", "overlay"].some((e) => r.includes(e));
	},
	ZR = (e, t) => {
		if (!GI) return;
		let n = e;
		for (; n; ) {
			if ([window, document, document.documentElement].includes(n)) return window;
			if (qR(n, t)) return n;
			n = n.parentNode;
		}
		return n;
	};
let JR;
const QR = () => {
	var e;
	if (!GI) return 0;
	if (void 0 !== JR) return JR;
	const t = document.createElement("div");
	(t.className = "el-scrollbar__wrap"), (t.style.visibility = "hidden"), (t.style.width = "100px"), (t.style.position = "absolute"), (t.style.top = "-9999px"), document.body.appendChild(t);
	const n = t.offsetWidth;
	t.style.overflow = "scroll";
	const r = document.createElement("div");
	(r.style.width = "100%"), t.appendChild(r);
	const i = r.offsetWidth;
	return null == (e = t.parentNode) || e.removeChild(t), (JR = n - i), JR;
};
function eL(e, t) {
	if (!GI) return;
	if (!t) return void (e.scrollTop = 0);
	const n = [];
	let r = t.offsetParent;
	for (; null !== r && e !== r && e.contains(r); ) n.push(r), (r = r.offsetParent);
	const i = t.offsetTop + n.reduce((e, t) => e + t.offsetTop, 0),
		s = i + t.offsetHeight,
		o = e.scrollTop,
		a = o + e.clientHeight;
	i < o ? (e.scrollTop = i) : s > a && (e.scrollTop = s - e.clientHeight);
}
/*! Element Plus Icons Vue v2.0.5 */ var tL = (e, t) => {
		let n = e.__vccOpts || e;
		for (let [r, i] of t) n[r] = i;
		return n;
	},
	nL = { name: "ArrowDown" },
	rL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	iL = [ni("path", { fill: "currentColor", d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z" }, null, -1)];
var sL = tL(nL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", rL, iL);
			}
		],
		["__file", "arrow-down.vue"]
	]),
	oL = { name: "ArrowLeft" },
	aL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	lL = [ni("path", { fill: "currentColor", d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z" }, null, -1)];
var uL = tL(oL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", aL, lL);
			}
		],
		["__file", "arrow-left.vue"]
	]),
	cL = { name: "ArrowRight" },
	hL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	dL = [ni("path", { fill: "currentColor", d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z" }, null, -1)];
var pL = tL(cL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", hL, dL);
			}
		],
		["__file", "arrow-right.vue"]
	]),
	fL = { name: "ArrowUp" },
	mL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	vL = [ni("path", { fill: "currentColor", d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z" }, null, -1)];
var gL = tL(fL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", mL, vL);
			}
		],
		["__file", "arrow-up.vue"]
	]),
	yL = { name: "Back" },
	bL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	xL = [
		ni("path", { fill: "currentColor", d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z" }, null, -1),
		ni("path", { fill: "currentColor", d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z" }, null, -1)
	];
var _L = tL(yL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", bL, xL);
			}
		],
		["__file", "back.vue"]
	]),
	wL = { name: "Calendar" },
	CL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	SL = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
			},
			null,
			-1
		)
	];
var EL = tL(wL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", CL, SL);
			}
		],
		["__file", "calendar.vue"]
	]),
	TL = { name: "CaretRight" },
	kL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	AL = [ni("path", { fill: "currentColor", d: "M384 192v640l384-320.064z" }, null, -1)];
var ML = tL(TL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", kL, AL);
			}
		],
		["__file", "caret-right.vue"]
	]),
	IL = { name: "CaretTop" },
	RL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	LL = [ni("path", { fill: "currentColor", d: "M512 320 192 704h639.936z" }, null, -1)];
var OL = tL(IL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", RL, LL);
			}
		],
		["__file", "caret-top.vue"]
	]),
	PL = { name: "Check" },
	NL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	DL = [ni("path", { fill: "currentColor", d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z" }, null, -1)];
var BL = tL(PL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", NL, DL);
			}
		],
		["__file", "check.vue"]
	]),
	FL = { name: "CircleCheckFilled" },
	HL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	VL = [ni("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z" }, null, -1)];
var UL = tL(FL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", HL, VL);
			}
		],
		["__file", "circle-check-filled.vue"]
	]),
	zL = { name: "CircleCheck" },
	$L = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	jL = [
		ni("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1),
		ni("path", { fill: "currentColor", d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z" }, null, -1)
	];
var WL = tL(zL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", $L, jL);
			}
		],
		["__file", "circle-check.vue"]
	]),
	GL = { name: "CircleCloseFilled" },
	YL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	XL = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
			},
			null,
			-1
		)
	];
var KL = tL(GL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", YL, XL);
			}
		],
		["__file", "circle-close-filled.vue"]
	]),
	qL = { name: "CircleClose" },
	ZL = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	JL = [
		ni("path", { fill: "currentColor", d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z" }, null, -1),
		ni("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1)
	];
var QL = tL(qL, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", ZL, JL);
			}
		],
		["__file", "circle-close.vue"]
	]),
	eO = { name: "Clock" },
	tO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	nO = [
		ni("path", { fill: "currentColor", d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z" }, null, -1),
		ni("path", { fill: "currentColor", d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z" }, null, -1),
		ni("path", { fill: "currentColor", d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z" }, null, -1)
	];
var rO = tL(eO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", tO, nO);
			}
		],
		["__file", "clock.vue"]
	]),
	iO = { name: "Close" },
	sO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	oO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
			},
			null,
			-1
		)
	];
var aO = tL(iO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", sO, oO);
			}
		],
		["__file", "close.vue"]
	]),
	lO = { name: "DArrowLeft" },
	uO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	cO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
			},
			null,
			-1
		)
	];
var hO = tL(lO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", uO, cO);
			}
		],
		["__file", "d-arrow-left.vue"]
	]),
	dO = { name: "DArrowRight" },
	pO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	fO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
			},
			null,
			-1
		)
	];
var mO = tL(dO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", pO, fO);
			}
		],
		["__file", "d-arrow-right.vue"]
	]),
	vO = { name: "Delete" },
	gO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	yO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
			},
			null,
			-1
		)
	];
var bO = tL(vO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", gO, yO);
			}
		],
		["__file", "delete.vue"]
	]),
	xO = { name: "Document" },
	_O = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	wO = [ni("path", { fill: "currentColor", d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z" }, null, -1)];
var CO = tL(xO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", _O, wO);
			}
		],
		["__file", "document.vue"]
	]),
	SO = { name: "FullScreen" },
	EO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	TO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
			},
			null,
			-1
		)
	];
var kO = tL(SO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", EO, TO);
			}
		],
		["__file", "full-screen.vue"]
	]),
	AO = { name: "Hide" },
	MO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	IO = [
		ni(
			"path",
			{
				d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
				fill: "currentColor"
			},
			null,
			-1
		),
		ni("path", { d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z", fill: "currentColor" }, null, -1)
	];
var RO = tL(AO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", MO, IO);
			}
		],
		["__file", "hide.vue"]
	]),
	LO = { name: "InfoFilled" },
	OO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	PO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
			},
			null,
			-1
		)
	];
var NO = tL(LO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", OO, PO);
			}
		],
		["__file", "info-filled.vue"]
	]),
	DO = { name: "Loading" },
	BO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	FO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
			},
			null,
			-1
		)
	];
var HO = tL(DO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", BO, FO);
			}
		],
		["__file", "loading.vue"]
	]),
	VO = { name: "Minus" },
	UO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	zO = [ni("path", { fill: "currentColor", d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z" }, null, -1)];
var $O = tL(VO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", UO, zO);
			}
		],
		["__file", "minus.vue"]
	]),
	jO = { name: "MoreFilled" },
	WO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	GO = [ni("path", { fill: "currentColor", d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z" }, null, -1)];
var YO = tL(jO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", WO, GO);
			}
		],
		["__file", "more-filled.vue"]
	]),
	XO = { name: "More" },
	KO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	qO = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
			},
			null,
			-1
		)
	];
var ZO = tL(XO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", KO, qO);
			}
		],
		["__file", "more.vue"]
	]),
	JO = { name: "PictureFilled" },
	QO = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	eP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"
			},
			null,
			-1
		)
	];
var tP = tL(JO, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", QO, eP);
			}
		],
		["__file", "picture-filled.vue"]
	]),
	nP = { name: "Plus" },
	rP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	iP = [ni("path", { fill: "currentColor", d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z" }, null, -1)];
var sP = tL(nP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", rP, iP);
			}
		],
		["__file", "plus.vue"]
	]),
	oP = { name: "QuestionFilled" },
	aP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	lP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
			},
			null,
			-1
		)
	];
var uP = tL(oP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", aP, lP);
			}
		],
		["__file", "question-filled.vue"]
	]),
	cP = { name: "RefreshLeft" },
	hP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	dP = [ni("path", { fill: "currentColor", d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z" }, null, -1)];
var pP = tL(cP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", hP, dP);
			}
		],
		["__file", "refresh-left.vue"]
	]),
	fP = { name: "RefreshRight" },
	mP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	vP = [ni("path", { fill: "currentColor", d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z" }, null, -1)];
var gP = tL(fP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", mP, vP);
			}
		],
		["__file", "refresh-right.vue"]
	]),
	yP = { name: "ScaleToOriginal" },
	bP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	xP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
			},
			null,
			-1
		)
	];
var _P = tL(yP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", bP, xP);
			}
		],
		["__file", "scale-to-original.vue"]
	]),
	wP = { name: "Search" },
	CP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	SP = [ni("path", { fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z" }, null, -1)];
var EP = tL(wP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", CP, SP);
			}
		],
		["__file", "search.vue"]
	]),
	TP = { name: "SortDown" },
	kP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	AP = [ni("path", { fill: "currentColor", d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z" }, null, -1)];
var MP = tL(TP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", kP, AP);
			}
		],
		["__file", "sort-down.vue"]
	]),
	IP = { name: "SortUp" },
	RP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	LP = [ni("path", { fill: "currentColor", d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z" }, null, -1)];
var OP = tL(IP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", RP, LP);
			}
		],
		["__file", "sort-up.vue"]
	]),
	PP = { name: "StarFilled" },
	NP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	DP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
			},
			null,
			-1
		)
	];
var BP = tL(PP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", NP, DP);
			}
		],
		["__file", "star-filled.vue"]
	]),
	FP = { name: "Star" },
	HP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	VP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
			},
			null,
			-1
		)
	];
var UP = tL(FP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", HP, VP);
			}
		],
		["__file", "star.vue"]
	]),
	zP = { name: "SuccessFilled" },
	$P = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	jP = [ni("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z" }, null, -1)];
var WP = tL(zP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", $P, jP);
			}
		],
		["__file", "success-filled.vue"]
	]),
	GP = { name: "View" },
	YP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	XP = [
		ni(
			"path",
			{
				fill: "currentColor",
				d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
			},
			null,
			-1
		)
	];
var KP = tL(GP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", YP, XP);
			}
		],
		["__file", "view.vue"]
	]),
	qP = { name: "WarningFilled" },
	ZP = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	JP = [ni("path", { fill: "currentColor", d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z" }, null, -1)];
var QP = tL(qP, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", ZP, JP);
			}
		],
		["__file", "warning-filled.vue"]
	]),
	eN = { name: "ZoomIn" },
	tN = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	nN = [
		ni(
			"path",
			{ fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z" },
			null,
			-1
		)
	];
var rN = tL(eN, [
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("svg", tN, nN);
			}
		],
		["__file", "zoom-in.vue"]
	]),
	iN = { name: "ZoomOut" },
	sN = { viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg" },
	oN = [ni("path", { fill: "currentColor", d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z" }, null, -1)];
var aN = tL(iN, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return Wr(), Kr("svg", sN, oN);
		}
	],
	["__file", "zoom-out.vue"]
]);
const lN = (e, t) => {
		if (!ER(e) || (ER((n = e)) && n.__epPropKey)) return e;
		var n;
		const { values: r, required: i, default: s, type: o, validator: a } = e,
			l = {
				type: o,
				required: !!i,
				validator:
					r || a
						? (n) => {
								let i = !1,
									o = [];
								if ((r && ((o = Array.from(r)), xR(e, "default") && o.push(s), i || (i = o.includes(n))), a && (i || (i = a(n))), !i && o.length > 0)) {
									const e = [...new Set(o)].map((e) => JSON.stringify(e)).join(", ");
									Bi(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${e}], got value ${JSON.stringify(n)}.`);
								}
								return i;
						  }
						: void 0,
				__epPropKey: !0
			};
		return xR(e, "default") && (l.default = s), l;
	},
	uN = (e) => nk(Object.entries(e).map(([e, t]) => [e, lN(t, e)])),
	cN = [String, Object, Function],
	hN = { Close: aO },
	dN = { Close: aO, SuccessFilled: WP, InfoFilled: NO, WarningFilled: QP, CircleCloseFilled: KL },
	pN = { success: WP, warning: QP, error: KL, info: NO },
	fN = { validating: HO, success: WL, error: QL },
	mN = (e, t) => {
		if (
			((e.install = (n) => {
				for (const r of [e, ...Object.values(null != t ? t : {})]) n.component(r.name, r);
			}),
			t)
		)
			for (const [n, r] of Object.entries(t)) e[n] = r;
		return e;
	},
	vN = (e, t) => (
		(e.install = (n) => {
			(e._context = n._context), (n.config.globalProperties[t] = e);
		}),
		e
	),
	gN = (e) => ((e.install = yR), e),
	yN =
		(...e) =>
		(t) => {
			e.forEach((e) => {
				CR(e) ? e(t) : (e.value = t);
			});
		},
	bN = { tab: "Tab", enter: "Enter", space: "Space", left: "ArrowLeft", up: "ArrowUp", right: "ArrowRight", down: "ArrowDown", esc: "Escape", delete: "Delete", backspace: "Backspace", numpadEnter: "NumpadEnter", pageUp: "PageUp", pageDown: "PageDown", home: "Home", end: "End" },
	xN = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"],
	_N = "update:modelValue",
	wN = Symbol("INSTALLED_KEY"),
	CN = ["", "default", "small", "large"],
	SN = { large: 40, default: 32, small: 24 },
	EN = (e) => ["", ...CN].includes(e);
var TN = ((e) => (
	(e[(e.TEXT = 1)] = "TEXT"),
	(e[(e.CLASS = 2)] = "CLASS"),
	(e[(e.STYLE = 4)] = "STYLE"),
	(e[(e.PROPS = 8)] = "PROPS"),
	(e[(e.FULL_PROPS = 16)] = "FULL_PROPS"),
	(e[(e.HYDRATE_EVENTS = 32)] = "HYDRATE_EVENTS"),
	(e[(e.STABLE_FRAGMENT = 64)] = "STABLE_FRAGMENT"),
	(e[(e.KEYED_FRAGMENT = 128)] = "KEYED_FRAGMENT"),
	(e[(e.UNKEYED_FRAGMENT = 256)] = "UNKEYED_FRAGMENT"),
	(e[(e.NEED_PATCH = 512)] = "NEED_PATCH"),
	(e[(e.DYNAMIC_SLOTS = 1024)] = "DYNAMIC_SLOTS"),
	(e[(e.HOISTED = -1)] = "HOISTED"),
	(e[(e.BAIL = -2)] = "BAIL"),
	e
))(TN || {});
function kN(e) {
	return Zr(e) && e.type === Hr;
}
function AN(e) {
	return (
		Zr(e) &&
		!kN(e) &&
		!(function (e) {
			return Zr(e) && e.type === Ur;
		})(e)
	);
}
const MN = (e) => e ** 3,
	IN = (e) => [...new Set(e)],
	RN = (e) => (e || 0 === e ? (Array.isArray(e) ? e : [e]) : []),
	LN = () => GI && /firefox/i.test(window.navigator.userAgent),
	ON = (e) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(e),
	PN = (e) => (GI ? window.requestAnimationFrame(e) : setTimeout(e, 16)),
	NN = (e) => (GI ? window.cancelAnimationFrame(e) : clearTimeout(e)),
	DN = () => Math.floor(1e4 * Math.random()),
	BN = ["class", "style"],
	FN = /^on[A-Z]/,
	HN = (e = {}) => {
		const { excludeListeners: t = !1, excludeKeys: n } = e,
			r = ht(() => ((null == n ? void 0 : n.value) || []).concat(BN)),
			i = Si();
		return ht(
			i
				? () => {
						var e;
						return nk(Object.entries(null == (e = i.proxy) ? void 0 : e.$attrs).filter(([e]) => !(r.value.includes(e) || (t && FN.test(e)))));
				  }
				: () => ({})
		);
	},
	VN = Symbol("breadcrumbKey"),
	UN = Symbol("buttonGroupContextKey"),
	zN = Symbol("carouselContextKey"),
	$N = Symbol("collapseContextKey"),
	jN = Symbol(),
	WN = Symbol("dialogInjectionKey"),
	GN = Symbol("formContextKey"),
	YN = Symbol("formItemContextKey"),
	XN = Symbol("elPaginationKey"),
	KN = Symbol("radioGroupKey"),
	qN = Symbol("rowContextKey"),
	ZN = Symbol("scrollbarContextKey"),
	JN = Symbol("tabsRootContextKey"),
	QN = Symbol("uploadContextKey"),
	eD = Symbol("popper"),
	tD = Symbol("popperContent"),
	nD = Symbol("tooltipV2"),
	rD = Symbol("tooltipV2Content"),
	iD = Symbol(),
	sD = (e) => {
		const t = Si();
		return ht(() => {
			var n, r;
			return null != (r = (null == (n = t.proxy) ? void 0 : n.$props)[e]) ? r : void 0;
		});
	},
	oD = Qe();
function aD(e, t) {
	const n = Si() ? vn(jN, oD) : oD;
	return e
		? ht(() => {
				var r, i;
				return null != (i = null == (r = n.value) ? void 0 : r[e]) ? i : t;
		  })
		: n;
}
const lD = (e, t, n = !1) => {
		var r;
		const i = !!Si(),
			s = i ? aD() : void 0,
			o = null != (r = null == t ? void 0 : t.provide) ? r : i ? mn : void 0;
		if (!o) return;
		const a = ht(() => {
			const t = it(e);
			return (null == s ? void 0 : s.value) ? uD(s.value, t) : t;
		});
		return o(jN, a), (!n && oD.value) || (oD.value = a.value), a;
	},
	uD = (e, t) => {
		var n;
		const r = [...new Set([...VR(e), ...VR(t)])],
			i = {};
		for (const s of r) i[s] = null != (n = t[s]) ? n : e[s];
		return i;
	},
	cD = lN({ type: String, values: CN, required: !1 }),
	hD = (e, t = {}) => {
		const n = Qe(void 0),
			r = t.prop ? n : sD("size"),
			i = t.global ? n : aD("size"),
			s = t.form ? { size: void 0 } : vn(GN, void 0),
			o = t.formItem ? { size: void 0 } : vn(YN, void 0);
		return ht(() => r.value || it(e) || (null == o ? void 0 : o.size) || (null == s ? void 0 : s.size) || i.value || "");
	},
	dD = (e) => {
		const t = sD("disabled"),
			n = vn(GN, void 0);
		return ht(() => t.value || it(e) || (null == n ? void 0 : n.disabled) || !1);
	},
	pD = ({ from: e, replacement: t, scope: n, version: r, ref: i, type: s = "API" }, o) => {
		ds(
			() => it(o),
			(e) => {},
			{ immediate: !0 }
		);
	},
	fD = (e, t, n) => {
		let r = { offsetX: 0, offsetY: 0 };
		const i = (t) => {
				const n = t.clientX,
					i = t.clientY,
					{ offsetX: s, offsetY: o } = r,
					a = e.value.getBoundingClientRect(),
					l = a.left,
					u = a.top,
					c = a.width,
					h = a.height,
					d = document.documentElement.clientWidth,
					p = document.documentElement.clientHeight,
					f = -l + s,
					m = -u + o,
					v = d - l - c + s,
					g = p - u - h + o,
					y = (t) => {
						const a = Math.min(Math.max(s + t.clientX - n, f), v),
							l = Math.min(Math.max(o + t.clientY - i, m), g);
						(r = { offsetX: a, offsetY: l }), (e.value.style.transform = `translate(${KR(a)}, ${KR(l)})`);
					},
					b = () => {
						document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", b);
					};
				document.addEventListener("mousemove", y), document.addEventListener("mouseup", b);
			},
			s = () => {
				t.value && e.value && t.value.removeEventListener("mousedown", i);
			};
		Vn(() => {
			cs(() => {
				n.value ? t.value && e.value && t.value.addEventListener("mousedown", i) : s();
			});
		}),
			$n(() => {
				s();
			});
	},
	mD = { prefix: Math.floor(1e4 * Math.random()), current: 0 },
	vD = Symbol("elIdInjection"),
	gD = (e) => {
		const t = vn(vD, mD);
		return ht(() => it(e) || `el-id-${t.prefix}-${t.current++}`);
	},
	yD = () => ({ form: vn(GN, void 0), formItem: vn(YN, void 0) }),
	bD = (e, { formItemContext: t, disableIdGeneration: n, disableIdManagement: r }) => {
		n || (n = Qe(!1)), r || (r = Qe(!1));
		const i = Qe();
		let s;
		const o = ht(() => {
			var n;
			return !!(!e.label && t && t.inputIds && (null == (n = t.inputIds) ? void 0 : n.length) <= 1);
		});
		return (
			Vn(() => {
				s = ds(
					[ut(e, "id"), n],
					([e, n]) => {
						const s = null != e ? e : n ? void 0 : gD().value;
						s !== i.value && ((null == t ? void 0 : t.removeInputId) && (i.value && t.removeInputId(i.value), (null == r ? void 0 : r.value) || n || !s || t.addInputId(s)), (i.value = s));
					},
					{ immediate: !0 }
				);
			}),
			jn(() => {
				s && s(), (null == t ? void 0 : t.removeInputId) && i.value && t.removeInputId(i.value);
			}),
			{ isLabeledByFormItem: o, inputId: i }
		);
	};
var xD = {
	name: "en",
	el: {
		colorpicker: { confirm: "OK", clear: "Clear", defaultLabel: "color picker", description: "current color is {color}. press enter to select a new color." },
		datepicker: {
			now: "Now",
			today: "Today",
			cancel: "Cancel",
			clear: "Clear",
			confirm: "OK",
			dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
			monthTablePrompt: "Use the arrow keys and enter to select the month",
			yearTablePrompt: "Use the arrow keys and enter to select the year",
			selectedDate: "Selected date",
			selectDate: "Select date",
			selectTime: "Select time",
			startDate: "Start Date",
			startTime: "Start Time",
			endDate: "End Date",
			endTime: "End Time",
			prevYear: "Previous Year",
			nextYear: "Next Year",
			prevMonth: "Previous Month",
			nextMonth: "Next Month",
			year: "",
			month1: "January",
			month2: "February",
			month3: "March",
			month4: "April",
			month5: "May",
			month6: "June",
			month7: "July",
			month8: "August",
			month9: "September",
			month10: "October",
			month11: "November",
			month12: "December",
			week: "week",
			weeks: { sun: "Sun", mon: "Mon", tue: "Tue", wed: "Wed", thu: "Thu", fri: "Fri", sat: "Sat" },
			weeksFull: { sun: "Sunday", mon: "Monday", tue: "Tuesday", wed: "Wednesday", thu: "Thursday", fri: "Friday", sat: "Saturday" },
			months: { jan: "Jan", feb: "Feb", mar: "Mar", apr: "Apr", may: "May", jun: "Jun", jul: "Jul", aug: "Aug", sep: "Sep", oct: "Oct", nov: "Nov", dec: "Dec" }
		},
		inputNumber: { decrease: "decrease number", increase: "increase number" },
		select: { loading: "Loading", noMatch: "No matching data", noData: "No data", placeholder: "Select" },
		dropdown: { toggleDropdown: "Toggle Dropdown" },
		cascader: { noMatch: "No matching data", loading: "Loading", placeholder: "Select", noData: "No data" },
		pagination: { goto: "Go to", pagesize: "/page", total: "Total {total}", pageClassifier: "", deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details" },
		dialog: { close: "Close this dialog" },
		drawer: { close: "Close this dialog" },
		messagebox: { title: "Message", confirm: "OK", cancel: "Cancel", error: "Illegal input", close: "Close this dialog" },
		upload: { deleteTip: "press delete to remove", delete: "Delete", preview: "Preview", continue: "Continue" },
		slider: { defaultLabel: "slider between {min} and {max}", defaultRangeStartLabel: "pick start value", defaultRangeEndLabel: "pick end value" },
		table: { emptyText: "No Data", confirmFilter: "Confirm", resetFilter: "Reset", clearFilter: "All", sumText: "Sum" },
		tree: { emptyText: "No Data" },
		transfer: { noMatch: "No matching data", noData: "No data", titles: ["List 1", "List 2"], filterPlaceholder: "Enter keyword", noCheckedFormat: "{total} items", hasCheckedFormat: "{checked}/{total} checked" },
		image: { error: "FAILED" },
		pageHeader: { title: "Back" },
		popconfirm: { confirmButtonText: "Yes", cancelButtonText: "No" }
	}
};
const _D = (e) => (t, n) => wD(t, n, it(e)),
	wD = (e, t, n) =>
		XS(n, e, e).replace(/\{(\w+)\}/g, (e, n) => {
			var r;
			return `${null != (r = null == t ? void 0 : t[n]) ? r : `{${n}}`}`;
		}),
	CD = () => {
		const e = aD("locale");
		return ((e) => ({ lang: ht(() => it(e).name), locale: Je(e) ? e : Qe(e), t: _D(e) }))(ht(() => e.value || xD));
	},
	SD = (e) => {
		if ((Je(e) || $R("[useLockscreen]", "You need to pass a ref param to this function"), !GI || WR(document.body, "el-popup-parent--hidden"))) return;
		let t = 0,
			n = !1,
			r = "0",
			i = 0;
		const s = () => {
			YR(document.body, "el-popup-parent--hidden"), n && (document.body.style.paddingRight = r);
		};
		ds(e, (e) => {
			if (!e) return void s();
			(n = !WR(document.body, "el-popup-parent--hidden")), n && ((r = document.body.style.paddingRight), (i = Number.parseInt(XR(document.body, "paddingRight"), 10))), (t = QR());
			const o = document.documentElement.clientHeight < document.body.scrollHeight,
				a = XR(document.body, "overflowY");
			t > 0 && (o || "scroll" === a) && n && (document.body.style.paddingRight = `${i + t}px`), GR(document.body, "el-popup-parent--hidden");
		}),
			M(() => s());
	},
	ED = lN({ type: Boolean, default: null }),
	TD = lN({ type: Function }),
	kD = (e) => {
		if (!e) return { onClick: yR, onMousedown: yR, onMouseup: yR };
		let t = !1,
			n = !1;
		return {
			onClick: (r) => {
				t && n && e(r), (t = n = !1);
			},
			onMousedown: (e) => {
				t = e.target === e.currentTarget;
			},
			onMouseup: (e) => {
				n = e.target === e.currentTarget;
			}
		};
	};
let AD = [];
let MD;
const ID = `el-popper-container-${DN()}`,
	RD = `#${ID}`,
	LD = () => {
		Hn(() => {
			GI &&
				((MD && document.body.querySelector(RD)) ||
					(MD = (() => {
						const e = document.createElement("div");
						return (e.id = ID), document.body.appendChild(e), e;
					})()));
		});
	},
	OD = uN({ showAfter: { type: Number, default: 0 }, hideAfter: { type: Number, default: 200 } }),
	PD = ({ showAfter: e, hideAfter: t, open: n, close: r }) => {
		const { registerTimeout: i } = (function () {
			let e;
			const t = () => window.clearTimeout(e);
			return (
				WI(() => t()),
				{
					registerTimeout: (n, r) => {
						t(), (e = window.setTimeout(n, r));
					},
					cancelTimeout: t
				}
			);
		})();
		return {
			onOpen: (t) => {
				i(() => {
					n(t);
				}, it(e));
			},
			onClose: (e) => {
				i(() => {
					r(e);
				}, it(t));
			}
		};
	},
	ND = Symbol("elForwardRef"),
	DD = (e, t, n, r, i) => {
		let s = `${e}-${t}`;
		return n && (s += `-${n}`), r && (s += `__${r}`), i && (s += `--${i}`), s;
	},
	BD = (e) => {
		const t = aD("namespace"),
			n = ht(() => t.value || "el");
		return {
			namespace: n,
			b: (t = "") => DD(it(n), e, t, "", ""),
			e: (t) => (t ? DD(it(n), e, "", t, "") : ""),
			m: (t) => (t ? DD(it(n), e, "", "", t) : ""),
			be: (t, r) => (t && r ? DD(it(n), e, t, r, "") : ""),
			em: (t, r) => (t && r ? DD(it(n), e, "", t, r) : ""),
			bm: (t, r) => (t && r ? DD(it(n), e, t, "", r) : ""),
			bem: (t, r, i) => (t && r && i ? DD(it(n), e, t, r, i) : ""),
			is: (e, ...t) => {
				const n = !(t.length >= 1) || t[0];
				return e && n ? `is-${e}` : "";
			},
			cssVar: (e) => {
				const t = {};
				for (const r in e) t[`--${n.value}-${r}`] = e[r];
				return t;
			},
			cssVarName: (e) => `--${n.value}-${e}`,
			cssVarBlock: (t) => {
				const r = {};
				for (const i in t) r[`--${n.value}-${e}-${i}`] = t[i];
				return r;
			},
			cssVarBlockName: (t) => `--${n.value}-${e}-${t}`
		};
	},
	FD = Qe(0),
	HD = () => {
		const e = aD("zIndex", 2e3),
			t = ht(() => e.value + FD.value);
		return { initialZIndex: e, currentZIndex: t, nextZIndex: () => (FD.value++, t.value) };
	};
function VD(e) {
	return e.split("-")[0];
}
function UD(e) {
	return e.split("-")[1];
}
function zD(e) {
	return ["top", "bottom"].includes(VD(e)) ? "x" : "y";
}
function $D(e) {
	return "y" === e ? "height" : "width";
}
function jD(e, t, n) {
	let { reference: r, floating: i } = e;
	const s = r.x + r.width / 2 - i.width / 2,
		o = r.y + r.height / 2 - i.height / 2,
		a = zD(t),
		l = $D(a),
		u = r[l] / 2 - i[l] / 2,
		c = "x" === a;
	let h;
	switch (VD(t)) {
		case "top":
			h = { x: s, y: r.y - i.height };
			break;
		case "bottom":
			h = { x: s, y: r.y + r.height };
			break;
		case "right":
			h = { x: r.x + r.width, y: o };
			break;
		case "left":
			h = { x: r.x - i.width, y: o };
			break;
		default:
			h = { x: r.x, y: r.y };
	}
	switch (UD(t)) {
		case "start":
			h[a] -= u * (n && c ? -1 : 1);
			break;
		case "end":
			h[a] += u * (n && c ? -1 : 1);
	}
	return h;
}
function WD(e) {
	return "number" != typeof e
		? (function (e) {
				return u({ top: 0, right: 0, bottom: 0, left: 0 }, e);
		  })(e)
		: { top: e, right: e, bottom: e, left: e };
}
function GD(e) {
	return c(u({}, e), { top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height });
}
const YD = Math.min,
	XD = Math.max;
const KD = (e) => ({
	name: "arrow",
	options: e,
	async fn(t) {
		const { element: n, padding: r = 0 } = null != e ? e : {},
			{ x: i, y: s, placement: o, rects: a, platform: l } = t;
		if (null == n) return {};
		const u = WD(r),
			c = { x: i, y: s },
			h = zD(o),
			d = UD(o),
			p = $D(h),
			f = await l.getDimensions(n),
			m = "y" === h ? "top" : "left",
			v = "y" === h ? "bottom" : "right",
			g = a.reference[p] + a.reference[h] - c[h] - a.floating[p],
			y = c[h] - a.reference[h],
			b = await (null == l.getOffsetParent ? void 0 : l.getOffsetParent(n));
		let x = b ? ("y" === h ? b.clientHeight || 0 : b.clientWidth || 0) : 0;
		0 === x && (x = a.floating[p]);
		const _ = g / 2 - y / 2,
			w = u[m],
			C = x - f[p] - u[v],
			S = x / 2 - f[p] / 2 + _,
			E = XD(w, YD(S, C));
		const T = ("start" === d ? u[m] : u[v]) > 0 && S !== E && a.reference[p] <= a.floating[p];
		return { [h]: c[h] - (T ? (S < w ? w - S : C - S) : 0), data: { [h]: E, centerOffset: S - E } };
	}
});
const qD = function (e) {
	return (
		void 0 === e && (e = 0),
		{
			name: "offset",
			options: e,
			async fn(t) {
				const { x: n, y: r } = t,
					i = await (async function (e, t) {
						const { placement: n, platform: r, elements: i } = e,
							s = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)),
							o = VD(n),
							a = UD(n),
							l = "x" === zD(n),
							c = ["left", "top"].includes(o) ? -1 : 1,
							h = s && l ? -1 : 1,
							d = "function" == typeof t ? t(e) : t;
						let { mainAxis: p, crossAxis: f, alignmentAxis: m } = "number" == typeof d ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : u({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, d);
						return a && "number" == typeof m && (f = "end" === a ? -1 * m : m), l ? { x: f * h, y: p * c } : { x: p * c, y: f * h };
					})(t, e);
				return { x: n + i.x, y: r + i.y, data: i };
			}
		}
	);
};
function ZD(e) {
	return e && e.document && e.location && e.alert && e.setInterval;
}
function JD(e) {
	if (null == e) return window;
	if (!ZD(e)) {
		const t = e.ownerDocument;
		return (t && t.defaultView) || window;
	}
	return e;
}
function QD(e) {
	return JD(e).getComputedStyle(e);
}
function eB(e) {
	return ZD(e) ? "" : e ? (e.nodeName || "").toLowerCase() : "";
}
function tB() {
	const e = navigator.userAgentData;
	return null != e && e.brands ? e.brands.map((e) => e.brand + "/" + e.version).join(" ") : navigator.userAgent;
}
function nB(e) {
	return e instanceof JD(e).HTMLElement;
}
function rB(e) {
	return e instanceof JD(e).Element;
}
function iB(e) {
	if ("undefined" == typeof ShadowRoot) return !1;
	return e instanceof JD(e).ShadowRoot || e instanceof ShadowRoot;
}
function sB(e) {
	const { overflow: t, overflowX: n, overflowY: r } = QD(e);
	return /auto|scroll|overlay|hidden/.test(t + r + n);
}
function oB(e) {
	return ["table", "td", "th"].includes(eB(e));
}
function aB(e) {
	const t = /firefox/i.test(tB()),
		n = QD(e);
	return "none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || ["transform", "perspective"].includes(n.willChange) || (t && "filter" === n.willChange) || (t && !!n.filter && "none" !== n.filter);
}
function lB() {
	return !/^((?!chrome|android).)*safari/i.test(tB());
}
const uB = Math.min,
	cB = Math.max,
	hB = Math.round;
function dB(e, t, n) {
	var r, i, s, o;
	void 0 === t && (t = !1), void 0 === n && (n = !1);
	const a = e.getBoundingClientRect();
	let l = 1,
		u = 1;
	t && nB(e) && ((l = (e.offsetWidth > 0 && hB(a.width) / e.offsetWidth) || 1), (u = (e.offsetHeight > 0 && hB(a.height) / e.offsetHeight) || 1));
	const c = rB(e) ? JD(e) : window,
		h = !lB() && n,
		d = (a.left + (h && null != (r = null == (i = c.visualViewport) ? void 0 : i.offsetLeft) ? r : 0)) / l,
		p = (a.top + (h && null != (s = null == (o = c.visualViewport) ? void 0 : o.offsetTop) ? s : 0)) / u,
		f = a.width / l,
		m = a.height / u;
	return { width: f, height: m, top: p, right: d + f, bottom: p + m, left: d, x: d, y: p };
}
function pB(e) {
	return ((t = e), (t instanceof JD(t).Node ? e.ownerDocument : e.document) || window.document).documentElement;
	var t;
}
function fB(e) {
	return rB(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function mB(e) {
	return dB(pB(e)).left + fB(e).scrollLeft;
}
function vB(e, t, n) {
	const r = nB(t),
		i = pB(t),
		s = dB(
			e,
			r &&
				(function (e) {
					const t = dB(e);
					return hB(t.width) !== e.offsetWidth || hB(t.height) !== e.offsetHeight;
				})(t),
			"fixed" === n
		);
	let o = { scrollLeft: 0, scrollTop: 0 };
	const a = { x: 0, y: 0 };
	if (r || (!r && "fixed" !== n))
		if ((("body" !== eB(t) || sB(i)) && (o = fB(t)), nB(t))) {
			const e = dB(t, !0);
			(a.x = e.x + t.clientLeft), (a.y = e.y + t.clientTop);
		} else i && (a.x = mB(i));
	return { x: s.left + o.scrollLeft - a.x, y: s.top + o.scrollTop - a.y, width: s.width, height: s.height };
}
function gB(e) {
	return "html" === eB(e) ? e : e.assignedSlot || e.parentNode || (iB(e) ? e.host : null) || pB(e);
}
function yB(e) {
	return nB(e) && "fixed" !== getComputedStyle(e).position ? e.offsetParent : null;
}
function bB(e) {
	const t = JD(e);
	let n = yB(e);
	for (; n && oB(n) && "static" === getComputedStyle(n).position; ) n = yB(n);
	return n && ("html" === eB(n) || ("body" === eB(n) && "static" === getComputedStyle(n).position && !aB(n)))
		? t
		: n ||
				(function (e) {
					let t = gB(e);
					for (iB(t) && (t = t.host); nB(t) && !["html", "body"].includes(eB(t)); ) {
						if (aB(t)) return t;
						t = t.parentNode;
					}
					return null;
				})(e) ||
				t;
}
function xB(e) {
	if (nB(e)) return { width: e.offsetWidth, height: e.offsetHeight };
	const t = dB(e);
	return { width: t.width, height: t.height };
}
function _B(e) {
	const t = gB(e);
	return ["html", "body", "#document"].includes(eB(t)) ? e.ownerDocument.body : nB(t) && sB(t) ? t : _B(t);
}
function wB(e, t) {
	var n;
	void 0 === t && (t = []);
	const r = _B(e),
		i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
		s = JD(r),
		o = i ? [s].concat(s.visualViewport || [], sB(r) ? r : []) : r,
		a = t.concat(o);
	return i ? a : a.concat(wB(o));
}
function CB(e, t, n) {
	return "viewport" === t
		? GD(
				(function (e, t) {
					const n = JD(e),
						r = pB(e),
						i = n.visualViewport;
					let s = r.clientWidth,
						o = r.clientHeight,
						a = 0,
						l = 0;
					if (i) {
						(s = i.width), (o = i.height);
						const e = lB();
						(e || (!e && "fixed" === t)) && ((a = i.offsetLeft), (l = i.offsetTop));
					}
					return { width: s, height: o, x: a, y: l };
				})(e, n)
		  )
		: rB(t)
		? (function (e, t) {
				const n = dB(e, !1, "fixed" === t),
					r = n.top + e.clientTop,
					i = n.left + e.clientLeft;
				return { top: r, left: i, x: i, y: r, right: i + e.clientWidth, bottom: r + e.clientHeight, width: e.clientWidth, height: e.clientHeight };
		  })(t, n)
		: GD(
				(function (e) {
					var t;
					const n = pB(e),
						r = fB(e),
						i = null == (t = e.ownerDocument) ? void 0 : t.body,
						s = cB(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
						o = cB(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0);
					let a = -r.scrollLeft + mB(e);
					const l = -r.scrollTop;
					return "rtl" === QD(i || n).direction && (a += cB(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
				})(pB(e))
		  );
}
function SB(e) {
	const t = wB(e),
		n = ["absolute", "fixed"].includes(QD(e).position) && nB(e) ? bB(e) : e;
	return rB(n)
		? t.filter(
				(e) =>
					rB(e) &&
					(function (e, t) {
						const n = null == t.getRootNode ? void 0 : t.getRootNode();
						if (e.contains(t)) return !0;
						if (n && iB(n)) {
							let n = t;
							do {
								if (n && e === n) return !0;
								n = n.parentNode || n.host;
							} while (n);
						}
						return !1;
					})(e, n) &&
					"body" !== eB(e)
		  )
		: [];
}
const EB = {
		getClippingRect: function (e) {
			let { element: t, boundary: n, rootBoundary: r, strategy: i } = e;
			const s = [...("clippingAncestors" === n ? SB(t) : [].concat(n)), r],
				o = s[0],
				a = s.reduce((e, n) => {
					const r = CB(t, n, i);
					return (e.top = cB(r.top, e.top)), (e.right = uB(r.right, e.right)), (e.bottom = uB(r.bottom, e.bottom)), (e.left = cB(r.left, e.left)), e;
				}, CB(t, o, i));
			return { width: a.right - a.left, height: a.bottom - a.top, x: a.left, y: a.top };
		},
		convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
			let { rect: t, offsetParent: n, strategy: r } = e;
			const i = nB(n),
				s = pB(n);
			if (n === s) return t;
			let o = { scrollLeft: 0, scrollTop: 0 };
			const a = { x: 0, y: 0 };
			if ((i || (!i && "fixed" !== r)) && (("body" !== eB(n) || sB(s)) && (o = fB(n)), nB(n))) {
				const e = dB(n, !0);
				(a.x = e.x + n.clientLeft), (a.y = e.y + n.clientTop);
			}
			return c(u({}, t), { x: t.x - o.scrollLeft + a.x, y: t.y - o.scrollTop + a.y });
		},
		isElement: rB,
		getDimensions: xB,
		getOffsetParent: bB,
		getDocumentElement: pB,
		getElementRects: (e) => {
			let { reference: t, floating: n, strategy: r } = e;
			return { reference: vB(t, bB(n), r), floating: c(u({}, xB(n)), { x: 0, y: 0 }) };
		},
		getClientRects: (e) => Array.from(e.getClientRects()),
		isRTL: (e) => "rtl" === QD(e).direction
	},
	TB = (e, t, n) =>
		(async (e, t, n) => {
			const { placement: r = "bottom", strategy: i = "absolute", middleware: s = [], platform: o } = n,
				a = await (null == o.isRTL ? void 0 : o.isRTL(t));
			let l = await o.getElementRects({ reference: e, floating: t, strategy: i }),
				{ x: h, y: d } = jD(l, r, a),
				p = r,
				f = {};
			for (let m = 0; m < s.length; m++) {
				const { name: n, fn: v } = s[m],
					{ x: g, y: y, data: b, reset: x } = await v({ x: h, y: d, initialPlacement: r, placement: p, strategy: i, middlewareData: f, rects: l, platform: o, elements: { reference: e, floating: t } });
				(h = null != g ? g : h),
					(d = null != y ? y : d),
					(f = c(u({}, f), { [n]: u(u({}, f[n]), b) })),
					x && ("object" == typeof x && (x.placement && (p = x.placement), x.rects && (l = !0 === x.rects ? await o.getElementRects({ reference: e, floating: t, strategy: i }) : x.rects), ({ x: h, y: d } = jD(l, p, a))), (m = -1));
			}
			return { x: h, y: d, placement: p, strategy: i, middlewareData: f };
		})(e, t, u({ platform: EB }, n));
uN({});
const kB = ({ middleware: e, placement: t, strategy: n }) => {
	const r = Qe(),
		i = Qe(),
		s = Qe(),
		o = Qe(),
		a = Qe({}),
		l = { x: s, y: o, placement: t, strategy: n, middlewareData: a },
		h = async () => {
			if (!GI) return;
			const s = ((e) => {
					if (!GI) return;
					if (!e) return e;
					const t = tR(e);
					return t || (Je(e) ? t : e);
				})(r),
				o = tR(i);
			if (!s || !o) return;
			const a = await TB(s, o, { placement: it(t), strategy: it(n), middleware: it(e) });
			VR(l).forEach((e) => {
				l[e].value = a[e];
			});
		};
	return (
		Vn(() => {
			cs(() => {
				h();
			});
		}),
		c(u({}, l), { update: h, referenceRef: r, contentRef: i })
	);
};
const AB = uN({ zIndex: { type: [Number, String], default: 100 }, target: { type: String, default: "" }, offset: { type: Number, default: 0 }, position: { type: String, values: ["top", "bottom"], default: "top" } }),
	MB = { scroll: ({ scrollTop: e, fixed: t }) => XI(e) && YI(t), change: (e) => YI(e) };
var IB = (e, t) => {
	const n = e.__vccOpts || e;
	for (const [r, i] of t) n[r] = i;
	return n;
};
const RB = mN(
		IB(
			Tn(
				c(u({}, { name: "ElAffix" }), {
					props: AB,
					emits: MB,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							i = BD("affix"),
							s = et(),
							o = et(),
							a = et(),
							{ height: l } = (function ({ window: e = nR, initialWidth: t = 1 / 0, initialHeight: n = 1 / 0 } = {}) {
								const r = Qe(t),
									i = Qe(n),
									s = () => {
										e && ((r.value = e.innerWidth), (i.value = e.innerHeight));
									};
								return s(), QI(s), iR("resize", s, { passive: !0 }), { width: r, height: i };
							})(),
							{ height: u, width: c, top: h, bottom: d, update: p } = fR(o),
							f = fR(s),
							m = Qe(!1),
							v = Qe(0),
							g = Qe(0),
							y = ht(() => ({ height: m.value ? `${u.value}px` : "", width: m.value ? `${c.value}px` : "" })),
							b = ht(() => {
								if (!m.value) return {};
								const e = r.offset ? `${r.offset}px` : 0;
								return { height: `${u.value}px`, width: `${c.value}px`, top: "top" === r.position ? e : "", bottom: "bottom" === r.position ? e : "", transform: g.value ? `translateY(${g.value}px)` : "", zIndex: r.zIndex };
							}),
							x = () => {
								if (a.value)
									if (((v.value = a.value instanceof Window ? document.documentElement.scrollTop : a.value.scrollTop || 0), "top" === r.position))
										if (r.target) {
											const e = f.bottom.value - r.offset - u.value;
											(m.value = r.offset > h.value && f.bottom.value > 0), (g.value = e < 0 ? e : 0);
										} else m.value = r.offset > h.value;
									else if (r.target) {
										const e = l.value - f.top.value - r.offset - u.value;
										(m.value = l.value - r.offset < d.value && l.value > f.top.value), (g.value = e < 0 ? -e : 0);
									} else m.value = l.value - r.offset < d.value;
							};
						return (
							ds(m, (e) => n("change", e)),
							Vn(() => {
								var e;
								r.target ? ((s.value = null != (e = document.querySelector(r.target)) ? e : void 0), s.value || $R("ElAffix", `Target is not existed: ${r.target}`)) : (s.value = document.documentElement), (a.value = ZR(o.value, !0)), p();
							}),
							iR(a, "scroll", () => {
								n("scroll", { scrollTop: v.value, fixed: m.value });
							}),
							cs(x),
							t({ update: x }),
							(e, t) => (Wr(), Kr("div", { ref_key: "root", ref: o, class: gt(it(i).b()), style: pt(it(y)) }, [ni("div", { class: gt({ [it(i).m("fixed")]: m.value }), style: pt(it(b)) }, [mi(e.$slots, "default")], 6)], 6))
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]
		)
	),
	LB = uN({ size: { type: [Number, String] }, color: { type: String } });
const OB = mN(
		IB(
			Tn(
				c(u({}, { name: "ElIcon", inheritAttrs: !1 }), {
					props: LB,
					setup(e) {
						const t = e,
							n = BD("icon"),
							r = ht(() => (t.size || t.color ? { fontSize: BR(t.size) ? void 0 : KR(t.size), "--color": t.color } : {}));
						return (e, t) => (Wr(), Kr("i", hi({ class: it(n).b(), style: it(r) }, e.$attrs), [mi(e.$slots, "default")], 16));
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]
		)
	),
	PB = uN({
		title: { type: String, default: "" },
		description: { type: String, default: "" },
		type: { type: String, values: VR(pN), default: "info" },
		closable: { type: Boolean, default: !0 },
		closeText: { type: String, default: "" },
		showIcon: Boolean,
		center: Boolean,
		effect: { type: String, values: ["light", "dark"], default: "light" }
	}),
	NB = { close: (e) => e instanceof MouseEvent };
const DB = mN(
	IB(
		Tn(
			c(u({}, { name: "ElAlert" }), {
				props: PB,
				emits: NB,
				setup(e, { emit: t }) {
					const n = e,
						{ Close: r } = dN,
						i = gs(),
						s = BD("alert"),
						o = Qe(!0),
						a = ht(() => pN[n.type]),
						l = ht(() => [s.e("icon"), { [s.is("big")]: !!n.description || !!i.default }]),
						u = ht(() => n.description || { [s.is("bold")]: i.default }),
						c = (e) => {
							(o.value = !1), t("close", e);
						};
					return (e, t) => (
						Wr(),
						qr(
							lo,
							{ name: it(s).b("fade"), persisted: "" },
							{
								default: cn(() => [
									yr(
										ni(
											"div",
											{ class: gt([it(s).b(), it(s).m(e.type), it(s).is("center", e.center), it(s).is(e.effect)]), role: "alert" },
											[
												e.showIcon && it(a) ? (Wr(), qr(it(OB), { key: 0, class: gt(it(l)) }, { default: cn(() => [(Wr(), qr(Nr(it(a))))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
												ni(
													"div",
													{ class: gt(it(s).e("content")) },
													[
														e.title || e.$slots.title ? (Wr(), Kr("span", { key: 0, class: gt([it(s).e("title"), it(u)]) }, [mi(e.$slots, "title", {}, () => [oi(bt(e.title), 1)])], 2)) : ai("v-if", !0),
														e.$slots.default || e.description ? (Wr(), Kr("p", { key: 1, class: gt(it(s).e("description")) }, [mi(e.$slots, "default", {}, () => [oi(bt(e.description), 1)])], 2)) : ai("v-if", !0),
														e.closable
															? (Wr(),
															  Kr(
																	Hr,
																	{ key: 2 },
																	[
																		e.closeText
																			? (Wr(), Kr("div", { key: 0, class: gt([it(s).e("close-btn"), it(s).is("customed")]), onClick: c }, bt(e.closeText), 3))
																			: (Wr(), qr(it(OB), { key: 1, class: gt(it(s).e("close-btn")), onClick: c }, { default: cn(() => [ri(it(r))]), _: 1 }, 8, ["class"]))
																	],
																	64
															  ))
															: ai("v-if", !0)
													],
													2
												)
											],
											2
										),
										[[Wo, o.value]]
									)
								]),
								_: 3
							},
							8,
							["name"]
						)
					);
				}
			})
		),
		[["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]
	)
);
let BB;
const FB = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
function HB(e, t = 1, n) {
	var r;
	BB || ((BB = document.createElement("textarea")), document.body.appendChild(BB));
	const {
		paddingSize: i,
		borderSize: s,
		boxSizing: o,
		contextStyle: a
	} = (function (e) {
		const t = window.getComputedStyle(e),
			n = t.getPropertyValue("box-sizing"),
			r = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")),
			i = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
		return { contextStyle: FB.map((e) => `${e}:${t.getPropertyValue(e)}`).join(";"), paddingSize: r, borderSize: i, boxSizing: n };
	})(e);
	BB.setAttribute("style", `${a};\n    height:0 !important;\n    visibility:hidden !important;\n    overflow:hidden !important;\n    position:absolute !important;\n    z-index:-1000 !important;\n    top:0 !important;\n    right:0 !important;\n`), (BB.value = e.value || e.placeholder || "");
	let l = BB.scrollHeight;
	const u = {};
	"border-box" === o ? (l += s) : "content-box" === o && (l -= i), (BB.value = "");
	const c = BB.scrollHeight - i;
	if (XI(t)) {
		let e = c * t;
		"border-box" === o && (e = e + i + s), (l = Math.max(e, l)), (u.minHeight = `${e}px`);
	}
	if (XI(n)) {
		let e = c * n;
		"border-box" === o && (e = e + i + s), (l = Math.min(e, l));
	}
	return (u.height = `${l}px`), null == (r = BB.parentNode) || r.removeChild(BB), (BB = void 0), u;
}
const VB = uN({
		id: { type: String, default: void 0 },
		size: cD,
		disabled: Boolean,
		modelValue: { type: [String, Number, Object], default: "" },
		type: { type: String, default: "text" },
		resize: { type: String, values: ["none", "both", "horizontal", "vertical"] },
		autosize: { type: [Boolean, Object], default: !1 },
		autocomplete: { type: String, default: "off" },
		formatter: { type: Function },
		parser: { type: Function },
		placeholder: { type: String },
		form: { type: String, default: "" },
		readonly: { type: Boolean, default: !1 },
		clearable: { type: Boolean, default: !1 },
		showPassword: { type: Boolean, default: !1 },
		showWordLimit: { type: Boolean, default: !1 },
		suffixIcon: { type: cN, default: "" },
		prefixIcon: { type: cN, default: "" },
		containerRole: { type: String, default: void 0 },
		label: { type: String, default: void 0 },
		tabindex: { type: [String, Number], default: 0 },
		validateEvent: { type: Boolean, default: !0 },
		inputStyle: { type: [Object, Array, String], default: () => ({}) }
	}),
	UB = {
		[_N]: (e) => SR(e),
		input: (e) => SR(e),
		change: (e) => SR(e),
		focus: (e) => e instanceof FocusEvent,
		blur: (e) => e instanceof FocusEvent,
		clear: () => !0,
		mouseleave: (e) => e instanceof MouseEvent,
		mouseenter: (e) => e instanceof MouseEvent,
		keydown: (e) => e instanceof Event,
		compositionstart: (e) => e instanceof CompositionEvent,
		compositionupdate: (e) => e instanceof CompositionEvent,
		compositionend: (e) => e instanceof CompositionEvent
	},
	zB = ["role"],
	$B = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"],
	jB = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const WB = mN(
		IB(
			Tn(
				c(u({}, { name: "ElInput", inheritAttrs: !1 }), {
					props: VB,
					emits: UB,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							i = { suffix: "append", prefix: "prepend" },
							s = Si(),
							o = ys(),
							a = gs(),
							l = ht(() => {
								const e = {};
								return "combobox" === r.containerRole && ((e["aria-haspopup"] = o["aria-haspopup"]), (e["aria-owns"] = o["aria-owns"]), (e["aria-expanded"] = o["aria-expanded"])), e;
							}),
							c = HN({ excludeKeys: ht(() => Object.keys(l.value)) }),
							{ form: h, formItem: d } = yD(),
							{ inputId: p } = bD(r, { formItemContext: d }),
							f = hD(),
							m = dD(),
							v = BD("input"),
							g = BD("textarea"),
							y = et(),
							b = et(),
							x = Qe(!1),
							_ = Qe(!1),
							w = Qe(!1),
							C = Qe(!1),
							S = Qe(),
							E = et(r.inputStyle),
							T = ht(() => y.value || b.value),
							k = ht(() => {
								var e;
								return null != (e = null == h ? void 0 : h.statusIcon) && e;
							}),
							A = ht(() => (null == d ? void 0 : d.validateState) || ""),
							M = ht(() => fN[A.value]),
							I = ht(() => (C.value ? KP : RO)),
							R = ht(() => [o.style, r.inputStyle]),
							L = ht(() => [r.inputStyle, E.value, { resize: r.resize }]),
							O = ht(() => (ik(r.modelValue) ? "" : String(r.modelValue))),
							P = ht(() => r.clearable && !m.value && !r.readonly && !!O.value && (x.value || _.value)),
							N = ht(() => r.showPassword && !m.value && !r.readonly && !!O.value && (!!O.value || x.value)),
							D = ht(() => r.showWordLimit && !!c.value.maxlength && ("text" === r.type || "textarea" === r.type) && !m.value && !r.readonly && !r.showPassword),
							B = ht(() => Array.from(O.value).length),
							F = ht(() => !!D.value && B.value > Number(c.value.maxlength)),
							H = ht(() => !!a.suffix || !!r.suffixIcon || P.value || r.showPassword || D.value || (!!A.value && k.value)),
							[V, U] = (function (e) {
								const t = Qe();
								return [
									function () {
										if (null == e.value) return;
										const { selectionStart: n, selectionEnd: r, value: i } = e.value;
										if (null == n || null == r) return;
										const s = i.slice(0, Math.max(0, n)),
											o = i.slice(Math.max(0, r));
										t.value = { selectionStart: n, selectionEnd: r, value: i, beforeTxt: s, afterTxt: o };
									},
									function () {
										if (null == e.value || null == t.value) return;
										const { value: n } = e.value,
											{ beforeTxt: r, afterTxt: i, selectionStart: s } = t.value;
										if (null == r || null == i || null == s) return;
										let o = n.length;
										if (n.endsWith(i)) o = n.length - i.length;
										else if (n.startsWith(r)) o = r.length;
										else {
											const e = r[s - 1],
												t = n.indexOf(e, s - 1);
											-1 !== t && (o = t + 1);
										}
										e.value.setSelectionRange(o, o);
									}
								];
							})(y);
						pR(b, (e) => {
							if (!D.value || "both" !== r.resize) return;
							const t = e[0],
								{ width: n } = t.contentRect;
							S.value = { right: `calc(100% - ${n + 15 + 6}px)` };
						});
						const z = () => {
								const { type: e, autosize: t } = r;
								if (GI && "textarea" === e)
									if (t) {
										const e = ER(t) ? t.minRows : void 0,
											n = ER(t) ? t.maxRows : void 0;
										E.value = u({}, HB(b.value, e, n));
									} else E.value = { minHeight: HB(b.value).minHeight };
							},
							$ = () => {
								const e = T.value;
								e && e.value !== O.value && (e.value = O.value);
							},
							j = (e) => {
								const { el: t } = s.vnode;
								if (!t) return;
								const n = Array.from(t.querySelectorAll(`.${v.e(e)}`)).find((e) => e.parentNode === t);
								if (!n) return;
								const r = i[e];
								a[r] ? (n.style.transform = `translateX(${"suffix" === e ? "-" : ""}${t.querySelector(`.${v.be("group", r)}`).offsetWidth}px)`) : n.removeAttribute("style");
							},
							W = () => {
								j("prefix"), j("suffix");
							},
							G = async (e) => {
								V();
								let { value: t } = e.target;
								r.formatter && ((t = r.parser ? r.parser(t) : t), (t = r.formatter(t))), w.value || (t !== O.value && (n(_N, t), n("input", t), await ns(), $(), U()));
							},
							Y = (e) => {
								n("change", e.target.value);
							},
							X = (e) => {
								n("compositionstart", e), (w.value = !0);
							},
							K = (e) => {
								var t;
								n("compositionupdate", e);
								const r = null == (t = e.target) ? void 0 : t.value,
									i = r[r.length - 1] || "";
								w.value = !ON(i);
							},
							q = (e) => {
								n("compositionend", e), w.value && ((w.value = !1), G(e));
							},
							Z = () => {
								(C.value = !C.value), J();
							},
							J = async () => {
								var e;
								await ns(), null == (e = T.value) || e.focus();
							},
							Q = (e) => {
								(x.value = !0), n("focus", e);
							},
							ee = (e) => {
								var t;
								(x.value = !1), n("blur", e), r.validateEvent && (null == (t = null == d ? void 0 : d.validate) || t.call(d, "blur").catch((e) => {}));
							},
							te = (e) => {
								(_.value = !1), n("mouseleave", e);
							},
							ne = (e) => {
								(_.value = !0), n("mouseenter", e);
							},
							re = (e) => {
								n("keydown", e);
							},
							ie = () => {
								n(_N, ""), n("change", ""), n("clear"), n("input", "");
							};
						return (
							ds(
								() => r.modelValue,
								() => {
									var e;
									ns(() => z()), r.validateEvent && (null == (e = null == d ? void 0 : d.validate) || e.call(d, "change").catch((e) => {}));
								}
							),
							ds(O, () => $()),
							ds(
								() => r.type,
								async () => {
									await ns(), $(), z(), W();
								}
							),
							Vn(async () => {
								!r.formatter && r.parser, $(), W(), await ns(), z();
							}),
							zn(async () => {
								await ns(), W();
							}),
							t({
								input: y,
								textarea: b,
								ref: T,
								textareaStyle: L,
								autosize: ut(r, "autosize"),
								focus: J,
								blur: () => {
									var e;
									return null == (e = T.value) ? void 0 : e.blur();
								},
								select: () => {
									var e;
									null == (e = T.value) || e.select();
								},
								clear: ie,
								resizeTextarea: z
							}),
							(e, t) =>
								yr(
									(Wr(),
									Kr(
										"div",
										hi(it(l), {
											class: [
												"textarea" === e.type ? it(g).b() : it(v).b(),
												it(v).m(it(f)),
												it(v).is("disabled", it(m)),
												it(v).is("exceed", it(F)),
												{
													[it(v).b("group")]: e.$slots.prepend || e.$slots.append,
													[it(v).bm("group", "append")]: e.$slots.append,
													[it(v).bm("group", "prepend")]: e.$slots.prepend,
													[it(v).m("prefix")]: e.$slots.prefix || e.prefixIcon,
													[it(v).m("suffix")]: e.$slots.suffix || e.suffixIcon || e.clearable || e.showPassword,
													[it(v).bm("suffix", "password-clear")]: it(P) && it(N)
												},
												e.$attrs.class
											],
											style: it(R),
											role: e.containerRole,
											onMouseenter: ne,
											onMouseleave: te
										}),
										[
											ai(" input "),
											"textarea" !== e.type
												? (Wr(),
												  Kr(
														Hr,
														{ key: 0 },
														[
															ai(" prepend slot "),
															e.$slots.prepend ? (Wr(), Kr("div", { key: 0, class: gt(it(v).be("group", "prepend")) }, [mi(e.$slots, "prepend")], 2)) : ai("v-if", !0),
															ni(
																"div",
																{ class: gt([it(v).e("wrapper"), it(v).is("focus", x.value)]) },
																[
																	ai(" prefix slot "),
																	e.$slots.prefix || e.prefixIcon
																		? (Wr(),
																		  Kr(
																				"span",
																				{ key: 0, class: gt(it(v).e("prefix")) },
																				[
																					ni(
																						"span",
																						{ class: gt(it(v).e("prefix-inner")) },
																						[mi(e.$slots, "prefix"), e.prefixIcon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(v).e("icon")) }, { default: cn(() => [(Wr(), qr(Nr(e.prefixIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)],
																						2
																					)
																				],
																				2
																		  ))
																		: ai("v-if", !0),
																	ni(
																		"input",
																		hi({ id: it(p), ref_key: "input", ref: y, class: it(v).e("inner") }, it(c), {
																			type: e.showPassword ? (C.value ? "text" : "password") : e.type,
																			disabled: it(m),
																			formatter: e.formatter,
																			parser: e.parser,
																			readonly: e.readonly,
																			autocomplete: e.autocomplete,
																			tabindex: e.tabindex,
																			"aria-label": e.label,
																			placeholder: e.placeholder,
																			style: e.inputStyle,
																			onCompositionstart: X,
																			onCompositionupdate: K,
																			onCompositionend: q,
																			onInput: G,
																			onFocus: Q,
																			onBlur: ee,
																			onChange: Y,
																			onKeydown: re
																		}),
																		null,
																		16,
																		$B
																	),
																	ai(" suffix slot "),
																	it(H)
																		? (Wr(),
																		  Kr(
																				"span",
																				{ key: 1, class: gt(it(v).e("suffix")) },
																				[
																					ni(
																						"span",
																						{ class: gt(it(v).e("suffix-inner")) },
																						[
																							it(P) && it(N) && it(D)
																								? ai("v-if", !0)
																								: (Wr(),
																								  Kr(
																										Hr,
																										{ key: 0 },
																										[mi(e.$slots, "suffix"), e.suffixIcon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(v).e("icon")) }, { default: cn(() => [(Wr(), qr(Nr(e.suffixIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)],
																										64
																								  )),
																							it(P)
																								? (Wr(),
																								  qr(it(OB), { key: 1, class: gt([it(v).e("icon"), it(v).e("clear")]), onMousedown: t[0] || (t[0] = zo(() => {}, ["prevent"])), onClick: ie }, { default: cn(() => [ri(it(QL))]), _: 1 }, 8, ["class"]))
																								: ai("v-if", !0),
																							it(N) ? (Wr(), qr(it(OB), { key: 2, class: gt([it(v).e("icon"), it(v).e("password")]), onClick: Z }, { default: cn(() => [(Wr(), qr(Nr(it(I))))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
																							it(D) ? (Wr(), Kr("span", { key: 3, class: gt(it(v).e("count")) }, [ni("span", { class: gt(it(v).e("count-inner")) }, bt(it(B)) + " / " + bt(it(c).maxlength), 3)], 2)) : ai("v-if", !0),
																							it(A) && it(M) && it(k)
																								? (Wr(), qr(it(OB), { key: 4, class: gt([it(v).e("icon"), it(v).e("validateIcon"), it(v).is("loading", "validating" === it(A))]) }, { default: cn(() => [(Wr(), qr(Nr(it(M))))]), _: 1 }, 8, ["class"]))
																								: ai("v-if", !0)
																						],
																						2
																					)
																				],
																				2
																		  ))
																		: ai("v-if", !0)
																],
																2
															),
															ai(" append slot "),
															e.$slots.append ? (Wr(), Kr("div", { key: 1, class: gt(it(v).be("group", "append")) }, [mi(e.$slots, "append")], 2)) : ai("v-if", !0)
														],
														64
												  ))
												: (Wr(),
												  Kr(
														Hr,
														{ key: 1 },
														[
															ai(" textarea "),
															ni(
																"textarea",
																hi({ id: it(p), ref_key: "textarea", ref: b, class: it(g).e("inner") }, it(c), {
																	tabindex: e.tabindex,
																	disabled: it(m),
																	readonly: e.readonly,
																	autocomplete: e.autocomplete,
																	style: it(L),
																	"aria-label": e.label,
																	placeholder: e.placeholder,
																	onCompositionstart: X,
																	onCompositionupdate: K,
																	onCompositionend: q,
																	onInput: G,
																	onFocus: Q,
																	onBlur: ee,
																	onChange: Y,
																	onKeydown: re
																}),
																null,
																16,
																jB
															),
															it(D) ? (Wr(), Kr("span", { key: 0, style: pt(S.value), class: gt(it(v).e("count")) }, bt(it(B)) + " / " + bt(it(c).maxlength), 7)) : ai("v-if", !0)
														],
														64
												  ))
										],
										16,
										zB
									)),
									[[Wo, "hidden" !== e.type]]
								)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]
		)
	),
	GB = {
		vertical: { offset: "offsetHeight", scroll: "scrollTop", scrollSize: "scrollHeight", size: "height", key: "vertical", axis: "Y", client: "clientY", direction: "top" },
		horizontal: { offset: "offsetWidth", scroll: "scrollLeft", scrollSize: "scrollWidth", size: "width", key: "horizontal", axis: "X", client: "clientX", direction: "left" }
	};
var YB = IB(
	Tn({
		__name: "thumb",
		props: uN({ vertical: Boolean, size: String, move: Number, ratio: { type: Number, required: !0 }, always: Boolean }),
		setup(e) {
			const t = e,
				n = vn(ZN),
				r = BD("scrollbar");
			n || $R("Thumb", "can not inject scrollbar context");
			const i = Qe(),
				s = Qe(),
				o = Qe({}),
				a = Qe(!1);
			let l = !1,
				u = !1,
				c = GI ? document.onselectstart : null;
			const h = ht(() => GB[t.vertical ? "vertical" : "horizontal"]),
				d = ht(() => (({ move: e, size: t, bar: n }) => ({ [n.size]: t, transform: `translate${n.axis}(${e}%)` }))({ size: t.size, move: t.move, bar: h.value })),
				p = ht(() => i.value[h.value.offset] ** 2 / n.wrapElement[h.value.scrollSize] / t.ratio / s.value[h.value.offset]),
				f = (e) => {
					var t;
					if ((e.stopPropagation(), e.ctrlKey || [1, 2].includes(e.button))) return;
					null == (t = window.getSelection()) || t.removeAllRanges(), v(e);
					const n = e.currentTarget;
					n && (o.value[h.value.axis] = n[h.value.offset] - (e[h.value.client] - n.getBoundingClientRect()[h.value.direction]));
				},
				m = (e) => {
					if (!s.value || !i.value || !n.wrapElement) return;
					const t = (100 * (Math.abs(e.target.getBoundingClientRect()[h.value.direction] - e[h.value.client]) - s.value[h.value.offset] / 2) * p.value) / i.value[h.value.offset];
					n.wrapElement[h.value.scroll] = (t * n.wrapElement[h.value.scrollSize]) / 100;
				},
				v = (e) => {
					e.stopImmediatePropagation(), (l = !0), document.addEventListener("mousemove", g), document.addEventListener("mouseup", y), (c = document.onselectstart), (document.onselectstart = () => !1);
				},
				g = (e) => {
					if (!i.value || !s.value) return;
					if (!1 === l) return;
					const t = o.value[h.value.axis];
					if (!t) return;
					const r = (100 * (-1 * (i.value.getBoundingClientRect()[h.value.direction] - e[h.value.client]) - (s.value[h.value.offset] - t)) * p.value) / i.value[h.value.offset];
					n.wrapElement[h.value.scroll] = (r * n.wrapElement[h.value.scrollSize]) / 100;
				},
				y = () => {
					(l = !1), (o.value[h.value.axis] = 0), document.removeEventListener("mousemove", g), document.removeEventListener("mouseup", y), b(), u && (a.value = !1);
				};
			$n(() => {
				b(), document.removeEventListener("mouseup", y);
			});
			const b = () => {
				document.onselectstart !== c && (document.onselectstart = c);
			};
			return (
				iR(ut(n, "scrollbarElement"), "mousemove", () => {
					(u = !1), (a.value = !!t.size);
				}),
				iR(ut(n, "scrollbarElement"), "mouseleave", () => {
					(u = !0), (a.value = l);
				}),
				(e, t) => (
					Wr(),
					qr(
						lo,
						{ name: it(r).b("fade"), persisted: "" },
						{
							default: cn(() => [
								yr(ni("div", { ref_key: "instance", ref: i, class: gt([it(r).e("bar"), it(r).is(it(h).key)]), onMousedown: m }, [ni("div", { ref_key: "thumb", ref: s, class: gt(it(r).e("thumb")), style: pt(it(d)), onMousedown: f }, null, 38)], 34), [[Wo, e.always || a.value]])
							]),
							_: 1
						},
						8,
						["name"]
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]
);
var XB = IB(
	Tn({
		__name: "bar",
		props: uN({ always: { type: Boolean, default: !0 }, width: String, height: String, ratioX: { type: Number, default: 1 }, ratioY: { type: Number, default: 1 } }),
		setup(e, { expose: t }) {
			const n = e,
				r = Qe(0),
				i = Qe(0);
			return (
				t({
					handleScroll: (e) => {
						if (e) {
							const t = e.offsetHeight - 4,
								s = e.offsetWidth - 4;
							(i.value = ((100 * e.scrollTop) / t) * n.ratioY), (r.value = ((100 * e.scrollLeft) / s) * n.ratioX);
						}
					}
				}),
				(e, t) => (
					Wr(),
					Kr(Hr, null, [ri(YB, { move: r.value, ratio: e.ratioX, size: e.width, always: e.always }, null, 8, ["move", "ratio", "size", "always"]), ri(YB, { move: i.value, ratio: e.ratioY, size: e.height, vertical: "", always: e.always }, null, 8, ["move", "ratio", "size", "always"])], 64)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]
);
const KB = uN({
		height: { type: [String, Number], default: "" },
		maxHeight: { type: [String, Number], default: "" },
		native: Boolean,
		wrapStyle: { type: [String, Object, Array], default: "" },
		wrapClass: { type: [String, Array], default: "" },
		viewClass: { type: [String, Array], default: "" },
		viewStyle: { type: [String, Array, Object], default: "" },
		noresize: Boolean,
		tag: { type: String, default: "div" },
		always: Boolean,
		minSize: { type: Number, default: 20 }
	}),
	qB = { scroll: ({ scrollTop: e, scrollLeft: t }) => XI(e) && XI(t) };
const ZB = mN(
		IB(
			Tn(
				c(u({}, { name: "ElScrollbar" }), {
					props: KB,
					emits: qB,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							i = BD("scrollbar");
						let s, o;
						const a = Qe(),
							l = Qe(),
							u = Qe(),
							c = Qe("0"),
							h = Qe("0"),
							d = Qe(),
							p = Qe(1),
							f = Qe(1),
							m = ht(() => {
								const e = {};
								return r.height && (e.height = KR(r.height)), r.maxHeight && (e.maxHeight = KR(r.maxHeight)), [r.wrapStyle, e];
							}),
							v = () => {
								var e;
								l.value && (null == (e = d.value) || e.handleScroll(l.value), n("scroll", { scrollTop: l.value.scrollTop, scrollLeft: l.value.scrollLeft }));
							};
						const g = () => {
							if (!l.value) return;
							const e = l.value.offsetHeight - 4,
								t = l.value.offsetWidth - 4,
								n = e ** 2 / l.value.scrollHeight,
								i = t ** 2 / l.value.scrollWidth,
								s = Math.max(n, r.minSize),
								o = Math.max(i, r.minSize);
							(p.value = n / (e - n) / (s / (e - s))), (f.value = i / (t - i) / (o / (t - o))), (h.value = s + 4 < e ? `${s}px` : ""), (c.value = o + 4 < t ? `${o}px` : "");
						};
						return (
							ds(
								() => r.noresize,
								(e) => {
									e ? (null == s || s(), null == o || o()) : (({ stop: s } = pR(u, g)), (o = iR("resize", g)));
								},
								{ immediate: !0 }
							),
							ds(
								() => [r.maxHeight, r.height],
								() => {
									r.native ||
										ns(() => {
											var e;
											g(), l.value && (null == (e = d.value) || e.handleScroll(l.value));
										});
								}
							),
							mn(ZN, Fe({ scrollbarElement: a, wrapElement: l })),
							Vn(() => {
								r.native || ns(() => g());
							}),
							zn(() => g()),
							t({
								wrap$: l,
								update: g,
								scrollTo: function (e, t) {
									ER(e) ? l.value.scrollTo(e) : XI(e) && XI(t) && l.value.scrollTo(e, t);
								},
								setScrollTop: (e) => {
									XI(e) && (l.value.scrollTop = e);
								},
								setScrollLeft: (e) => {
									XI(e) && (l.value.scrollLeft = e);
								},
								handleScroll: v
							}),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{ ref_key: "scrollbar$", ref: a, class: gt(it(i).b()) },
									[
										ni(
											"div",
											{ ref_key: "wrap$", ref: l, class: gt([e.wrapClass, it(i).e("wrap"), { [it(i).em("wrap", "hidden-default")]: !e.native }]), style: pt(it(m)), onScroll: v },
											[(Wr(), qr(Nr(e.tag), { ref_key: "resize$", ref: u, class: gt([it(i).e("view"), e.viewClass]), style: pt(e.viewStyle) }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["class", "style"]))],
											38
										),
										e.native ? ai("v-if", !0) : (Wr(), qr(XB, { key: 0, ref_key: "barRef", ref: d, height: h.value, width: c.value, always: e.always, "ratio-x": f.value, "ratio-y": p.value }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"]))
									],
									2
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]
		)
	),
	JB = { LIGHT: "light", DARK: "dark" },
	QB = uN({ role: { type: String, default: "tooltip" } });
var eF = IB(
	Tn(
		c(u({}, { name: "ElPopperRoot", inheritAttrs: !1 }), {
			props: QB,
			setup(e, { expose: t }) {
				const n = e,
					r = { triggerRef: Qe(), popperInstanceRef: Qe(), contentRef: Qe(), referenceRef: Qe(), role: ht(() => n.role) };
				return t(r), mn(eD, r), (e, t) => mi(e.$slots, "default");
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]
);
const tF = uN({ arrowOffset: { type: Number, default: 5 } });
var nF = IB(
	Tn(
		c(u({}, { name: "ElPopperArrow", inheritAttrs: !1 }), {
			props: tF,
			setup(e, { expose: t }) {
				const n = e,
					r = BD("popper"),
					{ arrowOffset: i, arrowRef: s } = vn(tD, void 0);
				return (
					ds(
						() => n.arrowOffset,
						(e) => {
							i.value = e;
						}
					),
					$n(() => {
						s.value = void 0;
					}),
					t({ arrowRef: s }),
					(e, t) => (Wr(), Kr("span", { ref_key: "arrowRef", ref: s, class: gt(it(r).e("arrow")), "data-popper-arrow": "" }, null, 2))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]
);
const rF = Tn({
	name: "ElOnlyChild",
	setup(e, { slots: t, attrs: n }) {
		var r;
		const i = vn(ND),
			s =
				((o = null != (r = null == i ? void 0 : i.setForwardRef) ? r : yR),
				{
					mounted(e) {
						o(e);
					},
					updated(e) {
						o(e);
					},
					unmounted() {
						o(null);
					}
				});
		var o;
		return () => {
			var e;
			const r = null == (e = t.default) ? void 0 : e.call(t, n);
			if (!r) return null;
			if (r.length > 1) return null;
			const i = iF(r);
			return i ? yr(si(i, n), [[s]]) : null;
		};
	}
});
function iF(e) {
	if (!e) return null;
	const t = e;
	for (const n of t) {
		if (ER(n))
			switch (n.type) {
				case Ur:
					continue;
				case Vr:
				case "svg":
					return sF(n);
				case Hr:
					return iF(n.children);
				default:
					return n;
			}
		return sF(n);
	}
	return null;
}
function sF(e) {
	return ri("span", { class: "el-only-child__content" }, [e]);
}
const oF = uN({ virtualRef: { type: Object }, virtualTriggering: Boolean, onMouseenter: Function, onMouseleave: Function, onClick: Function, onKeydown: Function, onFocus: Function, onBlur: Function, onContextmenu: Function, id: String, open: Boolean });
var aF = IB(
		Tn(
			c(u({}, { name: "ElPopperTrigger", inheritAttrs: !1 }), {
				props: oF,
				setup(e, { expose: t }) {
					const n = e,
						{ role: r, triggerRef: i } = vn(eD, void 0);
					var s;
					(s = i),
						mn(ND, {
							setForwardRef: (e) => {
								s.value = e;
							}
						});
					const o = ht(() => (l.value ? n.id : void 0)),
						a = ht(() => {
							if (r && "tooltip" === r.value) return n.open && n.id ? n.id : void 0;
						}),
						l = ht(() => {
							if (r && "tooltip" !== r.value) return r.value;
						}),
						u = ht(() => (l.value ? `${n.open}` : void 0));
					let c;
					return (
						Vn(() => {
							ds(
								() => n.virtualRef,
								(e) => {
									e && (i.value = tR(e));
								},
								{ immediate: !0 }
							),
								ds(
									() => i.value,
									(e, t) => {
										null == c || c(),
											(c = void 0),
											HR(e) &&
												(["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach((r) => {
													var i;
													const s = n[r];
													s && (e.addEventListener(r.slice(2).toLowerCase(), s), null == (i = null == t ? void 0 : t.removeEventListener) || i.call(t, r.slice(2).toLowerCase(), s));
												}),
												(c = ds(
													[o, a, l, u],
													(t) => {
														["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((n, r) => {
															ik(t[r]) ? e.removeAttribute(n) : e.setAttribute(n, t[r]);
														});
													},
													{ immediate: !0 }
												))),
											HR(t) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((e) => t.removeAttribute(e));
									},
									{ immediate: !0 }
								);
						}),
						$n(() => {
							null == c || c(), (c = void 0);
						}),
						t({ triggerRef: i }),
						(e, t) =>
							e.virtualTriggering
								? ai("v-if", !0)
								: (Wr(),
								  qr(it(rF), hi({ key: 0 }, e.$attrs, { "aria-controls": it(o), "aria-describedby": it(a), "aria-expanded": it(u), "aria-haspopup": it(l) }), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16, [
										"aria-controls",
										"aria-describedby",
										"aria-expanded",
										"aria-haspopup"
								  ]))
					);
				}
			})
		),
		[["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]
	),
	lF = "top",
	uF = "bottom",
	cF = "right",
	hF = "left",
	dF = "auto",
	pF = [lF, uF, cF, hF],
	fF = "start",
	mF = "viewport",
	vF = "popper",
	gF = pF.reduce(function (e, t) {
		return e.concat([t + "-" + fF, t + "-end"]);
	}, []),
	yF = [].concat(pF, [dF]).reduce(function (e, t) {
		return e.concat([t, t + "-" + fF, t + "-end"]);
	}, []),
	bF = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
function xF(e) {
	return e ? (e.nodeName || "").toLowerCase() : null;
}
function _F(e) {
	if (null == e) return window;
	if ("[object Window]" !== e.toString()) {
		var t = e.ownerDocument;
		return (t && t.defaultView) || window;
	}
	return e;
}
function wF(e) {
	return e instanceof _F(e).Element || e instanceof Element;
}
function CF(e) {
	return e instanceof _F(e).HTMLElement || e instanceof HTMLElement;
}
function SF(e) {
	return "undefined" != typeof ShadowRoot && (e instanceof _F(e).ShadowRoot || e instanceof ShadowRoot);
}
var EF = {
	name: "applyStyles",
	enabled: !0,
	phase: "write",
	fn: function (e) {
		var t = e.state;
		Object.keys(t.elements).forEach(function (e) {
			var n = t.styles[e] || {},
				r = t.attributes[e] || {},
				i = t.elements[e];
			!CF(i) ||
				!xF(i) ||
				(Object.assign(i.style, n),
				Object.keys(r).forEach(function (e) {
					var t = r[e];
					!1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
				}));
		});
	},
	effect: function (e) {
		var t = e.state,
			n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
		return (
			Object.assign(t.elements.popper.style, n.popper),
			(t.styles = n),
			t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
			function () {
				Object.keys(t.elements).forEach(function (e) {
					var r = t.elements[e],
						i = t.attributes[e] || {},
						s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
							return (e[t] = ""), e;
						}, {});
					!CF(r) ||
						!xF(r) ||
						(Object.assign(r.style, s),
						Object.keys(i).forEach(function (e) {
							r.removeAttribute(e);
						}));
				});
			}
		);
	},
	requires: ["computeStyles"]
};
function TF(e) {
	return e.split("-")[0];
}
var kF = Math.max,
	AF = Math.min,
	MF = Math.round;
function IF(e, t) {
	void 0 === t && (t = !1);
	var n = e.getBoundingClientRect(),
		r = 1,
		i = 1;
	if (CF(e) && t) {
		var s = e.offsetHeight,
			o = e.offsetWidth;
		o > 0 && (r = MF(n.width) / o || 1), s > 0 && (i = MF(n.height) / s || 1);
	}
	return { width: n.width / r, height: n.height / i, top: n.top / i, right: n.right / r, bottom: n.bottom / i, left: n.left / r, x: n.left / r, y: n.top / i };
}
function RF(e) {
	var t = IF(e),
		n = e.offsetWidth,
		r = e.offsetHeight;
	return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r };
}
function LF(e, t) {
	var n = t.getRootNode && t.getRootNode();
	if (e.contains(t)) return !0;
	if (n && SF(n)) {
		var r = t;
		do {
			if (r && e.isSameNode(r)) return !0;
			r = r.parentNode || r.host;
		} while (r);
	}
	return !1;
}
function OF(e) {
	return _F(e).getComputedStyle(e);
}
function PF(e) {
	return ["table", "td", "th"].indexOf(xF(e)) >= 0;
}
function NF(e) {
	return ((wF(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function DF(e) {
	return "html" === xF(e) ? e : e.assignedSlot || e.parentNode || (SF(e) ? e.host : null) || NF(e);
}
function BF(e) {
	return CF(e) && "fixed" !== OF(e).position ? e.offsetParent : null;
}
function FF(e) {
	for (var t = _F(e), n = BF(e); n && PF(n) && "static" === OF(n).position; ) n = BF(n);
	return n && ("html" === xF(n) || ("body" === xF(n) && "static" === OF(n).position))
		? t
		: n ||
				(function (e) {
					var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
					if (-1 !== navigator.userAgent.indexOf("Trident") && CF(e) && "fixed" === OF(e).position) return null;
					var n = DF(e);
					for (SF(n) && (n = n.host); CF(n) && ["html", "body"].indexOf(xF(n)) < 0; ) {
						var r = OF(n);
						if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || (t && "filter" === r.willChange) || (t && r.filter && "none" !== r.filter)) return n;
						n = n.parentNode;
					}
					return null;
				})(e) ||
				t;
}
function HF(e) {
	return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function VF(e, t, n) {
	return kF(e, AF(t, n));
}
function UF(e) {
	return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e);
}
function zF(e, t) {
	return t.reduce(function (t, n) {
		return (t[n] = e), t;
	}, {});
}
var $F = {
	name: "arrow",
	enabled: !0,
	phase: "main",
	fn: function (e) {
		var t,
			n = e.state,
			r = e.name,
			i = e.options,
			s = n.elements.arrow,
			o = n.modifiersData.popperOffsets,
			a = TF(n.placement),
			l = HF(a),
			u = [hF, cF].indexOf(a) >= 0 ? "height" : "width";
		if (s && o) {
			var c = (function (e, t) {
					return UF("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : zF(e, pF));
				})(i.padding, n),
				h = RF(s),
				d = "y" === l ? lF : hF,
				p = "y" === l ? uF : cF,
				f = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u],
				m = o[l] - n.rects.reference[l],
				v = FF(s),
				g = v ? ("y" === l ? v.clientHeight || 0 : v.clientWidth || 0) : 0,
				y = f / 2 - m / 2,
				b = c[d],
				x = g - h[u] - c[p],
				_ = g / 2 - h[u] / 2 + y,
				w = VF(b, _, x),
				C = l;
			n.modifiersData[r] = (((t = {})[C] = w), (t.centerOffset = w - _), t);
		}
	},
	effect: function (e) {
		var t = e.state,
			n = e.options.element,
			r = void 0 === n ? "[data-popper-arrow]" : n;
		null != r && (("string" == typeof r && !(r = t.elements.popper.querySelector(r))) || !LF(t.elements.popper, r) || (t.elements.arrow = r));
	},
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"]
};
function jF(e) {
	return e.split("-")[1];
}
var WF = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function GF(e) {
	var t,
		n = e.popper,
		r = e.popperRect,
		i = e.placement,
		s = e.variation,
		o = e.offsets,
		a = e.position,
		l = e.gpuAcceleration,
		u = e.adaptive,
		c = e.roundOffsets,
		h = e.isFixed,
		d = o.x,
		p = void 0 === d ? 0 : d,
		f = o.y,
		m = void 0 === f ? 0 : f,
		v = "function" == typeof c ? c({ x: p, y: m }) : { x: p, y: m };
	(p = v.x), (m = v.y);
	var g = o.hasOwnProperty("x"),
		y = o.hasOwnProperty("y"),
		b = hF,
		x = lF,
		_ = window;
	if (u) {
		var w = FF(n),
			C = "clientHeight",
			S = "clientWidth";
		if ((w === _F(n) && "static" !== OF((w = NF(n))).position && "absolute" === a && ((C = "scrollHeight"), (S = "scrollWidth")), (w = w), i === lF || ((i === hF || i === cF) && "end" === s)))
			(x = uF), (m -= (h && w === _ && _.visualViewport ? _.visualViewport.height : w[C]) - r.height), (m *= l ? 1 : -1);
		if (i === hF || ((i === lF || i === uF) && "end" === s)) (b = cF), (p -= (h && w === _ && _.visualViewport ? _.visualViewport.width : w[S]) - r.width), (p *= l ? 1 : -1);
	}
	var E,
		T = Object.assign({ position: a }, u && WF),
		k =
			!0 === c
				? (function (e) {
						var t = e.x,
							n = e.y,
							r = window.devicePixelRatio || 1;
						return { x: MF(t * r) / r || 0, y: MF(n * r) / r || 0 };
				  })({ x: p, y: m })
				: { x: p, y: m };
	return (
		(p = k.x),
		(m = k.y),
		l
			? Object.assign({}, T, (((E = {})[x] = y ? "0" : ""), (E[b] = g ? "0" : ""), (E.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)"), E))
			: Object.assign({}, T, (((t = {})[x] = y ? m + "px" : ""), (t[b] = g ? p + "px" : ""), (t.transform = ""), t))
	);
}
var YF = {
		name: "computeStyles",
		enabled: !0,
		phase: "beforeWrite",
		fn: function (e) {
			var t = e.state,
				n = e.options,
				r = n.gpuAcceleration,
				i = void 0 === r || r,
				s = n.adaptive,
				o = void 0 === s || s,
				a = n.roundOffsets,
				l = void 0 === a || a,
				u = { placement: TF(t.placement), variation: jF(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: "fixed" === t.options.strategy };
			null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, GF(Object.assign({}, u, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: l })))),
				null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, GF(Object.assign({}, u, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))),
				(t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }));
		},
		data: {}
	},
	XF = { passive: !0 };
var KF = {
		name: "eventListeners",
		enabled: !0,
		phase: "write",
		fn: function () {},
		effect: function (e) {
			var t = e.state,
				n = e.instance,
				r = e.options,
				i = r.scroll,
				s = void 0 === i || i,
				o = r.resize,
				a = void 0 === o || o,
				l = _F(t.elements.popper),
				u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
			return (
				s &&
					u.forEach(function (e) {
						e.addEventListener("scroll", n.update, XF);
					}),
				a && l.addEventListener("resize", n.update, XF),
				function () {
					s &&
						u.forEach(function (e) {
							e.removeEventListener("scroll", n.update, XF);
						}),
						a && l.removeEventListener("resize", n.update, XF);
				}
			);
		},
		data: {}
	},
	qF = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ZF(e) {
	return e.replace(/left|right|bottom|top/g, function (e) {
		return qF[e];
	});
}
var JF = { start: "end", end: "start" };
function QF(e) {
	return e.replace(/start|end/g, function (e) {
		return JF[e];
	});
}
function eH(e) {
	var t = _F(e);
	return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function tH(e) {
	return IF(NF(e)).left + eH(e).scrollLeft;
}
function nH(e) {
	var t = OF(e),
		n = t.overflow,
		r = t.overflowX,
		i = t.overflowY;
	return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function rH(e) {
	return ["html", "body", "#document"].indexOf(xF(e)) >= 0 ? e.ownerDocument.body : CF(e) && nH(e) ? e : rH(DF(e));
}
function iH(e, t) {
	var n;
	void 0 === t && (t = []);
	var r = rH(e),
		i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
		s = _F(r),
		o = i ? [s].concat(s.visualViewport || [], nH(r) ? r : []) : r,
		a = t.concat(o);
	return i ? a : a.concat(iH(DF(o)));
}
function sH(e) {
	return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height });
}
function oH(e, t) {
	return t === mF
		? sH(
				(function (e) {
					var t = _F(e),
						n = NF(e),
						r = t.visualViewport,
						i = n.clientWidth,
						s = n.clientHeight,
						o = 0,
						a = 0;
					return r && ((i = r.width), (s = r.height), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || ((o = r.offsetLeft), (a = r.offsetTop))), { width: i, height: s, x: o + tH(e), y: a };
				})(e)
		  )
		: wF(t)
		? (function (e) {
				var t = IF(e);
				return (t.top = t.top + e.clientTop), (t.left = t.left + e.clientLeft), (t.bottom = t.top + e.clientHeight), (t.right = t.left + e.clientWidth), (t.width = e.clientWidth), (t.height = e.clientHeight), (t.x = t.left), (t.y = t.top), t;
		  })(t)
		: sH(
				(function (e) {
					var t,
						n = NF(e),
						r = eH(e),
						i = null == (t = e.ownerDocument) ? void 0 : t.body,
						s = kF(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
						o = kF(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
						a = -r.scrollLeft + tH(e),
						l = -r.scrollTop;
					return "rtl" === OF(i || n).direction && (a += kF(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: l };
				})(NF(e))
		  );
}
function aH(e, t, n) {
	var r =
			"clippingParents" === t
				? (function (e) {
						var t = iH(DF(e)),
							n = ["absolute", "fixed"].indexOf(OF(e).position) >= 0 && CF(e) ? FF(e) : e;
						return wF(n)
							? t.filter(function (e) {
									return wF(e) && LF(e, n) && "body" !== xF(e);
							  })
							: [];
				  })(e)
				: [].concat(t),
		i = [].concat(r, [n]),
		s = i[0],
		o = i.reduce(function (t, n) {
			var r = oH(e, n);
			return (t.top = kF(r.top, t.top)), (t.right = AF(r.right, t.right)), (t.bottom = AF(r.bottom, t.bottom)), (t.left = kF(r.left, t.left)), t;
		}, oH(e, s));
	return (o.width = o.right - o.left), (o.height = o.bottom - o.top), (o.x = o.left), (o.y = o.top), o;
}
function lH(e) {
	var t,
		n = e.reference,
		r = e.element,
		i = e.placement,
		s = i ? TF(i) : null,
		o = i ? jF(i) : null,
		a = n.x + n.width / 2 - r.width / 2,
		l = n.y + n.height / 2 - r.height / 2;
	switch (s) {
		case lF:
			t = { x: a, y: n.y - r.height };
			break;
		case uF:
			t = { x: a, y: n.y + n.height };
			break;
		case cF:
			t = { x: n.x + n.width, y: l };
			break;
		case hF:
			t = { x: n.x - r.width, y: l };
			break;
		default:
			t = { x: n.x, y: n.y };
	}
	var u = s ? HF(s) : null;
	if (null != u) {
		var c = "y" === u ? "height" : "width";
		switch (o) {
			case fF:
				t[u] = t[u] - (n[c] / 2 - r[c] / 2);
				break;
			case "end":
				t[u] = t[u] + (n[c] / 2 - r[c] / 2);
		}
	}
	return t;
}
function uH(e, t) {
	void 0 === t && (t = {});
	var n = t,
		r = n.placement,
		i = void 0 === r ? e.placement : r,
		s = n.boundary,
		o = void 0 === s ? "clippingParents" : s,
		a = n.rootBoundary,
		l = void 0 === a ? mF : a,
		u = n.elementContext,
		c = void 0 === u ? vF : u,
		h = n.altBoundary,
		d = void 0 !== h && h,
		p = n.padding,
		f = void 0 === p ? 0 : p,
		m = UF("number" != typeof f ? f : zF(f, pF)),
		v = c === vF ? "reference" : vF,
		g = e.rects.popper,
		y = e.elements[d ? v : c],
		b = aH(wF(y) ? y : y.contextElement || NF(e.elements.popper), o, l),
		x = IF(e.elements.reference),
		_ = lH({ reference: x, element: g, strategy: "absolute", placement: i }),
		w = sH(Object.assign({}, g, _)),
		C = c === vF ? w : x,
		S = { top: b.top - C.top + m.top, bottom: C.bottom - b.bottom + m.bottom, left: b.left - C.left + m.left, right: C.right - b.right + m.right },
		E = e.modifiersData.offset;
	if (c === vF && E) {
		var T = E[i];
		Object.keys(S).forEach(function (e) {
			var t = [cF, uF].indexOf(e) >= 0 ? 1 : -1,
				n = [lF, uF].indexOf(e) >= 0 ? "y" : "x";
			S[e] += T[n] * t;
		});
	}
	return S;
}
var cH = {
	name: "flip",
	enabled: !0,
	phase: "main",
	fn: function (e) {
		var t = e.state,
			n = e.options,
			r = e.name;
		if (!t.modifiersData[r]._skip) {
			for (
				var i = n.mainAxis,
					s = void 0 === i || i,
					o = n.altAxis,
					a = void 0 === o || o,
					l = n.fallbackPlacements,
					u = n.padding,
					c = n.boundary,
					h = n.rootBoundary,
					d = n.altBoundary,
					p = n.flipVariations,
					f = void 0 === p || p,
					m = n.allowedAutoPlacements,
					v = t.options.placement,
					g = TF(v),
					y =
						l ||
						(g === v || !f
							? [ZF(v)]
							: (function (e) {
									if (TF(e) === dF) return [];
									var t = ZF(e);
									return [QF(e), t, QF(t)];
							  })(v)),
					b = [v].concat(y).reduce(function (e, n) {
						return e.concat(
							TF(n) === dF
								? (function (e, t) {
										void 0 === t && (t = {});
										var n = t,
											r = n.placement,
											i = n.boundary,
											s = n.rootBoundary,
											o = n.padding,
											a = n.flipVariations,
											l = n.allowedAutoPlacements,
											u = void 0 === l ? yF : l,
											c = jF(r),
											h = c
												? a
													? gF
													: gF.filter(function (e) {
															return jF(e) === c;
													  })
												: pF,
											d = h.filter(function (e) {
												return u.indexOf(e) >= 0;
											});
										0 === d.length && (d = h);
										var p = d.reduce(function (t, n) {
											return (t[n] = uH(e, { placement: n, boundary: i, rootBoundary: s, padding: o })[TF(n)]), t;
										}, {});
										return Object.keys(p).sort(function (e, t) {
											return p[e] - p[t];
										});
								  })(t, { placement: n, boundary: c, rootBoundary: h, padding: u, flipVariations: f, allowedAutoPlacements: m })
								: n
						);
					}, []),
					x = t.rects.reference,
					_ = t.rects.popper,
					w = new Map(),
					C = !0,
					S = b[0],
					E = 0;
				E < b.length;
				E++
			) {
				var T = b[E],
					k = TF(T),
					A = jF(T) === fF,
					M = [lF, uF].indexOf(k) >= 0,
					I = M ? "width" : "height",
					R = uH(t, { placement: T, boundary: c, rootBoundary: h, altBoundary: d, padding: u }),
					L = M ? (A ? cF : hF) : A ? uF : lF;
				x[I] > _[I] && (L = ZF(L));
				var O = ZF(L),
					P = [];
				if (
					(s && P.push(R[k] <= 0),
					a && P.push(R[L] <= 0, R[O] <= 0),
					P.every(function (e) {
						return e;
					}))
				) {
					(S = T), (C = !1);
					break;
				}
				w.set(T, P);
			}
			if (C)
				for (
					var N = function (e) {
							var t = b.find(function (t) {
								var n = w.get(t);
								if (n)
									return n.slice(0, e).every(function (e) {
										return e;
									});
							});
							if (t) return (S = t), "break";
						},
						D = f ? 3 : 1;
					D > 0;
					D--
				) {
					if ("break" === N(D)) break;
				}
			t.placement !== S && ((t.modifiersData[r]._skip = !0), (t.placement = S), (t.reset = !0));
		}
	},
	requiresIfExists: ["offset"],
	data: { _skip: !1 }
};
function hH(e, t, n) {
	return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x };
}
function dH(e) {
	return [lF, cF, uF, hF].some(function (t) {
		return e[t] >= 0;
	});
}
var pH = {
	name: "hide",
	enabled: !0,
	phase: "main",
	requiresIfExists: ["preventOverflow"],
	fn: function (e) {
		var t = e.state,
			n = e.name,
			r = t.rects.reference,
			i = t.rects.popper,
			s = t.modifiersData.preventOverflow,
			o = uH(t, { elementContext: "reference" }),
			a = uH(t, { altBoundary: !0 }),
			l = hH(o, r),
			u = hH(a, i, s),
			c = dH(l),
			h = dH(u);
		(t.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: h }), (t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": h }));
	}
};
var fH = {
	name: "offset",
	enabled: !0,
	phase: "main",
	requires: ["popperOffsets"],
	fn: function (e) {
		var t = e.state,
			n = e.options,
			r = e.name,
			i = n.offset,
			s = void 0 === i ? [0, 0] : i,
			o = yF.reduce(function (e, n) {
				return (
					(e[n] = (function (e, t, n) {
						var r = TF(e),
							i = [hF, lF].indexOf(r) >= 0 ? -1 : 1,
							s = "function" == typeof n ? n(Object.assign({}, t, { placement: e })) : n,
							o = s[0],
							a = s[1];
						return (o = o || 0), (a = (a || 0) * i), [hF, cF].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a };
					})(n, t.rects, s)),
					e
				);
			}, {}),
			a = o[t.placement],
			l = a.x,
			u = a.y;
		null != t.modifiersData.popperOffsets && ((t.modifiersData.popperOffsets.x += l), (t.modifiersData.popperOffsets.y += u)), (t.modifiersData[r] = o);
	}
};
var mH = {
	name: "popperOffsets",
	enabled: !0,
	phase: "read",
	fn: function (e) {
		var t = e.state,
			n = e.name;
		t.modifiersData[n] = lH({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement });
	},
	data: {}
};
var vH = {
	name: "preventOverflow",
	enabled: !0,
	phase: "main",
	fn: function (e) {
		var t = e.state,
			n = e.options,
			r = e.name,
			i = n.mainAxis,
			s = void 0 === i || i,
			o = n.altAxis,
			a = void 0 !== o && o,
			l = n.boundary,
			u = n.rootBoundary,
			c = n.altBoundary,
			h = n.padding,
			d = n.tether,
			p = void 0 === d || d,
			f = n.tetherOffset,
			m = void 0 === f ? 0 : f,
			v = uH(t, { boundary: l, rootBoundary: u, padding: h, altBoundary: c }),
			g = TF(t.placement),
			y = jF(t.placement),
			b = !y,
			x = HF(g),
			_ = (function (e) {
				return "x" === e ? "y" : "x";
			})(x),
			w = t.modifiersData.popperOffsets,
			C = t.rects.reference,
			S = t.rects.popper,
			E = "function" == typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m,
			T = "number" == typeof E ? { mainAxis: E, altAxis: E } : Object.assign({ mainAxis: 0, altAxis: 0 }, E),
			k = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
			A = { x: 0, y: 0 };
		if (w) {
			if (s) {
				var M,
					I = "y" === x ? lF : hF,
					R = "y" === x ? uF : cF,
					L = "y" === x ? "height" : "width",
					O = w[x],
					P = O + v[I],
					N = O - v[R],
					D = p ? -S[L] / 2 : 0,
					B = y === fF ? C[L] : S[L],
					F = y === fF ? -S[L] : -C[L],
					H = t.elements.arrow,
					V = p && H ? RF(H) : { width: 0, height: 0 },
					U = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 },
					z = U[I],
					$ = U[R],
					j = VF(0, C[L], V[L]),
					W = b ? C[L] / 2 - D - j - z - T.mainAxis : B - j - z - T.mainAxis,
					G = b ? -C[L] / 2 + D + j + $ + T.mainAxis : F + j + $ + T.mainAxis,
					Y = t.elements.arrow && FF(t.elements.arrow),
					X = Y ? ("y" === x ? Y.clientTop || 0 : Y.clientLeft || 0) : 0,
					K = null != (M = null == k ? void 0 : k[x]) ? M : 0,
					q = O + G - K,
					Z = VF(p ? AF(P, O + W - K - X) : P, O, p ? kF(N, q) : N);
				(w[x] = Z), (A[x] = Z - O);
			}
			if (a) {
				var J,
					Q = "x" === x ? lF : hF,
					ee = "x" === x ? uF : cF,
					te = w[_],
					ne = "y" === _ ? "height" : "width",
					re = te + v[Q],
					ie = te - v[ee],
					se = -1 !== [lF, hF].indexOf(g),
					oe = null != (J = null == k ? void 0 : k[_]) ? J : 0,
					ae = se ? re : te - C[ne] - S[ne] - oe + T.altAxis,
					le = se ? te + C[ne] + S[ne] - oe - T.altAxis : ie,
					ue =
						p && se
							? (function (e, t, n) {
									var r = VF(e, t, n);
									return r > n ? n : r;
							  })(ae, te, le)
							: VF(p ? ae : re, te, p ? le : ie);
				(w[_] = ue), (A[_] = ue - te);
			}
			t.modifiersData[r] = A;
		}
	},
	requiresIfExists: ["offset"]
};
function gH(e, t, n) {
	void 0 === n && (n = !1);
	var r = CF(t),
		i =
			CF(t) &&
			(function (e) {
				var t = e.getBoundingClientRect(),
					n = MF(t.width) / e.offsetWidth || 1,
					r = MF(t.height) / e.offsetHeight || 1;
				return 1 !== n || 1 !== r;
			})(t),
		s = NF(t),
		o = IF(e, i),
		a = { scrollLeft: 0, scrollTop: 0 },
		l = { x: 0, y: 0 };
	return (
		(r || (!r && !n)) &&
			(("body" !== xF(t) || nH(s)) &&
				(a = (function (e) {
					return e !== _F(e) && CF(e)
						? (function (e) {
								return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
						  })(e)
						: eH(e);
				})(t)),
			CF(t) ? (((l = IF(t, !0)).x += t.clientLeft), (l.y += t.clientTop)) : s && (l.x = tH(s))),
		{ x: o.left + a.scrollLeft - l.x, y: o.top + a.scrollTop - l.y, width: o.width, height: o.height }
	);
}
function yH(e) {
	var t = new Map(),
		n = new Set(),
		r = [];
	function i(e) {
		n.add(e.name),
			[].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
				if (!n.has(e)) {
					var r = t.get(e);
					r && i(r);
				}
			}),
			r.push(e);
	}
	return (
		e.forEach(function (e) {
			t.set(e.name, e);
		}),
		e.forEach(function (e) {
			n.has(e.name) || i(e);
		}),
		r
	);
}
function bH(e) {
	var t;
	return function () {
		return (
			t ||
				(t = new Promise(function (n) {
					Promise.resolve().then(function () {
						(t = void 0), n(e());
					});
				})),
			t
		);
	};
}
var xH = { placement: "bottom", modifiers: [], strategy: "absolute" };
function _H() {
	for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
	return !t.some(function (e) {
		return !(e && "function" == typeof e.getBoundingClientRect);
	});
}
function wH(e) {
	void 0 === e && (e = {});
	var t = e,
		n = t.defaultModifiers,
		r = void 0 === n ? [] : n,
		i = t.defaultOptions,
		s = void 0 === i ? xH : i;
	return function (e, t, n) {
		void 0 === n && (n = s);
		var i = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, xH, s), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} },
			o = [],
			a = !1,
			l = {
				state: i,
				setOptions: function (n) {
					var a = "function" == typeof n ? n(i.options) : n;
					u(), (i.options = Object.assign({}, s, i.options, a)), (i.scrollParents = { reference: wF(e) ? iH(e) : e.contextElement ? iH(e.contextElement) : [], popper: iH(t) });
					var c = (function (e) {
						var t = yH(e);
						return bF.reduce(function (e, n) {
							return e.concat(
								t.filter(function (e) {
									return e.phase === n;
								})
							);
						}, []);
					})(
						(function (e) {
							var t = e.reduce(function (e, t) {
								var n = e[t.name];
								return (e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t), e;
							}, {});
							return Object.keys(t).map(function (e) {
								return t[e];
							});
						})([].concat(r, i.options.modifiers))
					);
					return (
						(i.orderedModifiers = c.filter(function (e) {
							return e.enabled;
						})),
						i.orderedModifiers.forEach(function (e) {
							var t = e.name,
								n = e.options,
								r = void 0 === n ? {} : n,
								s = e.effect;
							if ("function" == typeof s) {
								var a = s({ state: i, name: t, instance: l, options: r }),
									u = function () {};
								o.push(a || u);
							}
						}),
						l.update()
					);
				},
				forceUpdate: function () {
					if (!a) {
						var e = i.elements,
							t = e.reference,
							n = e.popper;
						if (_H(t, n)) {
							(i.rects = { reference: gH(t, FF(n), "fixed" === i.options.strategy), popper: RF(n) }),
								(i.reset = !1),
								(i.placement = i.options.placement),
								i.orderedModifiers.forEach(function (e) {
									return (i.modifiersData[e.name] = Object.assign({}, e.data));
								});
							for (var r = 0; r < i.orderedModifiers.length; r++)
								if (!0 !== i.reset) {
									var s = i.orderedModifiers[r],
										o = s.fn,
										u = s.options,
										c = void 0 === u ? {} : u,
										h = s.name;
									"function" == typeof o && (i = o({ state: i, options: c, name: h, instance: l }) || i);
								} else (i.reset = !1), (r = -1);
						}
					}
				},
				update: bH(function () {
					return new Promise(function (e) {
						l.forceUpdate(), e(i);
					});
				}),
				destroy: function () {
					u(), (a = !0);
				}
			};
		if (!_H(e, t)) return l;
		function u() {
			o.forEach(function (e) {
				return e();
			}),
				(o = []);
		}
		return (
			l.setOptions(n).then(function (e) {
				!a && n.onFirstUpdate && n.onFirstUpdate(e);
			}),
			l
		);
	};
}
wH(), wH({ defaultModifiers: [KF, mH, YF, EF] });
var CH = wH({ defaultModifiers: [KF, mH, YF, EF, fH, cH, vH, $F, pH] });
const SH = (e) => {
		const t = [],
			n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
				acceptNode: (e) => {
					const t = "INPUT" === e.tagName && "hidden" === e.type;
					return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 || e === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
				}
			});
		for (; n.nextNode(); ) t.push(n.currentNode);
		return t;
	},
	EH = (e, t) => {
		for (const n of e) if (!TH(n, t)) return n;
	},
	TH = (e, t) => {
		if ("hidden" === getComputedStyle(e).visibility) return !0;
		for (; e; ) {
			if (t && e === t) return !1;
			if ("none" === getComputedStyle(e).display) return !0;
			e = e.parentElement;
		}
		return !1;
	},
	kH = (e, t) => {
		if (e && e.focus) {
			const n = document.activeElement;
			e.focus({ preventScroll: !0 }), e !== n && ((e) => e instanceof HTMLInputElement && "select" in e)(e) && t && e.select();
		}
	};
function AH(e, t) {
	const n = [...e],
		r = e.indexOf(t);
	return -1 !== r && n.splice(r, 1), n;
}
const MH = (() => {
		let e = [];
		return {
			push: (t) => {
				const n = e[0];
				n && t !== n && n.pause(), (e = AH(e, t)), e.unshift(t);
			},
			remove: (t) => {
				var n, r;
				(e = AH(e, t)), null == (r = null == (n = e[0]) ? void 0 : n.resume) || r.call(n);
			}
		};
	})(),
	IH = { cancelable: !0, bubbles: !1 },
	RH = Symbol("elFocusTrap");
var LH = IB(
	Tn({
		name: "ElFocusTrap",
		inheritAttrs: !1,
		props: { loop: Boolean, trapped: Boolean, focusTrapEl: Object, focusStartEl: { type: [Object, String], default: "first" } },
		emits: ["focusAfterTrapped", "focusAfterReleased", "focusin", "focusout", "focusout-prevented", "release-requested"],
		setup(e, { emit: t }) {
			const n = Qe();
			let r, i;
			((e) => {
				const t = (e) => {
					const t = e;
					t.key === bN.esc && AD.forEach((e) => e(t));
				};
				Vn(() => {
					0 === AD.length && document.addEventListener("keydown", t), GI && AD.push(e);
				}),
					$n(() => {
						(AD = AD.filter((t) => t !== e)), 0 === AD.length && GI && document.removeEventListener("keydown", t);
					});
			})((n) => {
				e.trapped && !s.paused && t("release-requested", n);
			});
			const s = {
					paused: !1,
					pause() {
						this.paused = !0;
					},
					resume() {
						this.paused = !1;
					}
				},
				o = (n) => {
					if (!e.loop && !e.trapped) return;
					if (s.paused) return;
					const { key: r, altKey: i, ctrlKey: o, metaKey: a, currentTarget: l, shiftKey: u } = n,
						{ loop: c } = e,
						h = r === bN.tab && !i && !o && !a,
						d = document.activeElement;
					if (h && d) {
						const e = l,
							[r, i] = ((e) => {
								const t = SH(e);
								return [EH(t, e), EH(t.reverse(), e)];
							})(e);
						r && i ? (u || d !== i ? u && [r, e].includes(d) && (n.preventDefault(), c && kH(i, !0), t("focusout-prevented")) : (n.preventDefault(), c && kH(r, !0), t("focusout-prevented"))) : d === e && (n.preventDefault(), t("focusout-prevented"));
					}
				};
			mn(RH, { focusTrapRef: n, onKeydown: o }),
				ds(
					() => e.focusTrapEl,
					(e) => {
						e && (n.value = e);
					},
					{ immediate: !0 }
				),
				ds([n], ([e], [t]) => {
					e && (e.addEventListener("keydown", o), e.addEventListener("focusin", u), e.addEventListener("focusout", c)), t && (t.removeEventListener("keydown", o), t.removeEventListener("focusin", u), t.removeEventListener("focusout", c));
				});
			const a = (e) => {
					t("focusAfterTrapped", e);
				},
				l = (e) => t("focusAfterReleased", e),
				u = (r) => {
					const o = it(n);
					if (!o) return;
					const a = r.target,
						l = a && o.contains(a);
					l && t("focusin", r), s.paused || (e.trapped && (l ? (i = a) : kH(i, !0)));
				},
				c = (r) => {
					const o = it(n);
					if (!s.paused && o)
						if (e.trapped) {
							const t = r.relatedTarget;
							ik(t) ||
								o.contains(t) ||
								setTimeout(() => {
									!s.paused && e.trapped && kH(i, !0);
								}, 0);
						} else {
							const e = r.target;
							(e && o.contains(e)) || t("focusout", r);
						}
				};
			async function h() {
				await ns();
				const t = it(n);
				if (t) {
					MH.push(s);
					const n = document.activeElement;
					r = n;
					if (!t.contains(n)) {
						const r = new Event("focus-trap.focus-after-trapped", IH);
						t.addEventListener("focus-trap.focus-after-trapped", a),
							t.dispatchEvent(r),
							r.defaultPrevented ||
								ns(() => {
									let r = e.focusStartEl;
									SR(r) || (kH(r), document.activeElement !== r && (r = "first")),
										"first" === r &&
											((e, t = !1) => {
												const n = document.activeElement;
												for (const r of e) if ((kH(r, t), document.activeElement !== n)) return;
											})(SH(t), !0),
										(document.activeElement !== n && "container" !== r) || kH(t);
								});
					}
				}
			}
			function d() {
				const e = it(n);
				if (e) {
					e.removeEventListener("focus-trap.focus-after-trapped", a);
					const t = new Event("focus-trap.focus-after-released", IH);
					e.addEventListener("focus-trap.focus-after-released", l), e.dispatchEvent(t), t.defaultPrevented || kH(null != r ? r : document.body, !0), e.removeEventListener("focus-trap.focus-after-released", a), MH.remove(s);
				}
			}
			return (
				Vn(() => {
					e.trapped && h(),
						ds(
							() => e.trapped,
							(e) => {
								e ? h() : d();
							}
						);
				}),
				$n(() => {
					e.trapped && d();
				}),
				{ onKeydown: o }
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return mi(e.$slots, "default", { handleKeydown: e.onKeydown });
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]
	]
);
const OH = uN({
		boundariesPadding: { type: Number, default: 0 },
		fallbackPlacements: { type: Array, default: () => [] },
		gpuAcceleration: { type: Boolean, default: !0 },
		offset: { type: Number, default: 12 },
		placement: { type: String, values: yF, default: "bottom" },
		popperOptions: { type: Object, default: () => ({}) },
		strategy: { type: String, values: ["fixed", "absolute"], default: "absolute" }
	}),
	PH = uN(
		c(u({}, OH), {
			id: String,
			style: { type: [String, Array, Object] },
			className: { type: [String, Array, Object] },
			effect: { type: String, default: "dark" },
			visible: Boolean,
			enterable: { type: Boolean, default: !0 },
			pure: Boolean,
			focusOnShow: { type: Boolean, default: !1 },
			trapping: { type: Boolean, default: !1 },
			popperClass: { type: [String, Array, Object] },
			popperStyle: { type: [String, Array, Object] },
			referenceEl: { type: Object },
			triggerTargetEl: { type: Object },
			stopPopperMouseEvent: { type: Boolean, default: !0 },
			ariaLabel: { type: String, default: void 0 },
			virtualTriggering: Boolean,
			zIndex: Number
		})
	),
	NH = (e, t) => {
		const { placement: n, strategy: r, popperOptions: i } = e,
			s = c(u({ placement: n, strategy: r }, i), { modifiers: DH(e) });
		return (
			(function (e, { arrowEl: t, arrowOffset: n }) {
				e.modifiers.push({ name: "arrow", options: { element: t, padding: null != n ? n : 5 } });
			})(s, t),
			(function (e, t) {
				t && (e.modifiers = [...e.modifiers, ...(null != t ? t : [])]);
			})(s, null == i ? void 0 : i.modifiers),
			s
		);
	};
function DH(e) {
	const { offset: t, gpuAcceleration: n, fallbackPlacements: r } = e;
	return [
		{ name: "offset", options: { offset: [0, null != t ? t : 12] } },
		{ name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } },
		{ name: "flip", options: { padding: 5, fallbackPlacements: null != r ? r : [] } },
		{ name: "computeStyles", options: { gpuAcceleration: n, adaptive: n } }
	];
}
var BH = IB(
	Tn(
		c(u({}, { name: "ElPopperContent" }), {
			props: PH,
			emits: ["mouseenter", "mouseleave", "focus", "blur", "close"],
			setup(e, { expose: t, emit: n }) {
				const r = e,
					{ popperInstanceRef: i, contentRef: s, triggerRef: o, role: a } = vn(eD, void 0),
					l = vn(YN, void 0),
					{ nextZIndex: h } = HD(),
					d = BD("popper"),
					p = Qe(),
					f = Qe("first"),
					m = Qe(),
					v = Qe();
				mn(tD, { arrowRef: m, arrowOffset: v }), l && (l.addInputId || l.removeInputId) && mn(YN, c(u({}, l), { addInputId: yR, removeInputId: yR }));
				const g = Qe(r.zIndex || h()),
					y = Qe(!1);
				let b;
				const x = ht(
						() =>
							((e) => {
								if (GI) return tR(e);
							})(r.referenceEl) || it(o)
					),
					_ = ht(() => [{ zIndex: it(g) }, r.popperStyle]),
					w = ht(() => [d.b(), d.is("pure", r.pure), d.is(r.effect), r.popperClass]),
					C = ht(() => (a && "dialog" === a.value ? "false" : void 0)),
					S = (e = !0) => {
						var t;
						null == (t = it(i)) || t.update(), e && (g.value = r.zIndex || h());
					},
					E = () => {
						var e, t;
						const n = { name: "eventListeners", enabled: r.visible };
						null == (t = null == (e = it(i)) ? void 0 : e.setOptions) || t.call(e, (e) => c(u({}, e), { modifiers: [...(e.modifiers || []), n] })), S(!1), r.visible && r.focusOnShow ? (y.value = !0) : !1 === r.visible && (y.value = !1);
					},
					T = () => {
						n("focus");
					},
					k = () => {
						(f.value = "first"), n("blur");
					},
					A = (e) => {
						var t;
						r.visible && !y.value && (e.relatedTarget && (null == (t = e.relatedTarget) || t.focus()), e.target && (f.value = e.target), (y.value = !0));
					},
					M = () => {
						r.trapping || (y.value = !1);
					},
					I = () => {
						(y.value = !1), n("close");
					};
				return (
					Vn(() => {
						let e;
						ds(
							x,
							(t) => {
								var n;
								null == e || e();
								const o = it(i);
								if ((null == (n = null == o ? void 0 : o.destroy) || n.call(o), t)) {
									const n = it(p);
									(s.value = n),
										(i.value = (({ referenceEl: e, popperContentEl: t, arrowEl: n }) => {
											const i = NH(r, { arrowEl: n, arrowOffset: it(v) });
											return CH(e, t, i);
										})({ referenceEl: t, popperContentEl: n, arrowEl: it(m) })),
										(e = ds(
											() => t.getBoundingClientRect(),
											() => S(),
											{ immediate: !0 }
										));
								} else i.value = void 0;
							},
							{ immediate: !0 }
						),
							ds(
								() => r.triggerTargetEl,
								(e, t) => {
									null == b || b(), (b = void 0);
									const n = it(e || p.value),
										i = it(t || p.value);
									if (HR(n)) {
										const { ariaLabel: e, id: t } = at(r);
										b = ds(
											[a, e, C, t],
											(e) => {
												["role", "aria-label", "aria-modal", "id"].forEach((t, r) => {
													ik(e[r]) ? n.removeAttribute(t) : n.setAttribute(t, e[r]);
												});
											},
											{ immediate: !0 }
										);
									}
									HR(i) &&
										["role", "aria-label", "aria-modal", "id"].forEach((e) => {
											i.removeAttribute(e);
										});
								},
								{ immediate: !0 }
							),
							ds(() => r.visible, E, { immediate: !0 }),
							ds(
								() => NH(r, { arrowEl: it(m), arrowOffset: it(v) }),
								(e) => {
									var t;
									return null == (t = i.value) ? void 0 : t.setOptions(e);
								}
							);
					}),
					$n(() => {
						null == b || b(), (b = void 0);
					}),
					t({ popperContentRef: p, popperInstanceRef: i, updatePopper: S, contentStyle: _ }),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ ref_key: "popperContentRef", ref: p, style: pt(it(_)), class: gt(it(w)), tabindex: "-1", onMouseenter: t[0] || (t[0] = (t) => e.$emit("mouseenter", t)), onMouseleave: t[1] || (t[1] = (t) => e.$emit("mouseleave", t)) },
							[
								ri(
									it(LH),
									{ trapped: y.value, "trap-on-focus-in": !0, "focus-trap-el": p.value, "focus-start-el": f.value, onFocusAfterTrapped: T, onFocusAfterReleased: k, onFocusin: A, onFocusoutPrevented: M, onReleaseRequested: I },
									{ default: cn(() => [mi(e.$slots, "default")]), _: 3 },
									8,
									["trapped", "focus-trap-el", "focus-start-el"]
								)
							],
							38
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]
);
const FH = mN(eF),
	HH = BD("tooltip"),
	VH = uN(
		c(u(u({}, OD), PH), {
			appendTo: { type: [String, Object], default: RD },
			content: { type: String, default: "" },
			rawContent: { type: Boolean, default: !1 },
			persistent: Boolean,
			ariaLabel: String,
			visible: { type: Boolean, default: null },
			transition: { type: String, default: `${HH.namespace.value}-fade-in-linear` },
			teleported: { type: Boolean, default: !0 },
			disabled: { type: Boolean }
		})
	),
	UH = uN(c(u({}, oF), { disabled: Boolean, trigger: { type: [String, Array], default: "hover" }, triggerKeys: { type: Array, default: () => [bN.enter, bN.space] } })),
	zH = uN({ openDelay: { type: Number }, visibleArrow: { type: Boolean, default: void 0 }, hideAfter: { type: Number, default: 200 }, showArrow: { type: Boolean, default: !0 } }),
	$H = Symbol("elTooltip");
var jH = IB(
	Tn({
		name: "ElTooltipContent",
		components: { ElPopperContent: BH },
		inheritAttrs: !1,
		props: VH,
		setup(e) {
			const t = Qe(null),
				n = Qe(!1),
				r = Qe(!1),
				i = Qe(!1),
				s = Qe(!1),
				{ controlled: o, id: a, open: l, trigger: u, onClose: c, onOpen: h, onShow: d, onHide: p, onBeforeShow: f, onBeforeHide: m } = vn($H, void 0),
				v = ht(() => e.persistent);
			$n(() => {
				s.value = !0;
			});
			const g = ht(() => !!it(v) || it(l)),
				y = ht(() => !e.disabled && it(l)),
				b = ht(() => {
					var t;
					return null != (t = e.style) ? t : {};
				}),
				x = ht(() => !it(l)),
				_ = () => {
					if (it(o)) return !0;
				},
				w = PI(_, () => {
					e.enterable && "hover" === it(u) && h();
				}),
				C = PI(_, () => {
					"hover" === it(u) && c();
				});
			let S;
			return (
				ds(
					() => it(l),
					(e) => {
						e || null == S || S();
					},
					{ flush: "post" }
				),
				{
					ariaHidden: x,
					entering: r,
					leaving: i,
					id: a,
					intermediateOpen: n,
					contentStyle: b,
					contentRef: t,
					destroyed: s,
					shouldRender: g,
					shouldShow: y,
					onClose: c,
					open: l,
					onAfterShow: () => {
						d(),
							(S = sR(
								ht(() => {
									var e;
									return null == (e = t.value) ? void 0 : e.popperContentRef;
								}),
								() => {
									if (it(o)) return;
									"hover" !== it(u) && c();
								}
							));
					},
					onBeforeEnter: () => {
						var e, n;
						null == (n = null == (e = t.value) ? void 0 : e.updatePopper) || n.call(e), null == f || f();
					},
					onBeforeLeave: () => {
						null == m || m();
					},
					onContentEnter: w,
					onContentLeave: C,
					onTransitionLeave: () => {
						p();
					},
					onBlur: () => {
						e.virtualTriggering || c();
					}
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-popper-content");
				return (
					Wr(),
					qr(
						Lr,
						{ disabled: !e.teleported, to: e.appendTo },
						[
							ri(
								lo,
								{ name: e.transition, onAfterLeave: e.onTransitionLeave, onBeforeEnter: e.onBeforeEnter, onAfterEnter: e.onAfterShow, onBeforeLeave: e.onBeforeLeave },
								{
									default: cn(() => [
										e.shouldRender
											? yr(
													(Wr(),
													qr(
														o,
														hi({ key: 0, id: e.id, ref: "contentRef" }, e.$attrs, {
															"aria-label": e.ariaLabel,
															"aria-hidden": e.ariaHidden,
															"boundaries-padding": e.boundariesPadding,
															"fallback-placements": e.fallbackPlacements,
															"gpu-acceleration": e.gpuAcceleration,
															offset: e.offset,
															placement: e.placement,
															"popper-options": e.popperOptions,
															strategy: e.strategy,
															effect: e.effect,
															enterable: e.enterable,
															pure: e.pure,
															"popper-class": e.popperClass,
															"popper-style": [e.popperStyle, e.contentStyle],
															"reference-el": e.referenceEl,
															"trigger-target-el": e.triggerTargetEl,
															visible: e.shouldShow,
															"z-index": e.zIndex,
															onMouseenter: e.onContentEnter,
															onMouseleave: e.onContentLeave,
															onBlur: e.onBlur,
															onClose: e.onClose
														}),
														{ default: cn(() => [ai(" Workaround bug #6378 "), e.destroyed ? ai("v-if", !0) : mi(e.$slots, "default", { key: 0 })]), _: 3 },
														16,
														[
															"id",
															"aria-label",
															"aria-hidden",
															"boundaries-padding",
															"fallback-placements",
															"gpu-acceleration",
															"offset",
															"placement",
															"popper-options",
															"strategy",
															"effect",
															"enterable",
															"pure",
															"popper-class",
															"popper-style",
															"reference-el",
															"trigger-target-el",
															"visible",
															"z-index",
															"onMouseenter",
															"onMouseleave",
															"onBlur",
															"onClose"
														]
													)),
													[[Wo, e.shouldShow]]
											  )
											: ai("v-if", !0)
									]),
									_: 3
								},
								8,
								["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"]
							)
						],
						8,
						["disabled", "to"]
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]
	]
);
const WH = (e, t, n) => (r) => {
	((e, t) => (_R(e) ? e.includes(t) : e === t))(it(e), t) && n(r);
};
var GH = IB(
	Tn({
		name: "ElTooltipTrigger",
		components: { ElPopperTrigger: aF },
		props: UH,
		setup(e) {
			const t = BD("tooltip"),
				{ controlled: n, id: r, open: i, onOpen: s, onClose: o, onToggle: a } = vn($H, void 0),
				l = Qe(null),
				u = () => {
					if (it(n) || e.disabled) return !0;
				},
				c = ut(e, "trigger"),
				h = PI(u, WH(c, "hover", s)),
				d = PI(u, WH(c, "hover", o)),
				p = PI(
					u,
					WH(c, "click", (e) => {
						0 === e.button && a(e);
					})
				),
				f = PI(u, WH(c, "focus", s));
			return {
				onBlur: PI(u, WH(c, "focus", o)),
				onContextMenu: PI(
					u,
					WH(c, "contextmenu", (e) => {
						e.preventDefault(), a(e);
					})
				),
				onFocus: f,
				onMouseenter: h,
				onMouseleave: d,
				onClick: p,
				onKeydown: PI(u, (t) => {
					const { code: n } = t;
					e.triggerKeys.includes(n) && (t.preventDefault(), a(t));
				}),
				open: i,
				id: r,
				triggerRef: l,
				ns: t
			};
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-popper-trigger");
				return (
					Wr(),
					qr(
						o,
						{
							id: e.id,
							"virtual-ref": e.virtualRef,
							open: e.open,
							"virtual-triggering": e.virtualTriggering,
							class: gt(e.ns.e("trigger")),
							onBlur: e.onBlur,
							onClick: e.onClick,
							onContextmenu: e.onContextMenu,
							onFocus: e.onFocus,
							onMouseenter: e.onMouseenter,
							onMouseleave: e.onMouseleave,
							onKeydown: e.onKeydown
						},
						{ default: cn(() => [mi(e.$slots, "default")]), _: 3 },
						8,
						["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]
	]
);
const {
		useModelToggleProps: YH,
		useModelToggle: XH,
		useModelToggleEmits: KH
	} = ((e) => {
		const t = `update:${e}`,
			n = `onUpdate:${e}`;
		return {
			useModelToggle: ({ indicator: r, toggleReason: i, shouldHideWhenRouteChanges: s, shouldProceed: o, onShow: a, onHide: l }) => {
				const c = Si(),
					{ emit: h } = c,
					d = c.props,
					p = ht(() => CR(d[n])),
					f = ht(() => null === d[e]),
					m = (e) => {
						!0 !== r.value && ((r.value = !0), i && (i.value = e), CR(a) && a(e));
					},
					v = (e) => {
						!1 !== r.value && ((r.value = !1), i && (i.value = e), CR(l) && l(e));
					},
					g = (e) => {
						if (!0 === d.disabled || (CR(o) && !o())) return;
						const n = p.value && GI;
						n && h(t, !0), (!f.value && n) || m(e);
					},
					y = (e) => {
						if (!0 === d.disabled || !GI) return;
						const n = p.value && GI;
						n && h(t, !1), (!f.value && n) || v(e);
					},
					b = (e) => {
						YI(e) && (d.disabled && e ? p.value && h(t, !1) : r.value !== e && (e ? m() : v()));
					};
				return (
					ds(() => d[e], b),
					s &&
						void 0 !== c.appContext.config.globalProperties.$route &&
						ds(
							() => u({}, c.proxy.$route),
							() => {
								s.value && r.value && y();
							}
						),
					Vn(() => {
						b(d[e]);
					}),
					{
						hide: y,
						show: g,
						toggle: () => {
							r.value ? y() : g();
						}
					}
				);
			},
			useModelToggleProps: { [e]: ED, [n]: TD },
			useModelToggleEmits: [t]
		};
	})("visible"),
	qH = Tn({
		name: "ElTooltip",
		components: { ElPopper: FH, ElPopperArrow: nF, ElTooltipContent: jH, ElTooltipTrigger: GH },
		props: u(u(u(u(u(u({}, QB), YH), VH), UH), tF), zH),
		emits: [...KH, "before-show", "before-hide", "show", "hide", "open", "close"],
		setup(e, { emit: t }) {
			LD();
			const n = ht(() => (BR(e.openDelay), e.openDelay || e.showAfter)),
				r = ht(() => (BR(e.visibleArrow), YI(e.visibleArrow) ? e.visibleArrow : e.showArrow)),
				i = gD(),
				s = Qe(null),
				o = Qe(null),
				a = () => {
					var e;
					const t = it(s);
					t && (null == (e = t.popperInstanceRef) || e.update());
				},
				l = Qe(!1),
				u = Qe(void 0),
				{ show: c, hide: h } = XH({ indicator: l, toggleReason: u }),
				{ onOpen: d, onClose: p } = PD({ showAfter: n, hideAfter: ut(e, "hideAfter"), open: c, close: h }),
				f = ht(() => YI(e.visible));
			mn($H, {
				controlled: f,
				id: i,
				open: Ve(l),
				trigger: ut(e, "trigger"),
				onOpen: (e) => {
					d(e);
				},
				onClose: (e) => {
					p(e);
				},
				onToggle: (e) => {
					it(l) ? p(e) : d(e);
				},
				onShow: () => {
					t("show", u.value);
				},
				onHide: () => {
					t("hide", u.value);
				},
				onBeforeShow: () => {
					t("before-show", u.value);
				},
				onBeforeHide: () => {
					t("before-hide", u.value);
				},
				updatePopper: a
			}),
				ds(
					() => e.disabled,
					(e) => {
						e && l.value && (l.value = !1);
					}
				);
			return {
				compatShowAfter: n,
				compatShowArrow: r,
				popperRef: s,
				contentRef: o,
				open: l,
				hide: h,
				isFocusInsideContent: () => {
					var e, t;
					const n = null == (t = null == (e = o.value) ? void 0 : e.contentRef) ? void 0 : t.popperContentRef;
					return n && n.contains(document.activeElement);
				},
				updatePopper: a,
				onOpen: d,
				onClose: p
			};
		}
	}),
	ZH = ["innerHTML"],
	JH = { key: 1 };
const QH = mN(
		IB(qH, [
			[
				"render",
				function (e, t, n, r, i, s) {
					const o = Or("el-tooltip-trigger"),
						a = Or("el-popper-arrow"),
						l = Or("el-tooltip-content"),
						u = Or("el-popper");
					return (
						Wr(),
						qr(
							u,
							{ ref: "popperRef", role: e.role },
							{
								default: cn(() => [
									ri(o, { disabled: e.disabled, trigger: e.trigger, "trigger-keys": e.triggerKeys, "virtual-ref": e.virtualRef, "virtual-triggering": e.virtualTriggering }, { default: cn(() => [e.$slots.default ? mi(e.$slots, "default", { key: 0 }) : ai("v-if", !0)]), _: 3 }, 8, [
										"disabled",
										"trigger",
										"trigger-keys",
										"virtual-ref",
										"virtual-triggering"
									]),
									ri(
										l,
										{
											ref: "contentRef",
											"aria-label": e.ariaLabel,
											"boundaries-padding": e.boundariesPadding,
											content: e.content,
											disabled: e.disabled,
											effect: e.effect,
											enterable: e.enterable,
											"fallback-placements": e.fallbackPlacements,
											"hide-after": e.hideAfter,
											"gpu-acceleration": e.gpuAcceleration,
											offset: e.offset,
											persistent: e.persistent,
											"popper-class": e.popperClass,
											"popper-style": e.popperStyle,
											placement: e.placement,
											"popper-options": e.popperOptions,
											pure: e.pure,
											"raw-content": e.rawContent,
											"reference-el": e.referenceEl,
											"trigger-target-el": e.triggerTargetEl,
											"show-after": e.compatShowAfter,
											strategy: e.strategy,
											teleported: e.teleported,
											transition: e.transition,
											"virtual-triggering": e.virtualTriggering,
											"z-index": e.zIndex,
											"append-to": e.appendTo
										},
										{
											default: cn(() => [
												mi(e.$slots, "content", {}, () => [e.rawContent ? (Wr(), Kr("span", { key: 0, innerHTML: e.content }, null, 8, ZH)) : (Wr(), Kr("span", JH, bt(e.content), 1))]),
												e.compatShowArrow ? (Wr(), qr(a, { key: 0, "arrow-offset": e.arrowOffset }, null, 8, ["arrow-offset"])) : ai("v-if", !0)
											]),
											_: 3
										},
										8,
										[
											"aria-label",
											"boundaries-padding",
											"content",
											"disabled",
											"effect",
											"enterable",
											"fallback-placements",
											"hide-after",
											"gpu-acceleration",
											"offset",
											"persistent",
											"popper-class",
											"popper-style",
											"placement",
											"popper-options",
											"pure",
											"raw-content",
											"reference-el",
											"trigger-target-el",
											"show-after",
											"strategy",
											"teleported",
											"transition",
											"virtual-triggering",
											"z-index",
											"append-to"
										]
									)
								]),
								_: 3
							},
							8,
							["role"]
						)
					);
				}
			],
			["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]
		])
	),
	eV = uN({
		valueKey: { type: String, default: "value" },
		modelValue: { type: [String, Number], default: "" },
		debounce: { type: Number, default: 300 },
		placement: { type: String, values: ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"], default: "bottom-start" },
		fetchSuggestions: { type: [Function, Array], default: yR },
		popperClass: { type: String, default: "" },
		triggerOnFocus: { type: Boolean, default: !0 },
		selectWhenUnmatched: { type: Boolean, default: !1 },
		hideLoading: { type: Boolean, default: !1 },
		label: { type: String },
		teleported: VH.teleported,
		highlightFirstItem: { type: Boolean, default: !1 }
	}),
	tV = { [_N]: (e) => SR(e), input: (e) => SR(e), change: (e) => SR(e), focus: (e) => e instanceof FocusEvent, blur: (e) => e instanceof FocusEvent, clear: () => !0, select: (e) => ER(e) },
	nV = ["aria-expanded", "aria-owns"],
	rV = { key: 0 },
	iV = ["id", "aria-selected", "onClick"];
const sV = mN(
		IB(
			Tn(
				c(u({}, { name: "ElAutocomplete", inheritAttrs: !1 }), {
					props: eV,
					emits: tV,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							i = HN(),
							s = ys(),
							o = BD("autocomplete"),
							a = Qe(),
							l = Qe(),
							u = Qe(),
							c = Qe();
						let h = !1;
						const d = Qe([]),
							p = Qe(-1),
							f = Qe(""),
							m = Qe(!1),
							v = Qe(!1),
							g = Qe(!1),
							y = ht(() => o.b(String(DN()))),
							b = ht(() => s.style),
							x = ht(() => (d.value.length > 0 || g.value) && m.value),
							_ = ht(() => !r.hideLoading && g.value),
							w = async () => {
								await ns(), x.value && (f.value = `${a.value.$el.offsetWidth}px`);
							},
							C = QT(async (e) => {
								if (v.value) return;
								const t = (e) => {
									(g.value = !1), v.value || (_R(e) ? ((d.value = e), (p.value = r.highlightFirstItem ? 0 : -1)) : $R("ElAutocomplete", "autocomplete suggestions must be an array"));
								};
								if (((g.value = !0), _R(r.fetchSuggestions))) t(r.fetchSuggestions);
								else {
									const n = await r.fetchSuggestions(e, t);
									_R(n) && t(n);
								}
							}, r.debounce),
							S = (e) => {
								const t = !!e;
								if ((n("input", e), n(_N, e), (v.value = !1), m.value || (m.value = h && t), !r.triggerOnFocus && !e)) return (v.value = !0), void (d.value = []);
								h && t && (h = !1), C(e);
							},
							E = (e) => {
								n("change", e);
							},
							T = (e) => {
								(m.value = !0), n("focus", e), r.triggerOnFocus && C(String(r.modelValue));
							},
							k = (e) => {
								n("blur", e);
							},
							A = () => {
								(m.value = !1), (h = !0), n(_N, ""), n("clear");
							},
							M = async () => {
								x.value && p.value >= 0 && p.value < d.value.length ? L(d.value[p.value]) : r.selectWhenUnmatched && (n("select", { value: r.modelValue }), await ns(), (d.value = []), (p.value = -1));
							},
							I = (e) => {
								x.value && (e.preventDefault(), e.stopPropagation(), R());
							},
							R = () => {
								m.value = !1;
							},
							L = async (e) => {
								n("input", e[r.valueKey]), n(_N, e[r.valueKey]), n("select", e), await ns(), (d.value = []), (p.value = -1);
							},
							O = (e) => {
								if (!x.value || g.value) return;
								if (e < 0) return void (p.value = -1);
								e >= d.value.length && (e = d.value.length - 1);
								const t = l.value.querySelector(`.${o.be("suggestion", "wrap")}`),
									n = t.querySelectorAll(`.${o.be("suggestion", "list")} li`)[e],
									r = t.scrollTop,
									{ offsetTop: i, scrollHeight: s } = n;
								i + s > r + t.clientHeight && (t.scrollTop += s), i < r && (t.scrollTop -= s), (p.value = e), a.value.ref.setAttribute("aria-activedescendant", `${y.value}-item-${p.value}`);
							};
						return (
							sR(c, R),
							Vn(() => {
								a.value.ref.setAttribute("role", "textbox"), a.value.ref.setAttribute("aria-autocomplete", "list"), a.value.ref.setAttribute("aria-controls", "id"), a.value.ref.setAttribute("aria-activedescendant", `${y.value}-item-${p.value}`);
							}),
							t({
								highlightedIndex: p,
								activated: m,
								loading: g,
								inputRef: a,
								popperRef: u,
								suggestions: d,
								handleSelect: L,
								handleKeyEnter: M,
								focus: () => {
									var e;
									null == (e = a.value) || e.focus();
								},
								close: R,
								highlight: O
							}),
							(e, t) => (
								Wr(),
								qr(
									it(QH),
									{
										ref_key: "popperRef",
										ref: u,
										visible: it(x),
										"onUpdate:visible": t[2] || (t[2] = (e) => (Je(x) ? (x.value = e) : null)),
										placement: e.placement,
										"fallback-placements": ["bottom-start", "top-start"],
										"popper-class": [it(o).e("popper"), e.popperClass],
										teleported: e.teleported,
										"gpu-acceleration": !1,
										pure: "",
										"manual-mode": "",
										effect: "light",
										trigger: "click",
										transition: `${it(o).namespace.value}-zoom-in-top`,
										persistent: "",
										onBeforeShow: w
									},
									{
										content: cn(() => [
											ni(
												"div",
												{ ref_key: "regionRef", ref: l, class: gt([it(o).b("suggestion"), it(o).is("loading", it(_))]), style: pt({ minWidth: f.value, outline: "none" }), role: "region" },
												[
													ri(
														it(ZB),
														{ id: it(y), tag: "ul", "wrap-class": it(o).be("suggestion", "wrap"), "view-class": it(o).be("suggestion", "list"), role: "listbox" },
														{
															default: cn(() => [
																it(_)
																	? (Wr(), Kr("li", rV, [ri(it(OB), { class: gt(it(o).is("loading")) }, { default: cn(() => [ri(it(HO))]), _: 1 }, 8, ["class"])]))
																	: (Wr(!0),
																	  Kr(
																			Hr,
																			{ key: 1 },
																			pi(
																				d.value,
																				(t, n) => (
																					Wr(),
																					Kr(
																						"li",
																						{ id: `${it(y)}-item-${n}`, key: n, class: gt({ highlighted: p.value === n }), role: "option", "aria-selected": p.value === n, onClick: (e) => L(t) },
																						[mi(e.$slots, "default", { item: t }, () => [oi(bt(t[e.valueKey]), 1)])],
																						10,
																						iV
																					)
																				)
																			),
																			128
																	  ))
															]),
															_: 3
														},
														8,
														["id", "wrap-class", "view-class"]
													)
												],
												6
											)
										]),
										default: cn(() => [
											ni(
												"div",
												{ ref_key: "listboxRef", ref: c, class: gt([it(o).b(), e.$attrs.class]), style: pt(it(b)), role: "combobox", "aria-haspopup": "listbox", "aria-expanded": it(x), "aria-owns": it(y) },
												[
													ri(
														it(WB),
														hi({ ref_key: "inputRef", ref: a }, it(i), {
															"model-value": e.modelValue,
															onInput: S,
															onChange: E,
															onFocus: T,
															onBlur: k,
															onClear: A,
															onKeydown: [
																t[0] ||
																	(t[0] = jo(
																		zo((e) => O(p.value - 1), ["prevent"]),
																		["up"]
																	)),
																t[1] ||
																	(t[1] = jo(
																		zo((e) => O(p.value + 1), ["prevent"]),
																		["down"]
																	)),
																jo(M, ["enter"]),
																jo(R, ["tab"]),
																jo(I, ["esc"])
															]
														}),
														fi({ _: 2 }, [
															e.$slots.prepend ? { name: "prepend", fn: cn(() => [mi(e.$slots, "prepend")]) } : void 0,
															e.$slots.append ? { name: "append", fn: cn(() => [mi(e.$slots, "append")]) } : void 0,
															e.$slots.prefix ? { name: "prefix", fn: cn(() => [mi(e.$slots, "prefix")]) } : void 0,
															e.$slots.suffix ? { name: "suffix", fn: cn(() => [mi(e.$slots, "suffix")]) } : void 0
														]),
														1040,
														["model-value", "onKeydown"]
													)
												],
												14,
												nV
											)
										]),
										_: 3
									},
									8,
									["visible", "placement", "popper-class", "teleported", "transition"]
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]
		)
	),
	oV = uN({ size: { type: [Number, String], values: CN, default: "", validator: (e) => XI(e) }, shape: { type: String, values: ["circle", "square"], default: "circle" }, icon: { type: cN }, src: { type: String, default: "" }, alt: String, srcSet: String, fit: { type: String, default: "cover" } }),
	aV = { error: (e) => e instanceof Event },
	lV = ["src", "alt", "srcset"];
const uV = mN(
		IB(
			Tn(
				c(u({}, { name: "ElAvatar" }), {
					props: oV,
					emits: aV,
					setup(e, { emit: t }) {
						const n = e,
							r = BD("avatar"),
							i = Qe(!1),
							s = ht(() => {
								const { size: e, icon: t, shape: i } = n,
									s = [r.b()];
								return SR(e) && s.push(r.m(e)), t && s.push(r.m("icon")), i && s.push(r.m(i)), s;
							}),
							o = ht(() => {
								const { size: e } = n;
								return XI(e) ? r.cssVarBlock({ size: KR(e) || "" }) : void 0;
							}),
							a = ht(() => ({ objectFit: n.fit }));
						function l(e) {
							(i.value = !0), t("error", e);
						}
						return (
							ds(
								() => n.src,
								() => (i.value = !1)
							),
							(e, t) => (
								Wr(),
								Kr(
									"span",
									{ class: gt(it(s)), style: pt(it(o)) },
									[
										(!e.src && !e.srcSet) || i.value
											? e.icon
												? (Wr(), qr(it(OB), { key: 1 }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 }))
												: mi(e.$slots, "default", { key: 2 })
											: (Wr(), Kr("img", { key: 0, src: e.src, alt: e.alt, srcset: e.srcSet, style: pt(it(a)), onError: l }, null, 44, lV))
									],
									6
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]
		)
	),
	cV = { visibilityHeight: { type: Number, default: 200 }, target: { type: String, default: "" }, right: { type: Number, default: 40 }, bottom: { type: Number, default: 40 } },
	hV = { click: (e) => e instanceof MouseEvent },
	dV = ["onClick"];
const pV = mN(
		IB(
			Tn(
				c(u({}, { name: "ElBacktop" }), {
					props: cV,
					emits: hV,
					setup(e, { emit: t }) {
						const n = e,
							r = BD("backtop"),
							i = et(),
							s = et(),
							o = Qe(!1),
							a = ht(() => ({ right: `${n.right}px`, bottom: `${n.bottom}px` })),
							l = () => {
								if (!i.value) return;
								const e = Date.now(),
									t = i.value.scrollTop,
									n = () => {
										if (!i.value) return;
										const r = (Date.now() - e) / 500;
										var s;
										r < 1 ? ((i.value.scrollTop = t * (1 - ((s = r) < 0.5 ? MN(2 * s) / 2 : 1 - MN(2 * (1 - s)) / 2))), requestAnimationFrame(n)) : (i.value.scrollTop = 0);
									};
								requestAnimationFrame(n);
							},
							u = (e) => {
								l(), t("click", e);
							},
							c = JI(() => {
								i.value && (o.value = i.value.scrollTop >= n.visibilityHeight);
							}, 300);
						return (
							iR(s, "scroll", c),
							Vn(() => {
								var e;
								(s.value = document), (i.value = document.documentElement), n.target && ((i.value = null != (e = document.querySelector(n.target)) ? e : void 0), i.value || $R("ElBacktop", `target is not existed: ${n.target}`), (s.value = i.value));
							}),
							(e, t) => (
								Wr(),
								qr(
									lo,
									{ name: `${it(r).namespace.value}-fade-in` },
									{
										default: cn(() => [
											o.value
												? (Wr(), Kr("div", { key: 0, style: pt(it(a)), class: gt(it(r).b()), onClick: zo(u, ["stop"]) }, [mi(e.$slots, "default", {}, () => [ri(it(OB), { class: gt(it(r).e("icon")) }, { default: cn(() => [ri(it(OL))]), _: 1 }, 8, ["class"])])], 14, dV))
												: ai("v-if", !0)
										]),
										_: 3
									},
									8,
									["name"]
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]
		)
	),
	fV = uN({ value: { type: [String, Number], default: "" }, max: { type: Number, default: 99 }, isDot: Boolean, hidden: Boolean, type: { type: String, values: ["primary", "success", "warning", "info", "danger"], default: "danger" } }),
	mV = ["textContent"];
const vV = mN(
		IB(
			Tn(
				c(u({}, { name: "ElBadge" }), {
					props: fV,
					setup(e, { expose: t }) {
						const n = e,
							r = BD("badge"),
							i = ht(() => (n.isDot ? "" : XI(n.value) && XI(n.max) && n.max < n.value ? `${n.max}+` : `${n.value}`));
						return (
							t({ content: i }),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{ class: gt(it(r).b()) },
									[
										mi(e.$slots, "default"),
										ri(
											lo,
											{ name: `${it(r).namespace.value}-zoom-in-center`, persisted: "" },
											{ default: cn(() => [yr(ni("sup", { class: gt([it(r).e("content"), it(r).em("content", e.type), it(r).is("fixed", !!e.$slots.default), it(r).is("dot", e.isDot)]), textContent: bt(it(i)) }, null, 10, mV), [[Wo, !e.hidden && (it(i) || e.isDot)]])]), _: 1 },
											8,
											["name"]
										)
									],
									2
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]
		)
	),
	gV = uN({ separator: { type: String, default: "/" }, separatorIcon: { type: cN, default: "" } });
var yV = IB(
	Tn(
		c(u({}, { name: "ElBreadcrumb" }), {
			props: gV,
			setup(e) {
				const t = e,
					n = BD("breadcrumb"),
					r = Qe();
				return (
					mn(VN, t),
					Vn(() => {
						const e = r.value.querySelectorAll(`.${n.e("item")}`);
						e.length && e[e.length - 1].setAttribute("aria-current", "page");
					}),
					(e, t) => (Wr(), Kr("div", { ref_key: "breadcrumb", ref: r, class: gt(it(n).b()), "aria-label": "Breadcrumb", role: "navigation" }, [mi(e.$slots, "default")], 2))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]
);
const bV = uN({ to: { type: [String, Object], default: "" }, replace: { type: Boolean, default: !1 } });
var xV = IB(
	Tn(
		c(u({}, { name: "ElBreadcrumbItem" }), {
			props: bV,
			setup(e) {
				const t = e,
					n = Si(),
					r = vn(VN, void 0),
					i = BD("breadcrumb"),
					{ separator: s, separatorIcon: o } = at(r),
					a = n.appContext.config.globalProperties.$router,
					l = Qe(),
					u = () => {
						t.to && a && (t.replace ? a.replace(t.to) : a.push(t.to));
					};
				return (e, t) => (
					Wr(),
					Kr(
						"span",
						{ class: gt(it(i).e("item")) },
						[
							ni("span", { ref_key: "link", ref: l, class: gt([it(i).e("inner"), it(i).is("link", !!e.to)]), role: "link", onClick: u }, [mi(e.$slots, "default")], 2),
							it(o) ? (Wr(), qr(it(OB), { key: 0, class: gt(it(i).e("separator")) }, { default: cn(() => [(Wr(), qr(Nr(it(o))))]), _: 1 }, 8, ["class"])) : (Wr(), Kr("span", { key: 1, class: gt(it(i).e("separator")), role: "presentation" }, bt(it(s)), 3))
						],
						2
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]
);
const _V = mN(yV, { BreadcrumbItem: xV }),
	wV = gN(xV),
	CV = ["default", "primary", "success", "warning", "info", "danger", "text", ""],
	SV = uN({
		size: cD,
		disabled: Boolean,
		type: { type: String, values: CV, default: "" },
		icon: { type: cN, default: "" },
		nativeType: { type: String, values: ["button", "submit", "reset"], default: "button" },
		loading: Boolean,
		loadingIcon: { type: cN, default: () => HO },
		plain: Boolean,
		text: Boolean,
		link: Boolean,
		bg: Boolean,
		autofocus: Boolean,
		round: Boolean,
		circle: Boolean,
		color: String,
		dark: Boolean,
		autoInsertSpace: { type: Boolean, default: void 0 }
	}),
	EV = { click: (e) => e instanceof MouseEvent };
function TV(e, t) {
	(function (e) {
		return "string" == typeof e && -1 !== e.indexOf(".") && 1 === parseFloat(e);
	})(e) && (e = "100%");
	var n = (function (e) {
		return "string" == typeof e && -1 !== e.indexOf("%");
	})(e);
	return (e = 360 === t ? e : Math.min(t, Math.max(0, parseFloat(e)))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (e = 360 === t ? (e < 0 ? (e % t) + t : e % t) / parseFloat(String(t)) : (e % t) / parseFloat(String(t)));
}
function kV(e) {
	return Math.min(1, Math.max(0, e));
}
function AV(e) {
	return (e = parseFloat(e)), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function MV(e) {
	return e <= 1 ? "".concat(100 * Number(e), "%") : e;
}
function IV(e) {
	return 1 === e.length ? "0" + e : String(e);
}
function RV(e, t, n) {
	(e = TV(e, 255)), (t = TV(t, 255)), (n = TV(n, 255));
	var r = Math.max(e, t, n),
		i = Math.min(e, t, n),
		s = 0,
		o = 0,
		a = (r + i) / 2;
	if (r === i) (o = 0), (s = 0);
	else {
		var l = r - i;
		switch (((o = a > 0.5 ? l / (2 - r - i) : l / (r + i)), r)) {
			case e:
				s = (t - n) / l + (t < n ? 6 : 0);
				break;
			case t:
				s = (n - e) / l + 2;
				break;
			case n:
				s = (e - t) / l + 4;
		}
		s /= 6;
	}
	return { h: s, s: o, l: a };
}
function LV(e, t, n) {
	return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * n * (t - e) : n < 0.5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function OV(e, t, n) {
	(e = TV(e, 255)), (t = TV(t, 255)), (n = TV(n, 255));
	var r = Math.max(e, t, n),
		i = Math.min(e, t, n),
		s = 0,
		o = r,
		a = r - i,
		l = 0 === r ? 0 : a / r;
	if (r === i) s = 0;
	else {
		switch (r) {
			case e:
				s = (t - n) / a + (t < n ? 6 : 0);
				break;
			case t:
				s = (n - e) / a + 2;
				break;
			case n:
				s = (e - t) / a + 4;
		}
		s /= 6;
	}
	return { h: s, s: l, v: o };
}
function PV(e, t, n, r) {
	var i = [IV(Math.round(e).toString(16)), IV(Math.round(t).toString(16)), IV(Math.round(n).toString(16))];
	return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function NV(e) {
	return DV(e) / 255;
}
function DV(e) {
	return parseInt(e, 16);
}
var BV = {
	aliceblue: "#f0f8ff",
	antiquewhite: "#faebd7",
	aqua: "#00ffff",
	aquamarine: "#7fffd4",
	azure: "#f0ffff",
	beige: "#f5f5dc",
	bisque: "#ffe4c4",
	black: "#000000",
	blanchedalmond: "#ffebcd",
	blue: "#0000ff",
	blueviolet: "#8a2be2",
	brown: "#a52a2a",
	burlywood: "#deb887",
	cadetblue: "#5f9ea0",
	chartreuse: "#7fff00",
	chocolate: "#d2691e",
	coral: "#ff7f50",
	cornflowerblue: "#6495ed",
	cornsilk: "#fff8dc",
	crimson: "#dc143c",
	cyan: "#00ffff",
	darkblue: "#00008b",
	darkcyan: "#008b8b",
	darkgoldenrod: "#b8860b",
	darkgray: "#a9a9a9",
	darkgreen: "#006400",
	darkgrey: "#a9a9a9",
	darkkhaki: "#bdb76b",
	darkmagenta: "#8b008b",
	darkolivegreen: "#556b2f",
	darkorange: "#ff8c00",
	darkorchid: "#9932cc",
	darkred: "#8b0000",
	darksalmon: "#e9967a",
	darkseagreen: "#8fbc8f",
	darkslateblue: "#483d8b",
	darkslategray: "#2f4f4f",
	darkslategrey: "#2f4f4f",
	darkturquoise: "#00ced1",
	darkviolet: "#9400d3",
	deeppink: "#ff1493",
	deepskyblue: "#00bfff",
	dimgray: "#696969",
	dimgrey: "#696969",
	dodgerblue: "#1e90ff",
	firebrick: "#b22222",
	floralwhite: "#fffaf0",
	forestgreen: "#228b22",
	fuchsia: "#ff00ff",
	gainsboro: "#dcdcdc",
	ghostwhite: "#f8f8ff",
	goldenrod: "#daa520",
	gold: "#ffd700",
	gray: "#808080",
	green: "#008000",
	greenyellow: "#adff2f",
	grey: "#808080",
	honeydew: "#f0fff0",
	hotpink: "#ff69b4",
	indianred: "#cd5c5c",
	indigo: "#4b0082",
	ivory: "#fffff0",
	khaki: "#f0e68c",
	lavenderblush: "#fff0f5",
	lavender: "#e6e6fa",
	lawngreen: "#7cfc00",
	lemonchiffon: "#fffacd",
	lightblue: "#add8e6",
	lightcoral: "#f08080",
	lightcyan: "#e0ffff",
	lightgoldenrodyellow: "#fafad2",
	lightgray: "#d3d3d3",
	lightgreen: "#90ee90",
	lightgrey: "#d3d3d3",
	lightpink: "#ffb6c1",
	lightsalmon: "#ffa07a",
	lightseagreen: "#20b2aa",
	lightskyblue: "#87cefa",
	lightslategray: "#778899",
	lightslategrey: "#778899",
	lightsteelblue: "#b0c4de",
	lightyellow: "#ffffe0",
	lime: "#00ff00",
	limegreen: "#32cd32",
	linen: "#faf0e6",
	magenta: "#ff00ff",
	maroon: "#800000",
	mediumaquamarine: "#66cdaa",
	mediumblue: "#0000cd",
	mediumorchid: "#ba55d3",
	mediumpurple: "#9370db",
	mediumseagreen: "#3cb371",
	mediumslateblue: "#7b68ee",
	mediumspringgreen: "#00fa9a",
	mediumturquoise: "#48d1cc",
	mediumvioletred: "#c71585",
	midnightblue: "#191970",
	mintcream: "#f5fffa",
	mistyrose: "#ffe4e1",
	moccasin: "#ffe4b5",
	navajowhite: "#ffdead",
	navy: "#000080",
	oldlace: "#fdf5e6",
	olive: "#808000",
	olivedrab: "#6b8e23",
	orange: "#ffa500",
	orangered: "#ff4500",
	orchid: "#da70d6",
	palegoldenrod: "#eee8aa",
	palegreen: "#98fb98",
	paleturquoise: "#afeeee",
	palevioletred: "#db7093",
	papayawhip: "#ffefd5",
	peachpuff: "#ffdab9",
	peru: "#cd853f",
	pink: "#ffc0cb",
	plum: "#dda0dd",
	powderblue: "#b0e0e6",
	purple: "#800080",
	rebeccapurple: "#663399",
	red: "#ff0000",
	rosybrown: "#bc8f8f",
	royalblue: "#4169e1",
	saddlebrown: "#8b4513",
	salmon: "#fa8072",
	sandybrown: "#f4a460",
	seagreen: "#2e8b57",
	seashell: "#fff5ee",
	sienna: "#a0522d",
	silver: "#c0c0c0",
	skyblue: "#87ceeb",
	slateblue: "#6a5acd",
	slategray: "#708090",
	slategrey: "#708090",
	snow: "#fffafa",
	springgreen: "#00ff7f",
	steelblue: "#4682b4",
	tan: "#d2b48c",
	teal: "#008080",
	thistle: "#d8bfd8",
	tomato: "#ff6347",
	turquoise: "#40e0d0",
	violet: "#ee82ee",
	wheat: "#f5deb3",
	white: "#ffffff",
	whitesmoke: "#f5f5f5",
	yellow: "#ffff00",
	yellowgreen: "#9acd32"
};
function FV(e) {
	var t = { r: 0, g: 0, b: 0 },
		n = 1,
		r = null,
		i = null,
		s = null,
		o = !1,
		a = !1;
	return (
		"string" == typeof e &&
			(e = (function (e) {
				if (0 === (e = e.trim().toLowerCase()).length) return !1;
				var t = !1;
				if (BV[e]) (e = BV[e]), (t = !0);
				else if ("transparent" === e) return { r: 0, g: 0, b: 0, a: 0, format: "name" };
				var n = zV.rgb.exec(e);
				if (n) return { r: n[1], g: n[2], b: n[3] };
				if ((n = zV.rgba.exec(e))) return { r: n[1], g: n[2], b: n[3], a: n[4] };
				if ((n = zV.hsl.exec(e))) return { h: n[1], s: n[2], l: n[3] };
				if ((n = zV.hsla.exec(e))) return { h: n[1], s: n[2], l: n[3], a: n[4] };
				if ((n = zV.hsv.exec(e))) return { h: n[1], s: n[2], v: n[3] };
				if ((n = zV.hsva.exec(e))) return { h: n[1], s: n[2], v: n[3], a: n[4] };
				if ((n = zV.hex8.exec(e))) return { r: DV(n[1]), g: DV(n[2]), b: DV(n[3]), a: NV(n[4]), format: t ? "name" : "hex8" };
				if ((n = zV.hex6.exec(e))) return { r: DV(n[1]), g: DV(n[2]), b: DV(n[3]), format: t ? "name" : "hex" };
				if ((n = zV.hex4.exec(e))) return { r: DV(n[1] + n[1]), g: DV(n[2] + n[2]), b: DV(n[3] + n[3]), a: NV(n[4] + n[4]), format: t ? "name" : "hex8" };
				if ((n = zV.hex3.exec(e))) return { r: DV(n[1] + n[1]), g: DV(n[2] + n[2]), b: DV(n[3] + n[3]), format: t ? "name" : "hex" };
				return !1;
			})(e)),
		"object" == typeof e &&
			($V(e.r) && $V(e.g) && $V(e.b)
				? ((t = (function (e, t, n) {
						return { r: 255 * TV(e, 255), g: 255 * TV(t, 255), b: 255 * TV(n, 255) };
				  })(e.r, e.g, e.b)),
				  (o = !0),
				  (a = "%" === String(e.r).substr(-1) ? "prgb" : "rgb"))
				: $V(e.h) && $V(e.s) && $V(e.v)
				? ((r = MV(e.s)),
				  (i = MV(e.v)),
				  (t = (function (e, t, n) {
						(e = 6 * TV(e, 360)), (t = TV(t, 100)), (n = TV(n, 100));
						var r = Math.floor(e),
							i = e - r,
							s = n * (1 - t),
							o = n * (1 - i * t),
							a = n * (1 - (1 - i) * t),
							l = r % 6;
						return { r: 255 * [n, o, s, s, a, n][l], g: 255 * [a, n, n, o, s, s][l], b: 255 * [s, s, a, n, n, o][l] };
				  })(e.h, r, i)),
				  (o = !0),
				  (a = "hsv"))
				: $V(e.h) &&
				  $V(e.s) &&
				  $V(e.l) &&
				  ((r = MV(e.s)),
				  (s = MV(e.l)),
				  (t = (function (e, t, n) {
						var r, i, s;
						if (((e = TV(e, 360)), (t = TV(t, 100)), (n = TV(n, 100)), 0 === t)) (i = n), (s = n), (r = n);
						else {
							var o = n < 0.5 ? n * (1 + t) : n + t - n * t,
								a = 2 * n - o;
							(r = LV(a, o, e + 1 / 3)), (i = LV(a, o, e)), (s = LV(a, o, e - 1 / 3));
						}
						return { r: 255 * r, g: 255 * i, b: 255 * s };
				  })(e.h, r, s)),
				  (o = !0),
				  (a = "hsl")),
			Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)),
		(n = AV(n)),
		{ ok: o, format: e.format || a, r: Math.min(255, Math.max(t.r, 0)), g: Math.min(255, Math.max(t.g, 0)), b: Math.min(255, Math.max(t.b, 0)), a: n }
	);
}
var HV = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")"),
	VV = "[\\s|\\(]+(".concat(HV, ")[,|\\s]+(").concat(HV, ")[,|\\s]+(").concat(HV, ")\\s*\\)?"),
	UV = "[\\s|\\(]+(".concat(HV, ")[,|\\s]+(").concat(HV, ")[,|\\s]+(").concat(HV, ")[,|\\s]+(").concat(HV, ")\\s*\\)?"),
	zV = {
		CSS_UNIT: new RegExp(HV),
		rgb: new RegExp("rgb" + VV),
		rgba: new RegExp("rgba" + UV),
		hsl: new RegExp("hsl" + VV),
		hsla: new RegExp("hsla" + UV),
		hsv: new RegExp("hsv" + VV),
		hsva: new RegExp("hsva" + UV),
		hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
		hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	};
function $V(e) {
	return Boolean(zV.CSS_UNIT.exec(String(e)));
}
var jV = (function () {
	function e(t, n) {
		var r;
		if ((void 0 === t && (t = ""), void 0 === n && (n = {}), t instanceof e)) return t;
		"number" == typeof t &&
			(t = (function (e) {
				return { r: e >> 16, g: (65280 & e) >> 8, b: 255 & e };
			})(t)),
			(this.originalInput = t);
		var i = FV(t);
		(this.originalInput = t),
			(this.r = i.r),
			(this.g = i.g),
			(this.b = i.b),
			(this.a = i.a),
			(this.roundA = Math.round(100 * this.a) / 100),
			(this.format = null !== (r = n.format) && void 0 !== r ? r : i.format),
			(this.gradientType = n.gradientType),
			this.r < 1 && (this.r = Math.round(this.r)),
			this.g < 1 && (this.g = Math.round(this.g)),
			this.b < 1 && (this.b = Math.round(this.b)),
			(this.isValid = i.ok);
	}
	return (
		(e.prototype.isDark = function () {
			return this.getBrightness() < 128;
		}),
		(e.prototype.isLight = function () {
			return !this.isDark();
		}),
		(e.prototype.getBrightness = function () {
			var e = this.toRgb();
			return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3;
		}),
		(e.prototype.getLuminance = function () {
			var e = this.toRgb(),
				t = e.r / 255,
				n = e.g / 255,
				r = e.b / 255;
			return 0.2126 * (t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4)) + 0.7152 * (n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)) + 0.0722 * (r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4));
		}),
		(e.prototype.getAlpha = function () {
			return this.a;
		}),
		(e.prototype.setAlpha = function (e) {
			return (this.a = AV(e)), (this.roundA = Math.round(100 * this.a) / 100), this;
		}),
		(e.prototype.toHsv = function () {
			var e = OV(this.r, this.g, this.b);
			return { h: 360 * e.h, s: e.s, v: e.v, a: this.a };
		}),
		(e.prototype.toHsvString = function () {
			var e = OV(this.r, this.g, this.b),
				t = Math.round(360 * e.h),
				n = Math.round(100 * e.s),
				r = Math.round(100 * e.v);
			return 1 === this.a ? "hsv(".concat(t, ", ").concat(n, "%, ").concat(r, "%)") : "hsva(".concat(t, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")");
		}),
		(e.prototype.toHsl = function () {
			var e = RV(this.r, this.g, this.b);
			return { h: 360 * e.h, s: e.s, l: e.l, a: this.a };
		}),
		(e.prototype.toHslString = function () {
			var e = RV(this.r, this.g, this.b),
				t = Math.round(360 * e.h),
				n = Math.round(100 * e.s),
				r = Math.round(100 * e.l);
			return 1 === this.a ? "hsl(".concat(t, ", ").concat(n, "%, ").concat(r, "%)") : "hsla(".concat(t, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")");
		}),
		(e.prototype.toHex = function (e) {
			return void 0 === e && (e = !1), PV(this.r, this.g, this.b, e);
		}),
		(e.prototype.toHexString = function (e) {
			return void 0 === e && (e = !1), "#" + this.toHex(e);
		}),
		(e.prototype.toHex8 = function (e) {
			return (
				void 0 === e && (e = !1),
				(function (e, t, n, r, i) {
					var s,
						o = [IV(Math.round(e).toString(16)), IV(Math.round(t).toString(16)), IV(Math.round(n).toString(16)), IV(((s = r), Math.round(255 * parseFloat(s)).toString(16)))];
					return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
				})(this.r, this.g, this.b, this.a, e)
			);
		}),
		(e.prototype.toHex8String = function (e) {
			return void 0 === e && (e = !1), "#" + this.toHex8(e);
		}),
		(e.prototype.toRgb = function () {
			return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a };
		}),
		(e.prototype.toRgbString = function () {
			var e = Math.round(this.r),
				t = Math.round(this.g),
				n = Math.round(this.b);
			return 1 === this.a ? "rgb(".concat(e, ", ").concat(t, ", ").concat(n, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(n, ", ").concat(this.roundA, ")");
		}),
		(e.prototype.toPercentageRgb = function () {
			var e = function (e) {
				return "".concat(Math.round(100 * TV(e, 255)), "%");
			};
			return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a };
		}),
		(e.prototype.toPercentageRgbString = function () {
			var e = function (e) {
				return Math.round(100 * TV(e, 255));
			};
			return 1 === this.a ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")");
		}),
		(e.prototype.toName = function () {
			if (0 === this.a) return "transparent";
			if (this.a < 1) return !1;
			for (var e = "#" + PV(this.r, this.g, this.b, !1), t = 0, n = Object.entries(BV); t < n.length; t++) {
				var r = n[t],
					i = r[0];
				if (e === r[1]) return i;
			}
			return !1;
		}),
		(e.prototype.toString = function (e) {
			var t = Boolean(e);
			e = null != e ? e : this.format;
			var n = !1,
				r = this.a < 1 && this.a >= 0;
			return t || !r || (!e.startsWith("hex") && "name" !== e)
				? ("rgb" === e && (n = this.toRgbString()),
				  "prgb" === e && (n = this.toPercentageRgbString()),
				  ("hex" !== e && "hex6" !== e) || (n = this.toHexString()),
				  "hex3" === e && (n = this.toHexString(!0)),
				  "hex4" === e && (n = this.toHex8String(!0)),
				  "hex8" === e && (n = this.toHex8String()),
				  "name" === e && (n = this.toName()),
				  "hsl" === e && (n = this.toHslString()),
				  "hsv" === e && (n = this.toHsvString()),
				  n || this.toHexString())
				: "name" === e && 0 === this.a
				? this.toName()
				: this.toRgbString();
		}),
		(e.prototype.toNumber = function () {
			return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
		}),
		(e.prototype.clone = function () {
			return new e(this.toString());
		}),
		(e.prototype.lighten = function (t) {
			void 0 === t && (t = 10);
			var n = this.toHsl();
			return (n.l += t / 100), (n.l = kV(n.l)), new e(n);
		}),
		(e.prototype.brighten = function (t) {
			void 0 === t && (t = 10);
			var n = this.toRgb();
			return (n.r = Math.max(0, Math.min(255, n.r - Math.round((-t / 100) * 255)))), (n.g = Math.max(0, Math.min(255, n.g - Math.round((-t / 100) * 255)))), (n.b = Math.max(0, Math.min(255, n.b - Math.round((-t / 100) * 255)))), new e(n);
		}),
		(e.prototype.darken = function (t) {
			void 0 === t && (t = 10);
			var n = this.toHsl();
			return (n.l -= t / 100), (n.l = kV(n.l)), new e(n);
		}),
		(e.prototype.tint = function (e) {
			return void 0 === e && (e = 10), this.mix("white", e);
		}),
		(e.prototype.shade = function (e) {
			return void 0 === e && (e = 10), this.mix("black", e);
		}),
		(e.prototype.desaturate = function (t) {
			void 0 === t && (t = 10);
			var n = this.toHsl();
			return (n.s -= t / 100), (n.s = kV(n.s)), new e(n);
		}),
		(e.prototype.saturate = function (t) {
			void 0 === t && (t = 10);
			var n = this.toHsl();
			return (n.s += t / 100), (n.s = kV(n.s)), new e(n);
		}),
		(e.prototype.greyscale = function () {
			return this.desaturate(100);
		}),
		(e.prototype.spin = function (t) {
			var n = this.toHsl(),
				r = (n.h + t) % 360;
			return (n.h = r < 0 ? 360 + r : r), new e(n);
		}),
		(e.prototype.mix = function (t, n) {
			void 0 === n && (n = 50);
			var r = this.toRgb(),
				i = new e(t).toRgb(),
				s = n / 100;
			return new e({ r: (i.r - r.r) * s + r.r, g: (i.g - r.g) * s + r.g, b: (i.b - r.b) * s + r.b, a: (i.a - r.a) * s + r.a });
		}),
		(e.prototype.analogous = function (t, n) {
			void 0 === t && (t = 6), void 0 === n && (n = 30);
			var r = this.toHsl(),
				i = 360 / n,
				s = [this];
			for (r.h = (r.h - ((i * t) >> 1) + 720) % 360; --t; ) (r.h = (r.h + i) % 360), s.push(new e(r));
			return s;
		}),
		(e.prototype.complement = function () {
			var t = this.toHsl();
			return (t.h = (t.h + 180) % 360), new e(t);
		}),
		(e.prototype.monochromatic = function (t) {
			void 0 === t && (t = 6);
			for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / t; t--; ) o.push(new e({ h: r, s: i, v: s })), (s = (s + a) % 1);
			return o;
		}),
		(e.prototype.splitcomplement = function () {
			var t = this.toHsl(),
				n = t.h;
			return [this, new e({ h: (n + 72) % 360, s: t.s, l: t.l }), new e({ h: (n + 216) % 360, s: t.s, l: t.l })];
		}),
		(e.prototype.onBackground = function (t) {
			var n = this.toRgb(),
				r = new e(t).toRgb();
			return new e({ r: r.r + (n.r - r.r) * n.a, g: r.g + (n.g - r.g) * n.a, b: r.b + (n.b - r.b) * n.a });
		}),
		(e.prototype.triad = function () {
			return this.polyad(3);
		}),
		(e.prototype.tetrad = function () {
			return this.polyad(4);
		}),
		(e.prototype.polyad = function (t) {
			for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / t, o = 1; o < t; o++) i.push(new e({ h: (r + o * s) % 360, s: n.s, l: n.l }));
			return i;
		}),
		(e.prototype.equals = function (t) {
			return this.toRgbString() === new e(t).toRgbString();
		}),
		e
	);
})();
function WV(e, t = 20) {
	return e.mix("#141414", t).toString();
}
const GV = ["aria-disabled", "disabled", "autofocus", "type"];
var YV = IB(
	Tn(
		c(u({}, { name: "ElButton" }), {
			props: SV,
			emits: EV,
			setup(e, { expose: t, emit: n }) {
				const r = e,
					i = gs();
				pD(
					{ from: "type.text", replacement: "type.link", version: "3.0.0", scope: "props", ref: "https://element-plus.org/en-US/component/button.html#button-attributes" },
					ht(() => "text" === r.type)
				);
				const s = vn(UN, void 0),
					o = aD("button"),
					a = BD("button"),
					{ form: l } = yD(),
					u = hD(ht(() => (null == s ? void 0 : s.size))),
					c = dD(),
					h = Qe(),
					d = ht(() => r.type || (null == s ? void 0 : s.type) || ""),
					p = ht(() => {
						var e, t, n;
						return null != (n = null != (t = r.autoInsertSpace) ? t : null == (e = o.value) ? void 0 : e.autoInsertSpace) && n;
					}),
					f = ht(() => {
						var e;
						const t = null == (e = i.default) ? void 0 : e.call(i);
						if (p.value && 1 === (null == t ? void 0 : t.length)) {
							const e = t[0];
							if ((null == e ? void 0 : e.type) === Vr) {
								const t = e.children;
								return /^\p{Unified_Ideograph}{2}$/u.test(t.trim());
							}
						}
						return !1;
					}),
					m = (function (e) {
						const t = dD(),
							n = BD("button");
						return ht(() => {
							let r = {};
							const i = e.color;
							if (i) {
								const s = new jV(i),
									o = e.dark ? s.tint(20).toString() : WV(s, 20);
								if (e.plain)
									(r = n.cssVarBlock({
										"bg-color": e.dark ? WV(s, 90) : s.tint(90).toString(),
										"text-color": i,
										"border-color": e.dark ? WV(s, 50) : s.tint(50).toString(),
										"hover-text-color": `var(${n.cssVarName("color-white")})`,
										"hover-bg-color": i,
										"hover-border-color": i,
										"active-bg-color": o,
										"active-text-color": `var(${n.cssVarName("color-white")})`,
										"active-border-color": o
									})),
										t.value &&
											((r[n.cssVarBlockName("disabled-bg-color")] = e.dark ? WV(s, 90) : s.tint(90).toString()),
											(r[n.cssVarBlockName("disabled-text-color")] = e.dark ? WV(s, 50) : s.tint(50).toString()),
											(r[n.cssVarBlockName("disabled-border-color")] = e.dark ? WV(s, 80) : s.tint(80).toString()));
								else {
									const a = e.dark ? WV(s, 30) : s.tint(30).toString(),
										l = s.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
									if (((r = n.cssVarBlock({ "bg-color": i, "text-color": l, "border-color": i, "hover-bg-color": a, "hover-text-color": l, "hover-border-color": a, "active-bg-color": o, "active-border-color": o })), t.value)) {
										const t = e.dark ? WV(s, 50) : s.tint(50).toString();
										(r[n.cssVarBlockName("disabled-bg-color")] = t), (r[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`), (r[n.cssVarBlockName("disabled-border-color")] = t);
									}
								}
							}
							return r;
						});
					})(r),
					v = (e) => {
						"reset" === r.nativeType && (null == l || l.resetFields()), n("click", e);
					};
				return (
					t({ ref: h, size: u, type: d, disabled: c, shouldAddSpace: f }),
					(e, t) => (
						Wr(),
						Kr(
							"button",
							{
								ref_key: "_ref",
								ref: h,
								class: gt([
									it(a).b(),
									it(a).m(it(d)),
									it(a).m(it(u)),
									it(a).is("disabled", it(c)),
									it(a).is("loading", e.loading),
									it(a).is("plain", e.plain),
									it(a).is("round", e.round),
									it(a).is("circle", e.circle),
									it(a).is("text", e.text),
									it(a).is("link", e.link),
									it(a).is("has-bg", e.bg)
								]),
								"aria-disabled": it(c) || e.loading,
								disabled: it(c) || e.loading,
								autofocus: e.autofocus,
								type: e.nativeType,
								style: pt(it(m)),
								onClick: v
							},
							[
								e.loading
									? (Wr(), Kr(Hr, { key: 0 }, [e.$slots.loading ? mi(e.$slots, "loading", { key: 0 }) : (Wr(), qr(it(OB), { key: 1, class: gt(it(a).is("loading")) }, { default: cn(() => [(Wr(), qr(Nr(e.loadingIcon)))]), _: 1 }, 8, ["class"]))], 64))
									: e.icon || e.$slots.icon
									? (Wr(), qr(it(OB), { key: 1 }, { default: cn(() => [e.icon ? (Wr(), qr(Nr(e.icon), { key: 0 })) : mi(e.$slots, "icon", { key: 1 })]), _: 3 }))
									: ai("v-if", !0),
								e.$slots.default ? (Wr(), Kr("span", { key: 2, class: gt({ [it(a).em("text", "expand")]: it(f) }) }, [mi(e.$slots, "default")], 2)) : ai("v-if", !0)
							],
							14,
							GV
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]
);
const XV = { size: SV.size, type: SV.type };
var KV = IB(
	Tn(
		c(u({}, { name: "ElButtonGroup" }), {
			props: XV,
			setup(e) {
				const t = e;
				mn(UN, Fe({ size: ut(t, "size"), type: ut(t, "type") }));
				const n = BD("button");
				return (e, t) => (Wr(), Kr("div", { class: gt(`${it(n).b("group")}`) }, [mi(e.$slots, "default")], 2));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]
);
const qV = mN(YV, { ButtonGroup: KV }),
	ZV = gN(KV);
var JV = { exports: {} },
	QV = (JV.exports = (function () {
		var e = 1e3,
			t = 6e4,
			n = 36e5,
			r = "millisecond",
			i = "second",
			s = "minute",
			o = "hour",
			a = "day",
			l = "week",
			u = "month",
			c = "quarter",
			h = "year",
			d = "date",
			p = "Invalid Date",
			f = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
			m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
			v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") },
			g = function (e, t, n) {
				var r = String(e);
				return !r || r.length >= t ? e : "" + Array(t + 1 - r.length).join(n) + e;
			},
			y = {
				s: g,
				z: function (e) {
					var t = -e.utcOffset(),
						n = Math.abs(t),
						r = Math.floor(n / 60),
						i = n % 60;
					return (t <= 0 ? "+" : "-") + g(r, 2, "0") + ":" + g(i, 2, "0");
				},
				m: function e(t, n) {
					if (t.date() < n.date()) return -e(n, t);
					var r = 12 * (n.year() - t.year()) + (n.month() - t.month()),
						i = t.clone().add(r, u),
						s = n - i < 0,
						o = t.clone().add(r + (s ? -1 : 1), u);
					return +(-(r + (n - i) / (s ? i - o : o - i)) || 0);
				},
				a: function (e) {
					return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
				},
				p: function (e) {
					return (
						{ M: u, y: h, w: l, d: a, D: d, h: o, m: s, s: i, ms: r, Q: c }[e] ||
						String(e || "")
							.toLowerCase()
							.replace(/s$/, "")
					);
				},
				u: function (e) {
					return void 0 === e;
				}
			},
			b = "en",
			x = {};
		x[b] = v;
		var _ = function (e) {
				return e instanceof E;
			},
			w = function e(t, n, r) {
				var i;
				if (!t) return b;
				if ("string" == typeof t) {
					var s = t.toLowerCase();
					x[s] && (i = s), n && ((x[s] = n), (i = s));
					var o = t.split("-");
					if (!i && o.length > 1) return e(o[0]);
				} else {
					var a = t.name;
					(x[a] = t), (i = a);
				}
				return !r && i && (b = i), i || (!r && b);
			},
			C = function (e, t) {
				if (_(e)) return e.clone();
				var n = "object" == typeof t ? t : {};
				return (n.date = e), (n.args = arguments), new E(n);
			},
			S = y;
		(S.l = w),
			(S.i = _),
			(S.w = function (e, t) {
				return C(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset });
			});
		var E = (function () {
				function v(e) {
					(this.$L = w(e.locale, null, !0)), this.parse(e);
				}
				var g = v.prototype;
				return (
					(g.parse = function (e) {
						(this.$d = (function (e) {
							var t = e.date,
								n = e.utc;
							if (null === t) return new Date(NaN);
							if (S.u(t)) return new Date();
							if (t instanceof Date) return new Date(t);
							if ("string" == typeof t && !/Z$/i.test(t)) {
								var r = t.match(f);
								if (r) {
									var i = r[2] - 1 || 0,
										s = (r[7] || "0").substring(0, 3);
									return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
								}
							}
							return new Date(t);
						})(e)),
							(this.$x = e.x || {}),
							this.init();
					}),
					(g.init = function () {
						var e = this.$d;
						(this.$y = e.getFullYear()), (this.$M = e.getMonth()), (this.$D = e.getDate()), (this.$W = e.getDay()), (this.$H = e.getHours()), (this.$m = e.getMinutes()), (this.$s = e.getSeconds()), (this.$ms = e.getMilliseconds());
					}),
					(g.$utils = function () {
						return S;
					}),
					(g.isValid = function () {
						return !(this.$d.toString() === p);
					}),
					(g.isSame = function (e, t) {
						var n = C(e);
						return this.startOf(t) <= n && n <= this.endOf(t);
					}),
					(g.isAfter = function (e, t) {
						return C(e) < this.startOf(t);
					}),
					(g.isBefore = function (e, t) {
						return this.endOf(t) < C(e);
					}),
					(g.$g = function (e, t, n) {
						return S.u(e) ? this[t] : this.set(n, e);
					}),
					(g.unix = function () {
						return Math.floor(this.valueOf() / 1e3);
					}),
					(g.valueOf = function () {
						return this.$d.getTime();
					}),
					(g.startOf = function (e, t) {
						var n = this,
							r = !!S.u(t) || t,
							c = S.p(e),
							p = function (e, t) {
								var i = S.w(n.$u ? Date.UTC(n.$y, t, e) : new Date(n.$y, t, e), n);
								return r ? i : i.endOf(a);
							},
							f = function (e, t) {
								return S.w(n.toDate()[e].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), n);
							},
							m = this.$W,
							v = this.$M,
							g = this.$D,
							y = "set" + (this.$u ? "UTC" : "");
						switch (c) {
							case h:
								return r ? p(1, 0) : p(31, 11);
							case u:
								return r ? p(1, v) : p(0, v + 1);
							case l:
								var b = this.$locale().weekStart || 0,
									x = (m < b ? m + 7 : m) - b;
								return p(r ? g - x : g + (6 - x), v);
							case a:
							case d:
								return f(y + "Hours", 0);
							case o:
								return f(y + "Minutes", 1);
							case s:
								return f(y + "Seconds", 2);
							case i:
								return f(y + "Milliseconds", 3);
							default:
								return this.clone();
						}
					}),
					(g.endOf = function (e) {
						return this.startOf(e, !1);
					}),
					(g.$set = function (e, t) {
						var n,
							l = S.p(e),
							c = "set" + (this.$u ? "UTC" : ""),
							p = ((n = {}), (n[a] = c + "Date"), (n[d] = c + "Date"), (n[u] = c + "Month"), (n[h] = c + "FullYear"), (n[o] = c + "Hours"), (n[s] = c + "Minutes"), (n[i] = c + "Seconds"), (n[r] = c + "Milliseconds"), n)[l],
							f = l === a ? this.$D + (t - this.$W) : t;
						if (l === u || l === h) {
							var m = this.clone().set(d, 1);
							m.$d[p](f), m.init(), (this.$d = m.set(d, Math.min(this.$D, m.daysInMonth())).$d);
						} else p && this.$d[p](f);
						return this.init(), this;
					}),
					(g.set = function (e, t) {
						return this.clone().$set(e, t);
					}),
					(g.get = function (e) {
						return this[S.p(e)]();
					}),
					(g.add = function (r, c) {
						var d,
							p = this;
						r = Number(r);
						var f = S.p(c),
							m = function (e) {
								var t = C(p);
								return S.w(t.date(t.date() + Math.round(e * r)), p);
							};
						if (f === u) return this.set(u, this.$M + r);
						if (f === h) return this.set(h, this.$y + r);
						if (f === a) return m(1);
						if (f === l) return m(7);
						var v = ((d = {}), (d[s] = t), (d[o] = n), (d[i] = e), d)[f] || 1,
							g = this.$d.getTime() + r * v;
						return S.w(g, this);
					}),
					(g.subtract = function (e, t) {
						return this.add(-1 * e, t);
					}),
					(g.format = function (e) {
						var t = this,
							n = this.$locale();
						if (!this.isValid()) return n.invalidDate || p;
						var r = e || "YYYY-MM-DDTHH:mm:ssZ",
							i = S.z(this),
							s = this.$H,
							o = this.$m,
							a = this.$M,
							l = n.weekdays,
							u = n.months,
							c = function (e, n, i, s) {
								return (e && (e[n] || e(t, r))) || i[n].slice(0, s);
							},
							h = function (e) {
								return S.s(s % 12 || 12, e, "0");
							},
							d =
								n.meridiem ||
								function (e, t, n) {
									var r = e < 12 ? "AM" : "PM";
									return n ? r.toLowerCase() : r;
								},
							f = {
								YY: String(this.$y).slice(-2),
								YYYY: this.$y,
								M: a + 1,
								MM: S.s(a + 1, 2, "0"),
								MMM: c(n.monthsShort, a, u, 3),
								MMMM: c(u, a),
								D: this.$D,
								DD: S.s(this.$D, 2, "0"),
								d: String(this.$W),
								dd: c(n.weekdaysMin, this.$W, l, 2),
								ddd: c(n.weekdaysShort, this.$W, l, 3),
								dddd: l[this.$W],
								H: String(s),
								HH: S.s(s, 2, "0"),
								h: h(1),
								hh: h(2),
								a: d(s, o, !0),
								A: d(s, o, !1),
								m: String(o),
								mm: S.s(o, 2, "0"),
								s: String(this.$s),
								ss: S.s(this.$s, 2, "0"),
								SSS: S.s(this.$ms, 3, "0"),
								Z: i
							};
						return r.replace(m, function (e, t) {
							return t || f[e] || i.replace(":", "");
						});
					}),
					(g.utcOffset = function () {
						return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
					}),
					(g.diff = function (r, d, p) {
						var f,
							m = S.p(d),
							v = C(r),
							g = (v.utcOffset() - this.utcOffset()) * t,
							y = this - v,
							b = S.m(this, v);
						return (b = ((f = {}), (f[h] = b / 12), (f[u] = b), (f[c] = b / 3), (f[l] = (y - g) / 6048e5), (f[a] = (y - g) / 864e5), (f[o] = y / n), (f[s] = y / t), (f[i] = y / e), f)[m] || y), p ? b : S.a(b);
					}),
					(g.daysInMonth = function () {
						return this.endOf(u).$D;
					}),
					(g.$locale = function () {
						return x[this.$L];
					}),
					(g.locale = function (e, t) {
						if (!e) return this.$L;
						var n = this.clone(),
							r = w(e, t, !0);
						return r && (n.$L = r), n;
					}),
					(g.clone = function () {
						return S.w(this.$d, this);
					}),
					(g.toDate = function () {
						return new Date(this.valueOf());
					}),
					(g.toJSON = function () {
						return this.isValid() ? this.toISOString() : null;
					}),
					(g.toISOString = function () {
						return this.$d.toISOString();
					}),
					(g.toString = function () {
						return this.$d.toUTCString();
					}),
					v
				);
			})(),
			T = E.prototype;
		return (
			(C.prototype = T),
			[
				["$ms", r],
				["$s", i],
				["$m", s],
				["$H", o],
				["$W", a],
				["$M", u],
				["$y", h],
				["$D", d]
			].forEach(function (e) {
				T[e[1]] = function (t) {
					return this.$g(t, e[0], e[1]);
				};
			}),
			(C.extend = function (e, t) {
				return e.$i || (e(t, E, C), (e.$i = !0)), C;
			}),
			(C.locale = w),
			(C.isDayjs = _),
			(C.unix = function (e) {
				return C(1e3 * e);
			}),
			(C.en = x[b]),
			(C.Ls = x),
			(C.p = {}),
			C
		);
	})()),
	eU = { exports: {} },
	tU = (eU.exports = function (e, t, n) {
		var r = t.prototype,
			i = function (e) {
				return e && (e.indexOf ? e : e.s);
			},
			s = function (e, t, n, r, s) {
				var o = e.name ? e : e.$locale(),
					a = i(o[t]),
					l = i(o[n]),
					u =
						a ||
						l.map(function (e) {
							return e.slice(0, r);
						});
				if (!s) return u;
				var c = o.weekStart;
				return u.map(function (e, t) {
					return u[(t + (c || 0)) % 7];
				});
			},
			o = function () {
				return n.Ls[n.locale()];
			},
			a = function (e, t) {
				return (
					e.formats[t] ||
					e.formats[t.toUpperCase()].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e, t, n) {
						return t || n.slice(1);
					})
				);
			},
			l = function () {
				var e = this;
				return {
					months: function (t) {
						return t ? t.format("MMMM") : s(e, "months");
					},
					monthsShort: function (t) {
						return t ? t.format("MMM") : s(e, "monthsShort", "months", 3);
					},
					firstDayOfWeek: function () {
						return e.$locale().weekStart || 0;
					},
					weekdays: function (t) {
						return t ? t.format("dddd") : s(e, "weekdays");
					},
					weekdaysMin: function (t) {
						return t ? t.format("dd") : s(e, "weekdaysMin", "weekdays", 2);
					},
					weekdaysShort: function (t) {
						return t ? t.format("ddd") : s(e, "weekdaysShort", "weekdays", 3);
					},
					longDateFormat: function (t) {
						return a(e.$locale(), t);
					},
					meridiem: this.$locale().meridiem,
					ordinal: this.$locale().ordinal
				};
			};
		(r.localeData = function () {
			return l.bind(this)();
		}),
			(n.localeData = function () {
				var e = o();
				return {
					firstDayOfWeek: function () {
						return e.weekStart || 0;
					},
					weekdays: function () {
						return n.weekdays();
					},
					weekdaysShort: function () {
						return n.weekdaysShort();
					},
					weekdaysMin: function () {
						return n.weekdaysMin();
					},
					months: function () {
						return n.months();
					},
					monthsShort: function () {
						return n.monthsShort();
					},
					longDateFormat: function (t) {
						return a(e, t);
					},
					meridiem: e.meridiem,
					ordinal: e.ordinal
				};
			}),
			(n.months = function () {
				return s(o(), "months");
			}),
			(n.monthsShort = function () {
				return s(o(), "monthsShort", "months", 3);
			}),
			(n.weekdays = function (e) {
				return s(o(), "weekdays", null, null, e);
			}),
			(n.weekdaysShort = function (e) {
				return s(o(), "weekdaysShort", "weekdays", 3, e);
			}),
			(n.weekdaysMin = function (e) {
				return s(o(), "weekdaysMin", "weekdays", 2, e);
			});
	}),
	nU = { exports: {} },
	rU = (nU.exports = (function () {
		var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" },
			t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
			n = /\d\d/,
			r = /\d\d?/,
			i = /\d*[^-_:/,()\s\d]+/,
			s = {},
			o = function (e) {
				return (e = +e) + (e > 68 ? 1900 : 2e3);
			},
			a = function (e) {
				return function (t) {
					this[e] = +t;
				};
			},
			l = [
				/[+-]\d\d:?(\d\d)?|Z/,
				function (e) {
					(this.zone || (this.zone = {})).offset = (function (e) {
						if (!e) return 0;
						if ("Z" === e) return 0;
						var t = e.match(/([+-]|\d\d)/g),
							n = 60 * t[1] + (+t[2] || 0);
						return 0 === n ? 0 : "+" === t[0] ? -n : n;
					})(e);
				}
			],
			u = function (e) {
				var t = s[e];
				return t && (t.indexOf ? t : t.s.concat(t.f));
			},
			c = function (e, t) {
				var n,
					r = s.meridiem;
				if (r) {
					for (var i = 1; i <= 24; i += 1)
						if (e.indexOf(r(i, 0, t)) > -1) {
							n = i > 12;
							break;
						}
				} else n = e === (t ? "pm" : "PM");
				return n;
			},
			h = {
				A: [
					i,
					function (e) {
						this.afternoon = c(e, !1);
					}
				],
				a: [
					i,
					function (e) {
						this.afternoon = c(e, !0);
					}
				],
				S: [
					/\d/,
					function (e) {
						this.milliseconds = 100 * +e;
					}
				],
				SS: [
					n,
					function (e) {
						this.milliseconds = 10 * +e;
					}
				],
				SSS: [
					/\d{3}/,
					function (e) {
						this.milliseconds = +e;
					}
				],
				s: [r, a("seconds")],
				ss: [r, a("seconds")],
				m: [r, a("minutes")],
				mm: [r, a("minutes")],
				H: [r, a("hours")],
				h: [r, a("hours")],
				HH: [r, a("hours")],
				hh: [r, a("hours")],
				D: [r, a("day")],
				DD: [n, a("day")],
				Do: [
					i,
					function (e) {
						var t = s.ordinal,
							n = e.match(/\d+/);
						if (((this.day = n[0]), t)) for (var r = 1; r <= 31; r += 1) t(r).replace(/\[|\]/g, "") === e && (this.day = r);
					}
				],
				M: [r, a("month")],
				MM: [n, a("month")],
				MMM: [
					i,
					function (e) {
						var t = u("months"),
							n =
								(
									u("monthsShort") ||
									t.map(function (e) {
										return e.slice(0, 3);
									})
								).indexOf(e) + 1;
						if (n < 1) throw new Error();
						this.month = n % 12 || n;
					}
				],
				MMMM: [
					i,
					function (e) {
						var t = u("months").indexOf(e) + 1;
						if (t < 1) throw new Error();
						this.month = t % 12 || t;
					}
				],
				Y: [/[+-]?\d+/, a("year")],
				YY: [
					n,
					function (e) {
						this.year = o(e);
					}
				],
				YYYY: [/\d{4}/, a("year")],
				Z: l,
				ZZ: l
			};
		function d(n) {
			var r, i;
			(r = n), (i = s && s.formats);
			for (
				var o = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (t, n, r) {
						var s = r && r.toUpperCase();
						return (
							n ||
							i[r] ||
							e[r] ||
							i[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e, t, n) {
								return t || n.slice(1);
							})
						);
					})).match(t),
					a = o.length,
					l = 0;
				l < a;
				l += 1
			) {
				var u = o[l],
					c = h[u],
					d = c && c[0],
					p = c && c[1];
				o[l] = p ? { regex: d, parser: p } : u.replace(/^\[|\]$/g, "");
			}
			return function (e) {
				for (var t = {}, n = 0, r = 0; n < a; n += 1) {
					var i = o[n];
					if ("string" == typeof i) r += i.length;
					else {
						var s = i.regex,
							l = i.parser,
							u = e.slice(r),
							c = s.exec(u)[0];
						l.call(t, c), (e = e.replace(c, ""));
					}
				}
				return (
					(function (e) {
						var t = e.afternoon;
						if (void 0 !== t) {
							var n = e.hours;
							t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
						}
					})(t),
					t
				);
			};
		}
		return function (e, t, n) {
			(n.p.customParseFormat = !0), e && e.parseTwoDigitYear && (o = e.parseTwoDigitYear);
			var r = t.prototype,
				i = r.parse;
			r.parse = function (e) {
				var t = e.date,
					r = e.utc,
					o = e.args;
				this.$u = r;
				var a = o[1];
				if ("string" == typeof a) {
					var l = !0 === o[2],
						u = !0 === o[3],
						c = l || u,
						h = o[2];
					u && (h = o[2]),
						(s = this.$locale()),
						!l && h && (s = n.Ls[h]),
						(this.$d = (function (e, t, n) {
							try {
								if (["x", "X"].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
								var r = d(t)(e),
									i = r.year,
									s = r.month,
									o = r.day,
									a = r.hours,
									l = r.minutes,
									u = r.seconds,
									c = r.milliseconds,
									h = r.zone,
									p = new Date(),
									f = o || (i || s ? 1 : p.getDate()),
									m = i || p.getFullYear(),
									v = 0;
								(i && !s) || (v = s > 0 ? s - 1 : p.getMonth());
								var g = a || 0,
									y = l || 0,
									b = u || 0,
									x = c || 0;
								return h ? new Date(Date.UTC(m, v, f, g, y, b, x + 60 * h.offset * 1e3)) : n ? new Date(Date.UTC(m, v, f, g, y, b, x)) : new Date(m, v, f, g, y, b, x);
							} catch (_) {
								return new Date("");
							}
						})(t, a, r)),
						this.init(),
						h && !0 !== h && (this.$L = this.locale(h).$L),
						c && t != this.format(a) && (this.$d = new Date("")),
						(s = {});
				} else if (a instanceof Array)
					for (var p = a.length, f = 1; f <= p; f += 1) {
						o[1] = a[f - 1];
						var m = n.apply(this, o);
						if (m.isValid()) {
							(this.$d = m.$d), (this.$L = m.$L), this.init();
							break;
						}
						f === p && (this.$d = new Date(""));
					}
				else i.call(this, e);
			};
		};
	})());
const iU = ["hours", "minutes", "seconds"],
	sU = { date: "YYYY-MM-DD", dates: "YYYY-MM-DD", week: "gggg[w]ww", year: "YYYY", month: "YYYY-MM", datetime: "YYYY-MM-DD HH:mm:ss", monthrange: "YYYY-MM", daterange: "YYYY-MM-DD", datetimerange: "YYYY-MM-DD HH:mm:ss" },
	oU = (e, t) => [e > 0 ? e - 1 : void 0, e, e < t ? e + 1 : void 0],
	aU = (e) => Array.from(Array.from({ length: e }).keys()),
	lU = (e) =>
		e
			.replace(/\W?m{1,2}|\W?ZZ/g, "")
			.replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "")
			.trim(),
	uU = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(),
	cU = function (e, t) {
		const n = wR(e),
			r = wR(t);
		return n && r ? e.getTime() === t.getTime() : !n && !r && e === t;
	},
	hU = function (e, t) {
		const n = _R(e),
			r = _R(t);
		return n && r ? e.length === t.length && e.every((e, n) => cU(e, t[n])) : !n && !r && cU(e, t);
	},
	dU = function (e, t, n) {
		const r = FR(t) || "x" === t ? QV(e).locale(n) : QV(e, t).locale(n);
		return r.isValid() ? r : void 0;
	},
	pU = function (e, t, n) {
		return FR(t) ? e : "x" === t ? +e : QV(e).locale(n).format(t);
	},
	fU = uN({
		id: { type: [Array, String] },
		name: { type: [Array, String], default: "" },
		popperClass: { type: String, default: "" },
		format: String,
		valueFormat: String,
		type: { type: String, default: "" },
		clearable: { type: Boolean, default: !0 },
		clearIcon: { type: [String, Object], default: QL },
		editable: { type: Boolean, default: !0 },
		prefixIcon: { type: [String, Object], default: "" },
		size: cD,
		readonly: { type: Boolean, default: !1 },
		disabled: { type: Boolean, default: !1 },
		placeholder: { type: String, default: "" },
		popperOptions: { type: Object, default: () => ({}) },
		modelValue: { type: [Date, Array, String, Number], default: "" },
		rangeSeparator: { type: String, default: "-" },
		startPlaceholder: String,
		endPlaceholder: String,
		defaultValue: { type: [Date, Array] },
		defaultTime: { type: [Date, Array] },
		isRange: { type: Boolean, default: !1 },
		disabledHours: { type: Function },
		disabledMinutes: { type: Function },
		disabledSeconds: { type: Function },
		disabledDate: { type: Function },
		cellClassName: { type: Function },
		shortcuts: { type: Array, default: () => [] },
		arrowControl: { type: Boolean, default: !1 },
		label: { type: String, default: void 0 },
		tabindex: { type: [String, Number], default: 0 },
		validateEvent: { type: Boolean, default: !0 },
		unlinkPanels: Boolean
	}),
	mU = ["id", "name", "placeholder", "value", "disabled", "readonly"],
	vU = ["id", "name", "placeholder", "value", "disabled", "readonly"];
var gU = IB(
	Tn(
		c(u({}, { name: "Picker" }), {
			props: fU,
			emits: ["update:modelValue", "change", "focus", "blur", "calendar-change", "panel-change", "visible-change", "keydown"],
			setup(e, { expose: t, emit: n }) {
				const r = e,
					{ lang: i } = CD(),
					s = BD("date"),
					o = BD("input"),
					a = BD("range"),
					l = vn(GN, {}),
					u = vn(YN, {}),
					c = vn("ElPopperOptions", {}),
					h = Qe(),
					d = Qe(),
					p = Qe(!1),
					f = Qe(!1),
					m = Qe(null);
				let v = !1,
					g = !1;
				ds(p, (e) => {
					e
						? (m.value = r.modelValue)
						: ((q.value = null),
						  ns(() => {
								y(r.modelValue);
						  }));
				});
				const y = (e, t) => {
						var i;
						(!t && hU(e, m.value)) || (n("change", e), r.validateEvent && (null == (i = u.validate) || i.call(u, "change").catch((e) => {})));
					},
					b = (e) => {
						if (!hU(r.modelValue, e)) {
							let t;
							_R(e) ? (t = e.map((e) => pU(e, r.valueFormat, i.value))) : e && (t = pU(e, r.valueFormat, i.value)), n("update:modelValue", e ? t : e, i.value);
						}
					},
					x = ht(() => {
						if (d.value) {
							const e = G.value ? d.value : d.value.$el;
							return Array.from(e.querySelectorAll("input"));
						}
						return [];
					}),
					_ = (e, t, n) => {
						const r = x.value;
						r.length && (n && "min" !== n ? "max" === n && (r[1].setSelectionRange(e, t), r[1].focus()) : (r[0].setSelectionRange(e, t), r[0].focus()));
					},
					w = () => {
						A(!0, !0),
							ns(() => {
								g = !1;
							});
					},
					C = (e = "", t = !1) => {
						let n;
						t || w(), (p.value = t), (n = _R(e) ? e.map((e) => e.toDate()) : e ? e.toDate() : e), (q.value = null), b(n);
					},
					S = () => {
						f.value = !0;
					},
					E = () => {
						n("visible-change", !0);
					},
					T = (e) => {
						(null == e ? void 0 : e.key) === bN.esc && A(!0, !0);
					},
					k = () => {
						(f.value = !1), (g = !1), n("visible-change", !1);
					},
					A = (e = !0, t = !1) => {
						g = t;
						const [n, r] = it(x);
						let i = n;
						!e && G.value && (i = r), i && i.focus();
					},
					M = (e) => {
						r.readonly || L.value || p.value || g || ((p.value = !0), n("focus", e));
					};
				let I;
				const R = (e) => {
						const t = async () => {
							setTimeout(() => {
								var i, s;
								I === t &&
									(((null == (i = h.value) ? void 0 : i.isFocusInsideContent()) && !v) ||
										0 !== x.value.filter((e) => e.contains(document.activeElement)).length ||
										(Z(), (p.value = !1), n("blur", e), r.validateEvent && (null == (s = u.validate) || s.call(u, "blur").catch((e) => {}))),
									(v = !1));
							}, 0);
						};
						(I = t), t();
					},
					L = ht(() => r.disabled || l.disabled),
					O = ht(() => {
						let e;
						if ((U.value ? ae.value.getDefaultValue && (e = ae.value.getDefaultValue()) : (e = _R(r.modelValue) ? r.modelValue.map((e) => dU(e, r.valueFormat, i.value)) : dU(r.modelValue, r.valueFormat, i.value)), ae.value.getRangeAvailableTime)) {
							const t = ae.value.getRangeAvailableTime(e);
							rk(t, e) || ((e = t), b(_R(e) ? e.map((e) => e.toDate()) : e.toDate()));
						}
						return _R(e) && e.some((e) => !e) && (e = []), e;
					}),
					P = ht(() => {
						if (!ae.value.panelReady) return "";
						const e = Q(O.value);
						return _R(q.value) ? [q.value[0] || (e && e[0]) || "", q.value[1] || (e && e[1]) || ""] : null !== q.value ? q.value : (!D.value && U.value) || (!p.value && U.value) ? "" : e ? (B.value ? e.join(", ") : e) : "";
					}),
					N = ht(() => r.type.includes("time")),
					D = ht(() => r.type.startsWith("time")),
					B = ht(() => "dates" === r.type),
					F = ht(() => r.prefixIcon || (N.value ? rO : EL)),
					H = Qe(!1),
					V = (e) => {
						r.readonly || L.value || (H.value && (e.stopPropagation(), w(), b(null), y(null, !0), (H.value = !1), (p.value = !1), ae.value.handleClear && ae.value.handleClear()));
					},
					U = ht(() => {
						const { modelValue: e } = r;
						return !e || (_R(e) && !e.filter(Boolean).length);
					}),
					z = async (e) => {
						var t;
						r.readonly || L.value || (("INPUT" !== (null == (t = e.target) ? void 0 : t.tagName) || x.value.includes(document.activeElement)) && (p.value = !0));
					},
					$ = () => {
						r.readonly || L.value || (!U.value && r.clearable && (H.value = !0));
					},
					j = () => {
						H.value = !1;
					},
					W = (e) => {
						var t;
						("INPUT" !== (null == (t = e.touches[0].target) ? void 0 : t.tagName) || x.value.includes(document.activeElement)) && (p.value = !0);
					},
					G = ht(() => r.type.includes("range")),
					Y = hD(),
					X = ht(() => {
						var e, t;
						return null == (t = null == (e = it(h)) ? void 0 : e.popperRef) ? void 0 : t.contentRef;
					}),
					K = ht(() => {
						var e;
						return it(G) ? it(d) : null == (e = it(d)) ? void 0 : e.$el;
					});
				sR(K, (e) => {
					const t = it(X),
						n = it(K);
					(t && (e.target === t || e.composedPath().includes(t))) || e.target === n || e.composedPath().includes(n) || (p.value = !1);
				});
				const q = Qe(null),
					Z = () => {
						if (q.value) {
							const e = J(P.value);
							e && ee(e) && (b(_R(e) ? e.map((e) => e.toDate()) : e.toDate()), (q.value = null));
						}
						"" === q.value && (b(null), y(null), (q.value = null));
					},
					J = (e) => (e ? ae.value.parseUserInput(e) : null),
					Q = (e) => (e ? ae.value.formatToString(e) : null),
					ee = (e) => ae.value.isValidValue(e),
					te = async (e) => {
						const { code: t } = e;
						if ((n("keydown", e), t !== bN.esc))
							if (t === bN.down && (ae.value.handleFocusPicker && (e.preventDefault(), e.stopPropagation()), !1 === p.value && ((p.value = !0), await ns()), ae.value.handleFocusPicker)) ae.value.handleFocusPicker();
							else {
								if (t !== bN.tab)
									return t === bN.enter || t === bN.numpadEnter ? ((null === q.value || "" === q.value || ee(J(P.value))) && (Z(), (p.value = !1)), void e.stopPropagation()) : void (q.value ? e.stopPropagation() : ae.value.handleKeydownInput && ae.value.handleKeydownInput(e));
								v = !0;
							}
						else !0 === p.value && ((p.value = !1), e.preventDefault(), e.stopPropagation());
					},
					ne = (e) => {
						(q.value = e), p.value || (p.value = !0);
					},
					re = (e) => {
						const t = e.target;
						q.value ? (q.value = [t.value, q.value[1]]) : (q.value = [t.value, null]);
					},
					ie = (e) => {
						const t = e.target;
						q.value ? (q.value = [q.value[0], t.value]) : (q.value = [null, t.value]);
					},
					se = () => {
						var e;
						const t = q.value,
							n = J(t && t[0]),
							r = it(O);
						if (n && n.isValid()) {
							q.value = [Q(n), (null == (e = P.value) ? void 0 : e[1]) || null];
							const t = [n, r && (r[1] || null)];
							ee(t) && (b(t), (q.value = null));
						}
					},
					oe = () => {
						var e;
						const t = it(q),
							n = J(t && t[1]),
							r = it(O);
						if (n && n.isValid()) {
							q.value = [(null == (e = it(P)) ? void 0 : e[0]) || null, Q(n)];
							const t = [r && r[0], n];
							ee(t) && (b(t), (q.value = null));
						}
					},
					ae = Qe({}),
					le = (e) => {
						(ae.value[e[0]] = e[1]), (ae.value.panelReady = !0);
					},
					ue = (e) => {
						n("calendar-change", e);
					},
					ce = (e, t, r) => {
						n("panel-change", e, t, r);
					};
				return (
					mn("EP_PICKER_BASE", { props: r }),
					t({ focus: A, handleFocusInput: M, handleBlurInput: R, onPick: C }),
					(e, t) => (
						Wr(),
						qr(
							it(QH),
							hi({ ref_key: "refPopper", ref: h, visible: p.value, "onUpdate:visible": t[2] || (t[2] = (e) => (p.value = e)), effect: "light", pure: "", trigger: "click" }, e.$attrs, {
								role: "dialog",
								teleported: "",
								transition: `${it(s).namespace.value}-zoom-in-top`,
								"popper-class": [`${it(s).namespace.value}-picker__popper`, e.popperClass],
								"popper-options": it(c),
								"fallback-placements": ["bottom", "top", "right", "left"],
								"gpu-acceleration": !1,
								"stop-popper-mouse-event": !1,
								"hide-after": 0,
								persistent: "",
								onBeforeShow: S,
								onShow: E,
								onHide: k
							}),
							{
								default: cn(() => [
									it(G)
										? (Wr(),
										  Kr(
												"div",
												{
													key: 1,
													ref_key: "inputRef",
													ref: d,
													class: gt([it(s).b("editor"), it(s).bm("editor", e.type), it(o).e("wrapper"), it(s).is("disabled", it(L)), it(s).is("active", p.value), it(a).b("editor"), it(Y) ? it(a).bm("editor", it(Y)) : "", e.$attrs.class]),
													style: pt(e.$attrs.style),
													onClick: M,
													onMousedown: z,
													onMouseenter: $,
													onMouseleave: j,
													onTouchstart: W,
													onKeydown: te
												},
												[
													it(F) ? (Wr(), qr(it(OB), { key: 0, class: gt([it(o).e("icon"), it(a).e("icon")]), onMousedown: z, onTouchstart: W }, { default: cn(() => [(Wr(), qr(Nr(it(F))))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
													ni(
														"input",
														{
															id: e.id && e.id[0],
															autocomplete: "off",
															name: e.name && e.name[0],
															placeholder: e.startPlaceholder,
															value: it(P) && it(P)[0],
															disabled: it(L),
															readonly: !e.editable || e.readonly,
															class: gt(it(a).b("input")),
															onInput: re,
															onChange: se,
															onFocus: M,
															onBlur: R
														},
														null,
														42,
														mU
													),
													mi(e.$slots, "range-separator", {}, () => [ni("span", { class: gt(it(a).b("separator")) }, bt(e.rangeSeparator), 3)]),
													ni(
														"input",
														{
															id: e.id && e.id[1],
															autocomplete: "off",
															name: e.name && e.name[1],
															placeholder: e.endPlaceholder,
															value: it(P) && it(P)[1],
															disabled: it(L),
															readonly: !e.editable || e.readonly,
															class: gt(it(a).b("input")),
															onFocus: M,
															onBlur: R,
															onInput: ie,
															onChange: oe
														},
														null,
														42,
														vU
													),
													e.clearIcon ? (Wr(), qr(it(OB), { key: 1, class: gt([it(o).e("icon"), it(a).e("close-icon"), { [it(a).e("close-icon--hidden")]: !H.value }]), onClick: V }, { default: cn(() => [(Wr(), qr(Nr(e.clearIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)
												],
												38
										  ))
										: (Wr(),
										  qr(
												it(WB),
												{
													key: 0,
													id: e.id,
													ref_key: "inputRef",
													ref: d,
													"container-role": "combobox",
													"model-value": it(P),
													name: e.name,
													size: it(Y),
													disabled: it(L),
													placeholder: e.placeholder,
													class: gt([it(s).b("editor"), it(s).bm("editor", e.type), e.$attrs.class]),
													style: pt(e.$attrs.style),
													readonly: !e.editable || e.readonly || it(B) || "week" === e.type,
													label: e.label,
													tabindex: e.tabindex,
													onInput: ne,
													onFocus: M,
													onBlur: R,
													onKeydown: te,
													onChange: Z,
													onMousedown: z,
													onMouseenter: $,
													onMouseleave: j,
													onTouchstart: W,
													onClick: t[0] || (t[0] = zo(() => {}, ["stop"]))
												},
												{
													prefix: cn(() => [it(F) ? (Wr(), qr(it(OB), { key: 0, class: gt(it(o).e("icon")), onMousedown: z, onTouchstart: W }, { default: cn(() => [(Wr(), qr(Nr(it(F))))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)]),
													suffix: cn(() => [H.value && e.clearIcon ? (Wr(), qr(it(OB), { key: 0, class: gt(`${it(o).e("icon")} clear-icon`), onClick: zo(V, ["stop"]) }, { default: cn(() => [(Wr(), qr(Nr(e.clearIcon)))]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)]),
													_: 1
												},
												8,
												["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"]
										  ))
								]),
								content: cn(() => [
									mi(e.$slots, "default", {
										visible: p.value,
										actualVisible: f.value,
										parsedValue: it(O),
										format: e.format,
										unlinkPanels: e.unlinkPanels,
										type: e.type,
										defaultValue: e.defaultValue,
										onPick: C,
										onSelectRange: _,
										onSetPickerOption: le,
										onCalendarChange: ue,
										onPanelChange: ce,
										onKeydown: T,
										onMousedown: t[1] || (t[1] = zo(() => {}, ["stop"]))
									})
								]),
								_: 3
							},
							16,
							["visible", "transition", "popper-class", "popper-options"]
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]
);
const yU = uN({ visible: Boolean, actualVisible: { type: Boolean, default: void 0 }, datetimeRole: String, parsedValue: { type: Object }, format: { type: String, default: "" } }),
	bU = ({ getAvailableHours: e, getAvailableMinutes: t, getAvailableSeconds: n }) => {
		const r = {};
		return {
			timePickerOptions: r,
			getAvailableTime: (r, i, s, o) => {
				const a = { hour: e, minute: t, second: n };
				let l = r;
				return (
					["hour", "minute", "second"].forEach((e) => {
						if (a[e]) {
							let t;
							const n = a[e];
							switch (e) {
								case "minute":
									t = n(l.hour(), i, o);
									break;
								case "second":
									t = n(l.hour(), l.minute(), i, o);
									break;
								default:
									t = n(i, o);
							}
							if ((null == t ? void 0 : t.length) && !t.includes(l[e]())) {
								const n = s ? 0 : t.length - 1;
								l = l[e](t[n]);
							}
						}
					}),
					l
				);
			},
			onSetOption: ([e, t]) => {
				r[e] = t;
			}
		};
	},
	xU = new Map();
let _U;
function wU(e, t) {
	let n = [];
	return (
		Array.isArray(t.arg) ? (n = t.arg) : HR(t.arg) && n.push(t.arg),
		function (r, i) {
			const s = t.instance.popperRef,
				o = r.target,
				a = null == i ? void 0 : i.target,
				l = !t || !t.instance,
				u = !o || !a,
				c = e.contains(o) || e.contains(a),
				h = e === o,
				d = (n.length && n.some((e) => (null == e ? void 0 : e.contains(o)))) || (n.length && n.includes(a)),
				p = s && (s.contains(o) || s.contains(a));
			l || u || c || h || d || p || t.value(r, i);
		}
	);
}
GI &&
	(document.addEventListener("mousedown", (e) => (_U = e)),
	document.addEventListener("mouseup", (e) => {
		for (const t of xU.values()) for (const { documentHandler: n } of t) n(e, _U);
	}));
const CU = {
	beforeMount(e, t) {
		xU.has(e) || xU.set(e, []), xU.get(e).push({ documentHandler: wU(e, t), bindingFn: t.value });
	},
	updated(e, t) {
		xU.has(e) || xU.set(e, []);
		const n = xU.get(e),
			r = n.findIndex((e) => e.bindingFn === t.oldValue),
			i = { documentHandler: wU(e, t), bindingFn: t.value };
		r >= 0 ? n.splice(r, 1, i) : n.push(i);
	},
	unmounted(e) {
		xU.delete(e);
	}
};
var SU = {
	beforeMount(e, t) {
		let n,
			r = null;
		const i = () => t.value && t.value(),
			s = () => {
				Date.now() - n < 100 && i(), clearInterval(r), (r = null);
			};
		RI(e, "mousedown", (e) => {
			0 === e.button && ((n = Date.now()), OI(document, "mouseup", s), clearInterval(r), (r = setInterval(i, 100)));
		});
	}
};
const EU = [],
	TU = (e) => {
		if (0 === EU.length) return;
		const t = EU[EU.length - 1]["_trap-focus-children"];
		if (t.length > 0 && e.code === bN.tab) {
			if (1 === t.length) return e.preventDefault(), void (document.activeElement !== t[0] && t[0].focus());
			const n = e.shiftKey,
				r = e.target === t[0],
				i = e.target === t[t.length - 1];
			r && n && (e.preventDefault(), t[t.length - 1].focus()), i && !n && (e.preventDefault(), t[0].focus());
		}
	},
	kU = {
		beforeMount(e) {
			(e["_trap-focus-children"] = EI(e)), EU.push(e), EU.length <= 1 && RI(document, "keydown", TU);
		},
		updated(e) {
			ns(() => {
				e["_trap-focus-children"] = EI(e);
			});
		},
		unmounted() {
			EU.shift(), 0 === EU.length && LI(document, "keydown", TU);
		}
	};
var AU,
	MU,
	IU,
	RU,
	LU,
	OU,
	PU,
	NU,
	DU,
	BU,
	FU,
	HU,
	VU,
	UU,
	zU,
	$U = !1;
function jU() {
	if (!$U) {
		$U = !0;
		var e = navigator.userAgent,
			t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e),
			n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
		if (((HU = /\b(iPhone|iP[ao]d)/.exec(e)), (VU = /\b(iP[ao]d)/.exec(e)), (BU = /Android/i.exec(e)), (UU = /FBAN\/\w+;/i.exec(e)), (zU = /Mobile/i.exec(e)), (FU = !!/Win64/.exec(e)), t)) {
			(AU = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN) && document && document.documentMode && (AU = document.documentMode);
			var r = /(?:Trident\/(\d+.\d+))/.exec(e);
			(OU = r ? parseFloat(r[1]) + 4 : AU), (MU = t[2] ? parseFloat(t[2]) : NaN), (IU = t[3] ? parseFloat(t[3]) : NaN), (RU = t[4] ? parseFloat(t[4]) : NaN) ? ((t = /(?:Chrome\/(\d+\.\d+))/.exec(e)), (LU = t && t[1] ? parseFloat(t[1]) : NaN)) : (LU = NaN);
		} else AU = MU = IU = LU = RU = NaN;
		if (n) {
			if (n[1]) {
				var i = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
				PU = !i || parseFloat(i[1].replace("_", "."));
			} else PU = !1;
			(NU = !!n[2]), (DU = !!n[3]);
		} else PU = NU = DU = !1;
	}
}
var WU,
	GU = {
		ie: function () {
			return jU() || AU;
		},
		ieCompatibilityMode: function () {
			return jU() || OU > AU;
		},
		ie64: function () {
			return GU.ie() && FU;
		},
		firefox: function () {
			return jU() || MU;
		},
		opera: function () {
			return jU() || IU;
		},
		webkit: function () {
			return jU() || RU;
		},
		safari: function () {
			return GU.webkit();
		},
		chrome: function () {
			return jU() || LU;
		},
		windows: function () {
			return jU() || NU;
		},
		osx: function () {
			return jU() || PU;
		},
		linux: function () {
			return jU() || DU;
		},
		iphone: function () {
			return jU() || HU;
		},
		mobile: function () {
			return jU() || HU || VU || BU || zU;
		},
		nativeApp: function () {
			return jU() || UU;
		},
		android: function () {
			return jU() || BU;
		},
		ipad: function () {
			return jU() || VU;
		}
	},
	YU = GU,
	XU = !!(typeof window < "u" && window.document && window.document.createElement),
	KU = { canUseDOM: XU, canUseWorkers: typeof Worker < "u", canUseEventListeners: XU && !(!window.addEventListener && !window.attachEvent), canUseViewport: XU && !!window.screen, isInWorker: !XU };
KU.canUseDOM && (WU = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
var qU = function (e, t) {
	if (!KU.canUseDOM || (t && !("addEventListener" in document))) return !1;
	var n = "on" + e,
		r = n in document;
	if (!r) {
		var i = document.createElement("div");
		i.setAttribute(n, "return;"), (r = "function" == typeof i[n]);
	}
	return !r && WU && "wheel" === e && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
};
function ZU(e) {
	var t = 0,
		n = 0,
		r = 0,
		i = 0;
	return (
		"detail" in e && (n = e.detail),
		"wheelDelta" in e && (n = -e.wheelDelta / 120),
		"wheelDeltaY" in e && (n = -e.wheelDeltaY / 120),
		"wheelDeltaX" in e && (t = -e.wheelDeltaX / 120),
		"axis" in e && e.axis === e.HORIZONTAL_AXIS && ((t = n), (n = 0)),
		(r = 10 * t),
		(i = 10 * n),
		"deltaY" in e && (i = e.deltaY),
		"deltaX" in e && (r = e.deltaX),
		(r || i) && e.deltaMode && (1 == e.deltaMode ? ((r *= 40), (i *= 40)) : ((r *= 800), (i *= 800))),
		r && !t && (t = r < 1 ? -1 : 1),
		i && !n && (n = i < 1 ? -1 : 1),
		{ spinX: t, spinY: n, pixelX: r, pixelY: i }
	);
}
ZU.getEventType = function () {
	return YU.firefox() ? "DOMMouseScroll" : qU("wheel") ? "wheel" : "mousewheel";
};
var JU = ZU;
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */ const QU = {
		beforeMount(e, t) {
			!(function (e, t) {
				if (e && e.addEventListener) {
					const n = function (e) {
						const n = JU(e);
						t && Reflect.apply(t, this, [e, n]);
					};
					e.addEventListener("wheel", n, { passive: !0 });
				}
			})(e, t.value);
		}
	},
	ez = {
		beforeMount(e, t) {
			var n, r;
			(e._handleResize = () => {
				var n;
				e && (null == (n = t.value) || n.call(t, e));
			}),
				(n = e),
				(r = e._handleResize),
				GI && n && (n.__resizeListeners__ || ((n.__resizeListeners__ = []), (n.__ro__ = new ResizeObserver(gR)), n.__ro__.observe(n)), n.__resizeListeners__.push(r));
		},
		beforeUnmount(e) {
			var t, n, r;
			(t = e), (n = e._handleResize), t && t.__resizeListeners__ && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(n), 1), t.__resizeListeners__.length || null == (r = t.__ro__) || r.disconnect());
		}
	},
	tz = uN({
		role: { type: String, required: !0 },
		spinnerDate: { type: Object, required: !0 },
		showSeconds: { type: Boolean, default: !0 },
		arrowControl: Boolean,
		amPmMode: { type: String, default: "" },
		disabledHours: { type: Function },
		disabledMinutes: { type: Function },
		disabledSeconds: { type: Function }
	}),
	nz = (e, t, n) => {
		const r = [],
			i = t && n();
		for (let s = 0; s < e; s++) r[s] = !!i && i.includes(s);
		return r;
	},
	rz = (e) => e.map((e, t) => e || t).filter((e) => !0 !== e),
	iz = (e, t, n) => ({ getHoursList: (t, n) => nz(24, e, () => e(t, n)), getMinutesList: (e, n, r) => nz(60, t, () => t(e, n, r)), getSecondsList: (e, t, r, i) => nz(60, n, () => n(e, t, r, i)) }),
	sz = (e, t, n) => {
		const { getHoursList: r, getMinutesList: i, getSecondsList: s } = iz(e, t, n);
		return { getAvailableHours: (e, t) => rz(r(e, t)), getAvailableMinutes: (e, t, n) => rz(i(e, t, n)), getAvailableSeconds: (e, t, n, r) => rz(s(e, t, n, r)) };
	},
	oz = (e) => {
		const t = Qe(e.parsedValue);
		return (
			ds(
				() => e.visible,
				(n) => {
					n || (t.value = e.parsedValue);
				}
			),
			t
		);
	},
	az = ["onClick"],
	lz = ["onMouseenter"];
var uz = IB(
	Tn({
		__name: "basic-time-spinner",
		props: tz,
		emits: ["change", "select-range", "set-option"],
		setup(e, { emit: t }) {
			const n = e,
				r = BD("time"),
				{ getHoursList: i, getMinutesList: s, getSecondsList: o } = iz(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
			let a = !1;
			const l = Qe(),
				u = { hours: Qe(), minutes: Qe(), seconds: Qe() },
				c = ht(() => (n.showSeconds ? iU : iU.slice(0, 2))),
				h = ht(() => {
					const { spinnerDate: e } = n;
					return { hours: e.hour(), minutes: e.minute(), seconds: e.second() };
				}),
				d = ht(() => {
					const { hours: e, minutes: t } = it(h);
					return { hours: i(n.role), minutes: s(e, n.role), seconds: o(e, t, n.role) };
				}),
				p = ht(() => {
					const { hours: e, minutes: t, seconds: n } = it(h);
					return { hours: oU(e, 23), minutes: oU(t, 59), seconds: oU(n, 59) };
				}),
				f = QT((e) => {
					(a = !1), g(e);
				}, 200),
				m = (e) => {
					if (!!!n.amPmMode) return "";
					let t = e < 12 ? " am" : " pm";
					return "A" === n.amPmMode && (t = t.toUpperCase()), t;
				},
				v = (e) => {
					let n;
					switch (e) {
						case "hours":
							n = [0, 2];
							break;
						case "minutes":
							n = [3, 5];
							break;
						case "seconds":
							n = [6, 8];
					}
					const [r, i] = n;
					t("select-range", r, i), (l.value = e);
				},
				g = (e) => {
					x(e, it(h)[e]);
				},
				y = () => {
					g("hours"), g("minutes"), g("seconds");
				},
				b = (e) => e.querySelector(`.${r.namespace.value}-scrollbar__wrap`),
				x = (e, t) => {
					if (n.arrowControl) return;
					const r = it(u[e]);
					r && r.$el && (b(r.$el).scrollTop = Math.max(0, t * _(e)));
				},
				_ = (e) => {
					const t = it(u[e]);
					return (null == t ? void 0 : t.$el.querySelector("li").offsetHeight) || 0;
				},
				w = () => {
					S(1);
				},
				C = () => {
					S(-1);
				},
				S = (e) => {
					l.value || v("hours");
					const t = l.value;
					let n = it(h)[t];
					const r = "hours" === l.value ? 24 : 60;
					(n = (n + e + r) % r), E(t, n), x(t, n), ns(() => v(t));
				},
				E = (e, r) => {
					if (it(d)[e][r]) return;
					const { hours: i, minutes: s, seconds: o } = it(h);
					let a;
					switch (e) {
						case "hours":
							a = n.spinnerDate.hour(r).minute(s).second(o);
							break;
						case "minutes":
							a = n.spinnerDate.hour(i).minute(r).second(o);
							break;
						case "seconds":
							a = n.spinnerDate.hour(i).minute(s).second(r);
					}
					t("change", a);
				},
				T = (e) => it(u[e]).$el.offsetHeight,
				k = () => {
					const e = (e) => {
						const t = it(u[e]);
						t &&
							t.$el &&
							(b(t.$el).onscroll = () => {
								((e) => {
									(a = !0), f(e);
									const t = Math.min(Math.round((b(it(u[e]).$el).scrollTop - (0.5 * T(e) - 10) / _(e) + 3) / _(e)), "hours" === e ? 23 : 59);
									E(e, t);
								})(e);
							});
					};
					e("hours"), e("minutes"), e("seconds");
				};
			Vn(() => {
				ns(() => {
					!n.arrowControl && k(), y(), "start" === n.role && v("hours");
				});
			});
			return (
				t("set-option", [`${n.role}_scrollDown`, S]),
				t("set-option", [`${n.role}_emitSelectRange`, v]),
				ds(
					() => n.spinnerDate,
					() => {
						a || y();
					}
				),
				(e, t) => (
					Wr(),
					Kr(
						"div",
						{ class: gt([it(r).b("spinner"), { "has-seconds": e.showSeconds }]) },
						[
							e.arrowControl
								? ai("v-if", !0)
								: (Wr(!0),
								  Kr(
										Hr,
										{ key: 0 },
										pi(
											it(c),
											(t) => (
												Wr(),
												qr(
													it(ZB),
													{
														key: t,
														ref_for: !0,
														ref: (e) => {
															return (n = e), void (u[t].value = n);
															var n;
														},
														class: gt(it(r).be("spinner", "wrapper")),
														"wrap-style": "max-height: inherit;",
														"view-class": it(r).be("spinner", "list"),
														noresize: "",
														tag: "ul",
														onMouseenter: (e) => v(t),
														onMousemove: (e) => g(t)
													},
													{
														default: cn(() => [
															(Wr(!0),
															Kr(
																Hr,
																null,
																pi(
																	it(d)[t],
																	(n, i) => (
																		Wr(),
																		Kr(
																			"li",
																			{
																				key: i,
																				class: gt([it(r).be("spinner", "item"), it(r).is("active", i === it(h)[t]), it(r).is("disabled", n)]),
																				onClick: (e) =>
																					((e, { value: t, disabled: n }) => {
																						n || (E(e, t), v(e), x(e, t));
																					})(t, { value: i, disabled: n })
																			},
																			["hours" === t ? (Wr(), Kr(Hr, { key: 0 }, [oi(bt(("0" + (e.amPmMode ? i % 12 || 12 : i)).slice(-2)) + bt(m(i)), 1)], 64)) : (Wr(), Kr(Hr, { key: 1 }, [oi(bt(("0" + i).slice(-2)), 1)], 64))],
																			10,
																			az
																		)
																	)
																),
																128
															))
														]),
														_: 2
													},
													1032,
													["class", "view-class", "onMouseenter", "onMousemove"]
												)
											)
										),
										128
								  )),
							e.arrowControl
								? (Wr(!0),
								  Kr(
										Hr,
										{ key: 1 },
										pi(
											it(c),
											(t) => (
												Wr(),
												Kr(
													"div",
													{ key: t, class: gt([it(r).be("spinner", "wrapper"), it(r).is("arrow")]), onMouseenter: (e) => v(t) },
													[
														yr((Wr(), qr(it(OB), { class: gt(["arrow-up", it(r).be("spinner", "arrow")]) }, { default: cn(() => [ri(it(gL))]), _: 1 }, 8, ["class"])), [[it(SU), C]]),
														yr((Wr(), qr(it(OB), { class: gt(["arrow-down", it(r).be("spinner", "arrow")]) }, { default: cn(() => [ri(it(sL))]), _: 1 }, 8, ["class"])), [[it(SU), w]]),
														ni(
															"ul",
															{ class: gt(it(r).be("spinner", "list")) },
															[
																(Wr(!0),
																Kr(
																	Hr,
																	null,
																	pi(
																		it(p)[t],
																		(n, i) => (
																			Wr(),
																			Kr(
																				"li",
																				{ key: i, class: gt([it(r).be("spinner", "item"), it(r).is("active", n === it(h)[t]), it(r).is("disabled", it(d)[t][n])]) },
																				[
																					"number" == typeof n
																						? (Wr(),
																						  Kr(
																								Hr,
																								{ key: 0 },
																								["hours" === t ? (Wr(), Kr(Hr, { key: 0 }, [oi(bt(("0" + (e.amPmMode ? n % 12 || 12 : n)).slice(-2)) + bt(m(n)), 1)], 64)) : (Wr(), Kr(Hr, { key: 1 }, [oi(bt(("0" + n).slice(-2)), 1)], 64))],
																								64
																						  ))
																						: ai("v-if", !0)
																				],
																				2
																			)
																		)
																	),
																	128
																))
															],
															2
														)
													],
													42,
													lz
												)
											)
										),
										128
								  ))
								: ai("v-if", !0)
						],
						2
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]
);
var cz = IB(
	Tn({
		__name: "panel-time-pick",
		props: yU,
		emits: ["pick", "select-range", "set-picker-option"],
		setup(e, { emit: t }) {
			const n = e,
				r = vn("EP_PICKER_BASE"),
				{ arrowControl: i, disabledHours: s, disabledMinutes: o, disabledSeconds: a, defaultValue: l } = r.props,
				{ getAvailableHours: u, getAvailableMinutes: c, getAvailableSeconds: h } = sz(s, o, a),
				d = BD("time"),
				{ t: p, lang: f } = CD(),
				m = Qe([0, 2]),
				v = oz(n),
				g = ht(() => (BR(n.actualVisible) ? `${d.namespace.value}-zoom-in-top` : "")),
				y = ht(() => n.format.includes("ss")),
				b = ht(() => (n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : "")),
				x = () => {
					t("pick", v.value, !1);
				},
				_ = (e) => {
					if (!n.visible) return;
					const r = T(e).millisecond(0);
					t("pick", r, !0);
				},
				w = (e, n) => {
					t("select-range", e, n), (m.value = [e, n]);
				},
				{ timePickerOptions: C, onSetOption: S, getAvailableTime: E } = bU({ getAvailableHours: u, getAvailableMinutes: c, getAvailableSeconds: h }),
				T = (e) => E(e, n.datetimeRole || "", !0);
			return (
				t("set-picker-option", [
					"isValidValue",
					(e) => {
						const t = QV(e).locale(f.value),
							n = T(t);
						return t.isSame(n);
					}
				]),
				t("set-picker-option", ["formatToString", (e) => (e ? e.format(n.format) : null)]),
				t("set-picker-option", ["parseUserInput", (e) => (e ? QV(e, n.format).locale(f.value) : null)]),
				t("set-picker-option", [
					"handleKeydownInput",
					(e) => {
						const t = e.code,
							{ left: n, right: r, up: i, down: s } = bN;
						if ([n, r].includes(t)) {
							return (
								((e) => {
									const t = [0, 3].concat(y.value ? [6] : []),
										n = ["hours", "minutes"].concat(y.value ? ["seconds"] : []),
										r = (t.indexOf(m.value[0]) + e + t.length) % t.length;
									C.start_emitSelectRange(n[r]);
								})(t === n ? -1 : 1),
								void e.preventDefault()
							);
						}
						if ([i, s].includes(t)) {
							const n = t === i ? -1 : 1;
							return C.start_scrollDown(n), void e.preventDefault();
						}
					}
				]),
				t("set-picker-option", ["getRangeAvailableTime", T]),
				t("set-picker-option", ["getDefaultValue", () => QV(l).locale(f.value)]),
				(e, r) => (
					Wr(),
					qr(
						lo,
						{ name: it(g) },
						{
							default: cn(() => [
								e.actualVisible || e.visible
									? (Wr(),
									  Kr(
											"div",
											{ key: 0, class: gt(it(d).b("panel")) },
											[
												ni(
													"div",
													{ class: gt([it(d).be("panel", "content"), { "has-seconds": it(y) }]) },
													[
														ri(
															uz,
															{
																ref: "spinner",
																role: e.datetimeRole || "start",
																"arrow-control": it(i),
																"show-seconds": it(y),
																"am-pm-mode": it(b),
																"spinner-date": e.parsedValue,
																"disabled-hours": it(s),
																"disabled-minutes": it(o),
																"disabled-seconds": it(a),
																onChange: _,
																onSetOption: it(S),
																onSelectRange: w
															},
															null,
															8,
															["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"]
														)
													],
													2
												),
												ni(
													"div",
													{ class: gt(it(d).be("panel", "footer")) },
													[
														ni("button", { type: "button", class: gt([it(d).be("panel", "btn"), "cancel"]), onClick: x }, bt(it(p)("el.datepicker.cancel")), 3),
														ni(
															"button",
															{
																type: "button",
																class: gt([it(d).be("panel", "btn"), "confirm"]),
																onClick:
																	r[0] ||
																	(r[0] = (e) =>
																		((e = !1, r = !1) => {
																			r || t("pick", n.parsedValue, e);
																		})())
															},
															bt(it(p)("el.datepicker.confirm")),
															3
														)
													],
													2
												)
											],
											2
									  ))
									: ai("v-if", !0)
							]),
							_: 1
						},
						8,
						["name"]
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]
);
const hz = uN({ visible: Boolean, actualVisible: Boolean, parsedValue: { type: Array }, format: { type: String, default: "" } }),
	dz = ["disabled"];
var pz = IB(
	Tn({
		__name: "panel-time-range",
		props: hz,
		emits: ["pick", "select-range", "set-picker-option"],
		setup(e, { emit: t }) {
			const n = e,
				r = (e, t) => {
					const n = [];
					for (let r = e; r <= t; r++) n.push(r);
					return n;
				},
				{ t: i, lang: s } = CD(),
				o = BD("time"),
				a = BD("picker"),
				l = vn("EP_PICKER_BASE"),
				{ arrowControl: u, disabledHours: c, disabledMinutes: h, disabledSeconds: d, defaultValue: p } = l.props,
				f = ht(() => n.parsedValue[0]),
				m = ht(() => n.parsedValue[1]),
				v = oz(n),
				g = ht(() => n.format.includes("ss")),
				y = ht(() => (n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : "")),
				b = (e) => {
					_(e.millisecond(0), m.value);
				},
				x = (e) => {
					_(f.value, e.millisecond(0));
				},
				_ = (e, n) => {
					t("pick", [e, n], !0);
				},
				w = ht(() => f.value > m.value),
				C = Qe([0, 2]),
				S = (e, n) => {
					t("select-range", e, n, "min"), (C.value = [e, n]);
				},
				E = ht(() => (g.value ? 11 : 8)),
				T = (e, n) => {
					t("select-range", e, n, "max");
					const r = it(E);
					C.value = [e + r, n + r];
				},
				k = (e, t) => {
					const n = c ? c(e) : [],
						i = "start" === e,
						s = (t || (i ? m.value : f.value)).hour(),
						o = i ? r(s + 1, 23) : r(0, s - 1);
					return pk(n, o);
				},
				A = (e, t, n) => {
					const i = h ? h(e, t) : [],
						s = "start" === t,
						o = n || (s ? m.value : f.value);
					if (e !== o.hour()) return i;
					const a = o.minute(),
						l = s ? r(a + 1, 59) : r(0, a - 1);
					return pk(i, l);
				},
				M = (e, t, n, i) => {
					const s = d ? d(e, t, n) : [],
						o = "start" === n,
						a = i || (o ? m.value : f.value),
						l = a.hour(),
						u = a.minute();
					if (e !== l || t !== u) return s;
					const c = a.second(),
						h = o ? r(c + 1, 59) : r(0, c - 1);
					return pk(s, h);
				},
				I = ([e, t]) => [N(e, "start", !0, t), N(t, "end", !1, e)],
				{ getAvailableHours: R, getAvailableMinutes: L, getAvailableSeconds: O } = sz(k, A, M),
				{ timePickerOptions: P, getAvailableTime: N, onSetOption: D } = bU({ getAvailableHours: R, getAvailableMinutes: L, getAvailableSeconds: O });
			return (
				t("set-picker-option", ["formatToString", (e) => (e ? (_R(e) ? e.map((e) => e.format(n.format)) : e.format(n.format)) : null)]),
				t("set-picker-option", ["parseUserInput", (e) => (e ? (_R(e) ? e.map((e) => QV(e, n.format).locale(s.value)) : QV(e, n.format).locale(s.value)) : null)]),
				t("set-picker-option", [
					"isValidValue",
					(e) => {
						const t = e.map((e) => QV(e).locale(s.value)),
							n = I(t);
						return t[0].isSame(n[0]) && t[1].isSame(n[1]);
					}
				]),
				t("set-picker-option", [
					"handleKeydownInput",
					(e) => {
						const t = e.code,
							{ left: n, right: r, up: i, down: s } = bN;
						if ([n, r].includes(t)) {
							return (
								((e) => {
									const t = g.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11],
										n = ["hours", "minutes"].concat(g.value ? ["seconds"] : []),
										r = (t.indexOf(C.value[0]) + e + t.length) % t.length,
										i = t.length / 2;
									r < i ? P.start_emitSelectRange(n[r]) : P.end_emitSelectRange(n[r - i]);
								})(t === n ? -1 : 1),
								void e.preventDefault()
							);
						}
						if ([i, s].includes(t)) {
							const n = t === i ? -1 : 1,
								r = C.value[0] < E.value ? "start" : "end";
							return P[`${r}_scrollDown`](n), void e.preventDefault();
						}
					}
				]),
				t("set-picker-option", [
					"getDefaultValue",
					() => {
						if (_R(p)) return p.map((e) => QV(e).locale(s.value));
						const e = QV(p).locale(s.value);
						return [e, e.add(60, "m")];
					}
				]),
				t("set-picker-option", ["getRangeAvailableTime", I]),
				(e, n) =>
					e.actualVisible
						? (Wr(),
						  Kr(
								"div",
								{ key: 0, class: gt([it(o).b("range-picker"), it(a).b("panel")]) },
								[
									ni(
										"div",
										{ class: gt(it(o).be("range-picker", "content")) },
										[
											ni(
												"div",
												{ class: gt(it(o).be("range-picker", "cell")) },
												[
													ni("div", { class: gt(it(o).be("range-picker", "header")) }, bt(it(i)("el.datepicker.startTime")), 3),
													ni(
														"div",
														{ class: gt([it(o).be("range-picker", "body"), it(o).be("panel", "content"), it(o).is("arrow", it(u)), { "has-seconds": it(g) }]) },
														[
															ri(
																uz,
																{
																	ref: "minSpinner",
																	role: "start",
																	"show-seconds": it(g),
																	"am-pm-mode": it(y),
																	"arrow-control": it(u),
																	"spinner-date": it(f),
																	"disabled-hours": k,
																	"disabled-minutes": A,
																	"disabled-seconds": M,
																	onChange: b,
																	onSetOption: it(D),
																	onSelectRange: S
																},
																null,
																8,
																["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"]
															)
														],
														2
													)
												],
												2
											),
											ni(
												"div",
												{ class: gt(it(o).be("range-picker", "cell")) },
												[
													ni("div", { class: gt(it(o).be("range-picker", "header")) }, bt(it(i)("el.datepicker.endTime")), 3),
													ni(
														"div",
														{ class: gt([it(o).be("range-picker", "body"), it(o).be("panel", "content"), it(o).is("arrow", it(u)), { "has-seconds": it(g) }]) },
														[
															ri(
																uz,
																{
																	ref: "maxSpinner",
																	role: "end",
																	"show-seconds": it(g),
																	"am-pm-mode": it(y),
																	"arrow-control": it(u),
																	"spinner-date": it(m),
																	"disabled-hours": k,
																	"disabled-minutes": A,
																	"disabled-seconds": M,
																	onChange: x,
																	onSetOption: it(D),
																	onSelectRange: T
																},
																null,
																8,
																["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"]
															)
														],
														2
													)
												],
												2
											)
										],
										2
									),
									ni(
										"div",
										{ class: gt(it(o).be("panel", "footer")) },
										[
											ni(
												"button",
												{
													type: "button",
													class: gt([it(o).be("panel", "btn"), "cancel"]),
													onClick:
														n[0] ||
														(n[0] = (e) => {
															t("pick", v.value, !1);
														})
												},
												bt(it(i)("el.datepicker.cancel")),
												3
											),
											ni(
												"button",
												{
													type: "button",
													class: gt([it(o).be("panel", "btn"), "confirm"]),
													disabled: it(w),
													onClick:
														n[1] ||
														(n[1] = (e) =>
															((e = !1) => {
																t("pick", [f.value, m.value], e);
															})())
												},
												bt(it(i)("el.datepicker.confirm")),
												11,
												dz
											)
										],
										2
									)
								],
								2
						  ))
						: ai("v-if", !0)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]
);
QV.extend(rU);
const fz = Tn({
	name: "ElTimePicker",
	install: null,
	props: c(u({}, fU), { isRange: { type: Boolean, default: !1 } }),
	emits: ["update:modelValue"],
	setup(e, t) {
		const n = Qe(),
			[r, i] = e.isRange ? ["timerange", pz] : ["time", cz],
			s = (e) => t.emit("update:modelValue", e);
		return (
			mn("ElPopperOptions", e.popperOptions),
			t.expose({
				focus: (e) => {
					var t;
					null == (t = n.value) || t.handleFocusInput(e);
				},
				blur: (e) => {
					var t;
					null == (t = n.value) || t.handleBlurInput(e);
				}
			}),
			() => {
				var t;
				const o = null != (t = e.format) ? t : "HH:mm:ss";
				return ri(gU, hi(e, { ref: n, type: r, format: o, "onUpdate:modelValue": s }), { default: (e) => ri(i, e, null) });
			}
		);
	}
});
fz.install = (e) => {
	e.component(fz.name, fz);
};
const mz = fz,
	vz = uN({ selectedDay: { type: Object }, range: { type: Array }, date: { type: Object, required: !0 }, hideHeader: { type: Boolean } }),
	gz = { pick: (e) => ER(e) },
	yz = { key: 0 },
	bz = ["onClick"];
var xz = IB(
	Tn(
		c(u({}, { name: "DateTable" }), {
			props: vz,
			emits: gz,
			setup(e, { expose: t, emit: n }) {
				const r = e;
				QV.extend(tU);
				const { t: i, lang: s } = CD(),
					o = BD("calendar-table"),
					a = BD("calendar-day"),
					l = QV().locale(s.value),
					u = l.$locale().weekStart || 0,
					c = ht(() => !!r.range && !!r.range.length),
					h = ht(() => {
						let e = [];
						if (c.value) {
							const [t, n] = r.range,
								i = aU(n.date() - t.date() + 1).map((e) => ({ text: t.date() + e, type: "current" }));
							let s = i.length % 7;
							s = 0 === s ? 0 : 7 - s;
							const o = aU(s).map((e, t) => ({ text: t + 1, type: "next" }));
							e = i.concat(o);
						} else {
							const t = r.date.startOf("month").day();
							e = [
								...((e, t) => {
									const n = e.subtract(1, "month").endOf("month").date();
									return aU(t).map((e, r) => n - (t - r - 1));
								})(r.date, t - u).map((e) => ({ text: e, type: "prev" })),
								...((e) => {
									const t = e.daysInMonth();
									return aU(t).map((e, t) => t + 1);
								})(r.date).map((e) => ({ text: e, type: "current" }))
							];
							const n = 7 - (e.length % 7 || 7),
								i = aU(n).map((e, t) => ({ text: t + 1, type: "next" }));
							e = e.concat(i);
						}
						return ((e) =>
							aU(e.length / 7).map((t) => {
								const n = 7 * t;
								return e.slice(n, n + 7);
							}))(e);
					}),
					d = ht(() => {
						const e = u;
						return 0 === e
							? xN.map((e) => i(`el.datepicker.weeks.${e}`))
							: xN
									.slice(e)
									.concat(xN.slice(0, e))
									.map((e) => i(`el.datepicker.weeks.${e}`));
					}),
					p = (e, t) => {
						switch (t) {
							case "prev":
								return r.date.startOf("month").subtract(1, "month").date(e);
							case "next":
								return r.date.startOf("month").add(1, "month").date(e);
							case "current":
								return r.date.date(e);
						}
					},
					f = ({ text: e, type: t }) => {
						const n = [t];
						if ("current" === t) {
							const i = p(e, t);
							i.isSame(r.selectedDay, "day") && n.push(a.is("selected")), i.isSame(l, "day") && n.push(a.is("today"));
						}
						return n;
					},
					m = ({ text: e, type: t }) => {
						const n = p(e, t);
						return { isSelected: n.isSame(r.selectedDay), type: `${t}-month`, day: n.format("YYYY-MM-DD"), date: n.toDate() };
					};
				return (
					t({ getFormattedDate: p }),
					(e, t) => (
						Wr(),
						Kr(
							"table",
							{ class: gt([it(o).b(), it(o).is("range", it(c))]), cellspacing: "0", cellpadding: "0" },
							[
								e.hideHeader
									? ai("v-if", !0)
									: (Wr(),
									  Kr("thead", yz, [
											(Wr(!0),
											Kr(
												Hr,
												null,
												pi(it(d), (e) => (Wr(), Kr("th", { key: e }, bt(e), 1))),
												128
											))
									  ])),
								ni("tbody", null, [
									(Wr(!0),
									Kr(
										Hr,
										null,
										pi(
											it(h),
											(t, r) => (
												Wr(),
												Kr(
													"tr",
													{ key: r, class: gt({ [it(o).e("row")]: !0, [it(o).em("row", "hide-border")]: 0 === r && e.hideHeader }) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(
																t,
																(t, r) => (
																	Wr(),
																	Kr(
																		"td",
																		{
																			key: r,
																			class: gt(f(t)),
																			onClick: (e) =>
																				(({ text: e, type: t }) => {
																					const r = p(e, t);
																					n("pick", r);
																				})(t)
																		},
																		[ni("div", { class: gt(it(a).b()) }, [mi(e.$slots, "dateCell", { data: m(t) }, () => [ni("span", null, bt(t.text), 1)])], 2)],
																		10,
																		bz
																	)
																)
															),
															128
														))
													],
													2
												)
											)
										),
										128
									))
								])
							],
							2
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]
);
const _z = uN({ modelValue: { type: Date }, range: { type: Array, validator: (e) => _R(e) && 2 === e.length && e.every((e) => wR(e)) } }),
	wz = { [_N]: (e) => wR(e), input: (e) => wR(e) };
const Cz = mN(
		IB(
			Tn(
				c(u({}, { name: "ElCalendar" }), {
					props: _z,
					emits: wz,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							i = BD("calendar"),
							{ t: s, lang: o } = CD(),
							a = Qe(),
							l = QV().locale(o.value),
							u = ht({
								get: () => (r.modelValue ? h.value : a.value),
								set(e) {
									if (!e) return;
									a.value = e;
									const t = e.toDate();
									n("input", t), n(_N, t);
								}
							}),
							c = ht(() => {
								if (!r.range) return [];
								const e = r.range.map((e) => QV(e).locale(o.value)),
									[t, n] = e;
								return t.isAfter(n) ? [] : t.isSame(n, "month") ? g(t, n) : t.add(1, "month").month() !== n.month() ? [] : g(t, n);
							}),
							h = ht(() => (r.modelValue ? QV(r.modelValue).locale(o.value) : u.value ? u.value : c.value.length ? c.value[0][0] : l)),
							d = ht(() => h.value.subtract(1, "month").date(1)),
							p = ht(() => h.value.add(1, "month").date(1)),
							f = ht(() => h.value.subtract(1, "year").date(1)),
							m = ht(() => h.value.add(1, "year").date(1)),
							v = ht(() => {
								const e = `el.datepicker.month${h.value.format("M")}`;
								return `${h.value.year()} ${s("el.datepicker.year")} ${s(e)}`;
							}),
							g = (e, t) => {
								const n = e.startOf("week"),
									r = t.endOf("week"),
									i = n.get("month"),
									s = r.get("month");
								if (i === s) return [[n, r]];
								if (i + 1 === s) {
									const e = n.endOf("month"),
										t = r.startOf("month"),
										i = e.isSame(t, "week");
									return [
										[n, e],
										[(i ? t.add(1, "week") : t).startOf("week"), r]
									];
								}
								if (i + 2 === s || (i + 1) % 11 === s) {
									const e = n.endOf("month"),
										t = n.add(1, "month").startOf("month"),
										i = e.isSame(t, "week") ? t.add(1, "week") : t,
										s = i.endOf("month"),
										o = r.startOf("month"),
										a = s.isSame(o, "week") ? o.add(1, "week") : o;
									return [
										[n, e],
										[i.startOf("week"), s],
										[a.startOf("week"), r]
									];
								}
								return [];
							},
							y = (e) => {
								u.value = e;
							},
							b = (e) => {
								let t;
								(t = "prev-month" === e ? d.value : "next-month" === e ? p.value : "prev-year" === e ? f.value : "next-year" === e ? m.value : l), t.isSame(h.value, "day") || y(t);
							};
						return (
							t({ selectedDay: u, pickDay: y, selectDate: b, calculateValidatedDateRange: g }),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{ class: gt(it(i).b()) },
									[
										ni(
											"div",
											{ class: gt(it(i).e("header")) },
											[
												mi(e.$slots, "header", { date: it(v) }, () => [
													ni("div", { class: gt(it(i).e("title")) }, bt(it(v)), 3),
													0 === it(c).length
														? (Wr(),
														  Kr(
																"div",
																{ key: 0, class: gt(it(i).e("button-group")) },
																[
																	ri(it(ZV), null, {
																		default: cn(() => [
																			ri(it(qV), { size: "small", onClick: t[0] || (t[0] = (e) => b("prev-month")) }, { default: cn(() => [oi(bt(it(s)("el.datepicker.prevMonth")), 1)]), _: 1 }),
																			ri(it(qV), { size: "small", onClick: t[1] || (t[1] = (e) => b("today")) }, { default: cn(() => [oi(bt(it(s)("el.datepicker.today")), 1)]), _: 1 }),
																			ri(it(qV), { size: "small", onClick: t[2] || (t[2] = (e) => b("next-month")) }, { default: cn(() => [oi(bt(it(s)("el.datepicker.nextMonth")), 1)]), _: 1 })
																		]),
																		_: 1
																	})
																],
																2
														  ))
														: ai("v-if", !0)
												])
											],
											2
										),
										0 === it(c).length
											? (Wr(),
											  Kr(
													"div",
													{ key: 0, class: gt(it(i).e("body")) },
													[ri(xz, { date: it(h), "selected-day": it(u), onPick: y }, fi({ _: 2 }, [e.$slots.dateCell ? { name: "dateCell", fn: cn((t) => [mi(e.$slots, "dateCell", yt(ii(t)))]) } : void 0]), 1032, ["date", "selected-day"])],
													2
											  ))
											: (Wr(),
											  Kr(
													"div",
													{ key: 1, class: gt(it(i).e("body")) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(
																it(c),
																(t, n) => (
																	Wr(),
																	qr(xz, { key: n, date: t[0], "selected-day": it(u), range: t, "hide-header": 0 !== n, onPick: y }, fi({ _: 2 }, [e.$slots.dateCell ? { name: "dateCell", fn: cn((t) => [mi(e.$slots, "dateCell", yt(ii(t)))]) } : void 0]), 1032, [
																		"date",
																		"selected-day",
																		"range",
																		"hide-header"
																	])
																)
															),
															128
														))
													],
													2
											  ))
									],
									2
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]
		)
	),
	Sz = uN({ header: { type: String, default: "" }, bodyStyle: { type: [String, Object, Array], default: "" }, shadow: { type: String, values: ["always", "hover", "never"], default: "always" } });
const Ez = mN(
		IB(
			Tn(
				c(u({}, { name: "ElCard" }), {
					props: Sz,
					setup(e) {
						const t = BD("card");
						return (e, n) => (
							Wr(),
							Kr(
								"div",
								{ class: gt([it(t).b(), it(t).is(`${e.shadow}-shadow`)]) },
								[e.$slots.header || e.header ? (Wr(), Kr("div", { key: 0, class: gt(it(t).e("header")) }, [mi(e.$slots, "header", {}, () => [oi(bt(e.header), 1)])], 2)) : ai("v-if", !0), ni("div", { class: gt(it(t).e("body")), style: pt(e.bodyStyle) }, [mi(e.$slots, "default")], 6)],
								2
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]
		)
	),
	Tz = uN({
		initialIndex: { type: Number, default: 0 },
		height: { type: String, default: "" },
		trigger: { type: String, default: "hover" },
		autoplay: { type: Boolean, default: !0 },
		interval: { type: Number, default: 3e3 },
		indicatorPosition: { type: String, default: "" },
		indicator: { type: Boolean, default: !0 },
		arrow: { type: String, default: "hover" },
		type: { type: String, default: "" },
		loop: { type: Boolean, default: !0 },
		direction: { type: String, default: "horizontal", validator: (e) => ["horizontal", "vertical"].includes(e) },
		pauseOnHover: { type: Boolean, default: !0 }
	}),
	kz = { change: (e, t) => [e, t].every(XI) },
	Az = ["onMouseenter", "onMouseleave"],
	Mz = ["onMouseenter", "onClick"],
	Iz = { key: 0 };
var Rz = IB(
	Tn(
		c(u({}, { name: "ElCarousel" }), {
			props: Tz,
			emits: kz,
			setup(e, { expose: t, emit: n }) {
				const r = e,
					i = BD("carousel"),
					s = Qe(-1),
					o = Qe(null),
					a = Qe(!1),
					l = Qe(),
					u = Qe([]),
					c = ht(() => "never" !== r.arrow && !it(m)),
					h = ht(() => u.value.some((e) => e.props.label.toString().length > 0)),
					d = ht(() => {
						const e = [i.b(), i.m(r.direction)];
						return it(f) && e.push(i.m("card")), e;
					}),
					p = ht(() => {
						const e = [i.e("indicators"), i.em("indicators", r.direction)];
						return h.value && e.push(i.em("indicators", "labels")), ("outside" === r.indicatorPosition || it(f)) && e.push(i.em("indicators", "outside")), e;
					}),
					f = ht(() => "card" === r.type),
					m = ht(() => "vertical" === r.direction),
					v = hk(
						(e) => {
							_(e);
						},
						300,
						{ trailing: !0 }
					),
					g = hk((e) => {
						!(function (e) {
							"hover" === r.trigger && e !== s.value && (s.value = e);
						})(e);
					}, 300);
				function y() {
					o.value && (clearInterval(o.value), (o.value = null));
				}
				function b() {
					r.interval <= 0 || !r.autoplay || o.value || (o.value = setInterval(() => x(), r.interval));
				}
				const x = () => {
					s.value < u.value.length - 1 ? (s.value = s.value + 1) : r.loop && (s.value = 0);
				};
				function _(e) {
					if (SR(e)) {
						const t = u.value.filter((t) => t.props.name === e);
						t.length > 0 && (e = u.value.indexOf(t[0]));
					}
					if (((e = Number(e)), Number.isNaN(e) || e !== Math.floor(e))) return;
					const t = u.value.length,
						n = s.value;
					(s.value = e < 0 ? (r.loop ? t - 1 : 0) : e >= t ? (r.loop ? 0 : t - 1) : e), n === s.value && w(n);
				}
				function w(e) {
					u.value.forEach((t, n) => {
						t.translateItem(n, s.value, e);
					});
				}
				function C() {
					(a.value = !0), r.pauseOnHover && y();
				}
				function S() {
					(a.value = !1), b();
				}
				function E(e) {
					it(m) ||
						u.value.forEach((t, n) => {
							e ===
								(function (e, t) {
									var n, r, i, s;
									const o = it(u),
										a = o.length;
									if (0 === a || !e.states.inStage) return !1;
									const l = t + 1,
										c = t - 1,
										h = a - 1,
										d = o[h].states.active,
										p = o[0].states.active,
										f = null == (r = null == (n = o[l]) ? void 0 : n.states) ? void 0 : r.active,
										m = null == (s = null == (i = o[c]) ? void 0 : i.states) ? void 0 : s.active;
									return (t === h && p) || f ? "left" : !!((0 === t && d) || m) && "right";
								})(t, n) && (t.states.hover = !0);
						});
				}
				function T() {
					it(m) ||
						u.value.forEach((e) => {
							e.states.hover = !1;
						});
				}
				function k() {
					_(s.value + 1);
				}
				ds(
					() => s.value,
					(e, t) => {
						w(t), t > -1 && n("change", e, t);
					}
				),
					ds(
						() => r.autoplay,
						(e) => {
							e ? b() : y();
						}
					),
					ds(
						() => r.loop,
						() => {
							_(s.value);
						}
					);
				const A = et();
				return (
					Vn(async () => {
						await ns(),
							(A.value = pR(l.value, () => {
								w();
							})),
							r.initialIndex < u.value.length && r.initialIndex >= 0 && (s.value = r.initialIndex),
							b();
					}),
					$n(() => {
						y(), l.value && A.value && A.value.stop();
					}),
					mn(zN, {
						root: l,
						isCardType: f,
						isVertical: m,
						items: u,
						loop: r.loop,
						addItem: function (e) {
							u.value.push(e);
						},
						removeItem: function (e) {
							const t = u.value.findIndex((t) => t.uid === e);
							-1 !== t && (u.value.splice(t, 1), s.value === t && k());
						},
						setActiveItem: _
					}),
					t({
						setActiveItem: _,
						prev: function () {
							_(s.value - 1);
						},
						next: k
					}),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ ref_key: "root", ref: l, class: gt(it(d)), onMouseenter: zo(C, ["stop"]), onMouseleave: zo(S, ["stop"]) },
							[
								ni(
									"div",
									{ class: gt(it(i).e("container")), style: pt({ height: e.height }) },
									[
										it(c)
											? (Wr(),
											  qr(
													lo,
													{ key: 0, name: "carousel-arrow-left", persisted: "" },
													{
														default: cn(() => [
															yr(
																ni(
																	"button",
																	{ type: "button", class: gt([it(i).e("arrow"), it(i).em("arrow", "left")]), onMouseenter: t[0] || (t[0] = (e) => E("left")), onMouseleave: T, onClick: t[1] || (t[1] = zo((e) => it(v)(s.value - 1), ["stop"])) },
																	[ri(it(OB), null, { default: cn(() => [ri(it(uL))]), _: 1 })],
																	34
																),
																[[Wo, ("always" === e.arrow || a.value) && (r.loop || s.value > 0)]]
															)
														]),
														_: 1
													}
											  ))
											: ai("v-if", !0),
										it(c)
											? (Wr(),
											  qr(
													lo,
													{ key: 1, name: "carousel-arrow-right", persisted: "" },
													{
														default: cn(() => [
															yr(
																ni(
																	"button",
																	{ type: "button", class: gt([it(i).e("arrow"), it(i).em("arrow", "right")]), onMouseenter: t[2] || (t[2] = (e) => E("right")), onMouseleave: T, onClick: t[3] || (t[3] = zo((e) => it(v)(s.value + 1), ["stop"])) },
																	[ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })],
																	34
																),
																[[Wo, ("always" === e.arrow || a.value) && (r.loop || s.value < u.value.length - 1)]]
															)
														]),
														_: 1
													}
											  ))
											: ai("v-if", !0),
										mi(e.$slots, "default")
									],
									6
								),
								"none" !== e.indicatorPosition
									? (Wr(),
									  Kr(
											"ul",
											{ key: 0, class: gt(it(p)) },
											[
												(Wr(!0),
												Kr(
													Hr,
													null,
													pi(
														u.value,
														(t, n) => (
															Wr(),
															Kr(
																"li",
																{
																	key: n,
																	class: gt([it(i).e("indicator"), it(i).em("indicator", e.direction), it(i).is("active", n === s.value)]),
																	onMouseenter: (e) => it(g)(n),
																	onClick: zo(
																		(e) =>
																			(function (e) {
																				s.value = e;
																			})(n),
																		["stop"]
																	)
																},
																[ni("button", { class: gt(it(i).e("button")) }, [it(h) ? (Wr(), Kr("span", Iz, bt(t.props.label), 1)) : ai("v-if", !0)], 2)],
																42,
																Mz
															)
														)
													),
													128
												))
											],
											2
									  ))
									: ai("v-if", !0)
							],
							42,
							Az
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]
);
const Lz = uN({ name: { type: String, default: "" }, label: { type: [String, Number], default: "" } });
var Oz = IB(
	Tn(
		c(u({}, { name: "ElCarouselItem" }), {
			props: Lz,
			setup(e) {
				const t = e,
					n = BD("carousel"),
					r = vn(zN),
					i = Si(),
					s = 0.83,
					o = Qe(!1),
					a = Qe(0),
					l = Qe(1),
					u = Qe(!1),
					c = Qe(!1),
					h = Qe(!1),
					d = Qe(!1),
					{ isCardType: p, isVertical: f } = r,
					m = ht(() => ({ transform: [`${"translate" + (it(f) ? "Y" : "X")}(${it(a)}px)`, `scale(${it(l)})`].join(" ") }));
				const v = (e, t, n) => {
					var i;
					const o = it(p),
						m = null != (i = r.items.value.length) ? i : Number.NaN,
						v = e === t;
					o || BR(n) || (d.value = v || e === n),
						!v &&
							m > 2 &&
							r.loop &&
							(e = (function (e, t, n) {
								const r = n - 1,
									i = n / 2;
								return 0 === t && e === r ? -1 : t === r && 0 === e ? n : e < t - 1 && t - e >= i ? n + 1 : e > t + 1 && e - t >= i ? -2 : e;
							})(e, t, m));
					const g = it(f);
					(u.value = v),
						o
							? ((h.value = Math.round(Math.abs(e - t)) <= 1),
							  (a.value = (function (e, t) {
									var n;
									const i = (null == (n = r.root.value) ? void 0 : n.offsetWidth) || 0;
									return h.value ? (i * (1.17 * (e - t) + 1)) / 4 : e < t ? (-1.83 * i) / 4 : (3.83 * i) / 4;
							  })(e, t)),
							  (l.value = it(u) ? 1 : s))
							: (a.value = (function (e, t, n) {
									const i = r.root.value;
									return i ? ((n ? i.offsetHeight : i.offsetWidth) || 0) * (e - t) : 0;
							  })(e, t, g)),
						(c.value = !0);
				};
				function g() {
					if (r && it(p)) {
						const e = r.items.value.findIndex(({ uid: e }) => e === i.uid);
						r.setActiveItem(e);
					}
				}
				return (
					Vn(() => {
						r.addItem({ props: t, states: Fe({ hover: o, translate: a, scale: l, active: u, ready: c, inStage: h, animating: d }), uid: i.uid, translateItem: v });
					}),
					jn(() => {
						r.removeItem(i.uid);
					}),
					(e, t) =>
						yr(
							(Wr(),
							Kr(
								"div",
								{ class: gt([it(n).e("item"), it(n).is("active", u.value), it(n).is("in-stage", h.value), it(n).is("hover", o.value), it(n).is("animating", d.value), { [it(n).em("item", "card")]: it(p) }]), style: pt(it(m)), onClick: g },
								[it(p) ? yr((Wr(), Kr("div", { key: 0, class: gt(it(n).e("mask")) }, null, 2)), [[Wo, !u.value]]) : ai("v-if", !0), mi(e.$slots, "default")],
								6
							)),
							[[Wo, c.value]]
						)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]
);
const Pz = mN(Rz, { CarouselItem: Oz }),
	Nz = gN(Oz),
	Dz = {
		modelValue: { type: Array, default: () => [] },
		disabled: Boolean,
		min: { type: Number, default: void 0 },
		max: { type: Number, default: void 0 },
		size: cD,
		id: { type: String, default: void 0 },
		label: { type: String, default: void 0 },
		fill: { type: String, default: void 0 },
		textColor: { type: String, default: void 0 },
		tag: { type: String, default: "div" }
	},
	Bz = {
		modelValue: { type: [Number, String, Boolean], default: () => {} },
		label: { type: [String, Boolean, Number, Object] },
		indeterminate: Boolean,
		disabled: Boolean,
		checked: Boolean,
		name: { type: String, default: void 0 },
		trueLabel: { type: [String, Number], default: void 0 },
		falseLabel: { type: [String, Number], default: void 0 },
		id: { type: String, default: void 0 },
		controls: { type: String, default: void 0 },
		border: Boolean,
		size: cD,
		tabindex: [String, Number]
	},
	Fz = () => {
		const e = vn(GN, {}),
			t = vn(YN, {}),
			n = vn("CheckboxGroup", {}),
			r = ht(() => n && "ElCheckboxGroup" === (null == n ? void 0 : n.name)),
			i = ht(() => t.size);
		return { isGroup: r, checkboxGroup: n, elForm: e, elFormItemSize: i, elFormItem: t };
	},
	Hz = (e, { model: t, isLimitExceeded: n, hasOwnLabel: r, isDisabled: i, isLabeledByFormItem: s }) => {
		const { elFormItem: o } = Fz(),
			{ emit: a } = Si();
		function l(t) {
			var n, r;
			return t === e.trueLabel || !0 === t ? null == (n = e.trueLabel) || n : null != (r = e.falseLabel) && r;
		}
		return (
			ds(
				() => e.modelValue,
				() => {
					var e;
					null == (e = null == o ? void 0 : o.validate) || e.call(o, "change").catch((e) => {});
				}
			),
			{
				handleChange: function (e) {
					if (n.value) return;
					const t = e.target;
					a("change", l(t.checked), e);
				},
				onClickRoot: async function (o) {
					n.value ||
						r.value ||
						i.value ||
						!s.value ||
						((t.value = l([!1, e.falseLabel].includes(t.value))),
						await ns(),
						(function (e, t) {
							a("change", l(e), t);
						})(t.value, o));
				}
			}
		);
	},
	Vz = { [_N]: (e) => SR(e) || XI(e) || YI(e), change: (e) => SR(e) || XI(e) || YI(e) },
	Uz = (e, t) => {
		const {
				model: n,
				isGroup: r,
				isLimitExceeded: i,
				elFormItem: s
			} = ((e) => {
				const t = Qe(!1),
					{ emit: n } = Si(),
					{ isGroup: r, checkboxGroup: i, elFormItem: s } = Fz(),
					o = Qe(!1);
				return {
					model: ht({
						get() {
							var n, s;
							return r.value ? (null == (n = i.modelValue) ? void 0 : n.value) : null != (s = e.modelValue) ? s : t.value;
						},
						set(e) {
							var s;
							r.value && Array.isArray(e) ? ((o.value = void 0 !== i.max && e.length > i.max.value), !1 === o.value && (null == (s = null == i ? void 0 : i.changeEvent) || s.call(i, e))) : (n(_N, e), (t.value = e));
						}
					}),
					isGroup: r,
					isLimitExceeded: o,
					elFormItem: s
				};
			})(e),
			{
				focus: o,
				size: a,
				isChecked: l,
				checkboxSize: u,
				hasOwnLabel: c
			} = ((e, t, { model: n }) => {
				const { isGroup: r, checkboxGroup: i } = Fz(),
					s = Qe(!1),
					o = hD(null == i ? void 0 : i.checkboxGroupSize, { prop: !0 });
				return {
					isChecked: ht(() => {
						const t = n.value;
						return "[object Boolean]" === AR(t) ? t : Array.isArray(t) ? t.includes(e.label) : null != t ? t === e.trueLabel : !!t;
					}),
					focus: s,
					size: o,
					checkboxSize: hD(
						ht(() => {
							var e;
							return r.value ? (null == (e = null == i ? void 0 : i.checkboxGroupSize) ? void 0 : e.value) : void 0;
						})
					),
					hasOwnLabel: ht(() => !(!t.default && !e.label))
				};
			})(e, t, { model: n }),
			{ isDisabled: h } = ((e, { model: t, isChecked: n }) => {
				const { elForm: r, isGroup: i, checkboxGroup: s } = Fz(),
					o = ht(() => {
						var e, r;
						const i = null == (e = s.max) ? void 0 : e.value,
							o = null == (r = s.min) ? void 0 : r.value;
						return (!(!i && !o) && t.value.length >= i && !n.value) || (t.value.length <= o && n.value);
					});
				return {
					isDisabled: ht(() => {
						var t, n;
						const a = e.disabled || (null == r ? void 0 : r.disabled);
						return null != (n = i.value ? (null == (t = s.disabled) ? void 0 : t.value) || a || o.value : a) && n;
					}),
					isLimitDisabled: o
				};
			})(e, { model: n, isChecked: l }),
			{ inputId: d, isLabeledByFormItem: p } = bD(e, { formItemContext: s, disableIdGeneration: c, disableIdManagement: r }),
			{ handleChange: f, onClickRoot: m } = Hz(e, { model: n, isLimitExceeded: i, hasOwnLabel: c, isDisabled: h, isLabeledByFormItem: p });
		return (
			((e, { model: t }) => {
				e.checked && (Array.isArray(t.value) && !t.value.includes(e.label) ? t.value.push(e.label) : (t.value = e.trueLabel || !0));
			})(e, { model: n }),
			{ elFormItem: s, inputId: d, isLabeledByFormItem: p, isChecked: l, isDisabled: h, isGroup: r, checkboxSize: u, hasOwnLabel: c, model: n, handleChange: f, onClickRoot: m, focus: o, size: a }
		);
	},
	zz = ["tabindex", "role", "aria-checked"],
	$z = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"],
	jz = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
var Wz = IB(
	Tn(
		c(u({}, { name: "ElCheckbox" }), {
			props: Bz,
			emits: Vz,
			setup(e) {
				const t = e,
					n = gs(),
					{ inputId: r, isLabeledByFormItem: i, isChecked: s, isDisabled: o, checkboxSize: a, hasOwnLabel: l, model: u, handleChange: c, onClickRoot: h, focus: d } = Uz(t, n),
					p = BD("checkbox");
				return (e, t) => (
					Wr(),
					qr(
						Nr(!it(l) && it(i) ? "span" : "label"),
						{ class: gt([it(p).b(), it(p).m(it(a)), it(p).is("disabled", it(o)), it(p).is("bordered", e.border), it(p).is("checked", it(s))]), "aria-controls": e.indeterminate ? e.controls : null, onClick: it(h) },
						{
							default: cn(() => [
								ni(
									"span",
									{
										class: gt([it(p).e("input"), it(p).is("disabled", it(o)), it(p).is("checked", it(s)), it(p).is("indeterminate", e.indeterminate), it(p).is("focus", it(d))]),
										tabindex: e.indeterminate ? 0 : void 0,
										role: e.indeterminate ? "checkbox" : void 0,
										"aria-checked": e.indeterminate ? "mixed" : void 0
									},
									[
										e.trueLabel || e.falseLabel
											? yr(
													(Wr(),
													Kr(
														"input",
														{
															key: 0,
															id: it(r),
															"onUpdate:modelValue": t[0] || (t[0] = (e) => (Je(u) ? (u.value = e) : null)),
															class: gt(it(p).e("original")),
															type: "checkbox",
															"aria-hidden": e.indeterminate ? "true" : "false",
															name: e.name,
															tabindex: e.tabindex,
															disabled: it(o),
															"true-value": e.trueLabel,
															"false-value": e.falseLabel,
															onChange: t[1] || (t[1] = (...e) => it(c) && it(c)(...e)),
															onFocus: t[2] || (t[2] = (e) => (d.value = !0)),
															onBlur: t[3] || (t[3] = (e) => (d.value = !1))
														},
														null,
														42,
														$z
													)),
													[[No, it(u)]]
											  )
											: yr(
													(Wr(),
													Kr(
														"input",
														{
															key: 1,
															id: it(r),
															"onUpdate:modelValue": t[4] || (t[4] = (e) => (Je(u) ? (u.value = e) : null)),
															class: gt(it(p).e("original")),
															type: "checkbox",
															"aria-hidden": e.indeterminate ? "true" : "false",
															disabled: it(o),
															value: e.label,
															name: e.name,
															tabindex: e.tabindex,
															onChange: t[5] || (t[5] = (...e) => it(c) && it(c)(...e)),
															onFocus: t[6] || (t[6] = (e) => (d.value = !0)),
															onBlur: t[7] || (t[7] = (e) => (d.value = !1))
														},
														null,
														42,
														jz
													)),
													[[No, it(u)]]
											  ),
										ni("span", { class: gt(it(p).e("inner")) }, null, 2)
									],
									10,
									zz
								),
								it(l) ? (Wr(), Kr("span", { key: 0, class: gt(it(p).e("label")) }, [mi(e.$slots, "default"), e.$slots.default ? ai("v-if", !0) : (Wr(), Kr(Hr, { key: 0 }, [oi(bt(e.label), 1)], 64))], 2)) : ai("v-if", !0)
							]),
							_: 3
						},
						8,
						["class", "aria-controls", "onClick"]
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]
);
const Gz = ["name", "tabindex", "disabled", "true-value", "false-value"],
	Yz = ["name", "tabindex", "disabled", "value"];
var Xz = IB(
	Tn(
		c(u({}, { name: "ElCheckboxButton" }), {
			props: Bz,
			emits: Vz,
			setup(e) {
				const t = e,
					n = gs(),
					{ focus: r, isChecked: i, isDisabled: s, size: o, model: a, handleChange: l } = Uz(t, n),
					{ checkboxGroup: u } = Fz(),
					c = BD("checkbox"),
					h = ht(() => {
						var e, t, n, r;
						const i = null != (t = null == (e = null == u ? void 0 : u.fill) ? void 0 : e.value) ? t : "";
						return { backgroundColor: i, borderColor: i, color: null != (r = null == (n = null == u ? void 0 : u.textColor) ? void 0 : n.value) ? r : "", boxShadow: i ? `-1px 0 0 0 ${i}` : void 0 };
					});
				return (e, t) => (
					Wr(),
					Kr(
						"label",
						{ class: gt([it(c).b("button"), it(c).bm("button", it(o)), it(c).is("disabled", it(s)), it(c).is("checked", it(i)), it(c).is("focus", it(r))]) },
						[
							e.trueLabel || e.falseLabel
								? yr(
										(Wr(),
										Kr(
											"input",
											{
												key: 0,
												"onUpdate:modelValue": t[0] || (t[0] = (e) => (Je(a) ? (a.value = e) : null)),
												class: gt(it(c).be("button", "original")),
												type: "checkbox",
												name: e.name,
												tabindex: e.tabindex,
												disabled: it(s),
												"true-value": e.trueLabel,
												"false-value": e.falseLabel,
												onChange: t[1] || (t[1] = (...e) => it(l) && it(l)(...e)),
												onFocus: t[2] || (t[2] = (e) => (r.value = !0)),
												onBlur: t[3] || (t[3] = (e) => (r.value = !1))
											},
											null,
											42,
											Gz
										)),
										[[No, it(a)]]
								  )
								: yr(
										(Wr(),
										Kr(
											"input",
											{
												key: 1,
												"onUpdate:modelValue": t[4] || (t[4] = (e) => (Je(a) ? (a.value = e) : null)),
												class: gt(it(c).be("button", "original")),
												type: "checkbox",
												name: e.name,
												tabindex: e.tabindex,
												disabled: it(s),
												value: e.label,
												onChange: t[5] || (t[5] = (...e) => it(l) && it(l)(...e)),
												onFocus: t[6] || (t[6] = (e) => (r.value = !0)),
												onBlur: t[7] || (t[7] = (e) => (r.value = !1))
											},
											null,
											42,
											Yz
										)),
										[[No, it(a)]]
								  ),
							e.$slots.default || e.label ? (Wr(), Kr("span", { key: 2, class: gt(it(c).be("button", "inner")), style: pt(it(i) ? it(h) : void 0) }, [mi(e.$slots, "default", {}, () => [oi(bt(e.label), 1)])], 6)) : ai("v-if", !0)
						],
						2
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]
);
var Kz = IB(
	Tn(
		c(u({}, { name: "ElCheckboxGroup" }), {
			props: Dz,
			emits: Vz,
			setup(e, { emit: t }) {
				const n = e,
					{ elFormItem: r } = Fz(),
					{ groupId: i, isLabeledByFormItem: s } = ((e, { elFormItem: t }) => {
						const { inputId: n, isLabeledByFormItem: r } = bD(e, { formItemContext: t });
						return { isLabeledByFormItem: r, groupId: n };
					})(n, { elFormItem: r }),
					o = hD(),
					a = BD("checkbox"),
					l = (e) => {
						t(_N, e),
							ns(() => {
								t("change", e);
							});
					},
					h = ht({
						get: () => n.modelValue,
						set(e) {
							l(e);
						}
					});
				return (
					mn("CheckboxGroup", c(u({ name: "ElCheckboxGroup", modelValue: h }, at(n)), { checkboxGroupSize: o, changeEvent: l })),
					ds(
						() => n.modelValue,
						() => {
							var e;
							null == (e = r.validate) || e.call(r, "change").catch((e) => {});
						}
					),
					(e, t) => (
						Wr(),
						qr(Nr(e.tag), { id: it(i), class: gt(it(a).b("group")), role: "group", "aria-label": it(s) ? void 0 : e.label || "checkbox-group", "aria-labelledby": it(s) ? it(r).labelId : void 0 }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, [
							"id",
							"class",
							"aria-label",
							"aria-labelledby"
						])
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]
);
const qz = mN(Wz, { CheckboxButton: Xz, CheckboxGroup: Kz }),
	Zz = gN(Xz),
	Jz = gN(Kz),
	Qz = uN({ size: cD, disabled: Boolean, label: { type: [String, Number, Boolean], default: "" } }),
	e$ = uN(c(u({}, Qz), { modelValue: { type: [String, Number, Boolean], default: "" }, name: { type: String, default: "" }, border: Boolean })),
	t$ = { [_N]: (e) => SR(e) || XI(e) || YI(e), change: (e) => SR(e) || XI(e) || YI(e) },
	n$ = (e, t) => {
		const n = Qe(),
			r = vn(KN, void 0),
			i = ht(() => !!r),
			s = ht({
				get: () => (i.value ? r.modelValue : e.modelValue),
				set(s) {
					i.value ? r.changeEvent(s) : t && t(_N, s), (n.value.checked = e.modelValue === e.label);
				}
			}),
			o = hD(ht(() => (null == r ? void 0 : r.size))),
			a = dD(ht(() => (null == r ? void 0 : r.disabled))),
			l = Qe(!1),
			u = ht(() => (a.value || (i.value && s.value !== e.label) ? -1 : 0));
		return { radioRef: n, isGroup: i, radioGroup: r, focus: l, size: o, disabled: a, tabIndex: u, modelValue: s };
	},
	r$ = ["value", "name", "disabled"];
var i$ = IB(
	Tn(
		c(u({}, { name: "ElRadio" }), {
			props: e$,
			emits: t$,
			setup(e, { emit: t }) {
				const n = e,
					r = BD("radio"),
					{ radioRef: i, radioGroup: s, focus: o, size: a, disabled: l, modelValue: u } = n$(n, t);
				function c() {
					ns(() => t("change", u.value));
				}
				return (e, t) => {
					var n;
					return (
						Wr(),
						Kr(
							"label",
							{ class: gt([it(r).b(), it(r).is("disabled", it(l)), it(r).is("focus", it(o)), it(r).is("bordered", e.border), it(r).is("checked", it(u) === e.label), it(r).m(it(a))]) },
							[
								ni(
									"span",
									{ class: gt([it(r).e("input"), it(r).is("disabled", it(l)), it(r).is("checked", it(u) === e.label)]) },
									[
										yr(
											ni(
												"input",
												{
													ref_key: "radioRef",
													ref: i,
													"onUpdate:modelValue": t[0] || (t[0] = (e) => (Je(u) ? (u.value = e) : null)),
													class: gt(it(r).e("original")),
													value: e.label,
													name: e.name || (null == (n = it(s)) ? void 0 : n.name),
													disabled: it(l),
													type: "radio",
													onFocus: t[1] || (t[1] = (e) => (o.value = !0)),
													onBlur: t[2] || (t[2] = (e) => (o.value = !1)),
													onChange: c
												},
												null,
												42,
												r$
											),
											[[Bo, it(u)]]
										),
										ni("span", { class: gt(it(r).e("inner")) }, null, 2)
									],
									2
								),
								ni("span", { class: gt(it(r).e("label")), onKeydown: t[3] || (t[3] = zo(() => {}, ["stop"])) }, [mi(e.$slots, "default", {}, () => [oi(bt(e.label), 1)])], 34)
							],
							2
						)
					);
				};
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]
);
const s$ = uN(c(u({}, Qz), { name: { type: String, default: "" } })),
	o$ = ["value", "name", "disabled"];
var a$ = IB(
	Tn(
		c(u({}, { name: "ElRadioButton" }), {
			props: s$,
			setup(e) {
				const t = e,
					n = BD("radio"),
					{ radioRef: r, focus: i, size: s, disabled: o, modelValue: a, radioGroup: l } = n$(t),
					u = ht(() => ({ backgroundColor: (null == l ? void 0 : l.fill) || "", borderColor: (null == l ? void 0 : l.fill) || "", boxShadow: (null == l ? void 0 : l.fill) ? `-1px 0 0 0 ${l.fill}` : "", color: (null == l ? void 0 : l.textColor) || "" }));
				return (e, t) => {
					var c;
					return (
						Wr(),
						Kr(
							"label",
							{ class: gt([it(n).b("button"), it(n).is("active", it(a) === e.label), it(n).is("disabled", it(o)), it(n).is("focus", it(i)), it(n).bm("button", it(s))]) },
							[
								yr(
									ni(
										"input",
										{
											ref_key: "radioRef",
											ref: r,
											"onUpdate:modelValue": t[0] || (t[0] = (e) => (Je(a) ? (a.value = e) : null)),
											class: gt(it(n).be("button", "original-radio")),
											value: e.label,
											type: "radio",
											name: e.name || (null == (c = it(l)) ? void 0 : c.name),
											disabled: it(o),
											onFocus: t[1] || (t[1] = (e) => (i.value = !0)),
											onBlur: t[2] || (t[2] = (e) => (i.value = !1))
										},
										null,
										42,
										o$
									),
									[[Bo, it(a)]]
								),
								ni("span", { class: gt(it(n).be("button", "inner")), style: pt(it(a) === e.label ? it(u) : {}), onKeydown: t[3] || (t[3] = zo(() => {}, ["stop"])) }, [mi(e.$slots, "default", {}, () => [oi(bt(e.label), 1)])], 38)
							],
							2
						)
					);
				};
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]
);
const l$ = uN({
		id: { type: String, default: void 0 },
		size: cD,
		disabled: Boolean,
		modelValue: { type: [String, Number, Boolean], default: "" },
		fill: { type: String, default: "" },
		label: { type: String, default: void 0 },
		textColor: { type: String, default: "" },
		name: { type: String, default: void 0 }
	}),
	u$ = t$,
	c$ = ["id", "aria-label", "aria-labelledby"];
var h$ = IB(
	Tn(
		c(u({}, { name: "ElRadioGroup" }), {
			props: l$,
			emits: u$,
			setup(e, { emit: t }) {
				const n = e,
					r = BD("radio"),
					i = gD(),
					s = Qe(),
					{ formItem: o } = yD(),
					{ inputId: a, isLabeledByFormItem: l } = bD(n, { formItemContext: o });
				Vn(() => {
					const e = s.value.querySelectorAll("[type=radio]"),
						t = e[0];
					!Array.from(e).some((e) => e.checked) && t && (t.tabIndex = 0);
				});
				const h = ht(() => n.name || i.value);
				return (
					mn(
						KN,
						Fe(
							c(u({}, at(n)), {
								changeEvent: (e) => {
									t(_N, e), ns(() => t("change", e));
								},
								name: h
							})
						)
					),
					ds(
						() => n.modelValue,
						() => (null == o ? void 0 : o.validate("change").catch((e) => {}))
					),
					(e, t) => (Wr(), Kr("div", { id: it(a), ref_key: "radioGroupRef", ref: s, class: gt(it(r).b("group")), role: "radiogroup", "aria-label": it(l) ? void 0 : e.label || "radio-group", "aria-labelledby": it(l) ? it(o).labelId : void 0 }, [mi(e.$slots, "default")], 10, c$))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]
);
const d$ = mN(i$, { RadioButton: a$, RadioGroup: h$ }),
	p$ = gN(h$),
	f$ = gN(a$);
var m$ = Tn({
	name: "NodeContent",
	setup: () => ({ ns: BD("cascader-node") }),
	render() {
		const { ns: e } = this,
			{ node: t, panel: n } = this.$parent,
			{ data: r, label: i } = t,
			{ renderLabelFn: s } = n;
		return xs("span", { class: e.e("label") }, s ? s({ node: t, data: r }) : i);
	}
});
const v$ = Symbol(),
	g$ = Tn({
		name: "ElCascaderNode",
		components: { ElCheckbox: qz, ElRadio: d$, NodeContent: m$, ElIcon: OB, Check: BL, Loading: HO, ArrowRight: pL },
		props: { node: { type: Object, required: !0 }, menuId: String },
		emits: ["expand"],
		setup(e, { emit: t }) {
			const n = vn(v$),
				r = BD("cascader-node"),
				i = ht(() => n.isHoverMenu),
				s = ht(() => n.config.multiple),
				o = ht(() => n.config.checkStrictly),
				a = ht(() => {
					var e;
					return null == (e = n.checkedNodes[0]) ? void 0 : e.uid;
				}),
				l = ht(() => e.node.isDisabled),
				u = ht(() => e.node.isLeaf),
				c = ht(() => (o.value && !u.value) || !l.value),
				h = ht(() => p(n.expandingNode)),
				d = ht(() => o.value && n.checkedNodes.some(p)),
				p = (t) => {
					var n;
					const { level: r, uid: i } = e.node;
					return (null == (n = null == t ? void 0 : t.pathNodes[r - 1]) ? void 0 : n.uid) === i;
				},
				f = () => {
					h.value || n.expandNode(e.node);
				},
				m = (t) => {
					const { node: r } = e;
					t !== r.checked && n.handleCheckChange(r, t);
				},
				v = () => {
					n.lazyLoad(e.node, () => {
						u.value || f();
					});
				},
				g = () => {
					const { node: t } = e;
					c.value && !t.loading && (t.loaded ? f() : v());
				},
				y = (t) => {
					e.node.loaded ? (m(t), !o.value && f()) : v();
				};
			return {
				panel: n,
				isHoverMenu: i,
				multiple: s,
				checkStrictly: o,
				checkedNodeId: a,
				isDisabled: l,
				isLeaf: u,
				expandable: c,
				inExpandingPath: h,
				inCheckedPath: d,
				ns: r,
				handleHoverExpand: (e) => {
					i.value && (g(), !u.value && t("expand", e));
				},
				handleExpand: g,
				handleClick: () => {
					(i.value && !u.value) || (!u.value || l.value || o.value || s.value ? g() : y(!0));
				},
				handleCheck: y,
				handleSelectCheck: (t) => {
					o.value ? (m(t), e.node.loaded && f()) : y(t);
				}
			};
		}
	}),
	y$ = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"],
	b$ = ni("span", null, null, -1);
var x$ = IB(
		Tn({
			name: "ElCascaderMenu",
			components: {
				Loading: HO,
				ElIcon: OB,
				ElScrollbar: ZB,
				ElCascaderNode: IB(g$, [
					[
						"render",
						function (e, t, n, r, i, s) {
							const o = Or("el-checkbox"),
								a = Or("el-radio"),
								l = Or("check"),
								u = Or("el-icon"),
								c = Or("node-content"),
								h = Or("loading"),
								d = Or("arrow-right");
							return (
								Wr(),
								Kr(
									"li",
									{
										id: `${e.menuId}-${e.node.uid}`,
										role: "menuitem",
										"aria-haspopup": !e.isLeaf,
										"aria-owns": e.isLeaf ? null : e.menuId,
										"aria-expanded": e.inExpandingPath,
										tabindex: e.expandable ? -1 : void 0,
										class: gt([e.ns.b(), e.ns.is("selectable", e.checkStrictly), e.ns.is("active", e.node.checked), e.ns.is("disabled", !e.expandable), e.inExpandingPath && "in-active-path", e.inCheckedPath && "in-checked-path"]),
										onMouseenter: t[2] || (t[2] = (...t) => e.handleHoverExpand && e.handleHoverExpand(...t)),
										onFocus: t[3] || (t[3] = (...t) => e.handleHoverExpand && e.handleHoverExpand(...t)),
										onClick: t[4] || (t[4] = (...t) => e.handleClick && e.handleClick(...t))
									},
									[
										ai(" prefix "),
										e.multiple
											? (Wr(),
											  qr(o, { key: 0, "model-value": e.node.checked, indeterminate: e.node.indeterminate, disabled: e.isDisabled, onClick: t[0] || (t[0] = zo(() => {}, ["stop"])), "onUpdate:modelValue": e.handleSelectCheck }, null, 8, [
													"model-value",
													"indeterminate",
													"disabled",
													"onUpdate:modelValue"
											  ]))
											: e.checkStrictly
											? (Wr(),
											  qr(
													a,
													{ key: 1, "model-value": e.checkedNodeId, label: e.node.uid, disabled: e.isDisabled, "onUpdate:modelValue": e.handleSelectCheck, onClick: t[1] || (t[1] = zo(() => {}, ["stop"])) },
													{ default: cn(() => [ai("\n                Add an empty element to avoid render label,\n                do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n            "), b$]), _: 1 },
													8,
													["model-value", "label", "disabled", "onUpdate:modelValue"]
											  ))
											: e.isLeaf && e.node.checked
											? (Wr(), qr(u, { key: 2, class: gt(e.ns.e("prefix")) }, { default: cn(() => [ri(l)]), _: 1 }, 8, ["class"]))
											: ai("v-if", !0),
										ai(" content "),
										ri(c),
										ai(" postfix "),
										e.isLeaf
											? ai("v-if", !0)
											: (Wr(),
											  Kr(
													Hr,
													{ key: 3 },
													[
														e.node.loading
															? (Wr(), qr(u, { key: 0, class: gt([e.ns.is("loading"), e.ns.e("postfix")]) }, { default: cn(() => [ri(h)]), _: 1 }, 8, ["class"]))
															: (Wr(), qr(u, { key: 1, class: gt(["arrow-right", e.ns.e("postfix")]) }, { default: cn(() => [ri(d)]), _: 1 }, 8, ["class"]))
													],
													64
											  ))
									],
									42,
									y$
								)
							);
						}
					],
					["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]
				])
			},
			props: { nodes: { type: Array, required: !0 }, index: { type: Number, required: !0 } },
			setup(e) {
				const t = Si(),
					n = BD("cascader-menu"),
					{ t: r } = CD(),
					i = DN();
				let s = null,
					o = null;
				const a = vn(v$),
					l = Qe(null),
					u = ht(() => !e.nodes.length),
					c = ht(() => !a.initialLoaded),
					h = ht(() => `cascader-menu-${i}-${e.index}`),
					d = () => {
						o && (clearTimeout(o), (o = null));
					},
					p = () => {
						l.value && ((l.value.innerHTML = ""), d());
					};
				return {
					ns: n,
					panel: a,
					hoverZone: l,
					isEmpty: u,
					isLoading: c,
					menuId: h,
					t: r,
					handleExpand: (e) => {
						s = e.target;
					},
					handleMouseMove: (e) => {
						if (a.isHoverMenu && s && l.value)
							if (s.contains(e.target)) {
								d();
								const n = t.vnode.el,
									{ left: r } = n.getBoundingClientRect(),
									{ offsetWidth: i, offsetHeight: o } = n,
									a = e.clientX - r,
									u = s.offsetTop,
									c = u + s.offsetHeight;
								l.value.innerHTML = `\n                    <path style="pointer-events: auto;" fill="transparent" d="M${a} ${u} L${i} 0 V${u} Z" />\n                    <path style="pointer-events: auto;" fill="transparent" d="M${a} ${c} L${i} ${o} V${c} Z" />\n                `;
							} else o || (o = window.setTimeout(p, a.config.hoverThreshold));
					},
					clearHoverZone: p
				};
			}
		}),
		[
			[
				"render",
				function (e, t, n, r, i, s) {
					const o = Or("el-cascader-node"),
						a = Or("loading"),
						l = Or("el-icon"),
						u = Or("el-scrollbar");
					return (
						Wr(),
						qr(
							u,
							{ key: e.menuId, tag: "ul", role: "menu", class: gt(e.ns.b()), "wrap-class": e.ns.e("wrap"), "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)], onMousemove: e.handleMouseMove, onMouseleave: e.clearHoverZone },
							{
								default: cn(() => {
									var t;
									return [
										(Wr(!0),
										Kr(
											Hr,
											null,
											pi(e.nodes, (t) => (Wr(), qr(o, { key: t.uid, node: t, "menu-id": e.menuId, onExpand: e.handleExpand }, null, 8, ["node", "menu-id", "onExpand"]))),
											128
										)),
										e.isLoading
											? (Wr(), Kr("div", { key: 0, class: gt(e.ns.e("empty-text")) }, [ri(l, { size: "14", class: gt(e.ns.is("loading")) }, { default: cn(() => [ri(a)]), _: 1 }, 8, ["class"]), oi(" " + bt(e.t("el.cascader.loading")), 1)], 2))
											: e.isEmpty
											? (Wr(), Kr("div", { key: 1, class: gt(e.ns.e("empty-text")) }, bt(e.t("el.cascader.noData")), 3))
											: (null == (t = e.panel) ? void 0 : t.isHoverMenu)
											? (Wr(), Kr("svg", { key: 2, ref: "hoverZone", class: gt(e.ns.e("hover-zone")) }, null, 2))
											: ai("v-if", !0)
									];
								}),
								_: 1
							},
							8,
							["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]
						)
					);
				}
			],
			["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]
		]
	),
	_$ = ((e) => ((e.CLICK = "click"), (e.HOVER = "hover"), e))(_$ || {});
let w$ = 0;
class C$ {
	constructor(e, t, n, r = !1) {
		(this.data = e), (this.config = t), (this.parent = n), (this.root = r), (this.uid = w$++), (this.checked = !1), (this.indeterminate = !1), (this.loading = !1);
		const { value: i, label: s, children: o } = t,
			a = e[o],
			l = ((e) => {
				const t = [e];
				let { parent: n } = e;
				for (; n; ) t.unshift(n), (n = n.parent);
				return t;
			})(this);
		(this.level = r ? 0 : n ? n.level + 1 : 1),
			(this.value = e[i]),
			(this.label = e[s]),
			(this.pathNodes = l),
			(this.pathValues = l.map((e) => e.value)),
			(this.pathLabels = l.map((e) => e.label)),
			(this.childrenData = a),
			(this.children = (a || []).map((e) => new C$(e, t, this))),
			(this.loaded = !t.lazy || this.isLeaf || !FR(a));
	}
	get isDisabled() {
		const { data: e, parent: t, config: n } = this,
			{ disabled: r, checkStrictly: i } = n;
		return (CR(r) ? r(e, this) : !!e[r]) || (!i && (null == t ? void 0 : t.isDisabled));
	}
	get isLeaf() {
		const { data: e, config: t, childrenData: n, loaded: r } = this,
			{ lazy: i, leaf: s } = t,
			o = CR(s) ? s(e, this) : e[s];
		return BR(o) ? !(i && !r) && !(Array.isArray(n) && n.length) : !!o;
	}
	get valueByOption() {
		return this.config.emitPath ? this.pathValues : this.value;
	}
	appendChild(e) {
		const { childrenData: t, children: n } = this,
			r = new C$(e, this.config, this);
		return Array.isArray(t) ? t.push(e) : (this.childrenData = [e]), n.push(r), r;
	}
	calcText(e, t) {
		const n = e ? this.pathLabels.join(t) : this.label;
		return (this.text = n), n;
	}
	broadcast(e, ...t) {
		const n = `onParent${DR(e)}`;
		this.children.forEach((r) => {
			r && (r.broadcast(e, ...t), r[n] && r[n](...t));
		});
	}
	emit(e, ...t) {
		const { parent: n } = this,
			r = `onChild${DR(e)}`;
		n && (n[r] && n[r](...t), n.emit(e, ...t));
	}
	onParentCheck(e) {
		this.isDisabled || this.setCheckState(e);
	}
	onChildCheck() {
		const { children: e } = this,
			t = e.filter((e) => !e.isDisabled),
			n = !!t.length && t.every((e) => e.checked);
		this.setCheckState(n);
	}
	setCheckState(e) {
		const t = this.children.length,
			n = this.children.reduce((e, t) => e + (t.checked ? 1 : t.indeterminate ? 0.5 : 0), 0);
		(this.checked = this.loaded && this.children.filter((e) => !e.isDisabled).every((e) => e.loaded && e.checked) && e), (this.indeterminate = this.loaded && n !== t && n > 0);
	}
	doCheck(e) {
		if (this.checked === e) return;
		const { checkStrictly: t, multiple: n } = this.config;
		t || !n ? (this.checked = e) : (this.broadcast("check", e), this.setCheckState(e), this.emit("check"));
	}
}
const S$ = (e, t) => e.reduce((e, n) => (n.isLeaf ? e.push(n) : (!t && e.push(n), (e = e.concat(S$(n.children, t)))), e), []);
class E$ {
	constructor(e, t) {
		this.config = t;
		const n = (e || []).map((e) => new C$(e, this.config));
		(this.nodes = n), (this.allNodes = S$(n, !1)), (this.leafNodes = S$(n, !0));
	}
	getNodes() {
		return this.nodes;
	}
	getFlattedNodes(e) {
		return e ? this.leafNodes : this.allNodes;
	}
	appendNode(e, t) {
		const n = t ? t.appendChild(e) : new C$(e, this.config);
		t || this.nodes.push(n), this.allNodes.push(n), n.isLeaf && this.leafNodes.push(n);
	}
	appendNodes(e, t) {
		e.forEach((e) => this.appendNode(e, t));
	}
	getNodeByValue(e, t = !1) {
		if (!e && 0 !== e) return null;
		return this.getFlattedNodes(t).find((t) => rk(t.value, e) || rk(t.pathValues, e)) || null;
	}
	getSameNode(e) {
		if (!e) return null;
		return this.getFlattedNodes(!1).find(({ value: t, level: n }) => rk(e.value, t) && e.level === n) || null;
	}
}
const T$ = { modelValue: [Number, String, Array], options: { type: Array, default: () => [] }, props: { type: Object, default: () => ({}) } },
	k$ = { expandTrigger: _$.CLICK, multiple: !1, checkStrictly: !1, emitPath: !0, lazy: !1, lazyLoad: yR, value: "value", label: "label", children: "children", leaf: "leaf", disabled: "disabled", hoverThreshold: 500 },
	A$ = (e) => {
		if (!e) return 0;
		const t = e.id.split("-");
		return Number(t[t.length - 2]);
	};
var M$ = IB(
	Tn({
		name: "ElCascaderPanel",
		components: { ElCascaderMenu: x$ },
		props: c(u({}, T$), { border: { type: Boolean, default: !0 }, renderLabel: Function }),
		emits: [_N, "change", "close", "expand-change"],
		setup(e, { emit: t, slots: n }) {
			let r = !1;
			const i = BD("cascader"),
				s = ((e) => ht(() => u(u({}, k$), e.props)))(e);
			let o = null;
			const a = Qe(!0),
				l = Qe([]),
				c = Qe(null),
				h = Qe([]),
				d = Qe(null),
				p = Qe([]),
				f = ht(() => s.value.expandTrigger === _$.HOVER),
				m = ht(() => e.renderLabel || n.default),
				v = (e, t) => {
					const n = s.value;
					(e = e || new C$({}, n, void 0, !0)).loading = !0;
					n.lazyLoad(e, (n) => {
						const r = e,
							i = r.root ? null : r;
						n && (null == o || o.appendNodes(n, i)), (r.loading = !1), (r.loaded = !0), (r.childrenData = r.childrenData || []), t && t(n);
					});
				},
				g = (e, n) => {
					var r;
					const { level: i } = e,
						s = h.value.slice(0, i);
					let o;
					e.isLeaf ? (o = e.pathNodes[i - 2]) : ((o = e), s.push(e.children)), (null == (r = d.value) ? void 0 : r.uid) !== (null == o ? void 0 : o.uid) && ((d.value = e), (h.value = s), !n && t("expand-change", (null == e ? void 0 : e.pathValues) || []));
				},
				y = (e, n, i = !0) => {
					const { checkStrictly: o, multiple: a } = s.value,
						l = p.value[0];
					(r = !0), !a && (null == l || l.doCheck(!1)), e.doCheck(n), w(), i && !a && !o && t("close"), !i && !a && !o && b(e);
				},
				b = (e) => {
					e && ((e = e.parent), b(e), e && g(e));
				},
				x = (e) => (null == o ? void 0 : o.getFlattedNodes(e)),
				_ = (e) => {
					var t;
					return null == (t = x(e)) ? void 0 : t.filter((e) => !1 !== e.checked);
				},
				w = () => {
					var e;
					const { checkStrictly: t, multiple: n } = s.value,
						r = ((e, t) => {
							const n = t.slice(0),
								r = n.map((e) => e.uid),
								i = e.reduce((e, t) => {
									const i = r.indexOf(t.uid);
									return i > -1 && (e.push(t), n.splice(i, 1), r.splice(i, 1)), e;
								}, []);
							return i.push(...n), i;
						})(p.value, _(!t)),
						i = r.map((e) => e.valueByOption);
					(p.value = r), (c.value = n ? i : null != (e = i[0]) ? e : null);
				},
				C = (t = !1, n = !1) => {
					const { modelValue: i } = e,
						{ lazy: l, multiple: u, checkStrictly: h } = s.value,
						d = !h;
					var p;
					if (a.value && !r && (n || !rk(i, c.value)))
						if (l && !t) {
							const e = IN(null != (p = RN(i)) && p.length ? JS(p, 1 / 0) : [])
								.map((e) => (null == o ? void 0 : o.getNodeByValue(e)))
								.filter((e) => !!e && !e.loaded && !e.loading);
							e.length
								? e.forEach((e) => {
										v(e, () => C(!1, n));
								  })
								: C(!0, n);
						} else {
							const e = u ? RN(i) : [i],
								t = IN(e.map((e) => (null == o ? void 0 : o.getNodeByValue(e, d))));
							S(t, !1), (c.value = i);
						}
				},
				S = (e, t = !0) => {
					const { checkStrictly: n } = s.value,
						r = p.value,
						i = e.filter((e) => !!e && (n || e.isLeaf)),
						a = null == o ? void 0 : o.getSameNode(d.value),
						l = (t && a) || i[0];
					l ? l.pathNodes.forEach((e) => g(e, !0)) : (d.value = null), r.forEach((e) => e.doCheck(!1)), i.forEach((e) => e.doCheck(!0)), (p.value = i), ns(E);
				},
				E = () => {
					GI &&
						l.value.forEach((e) => {
							const t = null == e ? void 0 : e.$el;
							if (t) {
								eL(t.querySelector(`.${i.namespace.value}-scrollbar__wrap`), t.querySelector(`.${i.b("node")}.${i.is("active")}`) || t.querySelector(`.${i.b("node")}.in-active-path`));
							}
						});
				};
			return (
				mn(v$, Fe({ config: s, expandingNode: d, checkedNodes: p, isHoverMenu: f, initialLoaded: a, renderLabelFn: m, lazyLoad: v, expandNode: g, handleCheckChange: y })),
				ds(
					[s, () => e.options],
					() => {
						const { options: t } = e,
							n = s.value;
						(r = !1),
							(o = new E$(t, n)),
							(h.value = [o.getNodes()]),
							n.lazy && FR(e.options)
								? ((a.value = !1),
								  v(void 0, (e) => {
										e && ((o = new E$(e, n)), (h.value = [o.getNodes()])), (a.value = !0), C(!1, !0);
								  }))
								: C(!1, !0);
					},
					{ deep: !0, immediate: !0 }
				),
				ds(
					() => e.modelValue,
					() => {
						(r = !1), C();
					}
				),
				ds(c, (n) => {
					rk(n, e.modelValue) || (t(_N, n), t("change", n));
				}),
				Un(() => (l.value = [])),
				Vn(() => !FR(e.modelValue) && C()),
				{
					ns: i,
					menuList: l,
					menus: h,
					checkedNodes: p,
					handleKeyDown: (e) => {
						const t = e.target,
							{ code: n } = e;
						switch (n) {
							case bN.up:
							case bN.down: {
								e.preventDefault();
								const r = n === bN.up ? -1 : 1;
								II(MI(t, r, `.${i.b("node")}[tabindex="-1"]`));
								break;
							}
							case bN.left: {
								e.preventDefault();
								const n = l.value[A$(t) - 1],
									r = null == n ? void 0 : n.$el.querySelector(`.${i.b("node")}[aria-expanded="true"]`);
								II(r);
								break;
							}
							case bN.right: {
								e.preventDefault();
								const n = l.value[A$(t) + 1],
									r = null == n ? void 0 : n.$el.querySelector(`.${i.b("node")}[tabindex="-1"]`);
								II(r);
								break;
							}
							case bN.enter:
								((e) => {
									if (!e) return;
									const t = e.querySelector("input");
									t ? t.click() : AI(e) && e.click();
								})(t);
						}
					},
					handleCheckChange: y,
					getFlattedNodes: x,
					getCheckedNodes: _,
					clearCheckedNodes: () => {
						p.value.forEach((e) => e.doCheck(!1)), w();
					},
					calculateCheckedValue: w,
					scrollToExpandingNode: E
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-cascader-menu");
				return (
					Wr(),
					Kr(
						"div",
						{ class: gt([e.ns.b("panel"), e.ns.is("bordered", e.border)]), onKeydown: t[0] || (t[0] = (...t) => e.handleKeyDown && e.handleKeyDown(...t)) },
						[
							(Wr(!0),
							Kr(
								Hr,
								null,
								pi(e.menus, (t, n) => (Wr(), qr(o, { key: n, ref_for: !0, ref: (t) => (e.menuList[n] = t), index: n, nodes: [...t] }, null, 8, ["index", "nodes"]))),
								128
							))
						],
						34
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]
	]
);
M$.install = (e) => {
	e.component(M$.name, M$);
};
const I$ = M$,
	R$ = I$,
	L$ = uN({
		closable: Boolean,
		type: { type: String, values: ["success", "info", "warning", "danger", ""], default: "" },
		hit: Boolean,
		disableTransitions: Boolean,
		color: { type: String, default: "" },
		size: { type: String, values: CN, default: "" },
		effect: { type: String, values: ["dark", "light", "plain"], default: "light" },
		round: Boolean
	}),
	O$ = { close: (e) => e instanceof MouseEvent, click: (e) => e instanceof MouseEvent };
const P$ = mN(
		IB(
			Tn(
				c(u({}, { name: "ElTag" }), {
					props: L$,
					emits: O$,
					setup(e, { emit: t }) {
						const n = e,
							r = hD(),
							i = BD("tag"),
							s = ht(() => {
								const { type: e, hit: t, effect: s, closable: o, round: a } = n;
								return [i.b(), i.is("closable", o), i.m(e), i.m(r.value), i.m(s), i.is("hit", t), i.is("round", a)];
							}),
							o = (e) => {
								t("close", e);
							},
							a = (e) => {
								t("click", e);
							};
						return (e, t) =>
							e.disableTransitions
								? (Wr(),
								  Kr(
										"span",
										{ key: 0, class: gt(it(s)), style: pt({ backgroundColor: e.color }), onClick: a },
										[
											ni("span", { class: gt(it(i).e("content")) }, [mi(e.$slots, "default")], 2),
											e.closable ? (Wr(), qr(it(OB), { key: 0, class: gt(it(i).e("close")), onClick: zo(o, ["stop"]) }, { default: cn(() => [ri(it(aO))]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)
										],
										6
								  ))
								: (Wr(),
								  qr(
										lo,
										{ key: 1, name: `${it(i).namespace.value}-zoom-in-center`, appear: "" },
										{
											default: cn(() => [
												ni(
													"span",
													{ class: gt(it(s)), style: pt({ backgroundColor: e.color }), onClick: a },
													[
														ni("span", { class: gt(it(i).e("content")) }, [mi(e.$slots, "default")], 2),
														e.closable ? (Wr(), qr(it(OB), { key: 0, class: gt(it(i).e("close")), onClick: zo(o, ["stop"]) }, { default: cn(() => [ri(it(aO))]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)
													],
													6
												)
											]),
											_: 3
										},
										8,
										["name"]
								  ));
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]
		)
	),
	N$ = { large: 36, default: 32, small: 28 },
	D$ = {
		modifiers: [
			{
				name: "arrowPosition",
				enabled: !0,
				phase: "main",
				fn: ({ state: e }) => {
					const { modifiersData: t, placement: n } = e;
					["right", "left", "bottom", "top"].includes(n) || (t.arrow.x = 35);
				},
				requires: ["arrow"]
			}
		]
	},
	B$ = Tn({
		name: "ElCascader",
		components: { ElCascaderPanel: I$, ElInput: WB, ElTooltip: QH, ElScrollbar: ZB, ElTag: P$, ElIcon: OB, CircleClose: QL, Check: BL, ArrowDown: sL },
		directives: { Clickoutside: CU },
		props: c(u({}, T$), {
			size: { type: String, validator: EN },
			placeholder: { type: String },
			disabled: Boolean,
			clearable: Boolean,
			filterable: Boolean,
			filterMethod: { type: Function, default: (e, t) => e.text.includes(t) },
			separator: { type: String, default: " / " },
			showAllLevels: { type: Boolean, default: !0 },
			collapseTags: Boolean,
			collapseTagsTooltip: { type: Boolean, default: !1 },
			debounce: { type: Number, default: 300 },
			beforeFilter: { type: Function, default: () => !0 },
			popperClass: { type: String, default: "" },
			teleported: VH.teleported,
			tagType: c(u({}, L$.type), { default: "info" })
		}),
		emits: [_N, "change", "focus", "blur", "visible-change", "expand-change", "remove-tag"],
		setup(e, { emit: t }) {
			let n = 0,
				r = 0;
			const i = BD("cascader"),
				s = BD("input"),
				{ t: o } = CD(),
				a = vn(GN, {}),
				l = vn(YN, {}),
				u = Qe(null),
				c = Qe(null),
				h = Qe(null),
				d = Qe(null),
				p = Qe(null),
				f = Qe(!1),
				m = Qe(!1),
				v = Qe(!1),
				g = Qe(""),
				y = Qe(""),
				b = Qe([]),
				x = Qe([]),
				_ = Qe([]),
				w = Qe(!1),
				C = ht(() => e.disabled || a.disabled),
				S = ht(() => e.placeholder || o("el.cascader.placeholder")),
				E = hD(),
				T = ht(() => (["small"].includes(E.value) ? "small" : "default")),
				k = ht(() => !!e.props.multiple),
				A = ht(() => !e.filterable || k.value),
				M = ht(() => (k.value ? y.value : g.value)),
				I = ht(() => {
					var e;
					return (null == (e = d.value) ? void 0 : e.checkedNodes) || [];
				}),
				R = ht(() => !(!e.clearable || C.value || v.value || !m.value) && !!I.value.length),
				L = ht(() => {
					const { showAllLevels: t, separator: n } = e,
						r = I.value;
					return r.length ? (k.value ? " " : r[0].calcText(t, n)) : "";
				}),
				O = ht({
					get: () => e.modelValue,
					set(e) {
						var n;
						t(_N, e), t("change", e), null == (n = l.validate) || n.call(l, "change").catch((e) => {});
					}
				}),
				P = ht(() => {
					var e, t;
					return null == (t = null == (e = u.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef;
				}),
				N = (n) => {
					var r, i, s;
					if (!C.value && (n = null != n ? n : !f.value) !== f.value) {
						if (((f.value = n), null == (i = null == (r = c.value) ? void 0 : r.input) || i.setAttribute("aria-expanded", `${n}`), n)) D(), ns(null == (s = d.value) ? void 0 : s.scrollToExpandingNode);
						else if (e.filterable) {
							const { value: e } = L;
							(g.value = e), (y.value = e);
						}
						t("visible-change", n);
					}
				},
				D = () => {
					ns(() => {
						var e;
						null == (e = u.value) || e.updatePopper();
					});
				},
				B = () => {
					v.value = !1;
				},
				F = (t) => {
					const { showAllLevels: n, separator: r } = e;
					return { node: t, key: t.uid, text: t.calcText(n, r), hitState: !1, closable: !C.value && !t.isDisabled, isCollapseTag: !1 };
				},
				H = (e) => {
					var n;
					const r = e.node;
					r.doCheck(!1), null == (n = d.value) || n.calculateCheckedValue(), t("remove-tag", r.valueByOption);
				},
				V = () => {
					var t, n;
					const { filterMethod: r, showAllLevels: i, separator: s } = e,
						o = null == (n = null == (t = d.value) ? void 0 : t.getFlattedNodes(!e.props.checkStrictly)) ? void 0 : n.filter((e) => !e.isDisabled && (e.calcText(i, s), r(e, M.value)));
					k.value &&
						(b.value.forEach((e) => {
							e.hitState = !1;
						}),
						x.value.forEach((e) => {
							e.hitState = !1;
						})),
						(v.value = !0),
						(_.value = o),
						D();
				},
				U = () => {
					var e;
					let t;
					(t = v.value && p.value ? p.value.$el.querySelector(`.${i.e("suggestion-item")}`) : null == (e = d.value) ? void 0 : e.$el.querySelector(`.${i.b("node")}[tabindex="-1"]`)), t && (t.focus(), !v.value && t.click());
				},
				z = () => {
					var e, t;
					const r = null == (e = c.value) ? void 0 : e.input,
						s = h.value,
						o = null == (t = p.value) ? void 0 : t.$el;
					if (GI && r) {
						if (o) {
							o.querySelector(`.${i.e("suggestion-list")}`).style.minWidth = `${r.offsetWidth}px`;
						}
						if (s) {
							const { offsetHeight: e } = s,
								t = b.value.length > 0 ? `${Math.max(e + 6, n)}px` : `${n}px`;
							(r.style.height = t), D();
						}
					}
				},
				$ = QT(() => {
					const { value: t } = M;
					if (!t) return;
					const n = e.beforeFilter(t);
					TR(n) ? n.then(V).catch(() => {}) : !1 !== n ? V() : B();
				}, e.debounce),
				j = (e, t) => {
					!f.value && N(!0), (null == t ? void 0 : t.isComposing) || (e ? $() : B());
				};
			return (
				ds(v, D),
				ds([I, C], () => {
					if (!k.value) return;
					const t = I.value,
						n = [],
						r = [];
					if ((t.forEach((e) => r.push(F(e))), (x.value = r), t.length)) {
						const [r, ...i] = t,
							s = i.length;
						n.push(F(r)), s && (e.collapseTags ? n.push({ key: -1, text: `+ ${s}`, closable: !1, isCollapseTag: !0 }) : i.forEach((e) => n.push(F(e))));
					}
					b.value = n;
				}),
				ds(b, () => {
					ns(() => z());
				}),
				ds(L, (e) => (g.value = e), { immediate: !0 }),
				Vn(() => {
					var e;
					const t = null == (e = c.value) ? void 0 : e.$el;
					(n = (null == t ? void 0 : t.offsetHeight) || N$[E.value] || 40), pR(t, z);
				}),
				{
					popperOptions: D$,
					tooltipRef: u,
					popperPaneRef: P,
					input: c,
					tagWrapper: h,
					panel: d,
					suggestionPanel: p,
					popperVisible: f,
					inputHover: m,
					inputPlaceholder: S,
					filtering: v,
					presentText: L,
					checkedValue: O,
					inputValue: g,
					searchInputValue: y,
					presentTags: b,
					allPresentTags: x,
					suggestions: _,
					isDisabled: C,
					isOnComposition: w,
					realSize: E,
					tagSize: T,
					multiple: k,
					readonly: A,
					clearBtnVisible: R,
					nsCascader: i,
					nsInput: s,
					t: o,
					togglePopperVisible: N,
					hideSuggestionPanel: B,
					deleteTag: H,
					focusFirstNode: U,
					getCheckedNodes: (e) => {
						var t;
						return null == (t = d.value) ? void 0 : t.getCheckedNodes(e);
					},
					handleExpandChange: (e) => {
						D(), t("expand-change", e);
					},
					handleKeyDown: (e) => {
						if (!w.value)
							switch (e.code) {
								case bN.enter:
									N();
									break;
								case bN.down:
									N(!0), ns(U), e.preventDefault();
									break;
								case bN.esc:
									!0 === f.value && (e.preventDefault(), e.stopPropagation(), N(!1));
									break;
								case bN.tab:
									N(!1);
							}
					},
					handleComposition: (e) => {
						var t;
						const n = null == (t = e.target) ? void 0 : t.value;
						if ("compositionend" === e.type) (w.value = !1), ns(() => j(n));
						else {
							const e = n[n.length - 1] || "";
							w.value = !ON(e);
						}
					},
					handleClear: () => {
						var e;
						null == (e = d.value) || e.clearCheckedNodes(), N(!1);
					},
					handleSuggestionClick: (e) => {
						var t, n;
						const { checked: r } = e;
						k.value ? null == (t = d.value) || t.handleCheckChange(e, !r, !1) : (!r && (null == (n = d.value) || n.handleCheckChange(e, !0, !1)), N(!1));
					},
					handleSuggestionKeyDown: (e) => {
						const t = e.target,
							{ code: n } = e;
						switch (n) {
							case bN.up:
							case bN.down: {
								const e = n === bN.up ? -1 : 1;
								II(MI(t, e, `.${i.e("suggestion-item")}[tabindex="-1"]`));
								break;
							}
							case bN.enter:
								t.click();
						}
					},
					handleDelete: () => {
						const e = b.value,
							t = e[e.length - 1];
						(r = y.value ? 0 : r + 1), t && r && (t.hitState ? H(t) : (t.hitState = !0));
					},
					handleInput: j
				}
			);
		}
	}),
	F$ = { key: 0 },
	H$ = { class: "el-cascader__collapse-tags" },
	V$ = ["placeholder"],
	U$ = ["onClick"];
var z$ = IB(B$, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("circle-close"),
				a = Or("el-icon"),
				l = Or("arrow-down"),
				u = Or("el-input"),
				c = Or("el-tag"),
				h = Or("el-tooltip"),
				d = Or("el-cascader-panel"),
				p = Or("check"),
				f = Or("el-scrollbar"),
				m = Dr("clickoutside");
			return (
				Wr(),
				qr(
					h,
					{
						ref: "tooltipRef",
						visible: e.popperVisible,
						"onUpdate:visible": t[17] || (t[17] = (t) => (e.popperVisible = t)),
						teleported: e.teleported,
						"popper-class": [e.nsCascader.e("dropdown"), e.popperClass],
						"popper-options": e.popperOptions,
						"fallback-placements": ["bottom-start", "bottom", "top-start", "top", "right", "left"],
						"stop-popper-mouse-event": !1,
						"gpu-acceleration": !1,
						placement: "bottom-start",
						transition: `${e.nsCascader.namespace.value}-zoom-in-top`,
						effect: "light",
						pure: "",
						persistent: "",
						onHide: e.hideSuggestionPanel
					},
					{
						default: cn(() => [
							yr(
								(Wr(),
								Kr(
									"div",
									{
										class: gt([e.nsCascader.b(), e.nsCascader.m(e.realSize), e.nsCascader.is("disabled", e.isDisabled), e.$attrs.class]),
										style: pt(e.$attrs.style),
										onClick: t[11] || (t[11] = () => e.togglePopperVisible(!e.readonly || void 0)),
										onKeydown: t[12] || (t[12] = (...t) => e.handleKeyDown && e.handleKeyDown(...t)),
										onMouseenter: t[13] || (t[13] = (t) => (e.inputHover = !0)),
										onMouseleave: t[14] || (t[14] = (t) => (e.inputHover = !1))
									},
									[
										ri(
											u,
											{
												ref: "input",
												modelValue: e.inputValue,
												"onUpdate:modelValue": t[1] || (t[1] = (t) => (e.inputValue = t)),
												placeholder: e.searchInputValue ? "" : e.inputPlaceholder,
												readonly: e.readonly,
												disabled: e.isDisabled,
												"validate-event": !1,
												size: e.realSize,
												class: gt(e.nsCascader.is("focus", e.popperVisible)),
												onCompositionstart: e.handleComposition,
												onCompositionupdate: e.handleComposition,
												onCompositionend: e.handleComposition,
												onFocus: t[2] || (t[2] = (t) => e.$emit("focus", t)),
												onBlur: t[3] || (t[3] = (t) => e.$emit("blur", t)),
												onInput: e.handleInput
											},
											{
												suffix: cn(() => [
													e.clearBtnVisible
														? (Wr(), qr(a, { key: "clear", class: gt([e.nsInput.e("icon"), "icon-circle-close"]), onClick: zo(e.handleClear, ["stop"]) }, { default: cn(() => [ri(o)]), _: 1 }, 8, ["class", "onClick"]))
														: (Wr(),
														  qr(a, { key: "arrow-down", class: gt([e.nsInput.e("icon"), "icon-arrow-down", e.nsCascader.is("reverse", e.popperVisible)]), onClick: t[0] || (t[0] = zo((t) => e.togglePopperVisible(), ["stop"])) }, { default: cn(() => [ri(l)]), _: 1 }, 8, [
																"class"
														  ]))
												]),
												_: 1
											},
											8,
											["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput"]
										),
										e.multiple
											? (Wr(),
											  Kr(
													"div",
													{ key: 0, ref: "tagWrapper", class: gt(e.nsCascader.e("tags")) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(
																e.presentTags,
																(t) => (
																	Wr(),
																	qr(
																		c,
																		{ key: t.key, type: e.tagType, size: e.tagSize, hit: t.hitState, closable: t.closable, "disable-transitions": "", onClose: (n) => e.deleteTag(t) },
																		{
																			default: cn(() => [
																				!1 === t.isCollapseTag
																					? (Wr(), Kr("span", F$, bt(t.text), 1))
																					: (Wr(),
																					  qr(
																							h,
																							{ key: 1, teleported: !1, disabled: e.popperVisible || !e.collapseTagsTooltip, "fallback-placements": ["bottom", "top", "right", "left"], placement: "bottom", effect: "light" },
																							{
																								default: cn(() => [ni("span", null, bt(t.text), 1)]),
																								content: cn(() => [
																									ni("div", H$, [
																										(Wr(!0),
																										Kr(
																											Hr,
																											null,
																											pi(
																												e.allPresentTags,
																												(t, n) => (
																													Wr(),
																													Kr("div", { key: n, class: "el-cascader__collapse-tag" }, [
																														(Wr(),
																														qr(
																															c,
																															{ key: t.key, class: "in-tooltip", type: e.tagType, size: e.tagSize, hit: t.hitState, closable: t.closable, "disable-transitions": "", onClose: (n) => e.deleteTag(t) },
																															{ default: cn(() => [ni("span", null, bt(t.text), 1)]), _: 2 },
																															1032,
																															["type", "size", "hit", "closable", "onClose"]
																														))
																													])
																												)
																											),
																											128
																										))
																									])
																								]),
																								_: 2
																							},
																							1032,
																							["disabled"]
																					  ))
																			]),
																			_: 2
																		},
																		1032,
																		["type", "size", "hit", "closable", "onClose"]
																	)
																)
															),
															128
														)),
														e.filterable && !e.isDisabled
															? yr(
																	(Wr(),
																	Kr(
																		"input",
																		{
																			key: 0,
																			"onUpdate:modelValue": t[4] || (t[4] = (t) => (e.searchInputValue = t)),
																			type: "text",
																			class: gt(e.nsCascader.e("search-input")),
																			placeholder: e.presentText ? "" : e.inputPlaceholder,
																			onInput: t[5] || (t[5] = (t) => e.handleInput(e.searchInputValue, t)),
																			onClick: t[6] || (t[6] = zo((t) => e.togglePopperVisible(!0), ["stop"])),
																			onKeydown: t[7] || (t[7] = jo((...t) => e.handleDelete && e.handleDelete(...t), ["delete"])),
																			onCompositionstart: t[8] || (t[8] = (...t) => e.handleComposition && e.handleComposition(...t)),
																			onCompositionupdate: t[9] || (t[9] = (...t) => e.handleComposition && e.handleComposition(...t)),
																			onCompositionend: t[10] || (t[10] = (...t) => e.handleComposition && e.handleComposition(...t))
																		},
																		null,
																		42,
																		V$
																	)),
																	[[Po, e.searchInputValue]]
															  )
															: ai("v-if", !0)
													],
													2
											  ))
											: ai("v-if", !0)
									],
									38
								)),
								[[m, () => e.togglePopperVisible(!1), e.popperPaneRef]]
							)
						]),
						content: cn(() => [
							yr(
								ri(
									d,
									{
										ref: "panel",
										modelValue: e.checkedValue,
										"onUpdate:modelValue": t[15] || (t[15] = (t) => (e.checkedValue = t)),
										options: e.options,
										props: e.props,
										border: !1,
										"render-label": e.$slots.default,
										onExpandChange: e.handleExpandChange,
										onClose: t[16] || (t[16] = (t) => e.$nextTick(() => e.togglePopperVisible(!1)))
									},
									null,
									8,
									["modelValue", "options", "props", "render-label", "onExpandChange"]
								),
								[[Wo, !e.filtering]]
							),
							e.filterable
								? yr(
										(Wr(),
										qr(
											f,
											{ key: 0, ref: "suggestionPanel", tag: "ul", class: gt(e.nsCascader.e("suggestion-panel")), "view-class": e.nsCascader.e("suggestion-list"), onKeydown: e.handleSuggestionKeyDown },
											{
												default: cn(() => [
													e.suggestions.length
														? (Wr(!0),
														  Kr(
																Hr,
																{ key: 0 },
																pi(
																	e.suggestions,
																	(t) => (
																		Wr(),
																		Kr(
																			"li",
																			{ key: t.uid, class: gt([e.nsCascader.e("suggestion-item"), e.nsCascader.is("checked", t.checked)]), tabindex: -1, onClick: (n) => e.handleSuggestionClick(t) },
																			[ni("span", null, bt(t.text), 1), t.checked ? (Wr(), qr(a, { key: 0 }, { default: cn(() => [ri(p)]), _: 1 })) : ai("v-if", !0)],
																			10,
																			U$
																		)
																	)
																),
																128
														  ))
														: mi(e.$slots, "empty", { key: 1 }, () => [ni("li", { class: gt(e.nsCascader.e("empty-text")) }, bt(e.t("el.cascader.noMatch")), 3)])
												]),
												_: 3
											},
											8,
											["class", "view-class", "onKeydown"]
										)),
										[[Wo, e.filtering]]
								  )
								: ai("v-if", !0)
						]),
						_: 3
					},
					8,
					["visible", "teleported", "popper-class", "popper-options", "transition", "onHide"]
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/index.vue"]
]);
z$.install = (e) => {
	e.component(z$.name, z$);
};
const $$ = z$,
	j$ = uN({ checked: { type: Boolean, default: !1 } }),
	W$ = { "update:checked": (e) => YI(e), change: (e) => YI(e) };
const G$ = mN(
		IB(
			Tn(
				c(u({}, { name: "ElCheckTag" }), {
					props: j$,
					emits: W$,
					setup(e, { emit: t }) {
						const n = e,
							r = BD("check-tag"),
							i = () => {
								const e = !n.checked;
								t("change", e), t("update:checked", e);
							};
						return (e, t) => (Wr(), Kr("span", { class: gt([it(r).b(), it(r).is("checked", e.checked)]), onClick: i }, [mi(e.$slots, "default")], 2));
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]
		)
	),
	Y$ = uN({
		tag: { type: String, default: "div" },
		span: { type: Number, default: 24 },
		offset: { type: Number, default: 0 },
		pull: { type: Number, default: 0 },
		push: { type: Number, default: 0 },
		xs: { type: [Number, Object], default: () => ({}) },
		sm: { type: [Number, Object], default: () => ({}) },
		md: { type: [Number, Object], default: () => ({}) },
		lg: { type: [Number, Object], default: () => ({}) },
		xl: { type: [Number, Object], default: () => ({}) }
	});
const X$ = mN(
		IB(
			Tn(
				c(u({}, { name: "ElCol" }), {
					props: Y$,
					setup(e) {
						const t = e,
							{ gutter: n } = vn(qN, { gutter: ht(() => 0) }),
							r = BD("col"),
							i = ht(() => {
								const e = {};
								return n.value && (e.paddingLeft = e.paddingRight = n.value / 2 + "px"), e;
							}),
							s = ht(() => {
								const e = [];
								["span", "offset", "pull", "push"].forEach((n) => {
									const i = t[n];
									XI(i) && ("span" === n ? e.push(r.b(`${t[n]}`)) : i > 0 && e.push(r.b(`${n}-${t[n]}`)));
								});
								return (
									["xs", "sm", "md", "lg", "xl"].forEach((n) => {
										XI(t[n])
											? e.push(r.b(`${n}-${t[n]}`))
											: ER(t[n]) &&
											  Object.entries(t[n]).forEach(([t, i]) => {
													e.push("span" !== t ? r.b(`${n}-${t}-${i}`) : r.b(`${n}-${i}`));
											  });
									}),
									n.value && e.push(r.is("guttered")),
									e
								);
							});
						return (e, t) => (Wr(), qr(Nr(e.tag), { class: gt([it(r).b(), it(s)]), style: pt(it(i)) }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["class", "style"]));
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]
		)
	),
	K$ = (e) => typeof XI(e),
	q$ = uN({ accordion: Boolean, modelValue: { type: [Array, String, Number], default: () => [] } }),
	Z$ = { [_N]: K$, change: K$ };
var J$ = IB(
	Tn(
		c(u({}, { name: "ElCollapse" }), {
			props: q$,
			emits: Z$,
			setup(e, { expose: t, emit: n }) {
				const r = e,
					i = BD("collapse"),
					s = Qe(zE(r.modelValue)),
					o = (e) => {
						s.value = e;
						const t = r.accordion ? s.value[0] : s.value;
						n(_N, t), n("change", t);
					};
				return (
					ds(
						() => r.modelValue,
						() => (s.value = zE(r.modelValue)),
						{ deep: !0 }
					),
					mn($N, {
						activeNames: s,
						handleItemClick: (e) => {
							if (r.accordion) o([(!s.value[0] && 0 !== s.value[0]) || s.value[0] !== e ? e : ""]);
							else {
								const t = [...s.value],
									n = t.indexOf(e);
								n > -1 ? t.splice(n, 1) : t.push(e), o(t);
							}
						}
					}),
					t({ activeNames: s, setActiveNames: o }),
					(e, t) => (Wr(), Kr("div", { class: gt(it(i).b()), role: "tablist", "aria-multiselectable": "true" }, [mi(e.$slots, "default")], 2))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]
);
var Q$ = IB(
	Tn(
		c(u({}, { name: "ElCollapseTransition" }), {
			setup(e) {
				const t = BD("collapse-transition"),
					n = {
						beforeEnter(e) {
							e.dataset || (e.dataset = {}), (e.dataset.oldPaddingTop = e.style.paddingTop), (e.dataset.oldPaddingBottom = e.style.paddingBottom), (e.style.maxHeight = 0), (e.style.paddingTop = 0), (e.style.paddingBottom = 0);
						},
						enter(e) {
							(e.dataset.oldOverflow = e.style.overflow),
								0 !== e.scrollHeight
									? ((e.style.maxHeight = `${e.scrollHeight}px`), (e.style.paddingTop = e.dataset.oldPaddingTop), (e.style.paddingBottom = e.dataset.oldPaddingBottom))
									: ((e.style.maxHeight = 0), (e.style.paddingTop = e.dataset.oldPaddingTop), (e.style.paddingBottom = e.dataset.oldPaddingBottom)),
								(e.style.overflow = "hidden");
						},
						afterEnter(e) {
							(e.style.maxHeight = ""), (e.style.overflow = e.dataset.oldOverflow);
						},
						beforeLeave(e) {
							e.dataset || (e.dataset = {}), (e.dataset.oldPaddingTop = e.style.paddingTop), (e.dataset.oldPaddingBottom = e.style.paddingBottom), (e.dataset.oldOverflow = e.style.overflow), (e.style.maxHeight = `${e.scrollHeight}px`), (e.style.overflow = "hidden");
						},
						leave(e) {
							0 !== e.scrollHeight && ((e.style.maxHeight = 0), (e.style.paddingTop = 0), (e.style.paddingBottom = 0));
						},
						afterLeave(e) {
							(e.style.maxHeight = ""), (e.style.overflow = e.dataset.oldOverflow), (e.style.paddingTop = e.dataset.oldPaddingTop), (e.style.paddingBottom = e.dataset.oldPaddingBottom);
						}
					};
				return (e, r) => (Wr(), qr(lo, hi({ name: it(t).b() }, gi(n)), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16, ["name"]));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]
);
Q$.install = (e) => {
	e.component(Q$.name, Q$);
};
const ej = Q$,
	tj = ej,
	nj = uN({ title: { type: String, default: "" }, name: { type: [String, Number], default: () => DN() }, disabled: Boolean }),
	rj = ["aria-expanded", "aria-controls", "aria-describedby"],
	ij = ["id", "tabindex", "onKeypress"],
	sj = ["id", "aria-hidden", "aria-labelledby"];
var oj = IB(
	Tn(
		c(u({}, { name: "ElCollapseItem" }), {
			props: nj,
			setup(e, { expose: t }) {
				const n = e,
					r = vn($N),
					i = BD("collapse"),
					s = Qe(!1),
					o = Qe(!1),
					a = Qe(DN()),
					l = ht(() => (null == r ? void 0 : r.activeNames.value.includes(n.name))),
					u = () => {
						setTimeout(() => {
							o.value ? (o.value = !1) : (s.value = !0);
						}, 50);
					},
					c = () => {
						n.disabled || (null == r || r.handleItemClick(n.name), (s.value = !1), (o.value = !0));
					},
					h = () => {
						null == r || r.handleItemClick(n.name);
					};
				return (
					t({ isActive: l }),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ class: gt([it(i).b("item"), it(i).is("active", it(l)), it(i).is("disabled", e.disabled)]) },
							[
								ni(
									"div",
									{ role: "tab", "aria-expanded": it(l), "aria-controls": it(i).b(`content-${a.value}`), "aria-describedby": it(i).b(`content-${a.value}`) },
									[
										ni(
											"div",
											{
												id: it(i).b(`head-${a.value}`),
												class: gt([it(i).be("item", "header"), it(i).is("active", it(l)), { focusing: s.value && !e.disabled }]),
												role: "button",
												tabindex: e.disabled ? -1 : 0,
												onClick: c,
												onKeypress: jo(zo(h, ["stop", "prevent"]), ["space", "enter"]),
												onFocus: u,
												onBlur: t[0] || (t[0] = (e) => (s.value = !1))
											},
											[mi(e.$slots, "title", {}, () => [oi(bt(e.title), 1)]), ri(it(OB), { class: gt([it(i).be("item", "arrow"), it(i).is("active", it(l))]) }, { default: cn(() => [ri(it(pL))]), _: 1 }, 8, ["class"])],
											42,
											ij
										)
									],
									8,
									rj
								),
								ri(it(ej), null, {
									default: cn(() => [
										yr(
											ni(
												"div",
												{ id: it(i).b(`content-${a.value}`), class: gt(it(i).be("item", "wrap")), role: "tabpanel", "aria-hidden": !it(l), "aria-labelledby": it(i).b(`head-${a.value}`) },
												[ni("div", { class: gt(it(i).be("item", "content")) }, [mi(e.$slots, "default")], 2)],
												10,
												sj
											),
											[[Wo, it(l)]]
										)
									]),
									_: 3
								})
							],
							2
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]
);
const aj = mN(J$, { CollapseItem: oj }),
	lj = gN(oj);
let uj = !1;
function cj(e, t) {
	if (!GI) return;
	const n = function (e) {
			var n;
			null == (n = t.drag) || n.call(t, e);
		},
		r = function (e) {
			var i;
			LI(document, "mousemove", n), LI(document, "mouseup", r), LI(document, "touchmove", n), LI(document, "touchend", r), (document.onselectstart = null), (document.ondragstart = null), (uj = !1), null == (i = t.end) || i.call(t, e);
		},
		i = function (e) {
			var i;
			uj || (e.preventDefault(), (document.onselectstart = () => !1), (document.ondragstart = () => !1), RI(document, "mousemove", n), RI(document, "mouseup", r), RI(document, "touchmove", n), RI(document, "touchend", r), (uj = !0), null == (i = t.start) || i.call(t, e));
		};
	RI(e, "mousedown", i), RI(e, "touchstart", i);
}
var hj = IB(
	Tn({
		name: "ElColorAlphaSlider",
		props: { color: { type: Object, required: !0 }, vertical: { type: Boolean, default: !1 } },
		setup(e) {
			const t = Si(),
				n = et(null),
				r = et(null),
				i = Qe(0),
				s = Qe(0),
				o = Qe(null);
			function a(r) {
				const i = t.vnode.el.getBoundingClientRect(),
					{ clientX: s, clientY: o } = vR(r);
				if (e.vertical) {
					let t = o - i.top;
					(t = Math.max(n.value.offsetHeight / 2, t)), (t = Math.min(t, i.height - n.value.offsetHeight / 2)), e.color.set("alpha", Math.round(((t - n.value.offsetHeight / 2) / (i.height - n.value.offsetHeight)) * 100));
				} else {
					let t = s - i.left;
					(t = Math.max(n.value.offsetWidth / 2, t)), (t = Math.min(t, i.width - n.value.offsetWidth / 2)), e.color.set("alpha", Math.round(((t - n.value.offsetWidth / 2) / (i.width - n.value.offsetWidth)) * 100));
				}
			}
			function l() {
				(i.value = (function () {
					if (e.vertical) return 0;
					const r = t.vnode.el,
						i = e.color.get("alpha");
					return r ? Math.round((i * (r.offsetWidth - n.value.offsetWidth / 2)) / 100) : 0;
				})()),
					(s.value = (function () {
						const r = t.vnode.el;
						if (!e.vertical) return 0;
						const i = e.color.get("alpha");
						return r ? Math.round((i * (r.offsetHeight - n.value.offsetHeight / 2)) / 100) : 0;
					})()),
					(o.value = (function () {
						if (e.color && e.color.value) {
							const { r: t, g: n, b: r } = e.color.toRgb();
							return `linear-gradient(to right, rgba(${t}, ${n}, ${r}, 0) 0%, rgba(${t}, ${n}, ${r}, 1) 100%)`;
						}
						return null;
					})());
			}
			return (
				ds(
					() => e.color.get("alpha"),
					() => {
						l();
					}
				),
				ds(
					() => e.color.value,
					() => {
						l();
					}
				),
				Vn(() => {
					const e = {
						drag: (e) => {
							a(e);
						},
						end: (e) => {
							a(e);
						}
					};
					cj(r.value, e), cj(n.value, e), l();
				}),
				{
					thumb: n,
					bar: r,
					thumbLeft: i,
					thumbTop: s,
					background: o,
					handleClick: function (e) {
						e.target !== n.value && a(e);
					},
					update: l
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return (
					Wr(),
					Kr(
						"div",
						{ class: gt(["el-color-alpha-slider", { "is-vertical": e.vertical }]) },
						[
							ni("div", { ref: "bar", class: "el-color-alpha-slider__bar", style: pt({ background: e.background }), onClick: t[0] || (t[0] = (...t) => e.handleClick && e.handleClick(...t)) }, null, 4),
							ni("div", { ref: "thumb", class: "el-color-alpha-slider__thumb", style: pt({ left: e.thumbLeft + "px", top: e.thumbTop + "px" }) }, null, 4)
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]
	]
);
var dj = IB(
	Tn({
		name: "ElColorHueSlider",
		props: { color: { type: Object, required: !0 }, vertical: Boolean },
		setup(e) {
			const t = Si(),
				n = Qe(null),
				r = Qe(null),
				i = Qe(0),
				s = Qe(0),
				o = ht(() => e.color.get("hue"));
			function a(r) {
				const i = t.vnode.el.getBoundingClientRect(),
					{ clientX: s, clientY: o } = vR(r);
				let a;
				if (e.vertical) {
					let e = o - i.top;
					(e = Math.min(e, i.height - n.value.offsetHeight / 2)), (e = Math.max(n.value.offsetHeight / 2, e)), (a = Math.round(((e - n.value.offsetHeight / 2) / (i.height - n.value.offsetHeight)) * 360));
				} else {
					let e = s - i.left;
					(e = Math.min(e, i.width - n.value.offsetWidth / 2)), (e = Math.max(n.value.offsetWidth / 2, e)), (a = Math.round(((e - n.value.offsetWidth / 2) / (i.width - n.value.offsetWidth)) * 360));
				}
				e.color.set("hue", a);
			}
			function l() {
				(i.value = (function () {
					const r = t.vnode.el;
					if (e.vertical) return 0;
					const i = e.color.get("hue");
					return r ? Math.round((i * (r.offsetWidth - n.value.offsetWidth / 2)) / 360) : 0;
				})()),
					(s.value = (function () {
						const r = t.vnode.el;
						if (!e.vertical) return 0;
						const i = e.color.get("hue");
						return r ? Math.round((i * (r.offsetHeight - n.value.offsetHeight / 2)) / 360) : 0;
					})());
			}
			return (
				ds(
					() => o.value,
					() => {
						l();
					}
				),
				Vn(() => {
					const e = {
						drag: (e) => {
							a(e);
						},
						end: (e) => {
							a(e);
						}
					};
					cj(r.value, e), cj(n.value, e), l();
				}),
				{
					bar: r,
					thumb: n,
					thumbLeft: i,
					thumbTop: s,
					hueValue: o,
					handleClick: function (e) {
						e.target !== n.value && a(e);
					},
					update: l
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return (
					Wr(),
					Kr(
						"div",
						{ class: gt(["el-color-hue-slider", { "is-vertical": e.vertical }]) },
						[
							ni("div", { ref: "bar", class: "el-color-hue-slider__bar", onClick: t[0] || (t[0] = (...t) => e.handleClick && e.handleClick(...t)) }, null, 512),
							ni("div", { ref: "thumb", class: "el-color-hue-slider__thumb", style: pt({ left: e.thumbLeft + "px", top: e.thumbTop + "px" }) }, null, 4)
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]
	]
);
const pj = Symbol(),
	fj = function (e, t, n) {
		return [e, (t * n) / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0, e / 2];
	},
	mj = function (e, t) {
		var n;
		"string" == typeof (n = e) && n.includes(".") && 1 === Number.parseFloat(n) && (e = "100%");
		const r = (function (e) {
			return "string" == typeof e && e.includes("%");
		})(e);
		return (e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`)))), r && (e = Number.parseInt("" + e * t, 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (e % t) / Number.parseFloat(t);
	},
	vj = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" },
	gj = function (e) {
		e = Math.min(Math.round(e), 255);
		const t = Math.floor(e / 16),
			n = e % 16;
		return `${vj[t] || t}${vj[n] || n}`;
	},
	yj = function ({ r: e, g: t, b: n }) {
		return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${gj(e)}${gj(t)}${gj(n)}`;
	},
	bj = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 },
	xj = function (e) {
		return 2 === e.length ? 16 * (bj[e[0].toUpperCase()] || +e[0]) + (bj[e[1].toUpperCase()] || +e[1]) : bj[e[1].toUpperCase()] || +e[1];
	},
	_j = function (e, t, n) {
		(e = mj(e, 255)), (t = mj(t, 255)), (n = mj(n, 255));
		const r = Math.max(e, t, n),
			i = Math.min(e, t, n);
		let s;
		const o = r,
			a = r - i,
			l = 0 === r ? 0 : a / r;
		if (r === i) s = 0;
		else {
			switch (r) {
				case e:
					s = (t - n) / a + (t < n ? 6 : 0);
					break;
				case t:
					s = (n - e) / a + 2;
					break;
				case n:
					s = (e - t) / a + 4;
			}
			s /= 6;
		}
		return { h: 360 * s, s: 100 * l, v: 100 * o };
	},
	wj = function (e, t, n) {
		(e = 6 * mj(e, 360)), (t = mj(t, 100)), (n = mj(n, 100));
		const r = Math.floor(e),
			i = e - r,
			s = n * (1 - t),
			o = n * (1 - i * t),
			a = n * (1 - (1 - i) * t),
			l = r % 6,
			u = [n, o, s, s, a, n][l],
			c = [a, n, n, o, s, s][l],
			h = [s, s, a, n, n, o][l];
		return { r: Math.round(255 * u), g: Math.round(255 * c), b: Math.round(255 * h) };
	};
class Cj {
	constructor(e) {
		(this._hue = 0), (this._saturation = 100), (this._value = 100), (this._alpha = 100), (this.enableAlpha = !1), (this.format = "hex"), (this.value = ""), (e = e || {});
		for (const t in e) xR(e, t) && (this[t] = e[t]);
		e.value ? this.fromString(e.value) : this.doOnChange();
	}
	set(e, t) {
		if (1 !== arguments.length || "object" != typeof e) (this[`_${e}`] = t), this.doOnChange();
		else for (const n in e) xR(e, n) && this.set(n, e[n]);
	}
	get(e) {
		return "alpha" === e ? Math.floor(this[`_${e}`]) : this[`_${e}`];
	}
	toRgb() {
		return wj(this._hue, this._saturation, this._value);
	}
	fromString(e) {
		if (!e) return (this._hue = 0), (this._saturation = 100), (this._value = 100), void this.doOnChange();
		const t = (e, t, n) => {
			(this._hue = Math.max(0, Math.min(360, e))), (this._saturation = Math.max(0, Math.min(100, t))), (this._value = Math.max(0, Math.min(100, n))), this.doOnChange();
		};
		if (e.includes("hsl")) {
			const n = e
				.replace(/hsla|hsl|\(|\)/gm, "")
				.split(/\s|,/g)
				.filter((e) => "" !== e)
				.map((e, t) => (t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
			if ((4 === n.length ? (this._alpha = 100 * Number.parseFloat(n[3])) : 3 === n.length && (this._alpha = 100), n.length >= 3)) {
				const {
					h: e,
					s: r,
					v: i
				} = (function (e, t, n) {
					n /= 100;
					let r = (t /= 100);
					const i = Math.max(n, 0.01);
					return (t *= (n *= 2) <= 1 ? n : 2 - n), (r *= i <= 1 ? i : 2 - i), { h: e, s: 100 * (0 === n ? (2 * r) / (i + r) : (2 * t) / (n + t)), v: ((n + t) / 2) * 100 };
				})(n[0], n[1], n[2]);
				t(e, r, i);
			}
		} else if (e.includes("hsv")) {
			const n = e
				.replace(/hsva|hsv|\(|\)/gm, "")
				.split(/\s|,/g)
				.filter((e) => "" !== e)
				.map((e, t) => (t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
			4 === n.length ? (this._alpha = 100 * Number.parseFloat(n[3])) : 3 === n.length && (this._alpha = 100), n.length >= 3 && t(n[0], n[1], n[2]);
		} else if (e.includes("rgb")) {
			const n = e
				.replace(/rgba|rgb|\(|\)/gm, "")
				.split(/\s|,/g)
				.filter((e) => "" !== e)
				.map((e, t) => (t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
			if ((4 === n.length ? (this._alpha = 100 * Number.parseFloat(n[3])) : 3 === n.length && (this._alpha = 100), n.length >= 3)) {
				const { h: e, s: r, v: i } = _j(n[0], n[1], n[2]);
				t(e, r, i);
			}
		} else if (e.includes("#")) {
			const n = e.replace("#", "").trim();
			if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(n)) return;
			let r, i, s;
			3 === n.length ? ((r = xj(n[0] + n[0])), (i = xj(n[1] + n[1])), (s = xj(n[2] + n[2]))) : (6 !== n.length && 8 !== n.length) || ((r = xj(n.slice(0, 2))), (i = xj(n.slice(2, 4))), (s = xj(n.slice(4, 6)))),
				8 === n.length ? (this._alpha = (xj(n.slice(6)) / 255) * 100) : (3 !== n.length && 6 !== n.length) || (this._alpha = 100);
			const { h: o, s: a, v: l } = _j(r, i, s);
			t(o, a, l);
		}
	}
	compare(e) {
		return Math.abs(e._hue - this._hue) < 2 && Math.abs(e._saturation - this._saturation) < 1 && Math.abs(e._value - this._value) < 1 && Math.abs(e._alpha - this._alpha) < 1;
	}
	doOnChange() {
		const { _hue: e, _saturation: t, _value: n, _alpha: r, format: i } = this;
		if (this.enableAlpha)
			switch (i) {
				case "hsl": {
					const r = fj(e, t / 100, n / 100);
					this.value = `hsla(${e}, ${Math.round(100 * r[1])}%, ${Math.round(100 * r[2])}%, ${this.get("alpha") / 100})`;
					break;
				}
				case "hsv":
					this.value = `hsva(${e}, ${Math.round(t)}%, ${Math.round(n)}%, ${this.get("alpha") / 100})`;
					break;
				case "hex":
					this.value = `${yj(wj(e, t, n))}${gj((255 * r) / 100)}`;
					break;
				default: {
					const { r: r, g: i, b: s } = wj(e, t, n);
					this.value = `rgba(${r}, ${i}, ${s}, ${this.get("alpha") / 100})`;
				}
			}
		else
			switch (i) {
				case "hsl": {
					const r = fj(e, t / 100, n / 100);
					this.value = `hsl(${e}, ${Math.round(100 * r[1])}%, ${Math.round(100 * r[2])}%)`;
					break;
				}
				case "hsv":
					this.value = `hsv(${e}, ${Math.round(t)}%, ${Math.round(n)}%)`;
					break;
				case "rgb": {
					const { r: r, g: i, b: s } = wj(e, t, n);
					this.value = `rgb(${r}, ${i}, ${s})`;
					break;
				}
				default:
					this.value = yj(wj(e, t, n));
			}
	}
}
const Sj = Tn({
		props: { colors: { type: Array, required: !0 }, color: { type: Object, required: !0 } },
		setup(e) {
			const { currentColor: t } = vn(pj),
				n = Qe(r(e.colors, e.color));
			function r(e, t) {
				return e.map((e) => {
					const n = new Cj();
					return (n.enableAlpha = !0), (n.format = "rgba"), n.fromString(e), (n.selected = n.value === t.value), n;
				});
			}
			return (
				ds(
					() => t.value,
					(e) => {
						const t = new Cj();
						t.fromString(e),
							n.value.forEach((e) => {
								e.selected = t.compare(e);
							});
					}
				),
				cs(() => {
					n.value = r(e.colors, e.color);
				}),
				{
					rgbaColors: n,
					handleSelect: function (t) {
						e.color.fromString(e.colors[t]);
					}
				}
			);
		}
	}),
	Ej = { class: "el-color-predefine" },
	Tj = { class: "el-color-predefine__colors" },
	kj = ["onClick"];
var Aj = IB(Sj, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return (
				Wr(),
				Kr("div", Ej, [
					ni("div", Tj, [
						(Wr(!0),
						Kr(
							Hr,
							null,
							pi(
								e.rgbaColors,
								(t, n) => (Wr(), Kr("div", { key: e.colors[n], class: gt(["el-color-predefine__color-selector", { selected: t.selected, "is-alpha": t._alpha < 100 }]), onClick: (t) => e.handleSelect(n) }, [ni("div", { style: pt({ backgroundColor: t.value }) }, null, 4)], 10, kj))
							),
							128
						))
					])
				])
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]
]);
const Mj = Tn({
		name: "ElSlPanel",
		props: { color: { type: Object, required: !0 } },
		setup(e) {
			const t = Si(),
				n = Qe(0),
				r = Qe(0),
				i = Qe("hsl(0, 100%, 50%)"),
				s = ht(() => ({ hue: e.color.get("hue"), value: e.color.get("value") }));
			function o() {
				const s = e.color.get("saturation"),
					o = e.color.get("value"),
					a = t.vnode.el,
					{ clientWidth: l, clientHeight: u } = a;
				(r.value = (s * l) / 100), (n.value = ((100 - o) * u) / 100), (i.value = `hsl(${e.color.get("hue")}, 100%, 50%)`);
			}
			function a(i) {
				const s = t.vnode.el.getBoundingClientRect(),
					{ clientX: o, clientY: a } = vR(i);
				let l = o - s.left,
					u = a - s.top;
				(l = Math.max(0, l)), (l = Math.min(l, s.width)), (u = Math.max(0, u)), (u = Math.min(u, s.height)), (r.value = l), (n.value = u), e.color.set({ saturation: (l / s.width) * 100, value: 100 - (u / s.height) * 100 });
			}
			return (
				ds(
					() => s.value,
					() => {
						o();
					}
				),
				Vn(() => {
					cj(t.vnode.el, {
						drag: (e) => {
							a(e);
						},
						end: (e) => {
							a(e);
						}
					}),
						o();
				}),
				{ cursorTop: n, cursorLeft: r, background: i, colorValue: s, handleDrag: a, update: o }
			);
		}
	}),
	Ij = ni("div", { class: "el-color-svpanel__white" }, null, -1),
	Rj = ni("div", { class: "el-color-svpanel__black" }, null, -1),
	Lj = [ni("div", null, null, -1)];
const Oj = Tn({
		name: "ElColorPicker",
		components: {
			ElButton: qV,
			ElTooltip: QH,
			ElInput: WB,
			ElIcon: OB,
			Close: aO,
			ArrowDown: sL,
			SvPanel: IB(Mj, [
				[
					"render",
					function (e, t, n, r, i, s) {
						return Wr(), Kr("div", { class: "el-color-svpanel", style: pt({ backgroundColor: e.background }) }, [Ij, Rj, ni("div", { class: "el-color-svpanel__cursor", style: pt({ top: e.cursorTop + "px", left: e.cursorLeft + "px" }) }, Lj, 4)], 4);
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]
			]),
			HueSlider: dj,
			AlphaSlider: hj,
			Predefine: Aj
		},
		directives: { ClickOutside: CU },
		props: { modelValue: String, id: String, showAlpha: Boolean, colorFormat: String, disabled: Boolean, size: { type: String, validator: EN }, popperClass: String, label: { type: String, default: void 0 }, tabindex: { type: [String, Number], default: 0 }, predefine: Array },
		emits: ["change", "active-change", _N],
		setup(e, { emit: t }) {
			const { t: n } = CD(),
				r = BD("color"),
				i = vn(GN, {}),
				s = vn(YN, {}),
				{ inputId: o, isLabeledByFormItem: a } = bD(e, { formItemContext: s }),
				l = Qe(null),
				u = Qe(null),
				c = Qe(null),
				h = Qe(null);
			let d = !0;
			const p = Fe(new Cj({ enableAlpha: e.showAlpha, format: e.colorFormat, value: e.modelValue })),
				f = Qe(!1),
				m = Qe(!1),
				v = Qe(""),
				g = ht(() =>
					e.modelValue || m.value
						? (function (e, t) {
								if (!(e instanceof Cj)) throw new TypeError("color should be instance of _color Class");
								const { r: n, g: r, b: i } = e.toRgb();
								return t ? `rgba(${n}, ${r}, ${i}, ${e.get("alpha") / 100})` : `rgb(${n}, ${r}, ${i})`;
						  })(p, e.showAlpha)
						: "transparent"
				),
				y = hD(),
				b = ht(() => !(!e.disabled && !i.disabled)),
				x = ht(() => (e.modelValue || m.value ? p.value : "")),
				_ = ht(() => (a.value ? void 0 : e.label || n("el.colorpicker.defaultLabel"))),
				w = ht(() => (a.value ? s.labelId : void 0));
			ds(
				() => e.modelValue,
				(e) => {
					e ? e && e !== p.value && ((d = !1), p.fromString(e)) : (m.value = !1);
				}
			),
				ds(
					() => x.value,
					(e) => {
						(v.value = e), d && t("active-change", e), (d = !0);
					}
				),
				ds(
					() => p.value,
					() => {
						e.modelValue || m.value || (m.value = !0);
					}
				);
			const C = QT(function (e) {
				f.value = e;
			}, 100);
			function S() {
				ns(() => {
					e.modelValue ? p.fromString(e.modelValue) : (m.value = !1);
				});
			}
			return (
				Vn(() => {
					e.modelValue && (v.value = x.value);
				}),
				ds(
					() => f.value,
					() => {
						ns(() => {
							var e, t, n;
							null == (e = l.value) || e.update(), null == (t = u.value) || t.update(), null == (n = c.value) || n.update();
						});
					}
				),
				mn(pj, { currentColor: x }),
				{
					color: p,
					colorDisabled: b,
					colorSize: y,
					displayedColor: g,
					showPanelColor: m,
					showPicker: f,
					customInput: v,
					buttonId: o,
					buttonAriaLabel: _,
					buttonAriaLabelledby: w,
					handleConfirm: function () {
						p.fromString(v.value);
					},
					hide: function () {
						C(!1), S();
					},
					handleTrigger: function () {
						b.value || C(!f.value);
					},
					clear: function () {
						var n;
						C(!1), t(_N, null), t("change", null), null !== e.modelValue && (null == (n = s.validate) || n.call(s, "change").catch((e) => {})), S();
					},
					confirmValue: function () {
						var n;
						const r = p.value;
						t(_N, r),
							t("change", r),
							null == (n = s.validate) || n.call(s, "change").catch((e) => {}),
							C(!1),
							ns(() => {
								const t = new Cj({ enableAlpha: e.showAlpha, format: e.colorFormat, value: e.modelValue });
								p.compare(t) || S();
							});
					},
					t: n,
					ns: r,
					hue: l,
					svPanel: u,
					alpha: c,
					popper: h
				}
			);
		}
	}),
	Pj = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex"];
var Nj = IB(Oj, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("hue-slider"),
				a = Or("sv-panel"),
				l = Or("alpha-slider"),
				u = Or("predefine"),
				c = Or("el-input"),
				h = Or("el-button"),
				d = Or("arrow-down"),
				p = Or("el-icon"),
				f = Or("close"),
				m = Or("el-tooltip"),
				v = Dr("click-outside");
			return (
				Wr(),
				qr(
					m,
					{
						ref: "popper",
						visible: e.showPicker,
						"onUpdate:visible": t[3] || (t[3] = (t) => (e.showPicker = t)),
						"show-arrow": !1,
						"fallback-placements": ["bottom", "top", "right", "left"],
						offset: 0,
						"gpu-acceleration": !1,
						"popper-class": [e.ns.be("picker", "panel"), e.ns.b("dropdown"), e.popperClass],
						"stop-popper-mouse-event": !1,
						effect: "light",
						trigger: "click",
						transition: "el-zoom-in-top",
						persistent: ""
					},
					{
						content: cn(() => [
							yr(
								(Wr(),
								Kr("div", null, [
									ni("div", { class: gt(e.ns.be("dropdown", "main-wrapper")) }, [ri(o, { ref: "hue", class: "hue-slider", color: e.color, vertical: "" }, null, 8, ["color"]), ri(a, { ref: "svPanel", color: e.color }, null, 8, ["color"])], 2),
									e.showAlpha ? (Wr(), qr(l, { key: 0, ref: "alpha", color: e.color }, null, 8, ["color"])) : ai("v-if", !0),
									e.predefine ? (Wr(), qr(u, { key: 1, ref: "predefine", color: e.color, colors: e.predefine }, null, 8, ["color", "colors"])) : ai("v-if", !0),
									ni(
										"div",
										{ class: gt(e.ns.be("dropdown", "btns")) },
										[
											ni(
												"span",
												{ class: gt(e.ns.be("dropdown", "value")) },
												[
													ri(c, { modelValue: e.customInput, "onUpdate:modelValue": t[0] || (t[0] = (t) => (e.customInput = t)), "validate-event": !1, size: "small", onKeyup: jo(e.handleConfirm, ["enter"]), onBlur: e.handleConfirm }, null, 8, [
														"modelValue",
														"onKeyup",
														"onBlur"
													])
												],
												2
											),
											ri(h, { class: gt(e.ns.be("dropdown", "link-btn")), text: "", size: "small", onClick: e.clear }, { default: cn(() => [oi(bt(e.t("el.colorpicker.clear")), 1)]), _: 1 }, 8, ["class", "onClick"]),
											ri(h, { plain: "", size: "small", class: gt(e.ns.be("dropdown", "btn")), onClick: e.confirmValue }, { default: cn(() => [oi(bt(e.t("el.colorpicker.confirm")), 1)]), _: 1 }, 8, ["class", "onClick"])
										],
										2
									)
								])),
								[[v, e.hide]]
							)
						]),
						default: cn(() => [
							ni(
								"div",
								{
									id: e.buttonId,
									class: gt([e.ns.b("picker"), e.ns.is("disabled", e.colorDisabled), e.ns.bm("picker", e.colorSize)]),
									role: "button",
									"aria-label": e.buttonAriaLabel,
									"aria-labelledby": e.buttonAriaLabelledby,
									"aria-description": e.t("el.colorpicker.description", { color: e.modelValue }),
									tabindex: e.tabindex,
									onKeydown: t[2] || (t[2] = jo((...t) => e.handleTrigger && e.handleTrigger(...t), ["enter"]))
								},
								[
									e.colorDisabled ? (Wr(), Kr("div", { key: 0, class: gt(e.ns.be("picker", "mask")) }, null, 2)) : ai("v-if", !0),
									ni(
										"div",
										{ class: gt(e.ns.be("picker", "trigger")), onClick: t[1] || (t[1] = (...t) => e.handleTrigger && e.handleTrigger(...t)) },
										[
											ni(
												"span",
												{ class: gt([e.ns.be("picker", "color"), e.ns.is("alpha", e.showAlpha)]) },
												[
													ni(
														"span",
														{ class: gt(e.ns.be("picker", "color-inner")), style: pt({ backgroundColor: e.displayedColor }) },
														[
															yr(ri(p, { class: gt([e.ns.be("picker", "icon"), e.ns.is("icon-arrow-down")]) }, { default: cn(() => [ri(d)]), _: 1 }, 8, ["class"]), [[Wo, e.modelValue || e.showPanelColor]]),
															e.modelValue || e.showPanelColor ? ai("v-if", !0) : (Wr(), qr(p, { key: 0, class: gt([e.ns.be("picker", "empty"), e.ns.is("icon-close")]) }, { default: cn(() => [ri(f)]), _: 1 }, 8, ["class"]))
														],
														6
													)
												],
												2
											)
										],
										2
									)
								],
								42,
								Pj
							)
						]),
						_: 1
					},
					8,
					["visible", "popper-class"]
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/index.vue"]
]);
Nj.install = (e) => {
	e.component(Nj.name, Nj);
};
const Dj = Nj,
	Bj = {},
	Fj = mN(
		Tn({
			name: "ElConfigProvider",
			props: uN({
				a11y: { type: Boolean, default: !0 },
				locale: { type: Object },
				size: cD,
				button: { type: Object },
				experimentalFeatures: { type: Object },
				keyboardNavigation: { type: Boolean, default: !0 },
				message: { type: Object },
				zIndex: Number,
				namespace: { type: String, default: "el" }
			}),
			setup(e, { slots: t }) {
				ds(
					() => e.message,
					(e) => {
						Object.assign(Bj, null != e ? e : {});
					},
					{ immediate: !0, deep: !0 }
				);
				const n = lD(e);
				return () => mi(t, "default", { config: null == n ? void 0 : n.value });
			}
		})
	);
var Hj = IB(
	Tn(
		c(u({}, { name: "ElContainer" }), {
			props: { direction: { type: String } },
			setup(e) {
				const t = e,
					n = gs(),
					r = BD("container"),
					i = ht(() => {
						if ("vertical" === t.direction) return !0;
						if ("horizontal" === t.direction) return !1;
						if (n && n.default) {
							return n.default().some((e) => {
								const t = e.type.name;
								return "ElHeader" === t || "ElFooter" === t;
							});
						}
						return !1;
					});
				return (e, t) => (Wr(), Kr("section", { class: gt([it(r).b(), it(r).is("vertical", it(i))]) }, [mi(e.$slots, "default")], 2));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]
);
var Vj = IB(
	Tn(
		c(u({}, { name: "ElAside" }), {
			props: { width: { type: String, default: null } },
			setup(e) {
				const t = e,
					n = BD("aside"),
					r = ht(() => (t.width ? n.cssVarBlock({ width: t.width }) : {}));
				return (e, t) => (Wr(), Kr("aside", { class: gt(it(n).b()), style: pt(it(r)) }, [mi(e.$slots, "default")], 6));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]
);
var Uj = IB(
	Tn(
		c(u({}, { name: "ElFooter" }), {
			props: { height: { type: String, default: null } },
			setup(e) {
				const t = e,
					n = BD("footer"),
					r = ht(() => (t.height ? n.cssVarBlock({ height: t.height }) : {}));
				return (e, t) => (Wr(), Kr("footer", { class: gt(it(n).b()), style: pt(it(r)) }, [mi(e.$slots, "default")], 6));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]
);
var zj = IB(
	Tn(
		c(u({}, { name: "ElHeader" }), {
			props: { height: { type: String, default: null } },
			setup(e) {
				const t = e,
					n = BD("header"),
					r = ht(() => (t.height ? n.cssVarBlock({ height: t.height }) : {}));
				return (e, t) => (Wr(), Kr("header", { class: gt(it(n).b()), style: pt(it(r)) }, [mi(e.$slots, "default")], 6));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]
);
var $j = IB(
	Tn(
		c(u({}, { name: "ElMain" }), {
			setup(e) {
				const t = BD("main");
				return (e, n) => (Wr(), Kr("main", { class: gt(it(t).b()) }, [mi(e.$slots, "default")], 2));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]
);
const jj = mN(Hj, { Aside: Vj, Footer: Uj, Header: zj, Main: $j }),
	Wj = gN(Vj),
	Gj = gN(Uj),
	Yj = gN(zj),
	Xj = gN($j);
var Kj,
	qj,
	Zj = { exports: {} },
	Jj = (Zj.exports = function (e, t, n) {
		var r = t.prototype,
			i = r.format;
		(n.en.ordinal = function (e) {
			var t = ["th", "st", "nd", "rd"],
				n = e % 100;
			return "[" + e + (t[(n - 20) % 10] || t[n] || t[0]) + "]";
		}),
			(r.format = function (e) {
				var t = this,
					n = this.$locale();
				if (!this.isValid()) return i.bind(this)(e);
				var r = this.$utils(),
					s = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function (e) {
						switch (e) {
							case "Q":
								return Math.ceil((t.$M + 1) / 3);
							case "Do":
								return n.ordinal(t.$D);
							case "gggg":
								return t.weekYear();
							case "GGGG":
								return t.isoWeekYear();
							case "wo":
								return n.ordinal(t.week(), "W");
							case "w":
							case "ww":
								return r.s(t.week(), "w" === e ? 1 : 2, "0");
							case "W":
							case "WW":
								return r.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
							case "k":
							case "kk":
								return r.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");
							case "X":
								return Math.floor(t.$d.getTime() / 1e3);
							case "x":
								return t.$d.getTime();
							case "z":
								return "[" + t.offsetName() + "]";
							case "zzz":
								return "[" + t.offsetName("long") + "]";
							default:
								return e;
						}
					});
				return i.bind(this)(s);
			});
	}),
	Qj = { exports: {} },
	eW = (Qj.exports =
		((Kj = "week"),
		(qj = "year"),
		function (e, t, n) {
			var r = t.prototype;
			(r.week = function (e) {
				if ((void 0 === e && (e = null), null !== e)) return this.add(7 * (e - this.week()), "day");
				var t = this.$locale().yearStart || 1;
				if (11 === this.month() && this.date() > 25) {
					var r = n(this).startOf(qj).add(1, qj).date(t),
						i = n(this).endOf(Kj);
					if (r.isBefore(i)) return 1;
				}
				var s = n(this).startOf(qj).date(t).startOf(Kj).subtract(1, "millisecond"),
					o = this.diff(s, Kj, !0);
				return o < 0 ? n(this).startOf("week").week() : Math.ceil(o);
			}),
				(r.weeks = function (e) {
					return void 0 === e && (e = null), this.week(e);
				});
		})),
	tW = { exports: {} },
	nW = (tW.exports = function (e, t) {
		t.prototype.weekYear = function () {
			var e = this.month(),
				t = this.week(),
				n = this.year();
			return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
		};
	}),
	rW = { exports: {} },
	iW = (rW.exports = function (e, t, n) {
		t.prototype.dayOfYear = function (e) {
			var t = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
			return null == e ? t : this.add(e - t, "day");
		};
	}),
	sW = { exports: {} },
	oW = (sW.exports = function (e, t) {
		t.prototype.isSameOrAfter = function (e, t) {
			return this.isSame(e, t) || this.isAfter(e, t);
		};
	}),
	aW = { exports: {} },
	lW = (aW.exports = function (e, t) {
		t.prototype.isSameOrBefore = function (e, t) {
			return this.isSame(e, t) || this.isBefore(e, t);
		};
	});
const uW = uN({ type: { type: String, default: "date" } }),
	cW = ["date", "dates", "year", "month", "week", "range"],
	hW = uN({ disabledDate: { type: Function }, date: { type: Object, required: !0 }, minDate: { type: Object }, maxDate: { type: Object }, parsedValue: { type: [Object, Array] }, rangeState: { type: Object, default: () => ({ endDate: null, selecting: !1 }) } }),
	dW = uN({ type: { type: String, required: !0, values: ["year", "month", "date", "dates", "week", "datetime", "datetimerange", "daterange", "monthrange"] } }),
	pW = uN({ unlinkPanels: Boolean, parsedValue: { type: Array } }),
	fW = (e) => ({ type: String, values: cW, default: e }),
	mW = uN(c(u({}, dW), { parsedValue: { type: [Object, Array] }, visible: { type: Boolean }, format: { type: String, default: "" } })),
	vW = uN(c(u({}, hW), { cellClassName: { type: Function }, showWeekNumber: Boolean, selectionMode: fW("date") })),
	gW = (e) => {
		if (!_R(e)) return !1;
		const [t, n] = e;
		return QV.isDayjs(t) && QV.isDayjs(n) && t.isSameOrBefore(n);
	},
	yW = (e, { lang: t, unit: n, unlinkPanels: r }) => {
		let i;
		if (_R(e)) {
			let [i, s] = e.map((e) => QV(e).locale(t));
			return r || (s = i.add(1, n)), [i, s];
		}
		return (i = e ? QV(e) : QV()), (i = i.locale(t)), [i, i.add(1, n)];
	};
var bW = Tn({
	name: "ElDatePickerCell",
	props: uN({ cell: { type: Object } }),
	setup(e) {
		const t = BD("date-table-cell"),
			{ slots: n } = vn(iD);
		return () => {
			const { cell: r } = e;
			if (n.default) {
				const e = n.default(r).filter((e) => -2 !== e.patchFlag && "Symbol(Comment)" !== e.type.toString());
				if (e.length) return e;
			}
			return ri("div", { class: t.b() }, [ri("span", { class: t.e("text") }, [null == r ? void 0 : r.text])]);
		};
	}
});
const xW = ["aria-label"],
	_W = { key: 0, scope: "col" },
	wW = ["aria-label"],
	CW = ["aria-current", "aria-selected", "tabindex"];
var SW = IB(
	Tn({
		__name: "basic-date-table",
		props: vW,
		emits: ["changerange", "pick", "select"],
		setup(e, { expose: t, emit: n }) {
			const r = e,
				i = BD("date-table"),
				{ t: s, lang: o } = CD(),
				a = Qe(),
				l = Qe(),
				u = Qe(),
				c = Qe(),
				h = Qe([[], [], [], [], [], []]),
				d = r.date.$locale().weekStart || 7,
				p = r.date
					.locale("en")
					.localeData()
					.weekdaysShort()
					.map((e) => e.toLowerCase()),
				f = ht(() => (d > 3 ? 7 - d : -d)),
				m = ht(() => {
					const e = r.date.startOf("month");
					return e.subtract(e.day() || 7, "day");
				}),
				v = ht(() => p.concat(p).slice(d, d + 7)),
				g = ht(() => w.value.flat().some((e) => e.isCurrent)),
				y = ht(() => {
					const e = r.date.startOf("month");
					return { startOfMonthDay: e.day() || 7, dateCountOfMonth: e.daysInMonth(), dateCountOfLastMonth: e.subtract(1, "month").daysInMonth() };
				}),
				b = ht(() => ("dates" === r.selectionMode ? RN(r.parsedValue) : [])),
				x = (e, { columnIndex: t, rowIndex: n }, i) => {
					const { disabledDate: s, cellClassName: o } = r,
						a = it(b),
						l = ((e, { count: t, rowIndex: n, columnIndex: r }) => {
							const { startOfMonthDay: i, dateCountOfMonth: s, dateCountOfLastMonth: o } = it(y),
								a = it(f);
							if (!(n >= 0 && n <= 1)) return t <= s ? (e.text = t) : ((e.text = t - s), (e.type = "next-month")), !0;
							{
								const s = i + a < 0 ? 7 + i + a : i + a;
								if (r + 7 * n >= s) return (e.text = t), !0;
								(e.text = o - (s - (r % 7)) + 1 + 7 * n), (e.type = "prev-month");
							}
							return !1;
						})(e, { count: i, rowIndex: n, columnIndex: t }),
						u = e.dayjs.toDate();
					return (e.selected = a.find((t) => t.valueOf() === e.dayjs.valueOf())), (e.isSelected = !!e.selected), (e.isCurrent = S(e)), (e.disabled = null == s ? void 0 : s(u)), (e.customClass = null == o ? void 0 : o(u)), l;
				},
				_ = (e) => {
					if ("week" === r.selectionMode) {
						const [t, n] = r.showWeekNumber ? [1, 7] : [0, 6],
							i = L(e[t + 1]);
						(e[t].inRange = i), (e[t].start = i), (e[n].inRange = i), (e[n].end = i);
					}
				},
				w = ht(() => {
					const { minDate: e, maxDate: t, rangeState: n, showWeekNumber: i } = r,
						s = f.value,
						a = h.value,
						l = "day";
					let u = 1;
					if (i) for (let r = 0; r < 6; r++) a[r][0] || (a[r][0] = { type: "week", text: m.value.add(7 * r + 1, l).week() });
					return (
						((e, t, { columnIndexOffset: n, startDate: r, nextEndDate: i, now: s, unit: o, relativeDateGetter: a, setCellMetadata: l, setRowMetadata: u }) => {
							for (let c = 0; c < e.row; c++) {
								const h = t[c];
								for (let t = 0; t < e.column; t++) {
									let u = h[t + n];
									u || (u = { row: c, column: t, type: "normal", inRange: !1, start: !1, end: !1 });
									const d = a(c * e.column + t);
									(u.dayjs = d),
										(u.date = d.toDate()),
										(u.timestamp = d.valueOf()),
										(u.type = "normal"),
										(u.inRange = !!(r && d.isSameOrAfter(r, o) && i && d.isSameOrBefore(i, o)) || !!(r && d.isSameOrBefore(r, o) && i && d.isSameOrAfter(i, o))),
										(null == r ? void 0 : r.isSameOrAfter(i)) ? ((u.start = !!i && d.isSame(i, o)), (u.end = r && d.isSame(r, o))) : ((u.start = !!r && d.isSame(r, o)), (u.end = !!i && d.isSame(i, o))),
										d.isSame(s, o) && (u.type = "today"),
										null == l || l(u, { rowIndex: c, columnIndex: t }),
										(h[t + n] = u);
								}
								null == u || u(h);
							}
						})({ row: 6, column: 7 }, a, {
							startDate: e,
							columnIndexOffset: i ? 1 : 0,
							nextEndDate: n.endDate || t || (n.selecting && e) || null,
							now: QV().locale(it(o)).startOf(l),
							unit: l,
							relativeDateGetter: (e) => m.value.add(e - s, l),
							setCellMetadata: (...e) => {
								x(...e, u) && (u += 1);
							},
							setRowMetadata: _
						}),
						a
					);
				});
			ds(
				() => r.date,
				async () => {
					var e, t;
					(null == (e = a.value) ? void 0 : e.contains(document.activeElement)) && (await ns(), null == (t = l.value) || t.focus());
				}
			);
			const C = (e = "") => ["normal", "today"].includes(e),
				S = (e) => "date" === r.selectionMode && C(e.type) && E(e, r.parsedValue),
				E = (e, t) =>
					!!t &&
					QV(t)
						.locale(o.value)
						.isSame(r.date.date(Number(e.text)), "day"),
				T = (e) => {
					const t = [];
					return (
						C(e.type) && !e.disabled ? (t.push("available"), "today" === e.type && t.push("today")) : t.push(e.type),
						S(e) && t.push("current"),
						e.inRange && (C(e.type) || "week" === r.selectionMode) && (t.push("in-range"), e.start && t.push("start-date"), e.end && t.push("end-date")),
						e.disabled && t.push("disabled"),
						e.selected && t.push("selected"),
						e.customClass && t.push(e.customClass),
						t.join(" ")
					);
				},
				k = (e, t) => {
					const n = 7 * e + (t - (r.showWeekNumber ? 1 : 0)) - f.value;
					return m.value.add(n, "day");
				},
				A = (e) => {
					var t;
					if (!r.rangeState.selecting) return;
					let i = e.target;
					if (("SPAN" === i.tagName && (i = null == (t = i.parentNode) ? void 0 : t.parentNode), "DIV" === i.tagName && (i = i.parentNode), "TD" !== i.tagName)) return;
					const s = i.parentNode.rowIndex - 1,
						o = i.cellIndex;
					w.value[s][o].disabled || (s === u.value && o === c.value) || ((u.value = s), (c.value = o), n("changerange", { selecting: !0, endDate: k(s, o) }));
				},
				M = (e) => (!g.value && 1 === (null == e ? void 0 : e.text) && "normal" === e.type) || e.isCurrent,
				I = (e) => {
					g.value || "date" !== r.selectionMode || R(e, !0);
				},
				R = (e, t = !1) => {
					const i = e.target.closest("td");
					if (!i || "TD" !== i.tagName) return;
					const s = i.parentNode.rowIndex - 1,
						o = i.cellIndex,
						a = w.value[s][o];
					if (a.disabled || "week" === a.type) return;
					const l = k(s, o);
					if ("range" === r.selectionMode) r.rangeState.selecting && r.minDate ? (l >= r.minDate ? n("pick", { minDate: r.minDate, maxDate: l }) : n("pick", { minDate: l, maxDate: r.minDate }), n("select", !1)) : (n("pick", { minDate: l, maxDate: null }), n("select", !0));
					else if ("date" === r.selectionMode) n("pick", l, t);
					else if ("week" === r.selectionMode) {
						const e = l.week(),
							t = `${l.year()}w${e}`;
						n("pick", { year: l.year(), week: e, value: t, date: l.startOf("week") });
					} else if ("dates" === r.selectionMode) {
						const e = a.selected ? RN(r.parsedValue).filter((e) => (null == e ? void 0 : e.valueOf()) !== l.valueOf()) : RN(r.parsedValue).concat([l]);
						n("pick", e);
					}
				},
				L = (e) => {
					if ("week" !== r.selectionMode) return !1;
					let t = r.date.startOf("day");
					if (("prev-month" === e.type && (t = t.subtract(1, "month")), "next-month" === e.type && (t = t.add(1, "month")), (t = t.date(Number.parseInt(e.text, 10))), r.parsedValue && !Array.isArray(r.parsedValue))) {
						const e = ((r.parsedValue.day() - d + 7) % 7) - 1;
						return r.parsedValue.subtract(e, "day").isSame(t, "day");
					}
					return !1;
				};
			return (
				t({
					focus: async () => {
						var e;
						null == (e = l.value) || e.focus();
					}
				}),
				(e, t) => (
					Wr(),
					Kr(
						"table",
						{ role: "grid", "aria-label": it(s)("el.datepicker.dateTablePrompt"), cellspacing: "0", cellpadding: "0", class: gt([it(i).b(), { "is-week-mode": "week" === e.selectionMode }]), onClick: R, onMousemove: A },
						[
							ni(
								"tbody",
								{ ref_key: "tbodyRef", ref: a },
								[
									ni("tr", null, [
										e.showWeekNumber ? (Wr(), Kr("th", _W, bt(it(s)("el.datepicker.week")), 1)) : ai("v-if", !0),
										(Wr(!0),
										Kr(
											Hr,
											null,
											pi(it(v), (e, t) => (Wr(), Kr("th", { key: t, scope: "col", "aria-label": it(s)("el.datepicker.weeksFull." + e) }, bt(it(s)("el.datepicker.weeks." + e)), 9, wW))),
											128
										))
									]),
									(Wr(!0),
									Kr(
										Hr,
										null,
										pi(
											it(w),
											(e, t) => (
												Wr(),
												Kr(
													"tr",
													{ key: t, class: gt([it(i).e("row"), { current: L(e[1]) }]) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(
																e,
																(e, n) => (
																	Wr(),
																	Kr(
																		"td",
																		{
																			key: `${t}.${n}`,
																			ref_for: !0,
																			ref: (t) => {
																				M(e) && (l.value = t);
																			},
																			class: gt(T(e)),
																			"aria-current": e.isCurrent ? "date" : void 0,
																			"aria-selected": e.isCurrent,
																			tabindex: M(e) ? 0 : -1,
																			onFocus: I
																		},
																		[ri(it(bW), { cell: e }, null, 8, ["cell"])],
																		42,
																		CW
																	)
																)
															),
															128
														))
													],
													2
												)
											)
										),
										128
									))
								],
								512
							)
						],
						42,
						xW
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]
);
const EW = uN(c(u({}, hW), { selectionMode: fW("month") })),
	TW = ["aria-label"],
	kW = ["aria-selected", "aria-label", "tabindex", "onKeydown"],
	AW = { class: "cell" };
var MW = IB(
	Tn({
		__name: "basic-month-table",
		props: EW,
		emits: ["changerange", "pick", "select"],
		setup(e, { expose: t, emit: n }) {
			const r = e,
				i = BD("month-table"),
				{ t: s, lang: o } = CD(),
				a = Qe(),
				l = Qe(),
				u = Qe(
					r.date
						.locale("en")
						.localeData()
						.monthsShort()
						.map((e) => e.toLowerCase())
				),
				c = Qe([[], [], []]),
				h = Qe(),
				d = Qe(),
				p = ht(() => {
					var e, t;
					const n = c.value,
						i = QV().locale(o.value).startOf("month");
					for (let s = 0; s < 3; s++) {
						const o = n[s];
						for (let n = 0; n < 4; n++) {
							const a = o[n] || (o[n] = { row: s, column: n, type: "normal", inRange: !1, start: !1, end: !1, text: -1, disabled: !1 });
							a.type = "normal";
							const l = 4 * s + n,
								u = r.date.startOf("year").month(l),
								c = r.rangeState.endDate || r.maxDate || (r.rangeState.selecting && r.minDate) || null;
							(a.inRange = !!(r.minDate && u.isSameOrAfter(r.minDate, "month") && c && u.isSameOrBefore(c, "month")) || !!(r.minDate && u.isSameOrBefore(r.minDate, "month") && c && u.isSameOrAfter(c, "month"))),
								(null == (e = r.minDate) ? void 0 : e.isSameOrAfter(c)) ? ((a.start = !(!c || !u.isSame(c, "month"))), (a.end = r.minDate && u.isSame(r.minDate, "month"))) : ((a.start = !(!r.minDate || !u.isSame(r.minDate, "month"))), (a.end = !(!c || !u.isSame(c, "month"))));
							i.isSame(u) && (a.type = "today"), (a.text = l), (a.disabled = (null == (t = r.disabledDate) ? void 0 : t.call(r, u.toDate())) || !1);
						}
					}
					return n;
				}),
				f = (e) => {
					const t = {},
						n = r.date.year(),
						i = new Date(),
						s = e.text;
					return (
						(t.disabled =
							!!r.disabledDate &&
							((e, t, n) => {
								const r = QV().locale(n).startOf("month").month(t).year(e),
									i = r.daysInMonth();
								return aU(i).map((e) => r.add(e, "day").toDate());
							})(n, s, o.value).every(r.disabledDate)),
						(t.current = RN(r.parsedValue).findIndex((e) => QV.isDayjs(e) && e.year() === n && e.month() === s) >= 0),
						(t.today = i.getFullYear() === n && i.getMonth() === s),
						e.inRange && ((t["in-range"] = !0), e.start && (t["start-date"] = !0), e.end && (t["end-date"] = !0)),
						t
					);
				},
				m = (e) => {
					const t = r.date.year(),
						n = e.text;
					return RN(r.date).findIndex((e) => e.year() === t && e.month() === n) >= 0;
				},
				v = (e) => {
					var t;
					if (!r.rangeState.selecting) return;
					let i = e.target;
					if (("A" === i.tagName && (i = null == (t = i.parentNode) ? void 0 : t.parentNode), "DIV" === i.tagName && (i = i.parentNode), "TD" !== i.tagName)) return;
					const s = i.parentNode.rowIndex,
						o = i.cellIndex;
					p.value[s][o].disabled || (s === h.value && o === d.value) || ((h.value = s), (d.value = o), n("changerange", { selecting: !0, endDate: r.date.startOf("year").month(4 * s + o) }));
				},
				g = (e) => {
					var t;
					const i = null == (t = e.target) ? void 0 : t.closest("td");
					if ("TD" !== (null == i ? void 0 : i.tagName)) return;
					if (WR(i, "disabled")) return;
					const s = i.cellIndex,
						o = 4 * i.parentNode.rowIndex + s,
						a = r.date.startOf("year").month(o);
					"range" === r.selectionMode ? (r.rangeState.selecting ? (r.minDate && a >= r.minDate ? n("pick", { minDate: r.minDate, maxDate: a }) : n("pick", { minDate: a, maxDate: r.minDate }), n("select", !1)) : (n("pick", { minDate: a, maxDate: null }), n("select", !0))) : n("pick", o);
				};
			return (
				ds(
					() => r.date,
					async () => {
						var e, t;
						(null == (e = a.value) ? void 0 : e.contains(document.activeElement)) && (await ns(), null == (t = l.value) || t.focus());
					}
				),
				t({
					focus: () => {
						var e;
						null == (e = l.value) || e.focus();
					}
				}),
				(e, t) => (
					Wr(),
					Kr(
						"table",
						{ role: "grid", "aria-label": it(s)("el.datepicker.monthTablePrompt"), class: gt(it(i).b()), onClick: g, onMousemove: v },
						[
							ni(
								"tbody",
								{ ref_key: "tbodyRef", ref: a },
								[
									(Wr(!0),
									Kr(
										Hr,
										null,
										pi(
											it(p),
											(e, t) => (
												Wr(),
												Kr("tr", { key: t }, [
													(Wr(!0),
													Kr(
														Hr,
														null,
														pi(
															e,
															(e, t) => (
																Wr(),
																Kr(
																	"td",
																	{
																		key: t,
																		ref_for: !0,
																		ref: (t) => m(e) && (l.value = t),
																		class: gt(f(e)),
																		"aria-selected": `${m(e)}`,
																		"aria-label": it(s)("el.datepicker.month" + (+e.text + 1)),
																		tabindex: m(e) ? 0 : -1,
																		onKeydown: [jo(zo(g, ["prevent", "stop"]), ["space"]), jo(zo(g, ["prevent", "stop"]), ["enter"])]
																	},
																	[ni("div", null, [ni("span", AW, bt(it(s)("el.datepicker.months." + u.value[e.text])), 1)])],
																	42,
																	kW
																)
															)
														),
														128
													))
												])
											)
										),
										128
									))
								],
								512
							)
						],
						42,
						TW
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]
);
const { date: IW, disabledDate: RW, parsedValue: LW } = hW,
	OW = uN({ date: IW, disabledDate: RW, parsedValue: LW }),
	PW = ["aria-label"],
	NW = ["aria-selected", "tabindex", "onKeydown"],
	DW = { class: "cell" },
	BW = { key: 1 };
var FW = IB(
	Tn({
		__name: "basic-year-table",
		props: OW,
		emits: ["pick"],
		setup(e, { expose: t, emit: n }) {
			const r = e,
				i = BD("year-table"),
				{ t: s, lang: o } = CD(),
				a = Qe(),
				l = Qe(),
				u = ht(() => 10 * Math.floor(r.date.year() / 10)),
				c = (e) => {
					const t = {},
						n = QV().locale(o.value);
					return (
						(t.disabled =
							!!r.disabledDate &&
							((e, t) => {
								const n = QV(String(e)).locale(t).startOf("year"),
									r = n.endOf("year").dayOfYear();
								return aU(r).map((e) => n.add(e, "day").toDate());
							})(e, o.value).every(r.disabledDate)),
						(t.current = RN(r.parsedValue).findIndex((t) => t.year() === e) >= 0),
						(t.today = n.year() === e),
						t
					);
				},
				h = (e) => (e === u.value && r.date.year() < u.value && r.date.year() > u.value + 9) || RN(r.date).findIndex((t) => t.year() === e) >= 0,
				d = (e) => {
					const t = e.target.closest("td");
					if (t) {
						if (WR(t.parentNode, "disabled")) return;
						const e = t.textContent || t.innerText;
						n("pick", Number(e));
					}
				};
			return (
				ds(
					() => r.date,
					async () => {
						var e, t;
						(null == (e = a.value) ? void 0 : e.contains(document.activeElement)) && (await ns(), null == (t = l.value) || t.focus());
					}
				),
				t({
					focus: () => {
						var e;
						null == (e = l.value) || e.focus();
					}
				}),
				(e, t) => (
					Wr(),
					Kr(
						"table",
						{ role: "grid", "aria-label": it(s)("el.datepicker.yearTablePrompt"), class: gt(it(i).b()), onClick: d },
						[
							ni(
								"tbody",
								{ ref_key: "tbodyRef", ref: a },
								[
									(Wr(),
									Kr(
										Hr,
										null,
										pi(3, (e, t) =>
											ni("tr", { key: t }, [
												(Wr(),
												Kr(
													Hr,
													null,
													pi(
														4,
														(e, n) => (
															Wr(),
															Kr(
																Hr,
																{ key: t + "_" + n },
																[
																	4 * t + n < 10
																		? (Wr(),
																		  Kr(
																				"td",
																				{
																					key: 0,
																					ref_for: !0,
																					ref: (e) => h(it(u) + 4 * t + n) && (l.value = e),
																					class: gt(["available", c(it(u) + 4 * t + n)]),
																					"aria-selected": `${h(it(u) + 4 * t + n)}`,
																					tabindex: h(it(u) + 4 * t + n) ? 0 : -1,
																					onKeydown: [jo(zo(d, ["prevent", "stop"]), ["space"]), jo(zo(d, ["prevent", "stop"]), ["enter"])]
																				},
																				[ni("span", DW, bt(it(u) + 4 * t + n), 1)],
																				42,
																				NW
																		  ))
																		: (Wr(), Kr("td", BW))
																],
																64
															)
														)
													),
													64
												))
											])
										),
										64
									))
								],
								512
							)
						],
						10,
						PW
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]
);
const HW = ["onClick"],
	VW = ["aria-label"],
	UW = ["aria-label"],
	zW = ["aria-label"],
	$W = ["aria-label"];
var jW = IB(
	Tn({
		__name: "panel-date-pick",
		props: mW,
		emits: ["pick", "set-picker-option", "panel-change"],
		setup(e, { emit: t }) {
			const n = e,
				r = BD("picker-panel"),
				i = BD("date-picker"),
				s = ys(),
				o = gs(),
				{ t: a, lang: l } = CD(),
				u = vn("EP_PICKER_BASE"),
				c = vn($H),
				{ shortcuts: h, disabledDate: d, cellClassName: p, defaultTime: f, arrowControl: m } = u.props,
				v = ut(u.props, "defaultValue"),
				g = Qe(),
				y = Qe(QV().locale(l.value)),
				b = ht(() => QV(f).locale(l.value)),
				x = ht(() => y.value.month()),
				_ = ht(() => y.value.year()),
				w = Qe([]),
				C = Qe(null),
				S = Qe(null),
				E = (e) => !(w.value.length > 0) || (w.value, n.format, !0),
				T = (e) => (f && !W.value ? b.value.year(e.year()).month(e.month()).date(e.date()) : H.value ? e.millisecond(0) : e.startOf("day")),
				k = (e, ...n) => {
					if (e)
						if (_R(e)) {
							const r = e.map(T);
							t("pick", r, ...n);
						} else t("pick", T(e), ...n);
					else t("pick", e, ...n);
					(C.value = null), (S.value = null);
				},
				A = (e, t) => {
					if ("date" === O.value) {
						e = e;
						let r = n.parsedValue ? n.parsedValue.year(e.year()).month(e.month()).date(e.date()) : e;
						E() || (r = w.value[0][0].year(e.year()).month(e.month()).date(e.date())), (y.value = r), k(r, H.value || t);
					} else "week" === O.value ? k(e.date) : "dates" === O.value && k(e, !0);
				},
				M = (e) => {
					const t = e ? "add" : "subtract";
					(y.value = y.value[t](1, "month")), ie("month");
				},
				I = (e) => {
					const t = y.value,
						n = e ? "add" : "subtract";
					(y.value = "year" === R.value ? t[n](10, "year") : t[n](1, "year")), ie("year");
				},
				R = Qe("date"),
				L = ht(() => {
					const e = a("el.datepicker.year");
					if ("year" === R.value) {
						const t = 10 * Math.floor(_.value / 10);
						return e ? `${t} ${e} - ${t + 9} ${e}` : `${t} - ${t + 9}`;
					}
					return `${_.value} ${e}`;
				}),
				O = ht(() => {
					const { type: e } = n;
					return ["week", "month", "year", "dates"].includes(e) ? e : "date";
				}),
				P = ht(() => ("date" === O.value ? R.value : O.value)),
				N = ht(() => !!h.length),
				D = async (e) => {
					(y.value = y.value.startOf("month").month(e)), "month" === O.value ? k(y.value, !1) : ((R.value = "date"), ["month", "year", "date", "week"].includes(O.value) && (k(y.value, !0), await ns(), te())), ie("month");
				},
				B = async (e) => {
					"year" === O.value ? ((y.value = y.value.startOf("year").year(e)), k(y.value, !1)) : ((y.value = y.value.year(e)), (R.value = "month"), ["month", "year", "date", "week"].includes(O.value) && (k(y.value, !0), await ns(), te())), ie("year");
				},
				F = async (e) => {
					(R.value = e), await ns(), te();
				},
				H = ht(() => "datetime" === n.type || "datetimerange" === n.type),
				V = ht(() => H.value || "dates" === O.value),
				U = () => {
					if ("dates" === O.value) k(n.parsedValue);
					else {
						let e = n.parsedValue;
						if (!e) {
							const t = QV(f).locale(l.value),
								n = ee();
							e = t.year(n.year()).month(n.month()).date(n.date());
						}
						(y.value = e), k(e);
					}
				},
				z = () => {
					const e = QV().locale(l.value).toDate();
					(d && d(e)) || !E() || ((y.value = QV().locale(l.value)), k(y.value));
				},
				$ = ht(() => uU(n.format)),
				j = ht(() => lU(n.format)),
				W = ht(() => (S.value ? S.value : n.parsedValue || v.value ? (n.parsedValue || y.value).format($.value) : void 0)),
				G = ht(() => (C.value ? C.value : n.parsedValue || v.value ? (n.parsedValue || y.value).format(j.value) : void 0)),
				Y = Qe(!1),
				X = () => {
					Y.value = !0;
				},
				K = () => {
					Y.value = !1;
				},
				q = (e) => ({ hour: e.hour(), minute: e.minute(), second: e.second(), year: e.year(), month: e.month(), date: e.date() }),
				Z = (e, t, r) => {
					const { hour: i, minute: s, second: o } = q(e),
						a = n.parsedValue ? n.parsedValue.hour(i).minute(s).second(o) : e;
					(y.value = a), k(y.value, !0), r || (Y.value = t);
				},
				J = (e) => {
					const t = QV(e, $.value).locale(l.value);
					if (t.isValid() && E()) {
						const { year: e, month: n, date: r } = q(y.value);
						(y.value = t.year(e).month(n).date(r)), (S.value = null), (Y.value = !1), k(y.value, !0);
					}
				},
				Q = (e) => {
					const t = QV(e, j.value).locale(l.value);
					if (t.isValid()) {
						if (d && d(t.toDate())) return;
						const { hour: e, minute: n, second: r } = q(y.value);
						(y.value = t.hour(e).minute(n).second(r)), (C.value = null), k(y.value, !0);
					}
				},
				ee = () => {
					const e = QV(v.value).locale(l.value);
					if (!v.value) {
						const e = b.value;
						return QV().hour(e.hour()).minute(e.minute()).second(e.second()).locale(l.value);
					}
					return e;
				},
				te = async () => {
					var e;
					["week", "month", "year", "date"].includes(O.value) && (null == (e = g.value) || e.focus(), "week" === O.value && re(bN.down));
				},
				ne = (e) => {
					const { code: t } = e;
					[bN.up, bN.down, bN.left, bN.right, bN.home, bN.end, bN.pageUp, bN.pageDown].includes(t) && (re(t), e.stopPropagation(), e.preventDefault()), [bN.enter, bN.space].includes(t) && null === C.value && null === S.value && (e.preventDefault(), k(y.value, !1));
				},
				re = (e) => {
					var n;
					const { up: r, down: i, left: s, right: o, home: a, end: u, pageUp: c, pageDown: h } = bN,
						p = {
							year: { [r]: -4, [i]: 4, [s]: -1, [o]: 1, offset: (e, t) => e.setFullYear(e.getFullYear() + t) },
							month: { [r]: -4, [i]: 4, [s]: -1, [o]: 1, offset: (e, t) => e.setMonth(e.getMonth() + t) },
							week: { [r]: -1, [i]: 1, [s]: -1, [o]: 1, offset: (e, t) => e.setDate(e.getDate() + 7 * t) },
							date: {
								[r]: -7,
								[i]: 7,
								[s]: -1,
								[o]: 1,
								[a]: (e) => -e.getDay(),
								[u]: (e) => 6 - e.getDay(),
								[c]: (e) => -new Date(e.getFullYear(), e.getMonth(), 0).getDate(),
								[h]: (e) => new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate(),
								offset: (e, t) => e.setDate(e.getDate() + t)
							}
						},
						f = y.value.toDate();
					for (; Math.abs(y.value.diff(f, "year", !0)) < 1; ) {
						const r = p[P.value];
						if (!r) return;
						if ((r.offset(f, CR(r[e]) ? r[e](f) : null != (n = r[e]) ? n : 0), d && d(f))) break;
						const i = QV(f).locale(l.value);
						(y.value = i), t("pick", i, !0);
						break;
					}
				},
				ie = (e) => {
					t("panel-change", y.value.toDate(), e, R.value);
				};
			return (
				ds(
					() => O.value,
					(e) => {
						["month", "year"].includes(e) ? (R.value = e) : (R.value = "date");
					},
					{ immediate: !0 }
				),
				ds(
					() => R.value,
					() => {
						null == c || c.updatePopper();
					}
				),
				ds(
					() => v.value,
					(e) => {
						e && (y.value = ee());
					},
					{ immediate: !0 }
				),
				ds(
					() => n.parsedValue,
					(e) => {
						if (e) {
							if ("dates" === O.value) return;
							if (Array.isArray(e)) return;
							y.value = e;
						} else y.value = ee();
					},
					{ immediate: !0 }
				),
				t("set-picker-option", ["isValidValue", (e) => QV.isDayjs(e) && e.isValid() && (!d || !d(e.toDate()))]),
				t("set-picker-option", ["formatToString", (e) => ("dates" === O.value ? e.map((e) => e.format(n.format)) : e.format(n.format))]),
				t("set-picker-option", ["parseUserInput", (e) => QV(e, n.format).locale(l.value)]),
				t("set-picker-option", ["handleFocusPicker", te]),
				(e, n) => (
					Wr(),
					Kr(
						"div",
						{ class: gt([it(r).b(), it(i).b(), { "has-sidebar": e.$slots.sidebar || it(N), "has-time": it(H) }]) },
						[
							ni(
								"div",
								{ class: gt(it(r).e("body-wrapper")) },
								[
									mi(e.$slots, "sidebar", { class: gt(it(r).e("sidebar")) }),
									it(N)
										? (Wr(),
										  Kr(
												"div",
												{ key: 0, class: gt(it(r).e("sidebar")) },
												[
													(Wr(!0),
													Kr(
														Hr,
														null,
														pi(
															it(h),
															(e, n) => (
																Wr(),
																Kr(
																	"button",
																	{
																		key: n,
																		type: "button",
																		class: gt(it(r).e("shortcut")),
																		onClick: (n) =>
																			((e) => {
																				const n = CR(e.value) ? e.value() : e.value;
																				n ? k(QV(n).locale(l.value)) : e.onClick && e.onClick({ attrs: s, slots: o, emit: t });
																			})(e)
																	},
																	bt(e.text),
																	11,
																	HW
																)
															)
														),
														128
													))
												],
												2
										  ))
										: ai("v-if", !0),
									ni(
										"div",
										{ class: gt(it(r).e("body")) },
										[
											it(H)
												? (Wr(),
												  Kr(
														"div",
														{ key: 0, class: gt(it(i).e("time-header")) },
														[
															ni(
																"span",
																{ class: gt(it(i).e("editor-wrap")) },
																[ri(it(WB), { placeholder: it(a)("el.datepicker.selectDate"), "model-value": it(G), size: "small", onInput: n[0] || (n[0] = (e) => (C.value = e)), onChange: Q }, null, 8, ["placeholder", "model-value"])],
																2
															),
															yr(
																(Wr(),
																Kr(
																	"span",
																	{ class: gt(it(i).e("editor-wrap")) },
																	[
																		ri(it(WB), { placeholder: it(a)("el.datepicker.selectTime"), "model-value": it(W), size: "small", onFocus: X, onInput: n[1] || (n[1] = (e) => (S.value = e)), onChange: J }, null, 8, ["placeholder", "model-value"]),
																		ri(it(cz), { visible: Y.value, format: it($), "time-arrow-control": it(m), "parsed-value": y.value, onPick: Z }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
																	],
																	2
																)),
																[[it(CU), K]]
															)
														],
														2
												  ))
												: ai("v-if", !0),
											yr(
												ni(
													"div",
													{ class: gt([it(i).e("header"), ("year" === R.value || "month" === R.value) && it(i).e("header--bordered")]) },
													[
														ni(
															"span",
															{ class: gt(it(i).e("prev-btn")) },
															[
																ni(
																	"button",
																	{ type: "button", "aria-label": it(a)("el.datepicker.prevYear"), class: gt(["d-arrow-left", it(r).e("icon-btn")]), onClick: n[2] || (n[2] = (e) => I(!1)) },
																	[ri(it(OB), null, { default: cn(() => [ri(it(hO))]), _: 1 })],
																	10,
																	VW
																),
																yr(
																	ni(
																		"button",
																		{ type: "button", "aria-label": it(a)("el.datepicker.prevMonth"), class: gt([it(r).e("icon-btn"), "arrow-left"]), onClick: n[3] || (n[3] = (e) => M(!1)) },
																		[ri(it(OB), null, { default: cn(() => [ri(it(uL))]), _: 1 })],
																		10,
																		UW
																	),
																	[[Wo, "date" === R.value]]
																)
															],
															2
														),
														ni("span", { role: "button", class: gt(it(i).e("header-label")), "aria-live": "polite", tabindex: "0", onKeydown: n[4] || (n[4] = jo((e) => F("year"), ["enter"])), onClick: n[5] || (n[5] = (e) => F("year")) }, bt(it(L)), 35),
														yr(
															ni(
																"span",
																{ role: "button", "aria-live": "polite", tabindex: "0", class: gt([it(i).e("header-label"), { active: "month" === R.value }]), onKeydown: n[6] || (n[6] = jo((e) => F("month"), ["enter"])), onClick: n[7] || (n[7] = (e) => F("month")) },
																bt(it(a)(`el.datepicker.month${it(x) + 1}`)),
																35
															),
															[[Wo, "date" === R.value]]
														),
														ni(
															"span",
															{ class: gt(it(i).e("next-btn")) },
															[
																yr(
																	ni(
																		"button",
																		{ type: "button", "aria-label": it(a)("el.datepicker.nextMonth"), class: gt([it(r).e("icon-btn"), "arrow-right"]), onClick: n[8] || (n[8] = (e) => M(!0)) },
																		[ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })],
																		10,
																		zW
																	),
																	[[Wo, "date" === R.value]]
																),
																ni(
																	"button",
																	{ type: "button", "aria-label": it(a)("el.datepicker.nextYear"), class: gt([it(r).e("icon-btn"), "d-arrow-right"]), onClick: n[9] || (n[9] = (e) => I(!0)) },
																	[ri(it(OB), null, { default: cn(() => [ri(it(mO))]), _: 1 })],
																	10,
																	$W
																)
															],
															2
														)
													],
													2
												),
												[[Wo, "time" !== R.value]]
											),
											ni(
												"div",
												{ class: gt(it(r).e("content")), onKeydown: ne },
												[
													"date" === R.value
														? (Wr(),
														  qr(SW, { key: 0, ref_key: "currentViewRef", ref: g, "selection-mode": it(O), date: y.value, "parsed-value": e.parsedValue, "disabled-date": it(d), "cell-class-name": it(p), onPick: A }, null, 8, [
																"selection-mode",
																"date",
																"parsed-value",
																"disabled-date",
																"cell-class-name"
														  ]))
														: ai("v-if", !0),
													"year" === R.value ? (Wr(), qr(FW, { key: 1, ref_key: "currentViewRef", ref: g, date: y.value, "disabled-date": it(d), "parsed-value": e.parsedValue, onPick: B }, null, 8, ["date", "disabled-date", "parsed-value"])) : ai("v-if", !0),
													"month" === R.value ? (Wr(), qr(MW, { key: 2, ref_key: "currentViewRef", ref: g, date: y.value, "parsed-value": e.parsedValue, "disabled-date": it(d), onPick: D }, null, 8, ["date", "parsed-value", "disabled-date"])) : ai("v-if", !0)
												],
												34
											)
										],
										2
									)
								],
								2
							),
							yr(
								ni(
									"div",
									{ class: gt(it(r).e("footer")) },
									[
										yr(ri(it(qV), { text: "", size: "small", class: gt(it(r).e("link-btn")), onClick: z }, { default: cn(() => [oi(bt(it(a)("el.datepicker.now")), 1)]), _: 1 }, 8, ["class"]), [[Wo, "dates" !== it(O)]]),
										ri(it(qV), { plain: "", size: "small", class: gt(it(r).e("link-btn")), onClick: U }, { default: cn(() => [oi(bt(it(a)("el.datepicker.confirm")), 1)]), _: 1 }, 8, ["class"])
									],
									2
								),
								[[Wo, it(V) && "date" === R.value]]
							)
						],
						2
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]
);
const WW = uN(u(u({}, dW), pW)),
	GW = (e, { defaultValue: t, leftDate: n, rightDate: r, unit: i, onParsedValueChanged: s }) => {
		const { emit: o } = Si(),
			{ pickerNs: a } = vn(iD),
			l = BD("date-range-picker"),
			{ t: u, lang: c } = CD(),
			h = ((e) => {
				const { emit: t } = Si(),
					n = ys(),
					r = gs();
				return (i) => {
					const s = CR(i.value) ? i.value() : i.value;
					s ? t("pick", [QV(s[0]).locale(e.value), QV(s[1]).locale(e.value)]) : i.onClick && i.onClick({ attrs: n, slots: r, emit: t });
				};
			})(c),
			d = Qe(),
			p = Qe(),
			f = Qe({ endDate: null, selecting: !1 }),
			m = () => {
				const [s, o] = yW(it(t), { lang: it(c), unit: i, unlinkPanels: e.unlinkPanels });
				(d.value = void 0), (p.value = void 0), (n.value = s), (r.value = o);
			};
		return (
			ds(
				t,
				(e) => {
					e && m();
				},
				{ immediate: !0 }
			),
			ds(
				() => e.parsedValue,
				(e) => {
					if (_R(e) && 2 === e.length) {
						const [t, r] = e;
						(d.value = t), (n.value = t), (p.value = r), s(it(d), it(p));
					} else m();
				},
				{ immediate: !0 }
			),
			{
				minDate: d,
				maxDate: p,
				rangeState: f,
				lang: c,
				ppNs: a,
				drpNs: l,
				handleChangeRange: (e) => {
					f.value = e;
				},
				handleRangeConfirm: (e = !1) => {
					const t = it(d),
						n = it(p);
					gW([t, n]) && o("pick", [t, n], e);
				},
				handleShortcutClick: h,
				onSelect: (e) => {
					(f.value.selecting = e), e || (f.value.endDate = null);
				},
				t: u
			}
		);
	},
	YW = ["onClick"],
	XW = ["disabled"],
	KW = ["disabled"],
	qW = ["disabled"],
	ZW = ["disabled"];
var JW = IB(
	Tn({
		__name: "panel-date-range",
		props: WW,
		emits: ["pick", "set-picker-option", "calendar-change", "panel-change"],
		setup(e, { emit: t }) {
			const n = e,
				r = "month",
				i = vn("EP_PICKER_BASE"),
				{ disabledDate: s, cellClassName: o, format: a, defaultTime: l, arrowControl: u, clearable: c } = i.props,
				h = ut(i.props, "shortcuts"),
				d = ut(i.props, "defaultValue"),
				{ lang: p } = CD(),
				f = Qe(QV().locale(p.value)),
				m = Qe(QV().locale(p.value).add(1, r)),
				{
					minDate: v,
					maxDate: g,
					rangeState: y,
					ppNs: b,
					drpNs: x,
					handleChangeRange: _,
					handleRangeConfirm: w,
					handleShortcutClick: C,
					onSelect: S,
					t: E
				} = GW(n, {
					defaultValue: d,
					leftDate: f,
					rightDate: m,
					unit: r,
					onParsedValueChanged: function (e, t) {
						if (n.unlinkPanels && t) {
							const n = (null == e ? void 0 : e.year()) || 0,
								i = (null == e ? void 0 : e.month()) || 0,
								s = t.year(),
								o = t.month();
							m.value = n === s && i === o ? t.add(1, r) : t;
						} else (m.value = f.value.add(1, r)), t && (m.value = m.value.hour(t.hour()).minute(t.minute()).second(t.second()));
					}
				}),
				T = Qe({ min: null, max: null }),
				k = Qe({ min: null, max: null }),
				A = ht(() => `${f.value.year()} ${E("el.datepicker.year")} ${E(`el.datepicker.month${f.value.month() + 1}`)}`),
				M = ht(() => `${m.value.year()} ${E("el.datepicker.year")} ${E(`el.datepicker.month${m.value.month() + 1}`)}`),
				I = ht(() => f.value.year()),
				R = ht(() => f.value.month()),
				L = ht(() => m.value.year()),
				O = ht(() => m.value.month()),
				P = ht(() => !!h.value.length),
				N = ht(() => (null !== T.value.min ? T.value.min : v.value ? v.value.format(V.value) : "")),
				D = ht(() => (null !== T.value.max ? T.value.max : g.value || v.value ? (g.value || v.value).format(V.value) : "")),
				B = ht(() => (null !== k.value.min ? k.value.min : v.value ? v.value.format(H.value) : "")),
				F = ht(() => (null !== k.value.max ? k.value.max : g.value || v.value ? (g.value || v.value).format(H.value) : "")),
				H = ht(() => uU(a)),
				V = ht(() => lU(a)),
				U = () => {
					(f.value = f.value.subtract(1, "year")), n.unlinkPanels || (m.value = f.value.add(1, "month")), K("year");
				},
				z = () => {
					(f.value = f.value.subtract(1, "month")), n.unlinkPanels || (m.value = f.value.add(1, "month")), K("month");
				},
				$ = () => {
					n.unlinkPanels ? (m.value = m.value.add(1, "year")) : ((f.value = f.value.add(1, "year")), (m.value = f.value.add(1, "month"))), K("year");
				},
				j = () => {
					n.unlinkPanels ? (m.value = m.value.add(1, "month")) : ((f.value = f.value.add(1, "month")), (m.value = f.value.add(1, "month"))), K("month");
				},
				W = () => {
					(f.value = f.value.add(1, "year")), K("year");
				},
				G = () => {
					(f.value = f.value.add(1, "month")), K("month");
				},
				Y = () => {
					(m.value = m.value.subtract(1, "year")), K("year");
				},
				X = () => {
					(m.value = m.value.subtract(1, "month")), K("month");
				},
				K = (e) => {
					t("panel-change", [f.value.toDate(), m.value.toDate()], e);
				},
				q = ht(() => {
					const e = (R.value + 1) % 12,
						t = R.value + 1 >= 12 ? 1 : 0;
					return n.unlinkPanels && new Date(I.value + t, e) < new Date(L.value, O.value);
				}),
				Z = ht(() => n.unlinkPanels && 12 * L.value + O.value - (12 * I.value + R.value + 1) >= 12),
				J = ht(() => !(v.value && g.value && !y.value.selecting && gW([v.value, g.value]))),
				Q = ht(() => "datetime" === n.type || "datetimerange" === n.type),
				ee = (e, t) => {
					if (e) {
						if (l) {
							return QV(l[t] || l)
								.locale(p.value)
								.year(e.year())
								.month(e.month())
								.date(e.date());
						}
						return e;
					}
				},
				te = (e, n = !0) => {
					const r = e.minDate,
						i = e.maxDate,
						s = ee(r, 0),
						o = ee(i, 1);
					(g.value === o && v.value === s) || (t("calendar-change", [r.toDate(), i && i.toDate()]), (g.value = o), (v.value = s), n && !Q.value && w());
				},
				ne = Qe(!1),
				re = Qe(!1),
				ie = () => {
					ne.value = !1;
				},
				se = () => {
					re.value = !1;
				},
				oe = (e, t) => {
					T.value[t] = e;
					const r = QV(e, V.value).locale(p.value);
					if (r.isValid()) {
						if (s && s(r.toDate())) return;
						"min" === t
							? ((f.value = r), (v.value = (v.value || f.value).year(r.year()).month(r.month()).date(r.date())), n.unlinkPanels || ((m.value = r.add(1, "month")), (g.value = v.value.add(1, "month"))))
							: ((m.value = r), (g.value = (g.value || m.value).year(r.year()).month(r.month()).date(r.date())), n.unlinkPanels || ((f.value = r.subtract(1, "month")), (v.value = g.value.subtract(1, "month"))));
					}
				},
				ae = (e, t) => {
					T.value[t] = null;
				},
				le = (e, t) => {
					k.value[t] = e;
					const n = QV(e, H.value).locale(p.value);
					n.isValid() &&
						("min" === t
							? ((ne.value = !0), (v.value = (v.value || f.value).hour(n.hour()).minute(n.minute()).second(n.second())), (g.value && !g.value.isBefore(v.value)) || (g.value = v.value))
							: ((re.value = !0), (g.value = (g.value || m.value).hour(n.hour()).minute(n.minute()).second(n.second())), (m.value = g.value), g.value && g.value.isBefore(v.value) && (v.value = g.value)));
				},
				ue = (e, t) => {
					(k.value[t] = null), "min" === t ? ((f.value = v.value), (ne.value = !1)) : ((m.value = g.value), (re.value = !1));
				},
				ce = (e, t, n) => {
					k.value.min || (e && ((f.value = e), (v.value = (v.value || f.value).hour(e.hour()).minute(e.minute()).second(e.second()))), n || (ne.value = t), (g.value && !g.value.isBefore(v.value)) || ((g.value = v.value), (m.value = e)));
				},
				he = (e, t, n) => {
					k.value.max || (e && ((m.value = e), (g.value = (g.value || m.value).hour(e.hour()).minute(e.minute()).second(e.second()))), n || (re.value = t), g.value && g.value.isBefore(v.value) && (v.value = g.value));
				},
				de = () => {
					(f.value = yW(it(d), { lang: it(p), unit: "month", unlinkPanels: n.unlinkPanels })[0]), (m.value = f.value.add(1, "month")), t("pick", null);
				};
			return (
				t("set-picker-option", ["isValidRange", gW]),
				t("set-picker-option", ["parseUserInput", (e) => (_R(e) ? e.map((e) => QV(e, a).locale(p.value)) : QV(e, a).locale(p.value))]),
				t("set-picker-option", ["formatToString", (e) => (_R(e) ? e.map((e) => e.format(a)) : e.format(a))]),
				t("set-picker-option", ["handleClear", de]),
				(e, t) => (
					Wr(),
					Kr(
						"div",
						{ class: gt([it(b).b(), it(x).b(), { "has-sidebar": e.$slots.sidebar || it(P), "has-time": it(Q) }]) },
						[
							ni(
								"div",
								{ class: gt(it(b).e("body-wrapper")) },
								[
									mi(e.$slots, "sidebar", { class: gt(it(b).e("sidebar")) }),
									it(P)
										? (Wr(),
										  Kr(
												"div",
												{ key: 0, class: gt(it(b).e("sidebar")) },
												[
													(Wr(!0),
													Kr(
														Hr,
														null,
														pi(it(h), (e, t) => (Wr(), Kr("button", { key: t, type: "button", class: gt(it(b).e("shortcut")), onClick: (t) => it(C)(e) }, bt(e.text), 11, YW))),
														128
													))
												],
												2
										  ))
										: ai("v-if", !0),
									ni(
										"div",
										{ class: gt(it(b).e("body")) },
										[
											it(Q)
												? (Wr(),
												  Kr(
														"div",
														{ key: 0, class: gt(it(x).e("time-header")) },
														[
															ni(
																"span",
																{ class: gt(it(x).e("editors-wrap")) },
																[
																	ni(
																		"span",
																		{ class: gt(it(x).e("time-picker-wrap")) },
																		[
																			ri(
																				it(WB),
																				{
																					size: "small",
																					disabled: it(y).selecting,
																					placeholder: it(E)("el.datepicker.startDate"),
																					class: gt(it(x).e("editor")),
																					"model-value": it(N),
																					onInput: t[0] || (t[0] = (e) => oe(e, "min")),
																					onChange: t[1] || (t[1] = (e) => ae(0, "min"))
																				},
																				null,
																				8,
																				["disabled", "placeholder", "class", "model-value"]
																			)
																		],
																		2
																	),
																	yr(
																		(Wr(),
																		Kr(
																			"span",
																			{ class: gt(it(x).e("time-picker-wrap")) },
																			[
																				ri(
																					it(WB),
																					{
																						size: "small",
																						class: gt(it(x).e("editor")),
																						disabled: it(y).selecting,
																						placeholder: it(E)("el.datepicker.startTime"),
																						"model-value": it(B),
																						onFocus: t[2] || (t[2] = (e) => (ne.value = !0)),
																						onInput: t[3] || (t[3] = (e) => le(e, "min")),
																						onChange: t[4] || (t[4] = (e) => ue(0, "min"))
																					},
																					null,
																					8,
																					["class", "disabled", "placeholder", "model-value"]
																				),
																				ri(it(cz), { visible: ne.value, format: it(H), "datetime-role": "start", "time-arrow-control": it(u), "parsed-value": f.value, onPick: ce }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
																			],
																			2
																		)),
																		[[it(CU), ie]]
																	)
																],
																2
															),
															ni("span", null, [ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })]),
															ni(
																"span",
																{ class: gt([it(x).e("editors-wrap"), "is-right"]) },
																[
																	ni(
																		"span",
																		{ class: gt(it(x).e("time-picker-wrap")) },
																		[
																			ri(
																				it(WB),
																				{
																					size: "small",
																					class: gt(it(x).e("editor")),
																					disabled: it(y).selecting,
																					placeholder: it(E)("el.datepicker.endDate"),
																					"model-value": it(D),
																					readonly: !it(v),
																					onInput: t[5] || (t[5] = (e) => oe(e, "max")),
																					onChange: t[6] || (t[6] = (e) => ae(0, "max"))
																				},
																				null,
																				8,
																				["class", "disabled", "placeholder", "model-value", "readonly"]
																			)
																		],
																		2
																	),
																	yr(
																		(Wr(),
																		Kr(
																			"span",
																			{ class: gt(it(x).e("time-picker-wrap")) },
																			[
																				ri(
																					it(WB),
																					{
																						size: "small",
																						class: gt(it(x).e("editor")),
																						disabled: it(y).selecting,
																						placeholder: it(E)("el.datepicker.endTime"),
																						"model-value": it(F),
																						readonly: !it(v),
																						onFocus: t[7] || (t[7] = (e) => it(v) && (re.value = !0)),
																						onInput: t[8] || (t[8] = (e) => le(e, "max")),
																						onChange: t[9] || (t[9] = (e) => ue(0, "max"))
																					},
																					null,
																					8,
																					["class", "disabled", "placeholder", "model-value", "readonly"]
																				),
																				ri(it(cz), { "datetime-role": "end", visible: re.value, format: it(H), "time-arrow-control": it(u), "parsed-value": m.value, onPick: he }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
																			],
																			2
																		)),
																		[[it(CU), se]]
																	)
																],
																2
															)
														],
														2
												  ))
												: ai("v-if", !0),
											ni(
												"div",
												{ class: gt([[it(b).e("content"), it(x).e("content")], "is-left"]) },
												[
													ni(
														"div",
														{ class: gt(it(x).e("header")) },
														[
															ni("button", { type: "button", class: gt([it(b).e("icon-btn"), "d-arrow-left"]), onClick: U }, [ri(it(OB), null, { default: cn(() => [ri(it(hO))]), _: 1 })], 2),
															ni("button", { type: "button", class: gt([it(b).e("icon-btn"), "arrow-left"]), onClick: z }, [ri(it(OB), null, { default: cn(() => [ri(it(uL))]), _: 1 })], 2),
															e.unlinkPanels
																? (Wr(), Kr("button", { key: 0, type: "button", disabled: !it(Z), class: gt([[it(b).e("icon-btn"), { "is-disabled": !it(Z) }], "d-arrow-right"]), onClick: W }, [ri(it(OB), null, { default: cn(() => [ri(it(mO))]), _: 1 })], 10, XW))
																: ai("v-if", !0),
															e.unlinkPanels
																? (Wr(), Kr("button", { key: 1, type: "button", disabled: !it(q), class: gt([[it(b).e("icon-btn"), { "is-disabled": !it(q) }], "arrow-right"]), onClick: G }, [ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })], 10, KW))
																: ai("v-if", !0),
															ni("div", null, bt(it(A)), 1)
														],
														2
													),
													ri(SW, { "selection-mode": "range", date: f.value, "min-date": it(v), "max-date": it(g), "range-state": it(y), "disabled-date": it(s), "cell-class-name": it(o), onChangerange: it(_), onPick: te, onSelect: it(S) }, null, 8, [
														"date",
														"min-date",
														"max-date",
														"range-state",
														"disabled-date",
														"cell-class-name",
														"onChangerange",
														"onSelect"
													])
												],
												2
											),
											ni(
												"div",
												{ class: gt([[it(b).e("content"), it(x).e("content")], "is-right"]) },
												[
													ni(
														"div",
														{ class: gt(it(x).e("header")) },
														[
															e.unlinkPanels
																? (Wr(), Kr("button", { key: 0, type: "button", disabled: !it(Z), class: gt([[it(b).e("icon-btn"), { "is-disabled": !it(Z) }], "d-arrow-left"]), onClick: Y }, [ri(it(OB), null, { default: cn(() => [ri(it(hO))]), _: 1 })], 10, qW))
																: ai("v-if", !0),
															e.unlinkPanels
																? (Wr(), Kr("button", { key: 1, type: "button", disabled: !it(q), class: gt([[it(b).e("icon-btn"), { "is-disabled": !it(q) }], "arrow-left"]), onClick: X }, [ri(it(OB), null, { default: cn(() => [ri(it(uL))]), _: 1 })], 10, ZW))
																: ai("v-if", !0),
															ni("button", { type: "button", class: gt([it(b).e("icon-btn"), "d-arrow-right"]), onClick: $ }, [ri(it(OB), null, { default: cn(() => [ri(it(mO))]), _: 1 })], 2),
															ni("button", { type: "button", class: gt([it(b).e("icon-btn"), "arrow-right"]), onClick: j }, [ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })], 2),
															ni("div", null, bt(it(M)), 1)
														],
														2
													),
													ri(SW, { "selection-mode": "range", date: m.value, "min-date": it(v), "max-date": it(g), "range-state": it(y), "disabled-date": it(s), "cell-class-name": it(o), onChangerange: it(_), onPick: te, onSelect: it(S) }, null, 8, [
														"date",
														"min-date",
														"max-date",
														"range-state",
														"disabled-date",
														"cell-class-name",
														"onChangerange",
														"onSelect"
													])
												],
												2
											)
										],
										2
									)
								],
								2
							),
							it(Q)
								? (Wr(),
								  Kr(
										"div",
										{ key: 0, class: gt(it(b).e("footer")) },
										[
											it(c) ? (Wr(), qr(it(qV), { key: 0, text: "", size: "small", class: gt(it(b).e("link-btn")), onClick: de }, { default: cn(() => [oi(bt(it(E)("el.datepicker.clear")), 1)]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
											ri(it(qV), { plain: "", size: "small", class: gt(it(b).e("link-btn")), disabled: it(J), onClick: t[10] || (t[10] = (e) => it(w)(!1)) }, { default: cn(() => [oi(bt(it(E)("el.datepicker.confirm")), 1)]), _: 1 }, 8, ["class", "disabled"])
										],
										2
								  ))
								: ai("v-if", !0)
						],
						2
					)
				)
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]
);
const QW = uN(u({}, pW)),
	eG = ["onClick"],
	tG = ["disabled"],
	nG = ["disabled"];
var rG = IB(
	Tn(
		c(u({}, { name: "DatePickerMonthRange" }), {
			props: QW,
			emits: ["pick", "set-picker-option"],
			setup(e, { emit: t }) {
				const n = e,
					r = "year",
					{ lang: i } = CD(),
					s = vn("EP_PICKER_BASE"),
					{ shortcuts: o, disabledDate: a, format: l } = s.props,
					u = ut(s.props, "defaultValue"),
					c = Qe(QV().locale(i.value)),
					h = Qe(QV().locale(i.value).add(1, r)),
					{
						minDate: d,
						maxDate: p,
						rangeState: f,
						ppNs: m,
						drpNs: v,
						handleChangeRange: g,
						handleRangeConfirm: y,
						handleShortcutClick: b,
						onSelect: x
					} = GW(n, {
						defaultValue: u,
						leftDate: c,
						rightDate: h,
						unit: r,
						onParsedValueChanged: function (e, t) {
							if (n.unlinkPanels && t) {
								const n = (null == e ? void 0 : e.year()) || 0,
									i = t.year();
								h.value = n === i ? t.add(1, r) : t;
							} else h.value = c.value.add(1, r);
						}
					}),
					_ = ht(() => !!o.length),
					{
						leftPrevYear: w,
						rightNextYear: C,
						leftNextYear: S,
						rightPrevYear: E,
						leftLabel: T,
						rightLabel: k,
						leftYear: A,
						rightYear: M
					} = (({ unlinkPanels: e, leftDate: t, rightDate: n }) => {
						const { t: r } = CD();
						return {
							leftPrevYear: () => {
								(t.value = t.value.subtract(1, "year")), e || (n.value = n.value.subtract(1, "year"));
							},
							rightNextYear: () => {
								e || (t.value = t.value.add(1, "year")), (n.value = n.value.add(1, "year"));
							},
							leftNextYear: () => {
								t.value = t.value.add(1, "year");
							},
							rightPrevYear: () => {
								n.value = n.value.subtract(1, "year");
							},
							leftLabel: ht(() => `${t.value.year()} ${r("el.datepicker.year")}`),
							rightLabel: ht(() => `${n.value.year()} ${r("el.datepicker.year")}`),
							leftYear: ht(() => t.value.year()),
							rightYear: ht(() => (n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year()))
						};
					})({ unlinkPanels: ut(n, "unlinkPanels"), leftDate: c, rightDate: h }),
					I = ht(() => n.unlinkPanels && M.value > A.value + 1),
					R = (e, t = !0) => {
						const n = e.minDate,
							r = e.maxDate;
						(p.value === r && d.value === n) || ((p.value = r), (d.value = n), t && y());
					};
				return (
					t("set-picker-option", ["formatToString", (e) => e.map((e) => e.format(l))]),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ class: gt([it(m).b(), it(v).b(), { "has-sidebar": Boolean(e.$slots.sidebar) || it(_) }]) },
							[
								ni(
									"div",
									{ class: gt(it(m).e("body-wrapper")) },
									[
										mi(e.$slots, "sidebar", { class: gt(it(m).e("sidebar")) }),
										it(_)
											? (Wr(),
											  Kr(
													"div",
													{ key: 0, class: gt(it(m).e("sidebar")) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(it(o), (e, t) => (Wr(), Kr("button", { key: t, type: "button", class: gt(it(m).e("shortcut")), onClick: (t) => it(b)(e) }, bt(e.text), 11, eG))),
															128
														))
													],
													2
											  ))
											: ai("v-if", !0),
										ni(
											"div",
											{ class: gt(it(m).e("body")) },
											[
												ni(
													"div",
													{ class: gt([[it(m).e("content"), it(v).e("content")], "is-left"]) },
													[
														ni(
															"div",
															{ class: gt(it(v).e("header")) },
															[
																ni("button", { type: "button", class: gt([it(m).e("icon-btn"), "d-arrow-left"]), onClick: t[0] || (t[0] = (...e) => it(w) && it(w)(...e)) }, [ri(it(OB), null, { default: cn(() => [ri(it(hO))]), _: 1 })], 2),
																e.unlinkPanels
																	? (Wr(),
																	  Kr(
																			"button",
																			{ key: 0, type: "button", disabled: !it(I), class: gt([[it(m).e("icon-btn"), { [it(m).is("disabled")]: !it(I) }], "d-arrow-right"]), onClick: t[1] || (t[1] = (...e) => it(S) && it(S)(...e)) },
																			[ri(it(OB), null, { default: cn(() => [ri(it(mO))]), _: 1 })],
																			10,
																			tG
																	  ))
																	: ai("v-if", !0),
																ni("div", null, bt(it(T)), 1)
															],
															2
														),
														ri(MW, { "selection-mode": "range", date: c.value, "min-date": it(d), "max-date": it(p), "range-state": it(f), "disabled-date": it(a), onChangerange: it(g), onPick: R, onSelect: it(x) }, null, 8, [
															"date",
															"min-date",
															"max-date",
															"range-state",
															"disabled-date",
															"onChangerange",
															"onSelect"
														])
													],
													2
												),
												ni(
													"div",
													{ class: gt([[it(m).e("content"), it(v).e("content")], "is-right"]) },
													[
														ni(
															"div",
															{ class: gt(it(v).e("header")) },
															[
																e.unlinkPanels
																	? (Wr(),
																	  Kr(
																			"button",
																			{ key: 0, type: "button", disabled: !it(I), class: gt([[it(m).e("icon-btn"), { "is-disabled": !it(I) }], "d-arrow-left"]), onClick: t[2] || (t[2] = (...e) => it(E) && it(E)(...e)) },
																			[ri(it(OB), null, { default: cn(() => [ri(it(hO))]), _: 1 })],
																			10,
																			nG
																	  ))
																	: ai("v-if", !0),
																ni("button", { type: "button", class: gt([it(m).e("icon-btn"), "d-arrow-right"]), onClick: t[3] || (t[3] = (...e) => it(C) && it(C)(...e)) }, [ri(it(OB), null, { default: cn(() => [ri(it(mO))]), _: 1 })], 2),
																ni("div", null, bt(it(k)), 1)
															],
															2
														),
														ri(MW, { "selection-mode": "range", date: h.value, "min-date": it(d), "max-date": it(p), "range-state": it(f), "disabled-date": it(a), onChangerange: it(g), onPick: R, onSelect: it(x) }, null, 8, [
															"date",
															"min-date",
															"max-date",
															"range-state",
															"disabled-date",
															"onChangerange",
															"onSelect"
														])
													],
													2
												)
											],
											2
										)
									],
									2
								)
							],
							2
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]
);
QV.extend(tU), QV.extend(Jj), QV.extend(rU), QV.extend(eW), QV.extend(nW), QV.extend(iW), QV.extend(oW), QV.extend(lW);
const iG = Tn({
	name: "ElDatePicker",
	install: null,
	props: u(u({}, fU), uW),
	emits: ["update:modelValue"],
	setup(e, { expose: t, emit: n, slots: r }) {
		const i = BD("picker-panel");
		mn("ElPopperOptions", Fe(ut(e, "popperOptions"))), mn(iD, { slots: r, pickerNs: i });
		const s = Qe();
		t({
			focus: (e = !0) => {
				var t;
				null == (t = s.value) || t.focus(e);
			}
		});
		const o = (e) => {
			n("update:modelValue", e);
		};
		return () => {
			var t;
			const n = null != (t = e.format) ? t : sU[e.type] || "YYYY-MM-DD",
				i = (function (e) {
					switch (e) {
						case "daterange":
						case "datetimerange":
							return JW;
						case "monthrange":
							return rG;
						default:
							return jW;
					}
				})(e.type);
			return ri(gU, hi(e, { format: n, type: e.type, ref: s, "onUpdate:modelValue": o }), { default: (e) => ri(i, e, null), "range-separator": r["range-separator"] });
		};
	}
});
iG.install = (e) => {
	e.component(iG.name, iG);
};
const sG = iG;
var oG = Tn({
	name: "ElDescriptionsCell",
	props: { cell: { type: Object }, tag: { type: String }, type: { type: String } },
	setup: () => ({ descriptions: vn("elDescriptions", {}) }),
	render() {
		var e, t, n, r, i, s;
		const o = ((e) => {
				if (!Zr(e)) return {};
				const t = e.props || {},
					n = (Zr(e.type) ? e.type.props : void 0) || {},
					r = {};
				return (
					Object.keys(n).forEach((e) => {
						xR(n[e], "default") && (r[e] = n[e].default);
					}),
					Object.keys(t).forEach((e) => {
						r[Wt(e)] = t[e];
					}),
					r
				);
			})(this.cell),
			{ border: a, direction: l } = this.descriptions,
			u = "vertical" === l,
			c = (null == (n = null == (t = null == (e = this.cell) ? void 0 : e.children) ? void 0 : t.label) ? void 0 : n.call(t)) || o.label,
			h = null == (s = null == (i = null == (r = this.cell) ? void 0 : r.children) ? void 0 : i.default) ? void 0 : s.call(i),
			d = o.span,
			p = o.align ? `is-${o.align}` : "",
			f = o.labelAlign ? `is-${o.labelAlign}` : p,
			m = o.className,
			v = o.labelClassName,
			g = { width: KR(o.width), minWidth: KR(o.minWidth) },
			y = BD("descriptions");
		switch (this.type) {
			case "label":
				return xs(this.tag, { style: g, class: [y.e("cell"), y.e("label"), y.is("bordered-label", a), y.is("vertical-label", u), f, v], colSpan: u ? d : 1 }, c);
			case "content":
				return xs(this.tag, { style: g, class: [y.e("cell"), y.e("content"), y.is("bordered-content", a), y.is("vertical-content", u), p, m], colSpan: u ? d : 2 * d - 1 }, h);
			default:
				return xs("td", { style: g, class: [y.e("cell"), p], colSpan: d }, [xs("span", { class: [y.e("label"), v] }, c), xs("span", { class: [y.e("content"), m] }, h)]);
		}
	}
});
const aG = Tn({ name: "ElDescriptionsRow", components: { [oG.name]: oG }, props: { row: { type: Array } }, setup: () => ({ descriptions: vn("elDescriptions", {}) }) }),
	lG = { key: 1 };
var uG = IB(aG, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-descriptions-cell");
			return "vertical" === e.descriptions.direction
				? (Wr(),
				  Kr(
						Hr,
						{ key: 0 },
						[
							ni("tr", null, [
								(Wr(!0),
								Kr(
									Hr,
									null,
									pi(e.row, (e, t) => (Wr(), qr(o, { key: `tr1-${t}`, cell: e, tag: "th", type: "label" }, null, 8, ["cell"]))),
									128
								))
							]),
							ni("tr", null, [
								(Wr(!0),
								Kr(
									Hr,
									null,
									pi(e.row, (e, t) => (Wr(), qr(o, { key: `tr2-${t}`, cell: e, tag: "td", type: "content" }, null, 8, ["cell"]))),
									128
								))
							])
						],
						64
				  ))
				: (Wr(),
				  Kr("tr", lG, [
						(Wr(!0),
						Kr(
							Hr,
							null,
							pi(
								e.row,
								(t, n) => (
									Wr(),
									Kr(
										Hr,
										{ key: `tr3-${n}` },
										[
											e.descriptions.border
												? (Wr(), Kr(Hr, { key: 0 }, [ri(o, { cell: t, tag: "td", type: "label" }, null, 8, ["cell"]), ri(o, { cell: t, tag: "td", type: "content" }, null, 8, ["cell"])], 64))
												: (Wr(), qr(o, { key: 1, cell: t, tag: "td", type: "both" }, null, 8, ["cell"]))
										],
										64
									)
								)
							),
							128
						))
				  ]));
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]
]);
var cG = IB(
		Tn({
			name: "ElDescriptions",
			components: { [uG.name]: uG },
			props: { border: { type: Boolean, default: !1 }, column: { type: Number, default: 3 }, direction: { type: String, default: "horizontal" }, size: { type: String, validator: EN }, title: { type: String, default: "" }, extra: { type: String, default: "" } },
			setup(e, { slots: t }) {
				mn("elDescriptions", e);
				const n = hD(),
					r = BD("descriptions"),
					i = ht(() => [r.b(), r.m(n.value)]),
					s = (e) => {
						const t = Array.isArray(e) ? e : [e],
							n = [];
						return (
							t.forEach((e) => {
								Array.isArray(e.children) ? n.push(...s(e.children)) : n.push(e);
							}),
							n
						);
					},
					o = (e, t, n, r = !1) => (e.props || (e.props = {}), t > n && (e.props.span = n), r && (e.props.span = t), e);
				return {
					descriptionKls: i,
					getRows: () => {
						var n;
						const r = s(null == (n = t.default) ? void 0 : n.call(t)).filter((e) => {
								var t;
								return "ElDescriptionsItem" === (null == (t = null == e ? void 0 : e.type) ? void 0 : t.name);
							}),
							i = [];
						let a = [],
							l = e.column,
							u = 0;
						return (
							r.forEach((t, n) => {
								var s;
								const c = (null == (s = t.props) ? void 0 : s.span) || 1;
								if ((n < r.length - 1 && (u += c > l ? l : c), n === r.length - 1)) {
									const n = e.column - (u % e.column);
									return a.push(o(t, n, l, !0)), void i.push(a);
								}
								c < l ? ((l -= c), a.push(t)) : (a.push(o(t, c, l)), i.push(a), (l = e.column), (a = []));
							}),
							i
						);
					},
					ns: r
				};
			}
		}),
		[
			[
				"render",
				function (e, t, n, r, i, s) {
					const o = Or("el-descriptions-row");
					return (
						Wr(),
						Kr(
							"div",
							{ class: gt(e.descriptionKls) },
							[
								e.title || e.extra || e.$slots.title || e.$slots.extra
									? (Wr(),
									  Kr("div", { key: 0, class: gt(e.ns.e("header")) }, [ni("div", { class: gt(e.ns.e("title")) }, [mi(e.$slots, "title", {}, () => [oi(bt(e.title), 1)])], 2), ni("div", { class: gt(e.ns.e("extra")) }, [mi(e.$slots, "extra", {}, () => [oi(bt(e.extra), 1)])], 2)], 2))
									: ai("v-if", !0),
								ni(
									"div",
									{ class: gt(e.ns.e("body")) },
									[
										ni(
											"table",
											{ class: gt([e.ns.e("table"), e.ns.is("bordered", e.border)]) },
											[
												ni("tbody", null, [
													(Wr(!0),
													Kr(
														Hr,
														null,
														pi(e.getRows(), (e, t) => (Wr(), qr(o, { key: t, row: e }, null, 8, ["row"]))),
														128
													))
												])
											],
											2
										)
									],
									2
								)
							],
							2
						)
					);
				}
			],
			["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/index.vue"]
		]
	),
	hG = Tn({
		name: "ElDescriptionsItem",
		props: {
			label: { type: String, default: "" },
			span: { type: Number, default: 1 },
			width: { type: [String, Number], default: "" },
			minWidth: { type: [String, Number], default: "" },
			align: { type: String, default: "left" },
			labelAlign: { type: String, default: "" },
			className: { type: String, default: "" },
			labelClassName: { type: String, default: "" }
		}
	});
const dG = mN(cG, { DescriptionsItem: hG }),
	pG = gN(hG);
const fG = Tn({
		name: "ElOverlay",
		props: uN({ mask: { type: Boolean, default: !0 }, customMaskEvent: { type: Boolean, default: !1 }, overlayClass: { type: [String, Array, Object] }, zIndex: { type: [String, Number] } }),
		emits: { click: (e) => e instanceof MouseEvent },
		setup(e, { slots: t, emit: n }) {
			const r = BD("overlay"),
				{
					onClick: i,
					onMousedown: s,
					onMouseup: o
				} = kD(
					e.customMaskEvent
						? void 0
						: (e) => {
								n("click", e);
						  }
				);
			return () =>
				e.mask
					? ri("div", { class: [r.b(), e.overlayClass], style: { zIndex: e.zIndex }, onClick: i, onMousedown: s, onMouseup: o }, [mi(t, "default")], TN.STYLE | TN.CLASS | TN.PROPS, ["onClick", "onMouseup", "onMousedown"])
					: xs("div", { class: e.overlayClass, style: { zIndex: e.zIndex, position: "fixed", top: "0px", right: "0px", bottom: "0px", left: "0px" } }, [mi(t, "default")]);
		}
	}),
	mG = uN({
		center: { type: Boolean, default: !1 },
		closeIcon: { type: cN, default: "" },
		customClass: { type: String, default: "" },
		draggable: { type: Boolean, default: !1 },
		fullscreen: { type: Boolean, default: !1 },
		showClose: { type: Boolean, default: !0 },
		title: { type: String, default: "" }
	}),
	vG = ["aria-label"],
	gG = ["id"];
var yG = IB(
	Tn(
		c(u({}, { name: "ElDialogContent" }), {
			props: mG,
			emits: { close: () => !0 },
			setup(e) {
				const t = e,
					{ t: n } = CD(),
					{ Close: r } = hN,
					{ dialogRef: i, headerRef: s, bodyId: o, ns: a, style: l } = vn(WN),
					{ focusTrapRef: u } = vn(RH),
					c = yN(u, i),
					h = ht(() => t.draggable);
				return (
					fD(i, s, h),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ ref: it(c), class: gt([it(a).b(), it(a).is("fullscreen", e.fullscreen), it(a).is("draggable", it(h)), { [it(a).m("center")]: e.center }, e.customClass]), style: pt(it(l)), tabindex: "-1", onClick: t[1] || (t[1] = zo(() => {}, ["stop"])) },
							[
								ni(
									"header",
									{ ref_key: "headerRef", ref: s, class: gt(it(a).e("header")) },
									[
										mi(e.$slots, "header", {}, () => [ni("span", { role: "heading", class: gt(it(a).e("title")) }, bt(e.title), 3)]),
										e.showClose
											? (Wr(),
											  Kr(
													"button",
													{ key: 0, "aria-label": it(n)("el.dialog.close"), class: gt(it(a).e("headerbtn")), type: "button", onClick: t[0] || (t[0] = (t) => e.$emit("close")) },
													[ri(it(OB), { class: gt(it(a).e("close")) }, { default: cn(() => [(Wr(), qr(Nr(e.closeIcon || it(r))))]), _: 1 }, 8, ["class"])],
													10,
													vG
											  ))
											: ai("v-if", !0)
									],
									2
								),
								ni("div", { id: it(o), class: gt(it(a).e("body")) }, [mi(e.$slots, "default")], 10, gG),
								e.$slots.footer ? (Wr(), Kr("footer", { key: 0, class: gt(it(a).e("footer")) }, [mi(e.$slots, "footer")], 2)) : ai("v-if", !0)
							],
							6
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]
);
const bG = uN(
		c(u({}, mG), {
			appendToBody: { type: Boolean, default: !1 },
			beforeClose: { type: Function },
			destroyOnClose: { type: Boolean, default: !1 },
			closeOnClickModal: { type: Boolean, default: !0 },
			closeOnPressEscape: { type: Boolean, default: !0 },
			lockScroll: { type: Boolean, default: !0 },
			modal: { type: Boolean, default: !0 },
			openDelay: { type: Number, default: 0 },
			closeDelay: { type: Number, default: 0 },
			top: { type: String },
			modelValue: { type: Boolean, required: !0 },
			modalClass: String,
			width: { type: [String, Number] },
			zIndex: { type: Number },
			trapFocus: { type: Boolean, default: !1 }
		})
	),
	xG = { open: () => !0, opened: () => !0, close: () => !0, closed: () => !0, [_N]: (e) => YI(e), openAutoFocus: () => !0, closeAutoFocus: () => !0 },
	_G = (e, t) => {
		const n = Si().emit,
			{ nextZIndex: r } = HD();
		let i = "";
		const s = gD(),
			o = gD(),
			a = Qe(!1),
			l = Qe(!1),
			u = Qe(!1),
			c = Qe(e.zIndex || r());
		let h, d;
		const p = ht(() => (XI(e.width) ? `${e.width}px` : e.width)),
			f = aD("namespace", "el"),
			m = ht(() => {
				const t = {},
					n = `--${f.value}-dialog`;
				return e.fullscreen || (e.top && (t[`${n}-margin-top`] = e.top), e.width && (t[`${n}-width`] = p.value)), t;
			});
		function v() {
			null == d || d(), null == h || h(), e.openDelay && e.openDelay > 0 ? ({ stop: h } = eR(() => b(), e.openDelay)) : b();
		}
		function g() {
			null == h || h(), null == d || d(), e.closeDelay && e.closeDelay > 0 ? ({ stop: d } = eR(() => x(), e.closeDelay)) : x();
		}
		function y() {
			e.beforeClose
				? e.beforeClose(function (e) {
						e || ((l.value = !0), (a.value = !1));
				  })
				: g();
		}
		function b() {
			GI && (a.value = !0);
		}
		function x() {
			a.value = !1;
		}
		return (
			e.lockScroll && SD(a),
			ds(
				() => e.modelValue,
				(i) => {
					i
						? ((l.value = !1),
						  v(),
						  (u.value = !0),
						  n("open"),
						  (c.value = e.zIndex ? c.value++ : r()),
						  ns(() => {
								t.value && (t.value.scrollTop = 0);
						  }))
						: a.value && g();
				}
			),
			ds(
				() => e.fullscreen,
				(e) => {
					t.value && (e ? ((i = t.value.style.transform), (t.value.style.transform = "")) : (t.value.style.transform = i));
				}
			),
			Vn(() => {
				e.modelValue && ((a.value = !0), (u.value = !0), v());
			}),
			{
				afterEnter: function () {
					n("opened");
				},
				afterLeave: function () {
					n("closed"), n(_N, !1), e.destroyOnClose && (u.value = !1);
				},
				beforeLeave: function () {
					n("close");
				},
				handleClose: y,
				onModalClick: function () {
					e.closeOnClickModal && y();
				},
				close: g,
				doClose: x,
				onOpenAutoFocus: function () {
					n("openAutoFocus");
				},
				onCloseAutoFocus: function () {
					n("closeAutoFocus");
				},
				onCloseRequested: function () {
					e.closeOnPressEscape && y();
				},
				titleId: s,
				bodyId: o,
				closed: l,
				style: m,
				rendered: u,
				visible: a,
				zIndex: c
			}
		);
	},
	wG = ["aria-label", "aria-labelledby", "aria-describedby"];
const CG = mN(
		IB(
			Tn(
				c(u({}, { name: "ElDialog" }), {
					props: bG,
					emits: xG,
					setup(e, { expose: t }) {
						const n = e,
							r = gs();
						pD(
							{ scope: "el-dialog", from: "the title slot", replacement: "the header slot", version: "3.0.0", ref: "https://element-plus.org/en-US/component/dialog.html#slots" },
							ht(() => !!r.title)
						);
						const i = BD("dialog"),
							s = Qe(),
							o = Qe(),
							a = Qe(),
							{ visible: l, titleId: u, bodyId: c, style: h, rendered: d, zIndex: p, afterEnter: f, afterLeave: m, beforeLeave: v, handleClose: g, onModalClick: y, onOpenAutoFocus: b, onCloseAutoFocus: x, onCloseRequested: _ } = _G(n, s);
						mn(WN, { dialogRef: s, headerRef: o, bodyId: c, ns: i, rendered: d, style: h });
						const w = kD(y),
							C = ht(() => n.draggable && !n.fullscreen);
						return (
							t({ visible: l, dialogContentRef: a }),
							(e, t) => (
								Wr(),
								qr(
									Lr,
									{ to: "body", disabled: !e.appendToBody },
									[
										ri(
											lo,
											{ name: "dialog-fade", onAfterEnter: it(f), onAfterLeave: it(m), onBeforeLeave: it(v), persisted: "" },
											{
												default: cn(() => [
													yr(
														ri(
															it(fG),
															{ "custom-mask-event": "", mask: e.modal, "overlay-class": e.modalClass, "z-index": it(p) },
															{
																default: cn(() => [
																	ni(
																		"div",
																		{
																			role: "dialog",
																			"aria-modal": "true",
																			"aria-label": e.title || void 0,
																			"aria-labelledby": e.title ? void 0 : it(u),
																			"aria-describedby": it(c),
																			class: gt(`${it(i).namespace.value}-overlay-dialog`),
																			onClick: t[0] || (t[0] = (...e) => it(w).onClick && it(w).onClick(...e)),
																			onMousedown: t[1] || (t[1] = (...e) => it(w).onMousedown && it(w).onMousedown(...e)),
																			onMouseup: t[2] || (t[2] = (...e) => it(w).onMouseup && it(w).onMouseup(...e))
																		},
																		[
																			ri(
																				it(LH),
																				{ loop: "", trapped: it(l), "focus-start-el": "container", onFocusAfterTrapped: it(b), onFocusAfterReleased: it(x), onReleaseRequested: it(_) },
																				{
																					default: cn(() => [
																						it(d)
																							? (Wr(),
																							  qr(
																									yG,
																									{
																										key: 0,
																										ref_key: "dialogContentRef",
																										ref: a,
																										"custom-class": e.customClass,
																										center: e.center,
																										"close-icon": e.closeIcon,
																										draggable: it(C),
																										fullscreen: e.fullscreen,
																										"show-close": e.showClose,
																										style: pt(it(h)),
																										title: e.title,
																										onClose: it(g)
																									},
																									fi(
																										{
																											header: cn(() => [e.$slots.title ? mi(e.$slots, "title", { key: 1 }) : mi(e.$slots, "header", { key: 0, close: it(g), titleId: it(u), titleClass: it(i).e("title") })]),
																											default: cn(() => [mi(e.$slots, "default")]),
																											_: 2
																										},
																										[e.$slots.footer ? { name: "footer", fn: cn(() => [mi(e.$slots, "footer")]) } : void 0]
																									),
																									1032,
																									["custom-class", "center", "close-icon", "draggable", "fullscreen", "show-close", "style", "title", "onClose"]
																							  ))
																							: ai("v-if", !0)
																					]),
																					_: 3
																				},
																				8,
																				["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onReleaseRequested"]
																			)
																		],
																		42,
																		wG
																	)
																]),
																_: 3
															},
															8,
															["mask", "overlay-class", "z-index"]
														),
														[[Wo, it(l)]]
													)
												]),
												_: 3
											},
											8,
											["onAfterEnter", "onAfterLeave", "onBeforeLeave"]
										)
									],
									8,
									["disabled"]
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]
		)
	),
	SG = uN({ direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" }, contentPosition: { type: String, values: ["left", "center", "right"], default: "center" }, borderStyle: { type: String, default: "solid" } });
const EG = mN(
		IB(
			Tn(
				c(u({}, { name: "ElDivider" }), {
					props: SG,
					setup(e) {
						const t = e,
							n = BD("divider"),
							r = ht(() => n.cssVar({ "border-style": t.borderStyle }));
						return (e, t) => (
							Wr(),
							Kr(
								"div",
								{ class: gt([it(n).b(), it(n).m(e.direction)]), style: pt(it(r)), role: "separator" },
								[e.$slots.default && "vertical" !== e.direction ? (Wr(), Kr("div", { key: 0, class: gt([it(n).e("text"), it(n).is(e.contentPosition)]) }, [mi(e.$slots, "default")], 2)) : ai("v-if", !0)],
								6
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]
		)
	),
	TG = uN(c(u({}, bG), { direction: { type: String, default: "rtl", values: ["ltr", "rtl", "ttb", "btt"] }, size: { type: [String, Number], default: "30%" }, withHeader: { type: Boolean, default: !0 }, modalFade: { type: Boolean, default: !0 } })),
	kG = Tn({
		name: "ElDrawer",
		components: { ElOverlay: fG, ElFocusTrap: LH, ElIcon: OB, Close: aO },
		props: TG,
		emits: xG,
		setup(e, { slots: t }) {
			pD(
				{ scope: "el-drawer", from: "the title slot", replacement: "the header slot", version: "3.0.0", ref: "https://element-plus.org/en-US/component/drawer.html#slots" },
				ht(() => !!t.title)
			);
			const n = Qe(),
				r = Qe(),
				i = BD("drawer"),
				{ t: s } = CD(),
				o = ht(() => "rtl" === e.direction || "ltr" === e.direction),
				a = ht(() => ("number" == typeof e.size ? `${e.size}px` : e.size));
			return c(u({}, _G(e, n)), { drawerRef: n, focusStartRef: r, isHorizontal: o, drawerSize: a, ns: i, t: s });
		}
	}),
	AG = ["aria-label", "aria-labelledby", "aria-describedby"],
	MG = ["id"],
	IG = ["aria-label"],
	RG = ["id"];
const LG = mN(
	IB(kG, [
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("close"),
					a = Or("el-icon"),
					l = Or("el-focus-trap"),
					u = Or("el-overlay");
				return (
					Wr(),
					qr(
						Lr,
						{ to: "body", disabled: !e.appendToBody },
						[
							ri(
								lo,
								{ name: e.ns.b("fade"), onAfterEnter: e.afterEnter, onAfterLeave: e.afterLeave, onBeforeLeave: e.beforeLeave, persisted: "" },
								{
									default: cn(() => [
										yr(
											ri(
												u,
												{ mask: e.modal, "overlay-class": e.modalClass, "z-index": e.zIndex, onClick: e.onModalClick },
												{
													default: cn(() => [
														ri(
															l,
															{ loop: "", trapped: e.visible, "focus-trap-el": e.drawerRef, "focus-start-el": e.focusStartRef, onReleaseRequested: e.onCloseRequested },
															{
																default: cn(() => [
																	ni(
																		"div",
																		{
																			ref: "drawerRef",
																			"aria-modal": "true",
																			"aria-label": e.title || void 0,
																			"aria-labelledby": e.title ? void 0 : e.titleId,
																			"aria-describedby": e.bodyId,
																			class: gt([e.ns.b(), e.direction, e.visible && "open", e.customClass]),
																			style: pt(e.isHorizontal ? "width: " + e.drawerSize : "height: " + e.drawerSize),
																			role: "dialog",
																			onClick: t[1] || (t[1] = zo(() => {}, ["stop"]))
																		},
																		[
																			ni("span", { ref: "focusStartRef", class: gt(e.ns.e("sr-focus")), tabindex: "-1" }, null, 2),
																			e.withHeader
																				? (Wr(),
																				  Kr(
																						"header",
																						{ key: 0, class: gt(e.ns.e("header")) },
																						[
																							e.$slots.title
																								? mi(e.$slots, "title", { key: 1 }, () => [ai(" DEPRECATED SLOT ")])
																								: mi(e.$slots, "header", { key: 0, close: e.handleClose, titleId: e.titleId, titleClass: e.ns.e("title") }, () => [
																										e.$slots.title ? ai("v-if", !0) : (Wr(), Kr("span", { key: 0, id: e.titleId, role: "heading", class: gt(e.ns.e("title")) }, bt(e.title), 11, MG))
																								  ]),
																							e.showClose
																								? (Wr(),
																								  Kr(
																										"button",
																										{ key: 2, "aria-label": e.t("el.drawer.close"), class: gt(e.ns.e("close-btn")), type: "button", onClick: t[0] || (t[0] = (...t) => e.handleClose && e.handleClose(...t)) },
																										[ri(a, { class: gt(e.ns.e("close")) }, { default: cn(() => [ri(o)]), _: 1 }, 8, ["class"])],
																										10,
																										IG
																								  ))
																								: ai("v-if", !0)
																						],
																						2
																				  ))
																				: ai("v-if", !0),
																			e.rendered ? (Wr(), Kr("div", { key: 1, id: e.bodyId, class: gt(e.ns.e("body")) }, [mi(e.$slots, "default")], 10, RG)) : ai("v-if", !0),
																			e.$slots.footer ? (Wr(), Kr("div", { key: 2, class: gt(e.ns.e("footer")) }, [mi(e.$slots, "footer")], 2)) : ai("v-if", !0)
																		],
																		14,
																		AG
																	)
																]),
																_: 3
															},
															8,
															["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"]
														)
													]),
													_: 3
												},
												8,
												["mask", "overlay-class", "z-index", "onClick"]
											),
											[[Wo, e.visible]]
										)
									]),
									_: 3
								},
								8,
								["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"]
							)
						],
						8,
						["disabled"]
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]
	])
);
var OG = IB({ inheritAttrs: !1 }, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return mi(e.$slots, "default");
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]
]);
var PG = IB({ name: "ElCollectionItem", inheritAttrs: !1 }, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return mi(e.$slots, "default");
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]
]);
const NG = (e) => {
		const t = `El${e}Collection`,
			n = `${t}Item`,
			r = Symbol(t),
			i = Symbol(n),
			s = c(u({}, OG), {
				name: t,
				setup() {
					const e = Qe(null),
						t = new Map();
					mn(r, {
						itemMap: t,
						getItems: () => {
							const n = it(e);
							if (!n) return [];
							const r = Array.from(n.querySelectorAll("[data-el-collection-item]"));
							return [...t.values()].sort((e, t) => r.indexOf(e.ref) - r.indexOf(t.ref));
						},
						collectionRef: e
					});
				}
			}),
			o = c(u({}, PG), {
				name: n,
				setup(e, { attrs: t }) {
					const n = Qe(null),
						s = vn(r, void 0);
					mn(i, { collectionItemRef: n }),
						Vn(() => {
							const e = it(n);
							e && s.itemMap.set(e, u({ ref: e }, t));
						}),
						$n(() => {
							const e = it(n);
							s.itemMap.delete(e);
						});
				}
			});
		return { COLLECTION_INJECTION_KEY: r, COLLECTION_ITEM_INJECTION_KEY: i, ElCollection: s, ElCollectionItem: o };
	},
	DG = uN({ style: { type: [String, Array, Object] }, currentTabId: { type: String }, defaultCurrentTabId: String, loop: Boolean, dir: { type: String, values: ["ltr", "rtl"], default: "ltr" }, orientation: { type: String }, onBlur: Function, onFocus: Function, onMousedown: Function }),
	{ ElCollection: BG, ElCollectionItem: FG, COLLECTION_INJECTION_KEY: HG, COLLECTION_ITEM_INJECTION_KEY: VG } = NG("RovingFocusGroup"),
	UG = Symbol("elRovingFocusGroup"),
	zG = Symbol("elRovingFocusGroupItem"),
	$G = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" },
	jG = (e, t, n) => {
		const r = ((e, t) => {
			if ("rtl" !== t) return e;
			switch (e) {
				case bN.right:
					return bN.left;
				case bN.left:
					return bN.right;
				default:
					return e;
			}
		})(e.key, n);
		if (!(("vertical" === t && [bN.left, bN.right].includes(r)) || ("horizontal" === t && [bN.up, bN.down].includes(r)))) return $G[r];
	},
	WG = (e) => {
		const { activeElement: t } = document;
		for (const n of e) {
			if (n === t) return;
			if ((n.focus(), t !== document.activeElement)) return;
		}
	},
	GG = { bubbles: !1, cancelable: !0 },
	YG = Tn({
		name: "ElRovingFocusGroupImpl",
		inheritAttrs: !1,
		props: DG,
		emits: ["currentTabIdChange", "entryFocus"],
		setup(e, { emit: t }) {
			var n;
			const r = Qe(null != (n = e.currentTabId || e.defaultCurrentTabId) ? n : null),
				i = Qe(!1),
				s = Qe(!1),
				o = Qe(null),
				{ getItems: a } = vn(HG, void 0),
				l = ht(() => [{ outline: "none" }, e.style]),
				u = PI(
					(t) => {
						var n;
						null == (n = e.onMousedown) || n.call(e, t);
					},
					() => {
						s.value = !0;
					}
				),
				c = PI(
					(t) => {
						var n;
						null == (n = e.onFocus) || n.call(e, t);
					},
					(e) => {
						const t = !it(s),
							{ target: n, currentTarget: o } = e;
						if (n === o && t && !it(i)) {
							const e = new Event("rovingFocusGroup.entryFocus", GG);
							if ((null == o || o.dispatchEvent(e), !e.defaultPrevented)) {
								const e = a().filter((e) => e.focusable),
									t = [e.find((e) => e.active), e.find((e) => e.id === it(r)), ...e].filter(Boolean).map((e) => e.ref);
								WG(t);
							}
						}
						s.value = !1;
					}
				),
				h = PI(
					(t) => {
						var n;
						null == (n = e.onBlur) || n.call(e, t);
					},
					() => {
						i.value = !1;
					}
				),
				d = (...e) => {
					t("entryFocus", ...e);
				};
			mn(UG, {
				currentTabbedId: Ve(r),
				loop: ut(e, "loop"),
				tabIndex: ht(() => (it(i) ? -1 : 0)),
				rovingFocusGroupRef: o,
				rovingFocusGroupRootStyle: l,
				orientation: ut(e, "orientation"),
				dir: ut(e, "dir"),
				onItemFocus: (e) => {
					t("currentTabIdChange", e);
				},
				onItemShiftTab: () => {
					i.value = !0;
				},
				onBlur: h,
				onFocus: c,
				onMousedown: u
			}),
				ds(
					() => e.currentTabId,
					(e) => {
						r.value = null != e ? e : null;
					}
				),
				Vn(() => {
					const e = it(o);
					RI(e, "rovingFocusGroup.entryFocus", d);
				}),
				$n(() => {
					const e = it(o);
					LI(e, "rovingFocusGroup.entryFocus", d);
				});
		}
	});
var XG = IB(
	Tn({
		name: "ElRovingFocusGroup",
		components: {
			ElFocusGroupCollection: BG,
			ElRovingFocusGroupImpl: IB(YG, [
				[
					"render",
					function (e, t, n, r, i, s) {
						return mi(e.$slots, "default");
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]
			])
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-roving-focus-group-impl"),
					a = Or("el-focus-group-collection");
				return Wr(), qr(a, null, { default: cn(() => [ri(o, yt(ii(e.$attrs)), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16)]), _: 3 });
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]
	]
);
var KG = IB(
	Tn({
		components: { ElRovingFocusCollectionItem: FG },
		props: { focusable: { type: Boolean, default: !0 }, active: { type: Boolean, default: !1 } },
		emits: ["mousedown", "focus", "keydown"],
		setup(e, { emit: t }) {
			const { currentTabbedId: n, loop: r, onItemFocus: i, onItemShiftTab: s } = vn(UG, void 0),
				{ getItems: o } = vn(HG, void 0),
				a = gD(),
				l = Qe(null),
				u = PI(
					(e) => {
						t("mousedown", e);
					},
					(t) => {
						e.focusable ? i(it(a)) : t.preventDefault();
					}
				),
				c = PI(
					(e) => {
						t("focus", e);
					},
					() => {
						i(it(a));
					}
				),
				h = PI(
					(e) => {
						t("keydown", e);
					},
					(e) => {
						const { key: t, shiftKey: n, target: i, currentTarget: a } = e;
						if (t === bN.tab && n) return void s();
						if (i !== a) return;
						const l = jG(e);
						if (l) {
							e.preventDefault();
							let t = o()
								.filter((e) => e.focusable)
								.map((e) => e.ref);
							switch (l) {
								case "last":
									t.reverse();
									break;
								case "prev":
								case "next": {
									"prev" === l && t.reverse();
									const e = t.indexOf(a);
									t = r.value ? ((c = e + 1), (u = t).map((e, t) => u[(t + c) % u.length])) : t.slice(e + 1);
									break;
								}
							}
							ns(() => {
								WG(t);
							});
						}
						var u, c;
					}
				),
				d = ht(() => n.value === it(a));
			return mn(zG, { rovingFocusGroupItemRef: l, tabIndex: ht(() => (it(d) ? 0 : -1)), handleMousedown: u, handleFocus: c, handleKeydown: h }), { id: a, handleKeydown: h, handleFocus: c, handleMousedown: u };
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-roving-focus-collection-item");
				return Wr(), qr(o, { id: e.id, focusable: e.focusable, active: e.active }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["id", "focusable", "active"]);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]
	]
);
const qG = uN({
		trigger: UH.trigger,
		effect: c(u({}, VH.effect), { default: "light" }),
		type: { type: String },
		placement: { type: String, default: "bottom" },
		popperOptions: { type: Object, default: () => ({}) },
		id: String,
		size: { type: String, default: "" },
		splitButton: Boolean,
		hideOnClick: { type: Boolean, default: !0 },
		loop: { type: Boolean, default: !0 },
		showTimeout: { type: Number, default: 150 },
		hideTimeout: { type: Number, default: 150 },
		tabindex: { type: [Number, String], default: 0 },
		maxHeight: { type: [Number, String], default: "" },
		popperClass: { type: String, default: "" },
		disabled: { type: Boolean, default: !1 },
		role: { type: String, default: "menu" },
		buttonProps: { type: Object }
	}),
	ZG = uN({ command: { type: [Object, String, Number], default: () => ({}) }, disabled: Boolean, divided: Boolean, textValue: String, icon: { type: cN } }),
	JG = uN({ onKeydown: { type: Function } }),
	QG = [bN.down, bN.pageDown, bN.home],
	eY = [bN.up, bN.pageUp, bN.end],
	tY = [...QG, ...eY],
	{ ElCollection: nY, ElCollectionItem: rY, COLLECTION_INJECTION_KEY: iY, COLLECTION_ITEM_INJECTION_KEY: sY } = NG("Dropdown"),
	oY = Symbol("elDropdown"),
	{ ButtonGroup: aY } = qV;
var lY = IB(
	Tn({
		name: "ElDropdown",
		components: { ElButton: qV, ElButtonGroup: aY, ElScrollbar: ZB, ElDropdownCollection: nY, ElTooltip: QH, ElRovingFocusGroup: XG, ElOnlyChild: rF, ElIcon: OB, ArrowDown: sL },
		props: qG,
		emits: ["visible-change", "click", "command"],
		setup(e, { emit: t }) {
			const n = Si(),
				r = BD("dropdown"),
				{ t: i } = CD(),
				s = Qe(),
				o = Qe(),
				a = Qe(null),
				l = Qe(null),
				u = Qe(null),
				c = Qe(null),
				h = Qe(!1),
				d = [bN.enter, bN.space, bN.down],
				p = ht(() => ({ maxHeight: KR(e.maxHeight) })),
				f = ht(() => [r.m(y.value)]),
				m = gD().value,
				v = ht(() => e.id || m);
			function g() {
				var e;
				null == (e = a.value) || e.onClose();
			}
			const y = hD();
			mn(oY, {
				contentRef: l,
				role: ht(() => e.role),
				triggerId: v,
				isUsingKeyboard: h,
				onItemEnter: function () {},
				onItemLeave: function () {
					const e = it(l);
					null == e || e.focus(), (c.value = null);
				}
			}),
				mn("elDropdown", {
					instance: n,
					dropdownSize: y,
					handleClick: function () {
						g();
					},
					commandHandler: function (...e) {
						t("command", ...e);
					},
					trigger: ut(e, "trigger"),
					hideOnClick: ut(e, "hideOnClick")
				});
			return {
				t: i,
				ns: r,
				scrollbar: u,
				wrapStyle: p,
				dropdownTriggerKls: f,
				dropdownSize: y,
				triggerId: v,
				triggerKeys: d,
				currentTabId: c,
				handleCurrentTabIdChange: function (e) {
					c.value = e;
				},
				handlerMainButtonClick: (e) => {
					t("click", e);
				},
				handleEntryFocus: function (e) {
					h.value || (e.preventDefault(), e.stopImmediatePropagation());
				},
				handleClose: g,
				handleOpen: function () {
					var e;
					null == (e = a.value) || e.onOpen();
				},
				handleShowTooltip: function (e) {
					"keydown" === (null == e ? void 0 : e.type) && l.value.focus(), t("visible-change", !0);
				},
				handleHideTooltip: function () {
					t("visible-change", !1);
				},
				onFocusAfterTrapped: (e) => {
					var t, n;
					e.preventDefault(), null == (n = null == (t = l.value) ? void 0 : t.focus) || n.call(t, { preventScroll: !0 });
				},
				popperRef: a,
				contentRef: l,
				triggeringElementRef: s,
				referenceElementRef: o
			};
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				var o;
				const a = Or("el-dropdown-collection"),
					l = Or("el-roving-focus-group"),
					u = Or("el-scrollbar"),
					c = Or("el-only-child"),
					h = Or("el-tooltip"),
					d = Or("el-button"),
					p = Or("arrow-down"),
					f = Or("el-icon"),
					m = Or("el-button-group");
				return (
					Wr(),
					Kr(
						"div",
						{ class: gt([e.ns.b(), e.ns.is("disabled", e.disabled)]) },
						[
							ri(
								h,
								{
									ref: "popperRef",
									role: e.role,
									effect: e.effect,
									"fallback-placements": ["bottom", "top"],
									"popper-options": e.popperOptions,
									"gpu-acceleration": !1,
									"hide-after": "hover" === e.trigger ? e.hideTimeout : 0,
									"manual-mode": !0,
									placement: e.placement,
									"popper-class": [e.ns.e("popper"), e.popperClass],
									"reference-element": null == (o = e.referenceElementRef) ? void 0 : o.$el,
									trigger: e.trigger,
									"trigger-keys": e.triggerKeys,
									"trigger-target-el": e.contentRef,
									"show-after": "hover" === e.trigger ? e.showTimeout : 0,
									"stop-popper-mouse-event": !1,
									"virtual-ref": e.triggeringElementRef,
									"virtual-triggering": e.splitButton,
									disabled: e.disabled,
									transition: `${e.ns.namespace.value}-zoom-in-top`,
									teleported: "",
									pure: "",
									persistent: "",
									onShow: e.handleShowTooltip,
									onHide: e.handleHideTooltip
								},
								fi(
									{
										content: cn(() => [
											ri(
												u,
												{ ref: "scrollbar", "wrap-style": e.wrapStyle, tag: "div", "view-class": e.ns.e("list") },
												{
													default: cn(() => [
														ri(
															l,
															{ loop: e.loop, "current-tab-id": e.currentTabId, orientation: "horizontal", onCurrentTabIdChange: e.handleCurrentTabIdChange, onEntryFocus: e.handleEntryFocus },
															{ default: cn(() => [ri(a, null, { default: cn(() => [mi(e.$slots, "dropdown")]), _: 3 })]), _: 3 },
															8,
															["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"]
														)
													]),
													_: 3
												},
												8,
												["wrap-style", "view-class"]
											)
										]),
										_: 2
									},
									[e.splitButton ? void 0 : { name: "default", fn: cn(() => [ri(c, { id: e.triggerId, role: "button", tabindex: e.tabindex }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["id", "tabindex"])]) }]
								),
								1032,
								["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "onShow", "onHide"]
							),
							e.splitButton
								? (Wr(),
								  qr(
										m,
										{ key: 0 },
										{
											default: cn(() => [
												ri(d, hi({ ref: "referenceElementRef" }, e.buttonProps, { size: e.dropdownSize, type: e.type, disabled: e.disabled, tabindex: e.tabindex, onClick: e.handlerMainButtonClick }), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16, [
													"size",
													"type",
													"disabled",
													"tabindex",
													"onClick"
												]),
												ri(
													d,
													hi({ id: e.triggerId, ref: "triggeringElementRef" }, e.buttonProps, { role: "button", size: e.dropdownSize, type: e.type, class: e.ns.e("caret-button"), disabled: e.disabled, tabindex: e.tabindex, "aria-label": e.t("el.dropdown.toggleDropdown") }),
													{ default: cn(() => [ri(f, { class: gt(e.ns.e("icon")) }, { default: cn(() => [ri(p)]), _: 1 }, 8, ["class"])]), _: 1 },
													16,
													["id", "size", "type", "class", "disabled", "tabindex", "aria-label"]
												)
											]),
											_: 3
										}
								  ))
								: ai("v-if", !0)
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]
	]
);
const uY = Tn({
		name: "DropdownItemImpl",
		components: { ElIcon: OB },
		props: ZG,
		emits: ["pointermove", "pointerleave", "click", "clickimpl"],
		setup(e, { emit: t }) {
			const n = BD("dropdown"),
				{ role: r } = vn(oY, void 0),
				{ collectionItemRef: i } = vn(sY, void 0),
				{ collectionItemRef: s } = vn(VG, void 0),
				{ rovingFocusGroupItemRef: o, tabIndex: a, handleFocus: l, handleKeydown: u, handleMousedown: c } = vn(zG, void 0);
			return {
				ns: n,
				itemRef: yN(i, s, o),
				dataset: { "data-el-collection-item": "" },
				role: ht(() => ("menu" === r.value ? "menuitem" : "navigation" === r.value ? "link" : "button")),
				tabIndex: a,
				handleFocus: l,
				handleKeydown: PI((e) => {
					const { code: n } = e;
					if (n === bN.enter || n === bN.space) return e.preventDefault(), e.stopImmediatePropagation(), t("clickimpl", e), !0;
				}, u),
				handleMousedown: c
			};
		}
	}),
	cY = ["aria-disabled", "tabindex", "role"];
const hY = () => {
	const e = vn("elDropdown", {}),
		t = ht(() => (null == e ? void 0 : e.dropdownSize));
	return { elDropdown: e, _elDropdownSize: t };
};
var dY = IB(
	Tn({
		name: "ElDropdownItem",
		components: {
			ElDropdownCollectionItem: rY,
			ElRovingFocusItem: KG,
			ElDropdownItemImpl: IB(uY, [
				[
					"render",
					function (e, t, n, r, i, s) {
						const o = Or("el-icon");
						return (
							Wr(),
							Kr(
								Hr,
								null,
								[
									e.divided ? (Wr(), Kr("li", hi({ key: 0, role: "separator", class: e.ns.bem("menu", "item", "divided") }, e.$attrs), null, 16)) : ai("v-if", !0),
									ni(
										"li",
										hi({ ref: e.itemRef }, u(u({}, e.dataset), e.$attrs), {
											"aria-disabled": e.disabled,
											class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
											tabindex: e.tabIndex,
											role: e.role,
											onClick: t[0] || (t[0] = (t) => e.$emit("clickimpl", t)),
											onFocus: t[1] || (t[1] = (...t) => e.handleFocus && e.handleFocus(...t)),
											onKeydown: t[2] || (t[2] = (...t) => e.handleKeydown && e.handleKeydown(...t)),
											onMousedown: t[3] || (t[3] = (...t) => e.handleMousedown && e.handleMousedown(...t)),
											onPointermove: t[4] || (t[4] = (t) => e.$emit("pointermove", t)),
											onPointerleave: t[5] || (t[5] = (t) => e.$emit("pointerleave", t))
										}),
										[e.icon ? (Wr(), qr(o, { key: 0 }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 })) : ai("v-if", !0), mi(e.$slots, "default")],
										16,
										cY
									)
								],
								64
							)
						);
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]
			])
		},
		inheritAttrs: !1,
		props: ZG,
		emits: ["pointermove", "pointerleave", "click"],
		setup(e, { emit: t, attrs: n }) {
			const { elDropdown: r } = hY(),
				i = Si(),
				s = Qe(null),
				o = ht(() => {
					var e, t;
					return null != (t = null == (e = it(s)) ? void 0 : e.textContent) ? t : "";
				}),
				{ onItemEnter: a, onItemLeave: l } = vn(oY, void 0),
				c = PI(
					(e) => (t("pointermove", e), e.defaultPrevented),
					NI((t) => {
						var n;
						e.disabled ? l(t) : (a(t), t.defaultPrevented || null == (n = t.currentTarget) || n.focus());
					})
				),
				h = PI(
					(e) => (t("pointerleave", e), e.defaultPrevented),
					NI((e) => {
						l(e);
					})
				);
			return {
				handleClick: PI(
					(e) => (t("click", e), "keydown" !== e.type && e.defaultPrevented),
					(t) => {
						var n, s, o;
						e.disabled ? t.stopImmediatePropagation() : ((null == (n = null == r ? void 0 : r.hideOnClick) ? void 0 : n.value) && (null == (s = r.handleClick) || s.call(r)), null == (o = r.commandHandler) || o.call(r, e.command, i, t));
					}
				),
				handlePointerMove: c,
				handlePointerLeave: h,
				textContent: o,
				propsAndAttrs: ht(() => u(u({}, e), n))
			};
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				var o;
				const a = Or("el-dropdown-item-impl"),
					l = Or("el-roving-focus-item"),
					u = Or("el-dropdown-collection-item");
				return (
					Wr(),
					qr(
						u,
						{ disabled: e.disabled, "text-value": null != (o = e.textValue) ? o : e.textContent },
						{
							default: cn(() => [
								ri(
									l,
									{ focusable: !e.disabled },
									{
										default: cn(() => [
											ri(a, hi(e.propsAndAttrs, { onPointerleave: e.handlePointerLeave, onPointermove: e.handlePointerMove, onClickimpl: e.handleClick }), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
										]),
										_: 3
									},
									8,
									["focusable"]
								)
							]),
							_: 3
						},
						8,
						["disabled", "text-value"]
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]
	]
);
const pY = Tn({
		name: "ElDropdownMenu",
		props: JG,
		setup(e) {
			const t = BD("dropdown"),
				{ _elDropdownSize: n } = hY(),
				r = n.value,
				{ focusTrapRef: i, onKeydown: s } = vn(RH, void 0),
				{ contentRef: o, role: a, triggerId: l } = vn(oY, void 0),
				{ collectionRef: u, getItems: c } = vn(iY, void 0),
				{ rovingFocusGroupRef: h, rovingFocusGroupRootStyle: d, tabIndex: p, onBlur: f, onFocus: m, onMousedown: v } = vn(UG, void 0),
				{ collectionRef: g } = vn(HG, void 0),
				y = ht(() => [t.b("menu"), t.bm("menu", null == r ? void 0 : r.value)]),
				b = yN(o, u, i, h, g),
				x = PI(
					(t) => {
						var n;
						null == (n = e.onKeydown) || n.call(e, t);
					},
					(e) => {
						const { currentTarget: t, code: n, target: r } = e;
						if ((t.contains(r), bN.tab === n && e.stopImmediatePropagation(), e.preventDefault(), r !== it(o))) return;
						if (!tY.includes(n)) return;
						const i = c()
							.filter((e) => !e.disabled)
							.map((e) => e.ref);
						eY.includes(n) && i.reverse(), WG(i);
					}
				);
			return {
				size: r,
				rovingFocusGroupRootStyle: d,
				tabIndex: p,
				dropdownKls: y,
				role: a,
				triggerId: l,
				dropdownListWrapperRef: b,
				handleKeydown: (e) => {
					x(e), s(e);
				},
				onBlur: f,
				onFocus: m,
				onMousedown: v
			};
		}
	}),
	fY = ["role", "aria-labelledby"];
var mY = IB(pY, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return (
				Wr(),
				Kr(
					"ul",
					{
						ref: e.dropdownListWrapperRef,
						class: gt(e.dropdownKls),
						style: pt(e.rovingFocusGroupRootStyle),
						tabindex: -1,
						role: e.role,
						"aria-labelledby": e.triggerId,
						onBlur: t[0] || (t[0] = (...t) => e.onBlur && e.onBlur(...t)),
						onFocus: t[1] || (t[1] = (...t) => e.onFocus && e.onFocus(...t)),
						onKeydown: t[2] || (t[2] = (...t) => e.handleKeydown && e.handleKeydown(...t)),
						onMousedown: t[3] || (t[3] = (...t) => e.onMousedown && e.onMousedown(...t))
					},
					[mi(e.$slots, "default")],
					46,
					fY
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]
]);
const vY = mN(lY, { DropdownItem: dY, DropdownMenu: mY }),
	gY = gN(dY),
	yY = gN(mY);
let bY = 0;
const xY = Tn({ name: "ImgEmpty", setup: () => ({ ns: BD("empty"), id: ++bY }) }),
	_Y = { viewBox: "0 0 79 86", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink" },
	wY = ["id"],
	CY = ["stop-color"],
	SY = ["stop-color"],
	EY = ["id"],
	TY = ["stop-color"],
	kY = ["stop-color"],
	AY = ["id"],
	MY = { id: "Illustrations", stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
	IY = { id: "B-type", transform: "translate(-1268.000000, -535.000000)" },
	RY = { id: "Group-2", transform: "translate(1268.000000, 535.000000)" },
	LY = ["fill"],
	OY = ["fill"],
	PY = { id: "Group-Copy", transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" },
	NY = ["fill"],
	DY = ["fill"],
	BY = ["fill"],
	FY = ["fill"],
	HY = ["fill"],
	VY = { id: "Rectangle-Copy-17", transform: "translate(53.000000, 45.000000)" },
	UY = ["fill", "xlink:href"],
	zY = ["fill", "mask"],
	$Y = ["fill"];
var jY = IB(xY, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return (
				Wr(),
				Kr("svg", _Y, [
					ni("defs", null, [
						ni(
							"linearGradient",
							{ id: `linearGradient-1-${e.id}`, x1: "38.8503086%", y1: "0%", x2: "61.1496914%", y2: "100%" },
							[ni("stop", { "stop-color": `var(${e.ns.cssVarBlockName("fill-color-1")})`, offset: "0%" }, null, 8, CY), ni("stop", { "stop-color": `var(${e.ns.cssVarBlockName("fill-color-4")})`, offset: "100%" }, null, 8, SY)],
							8,
							wY
						),
						ni(
							"linearGradient",
							{ id: `linearGradient-2-${e.id}`, x1: "0%", y1: "9.5%", x2: "100%", y2: "90.5%" },
							[ni("stop", { "stop-color": `var(${e.ns.cssVarBlockName("fill-color-1")})`, offset: "0%" }, null, 8, TY), ni("stop", { "stop-color": `var(${e.ns.cssVarBlockName("fill-color-6")})`, offset: "100%" }, null, 8, kY)],
							8,
							EY
						),
						ni("rect", { id: `path-3-${e.id}`, x: "0", y: "0", width: "17", height: "36" }, null, 8, AY)
					]),
					ni("g", MY, [
						ni("g", IY, [
							ni("g", RY, [
								ni(
									"path",
									{ id: "Oval-Copy-2", d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z", fill: `var(${e.ns.cssVarBlockName("fill-color-3")})` },
									null,
									8,
									LY
								),
								ni("polygon", { id: "Rectangle-Copy-14", fill: `var(${e.ns.cssVarBlockName("fill-color-7")})`, transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ", points: "13 58 53 58 42 45 2 45" }, null, 8, OY),
								ni("g", PY, [
									ni("polygon", { id: "Rectangle-Copy-10", fill: `var(${e.ns.cssVarBlockName("fill-color-7")})`, transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ", points: "2.84078316e-14 3 18 3 23 7 5 7" }, null, 8, NY),
									ni("polygon", { id: "Rectangle-Copy-11", fill: `var(${e.ns.cssVarBlockName("fill-color-5")})`, points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43" }, null, 8, DY),
									ni("rect", { id: "Rectangle-Copy-12", fill: `url(#linearGradient-1-${e.id})`, transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ", x: "38", y: "7", width: "17", height: "36" }, null, 8, BY),
									ni("polygon", { id: "Rectangle-Copy-13", fill: `var(${e.ns.cssVarBlockName("fill-color-2")})`, transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ", points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12" }, null, 8, FY)
								]),
								ni("rect", { id: "Rectangle-Copy-15", fill: `url(#linearGradient-2-${e.id})`, x: "13", y: "45", width: "40", height: "36" }, null, 8, HY),
								ni("g", VY, [
									ni("use", { id: "Mask", fill: `var(${e.ns.cssVarBlockName("fill-color-8")})`, transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ", "xlink:href": `#path-3-${e.id}` }, null, 8, UY),
									ni("polygon", { id: "Rectangle-Copy", fill: `var(${e.ns.cssVarBlockName("fill-color-9")})`, mask: `url(#mask-4-${e.id})`, transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ", points: "7 0 24 0 20 18 7 16.5" }, null, 8, zY)
								]),
								ni("polygon", { id: "Rectangle-Copy-18", fill: `var(${e.ns.cssVarBlockName("fill-color-2")})`, transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ", points: "62 45 79 45 70 58 53 58" }, null, 8, $Y)
							])
						])
					])
				])
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]
]);
const WY = { image: { type: String, default: "" }, imageSize: Number, description: { type: String, default: "" } },
	GY = ["src"],
	YY = { key: 1 };
const XY = mN(
		IB(
			Tn(
				c(u({}, { name: "ElEmpty" }), {
					props: WY,
					setup(e) {
						const t = e,
							{ t: n } = CD(),
							r = BD("empty"),
							i = ht(() => t.description || n("el.table.emptyText")),
							s = ht(() => ({ width: t.imageSize ? `${t.imageSize}px` : "" }));
						return (e, t) => (
							Wr(),
							Kr(
								"div",
								{ class: gt(it(r).b()) },
								[
									ni("div", { class: gt(it(r).e("image")), style: pt(it(s)) }, [e.image ? (Wr(), Kr("img", { key: 0, src: e.image, ondragstart: "return false" }, null, 8, GY)) : mi(e.$slots, "image", { key: 1 }, () => [ri(jY)])], 6),
									ni("div", { class: gt(it(r).e("description")) }, [e.$slots.description ? mi(e.$slots, "description", { key: 0 }) : (Wr(), Kr("p", YY, bt(it(i)), 1))], 2),
									e.$slots.default ? (Wr(), Kr("div", { key: 0, class: gt(it(r).e("bottom")) }, [mi(e.$slots, "default")], 2)) : ai("v-if", !0)
								],
								2
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]
		)
	),
	KY = uN({
		model: Object,
		rules: { type: Object },
		labelPosition: { type: String, values: ["left", "right", "top"], default: "right" },
		labelWidth: { type: [String, Number], default: "" },
		labelSuffix: { type: String, default: "" },
		inline: Boolean,
		inlineMessage: Boolean,
		statusIcon: Boolean,
		showMessage: { type: Boolean, default: !0 },
		size: { type: String, values: CN },
		disabled: Boolean,
		validateOnRuleChange: { type: Boolean, default: !0 },
		hideRequiredAsterisk: { type: Boolean, default: !1 },
		scrollToError: Boolean
	}),
	qY = { validate: (e, t, n) => (_R(e) || SR(e)) && YI(t) && SR(n) };
const ZY = (e, t) => {
	const n = zE(t);
	return n.length > 0 ? e.filter((e) => e.prop && n.includes(e.prop)) : e;
};
var JY = IB(
	Tn(
		c(u({}, { name: "ElForm" }), {
			props: KY,
			emits: qY,
			setup(e, { expose: t, emit: n }) {
				const r = e,
					i = [],
					s = hD(),
					o = BD("form"),
					a = ht(() => {
						const { labelPosition: e, inline: t } = r;
						return [o.b(), o.m(s.value || "default"), { [o.m(`label-${e}`)]: e, [o.m("inline")]: t }];
					}),
					l = (e = []) => {
						r.model && ZY(i, e).forEach((e) => e.resetField());
					},
					h = (e = []) => {
						ZY(i, e).forEach((e) => e.clearValidate());
					},
					d = ht(() => !!r.model),
					p = async (e) => m(void 0, e),
					f = async (e = []) => {
						if (!d.value) return !1;
						const t = ((e) => {
							if (0 === i.length) return [];
							const t = ZY(i, e);
							return t.length ? t : [];
						})(e);
						if (0 === t.length) return !0;
						let n = {};
						for (const i of t)
							try {
								await i.validate("");
							} catch (r) {
								n = u(u({}, n), r);
							}
						return 0 === Object.keys(n).length || Promise.reject(n);
					},
					m = async (e = [], t) => {
						const n = !CR(t);
						try {
							const n = await f(e);
							return !0 === n && (null == t || t(n)), n;
						} catch (Kj) {
							const i = Kj;
							return r.scrollToError && v(Object.keys(i)[0]), null == t || t(!1, i), n && Promise.reject(i);
						}
					},
					v = (e) => {
						var t;
						const n = ZY(i, e)[0];
						n && (null == (t = n.$el) || t.scrollIntoView());
					};
				return (
					ds(
						() => r.rules,
						() => {
							r.validateOnRuleChange && p().catch((e) => {});
						},
						{ deep: !0 }
					),
					mn(
						GN,
						Fe(
							u(
								c(u({}, at(r)), {
									emit: n,
									resetFields: l,
									clearValidate: h,
									validateField: m,
									addField: (e) => {
										i.push(e);
									},
									removeField: (e) => {
										e.prop && i.splice(i.indexOf(e), 1);
									}
								}),
								(function () {
									const e = Qe([]);
									function t(t) {
										return e.value.indexOf(t);
									}
									return {
										autoLabelWidth: ht(() => {
											if (!e.value.length) return "0";
											const t = Math.max(...e.value);
											return t ? `${t}px` : "";
										}),
										registerLabelWidth: function (n, r) {
											if (n && r) {
												const i = t(r);
												e.value.splice(i, 1, n);
											} else n && e.value.push(n);
										},
										deregisterLabelWidth: function (n) {
											const r = t(n);
											r > -1 && e.value.splice(r, 1);
										}
									};
								})()
							)
						)
					),
					t({ validate: p, validateField: m, resetFields: l, clearValidate: h, scrollToField: v }),
					(e, t) => (Wr(), Kr("form", { class: gt(it(a)) }, [mi(e.$slots, "default")], 2))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]
);
function QY() {
	return (QY =
		Object.assign ||
		function (e) {
			for (var t = 1; t < arguments.length; t++) {
				var n = arguments[t];
				for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
			}
			return e;
		}).apply(this, arguments);
}
function eX(e) {
	return (eX = Object.setPrototypeOf
		? Object.getPrototypeOf
		: function (e) {
				return e.__proto__ || Object.getPrototypeOf(e);
		  })(e);
}
function tX(e, t) {
	return (tX =
		Object.setPrototypeOf ||
		function (e, t) {
			return (e.__proto__ = t), e;
		})(e, t);
}
function nX() {
	if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
	if (Reflect.construct.sham) return !1;
	if ("function" == typeof Proxy) return !0;
	try {
		return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
	} catch (Kj) {
		return !1;
	}
}
function rX(e, t, n) {
	return (rX = nX()
		? Reflect.construct
		: function (e, t, n) {
				var r = [null];
				r.push.apply(r, t);
				var i = new (Function.bind.apply(e, r))();
				return n && tX(i, n.prototype), i;
		  }).apply(null, arguments);
}
function iX(e) {
	var t = "function" == typeof Map ? new Map() : void 0;
	return (iX = function (e) {
		if (null === e || ((n = e), -1 === Function.toString.call(n).indexOf("[native code]"))) return e;
		var n;
		if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
		if (void 0 !== t) {
			if (t.has(e)) return t.get(e);
			t.set(e, r);
		}
		function r() {
			return rX(e, arguments, eX(this).constructor);
		}
		return (r.prototype = Object.create(e.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } })), tX(r, e);
	})(e);
}
var sX = /%[sdj%]/g,
	oX = function () {};
function aX(e) {
	if (!e || !e.length) return null;
	var t = {};
	return (
		e.forEach(function (e) {
			var n = e.field;
			(t[n] = t[n] || []), t[n].push(e);
		}),
		t
	);
}
function lX(e) {
	for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
	var i = 0,
		s = n.length;
	if ("function" == typeof e) return e.apply(null, n);
	if ("string" == typeof e) {
		var o = e.replace(sX, function (e) {
			if ("%%" === e) return "%";
			if (i >= s) return e;
			switch (e) {
				case "%s":
					return String(n[i++]);
				case "%d":
					return Number(n[i++]);
				case "%j":
					try {
						return JSON.stringify(n[i++]);
					} catch (t) {
						return "[Circular]";
					}
					break;
				default:
					return e;
			}
		});
		return o;
	}
	return e;
}
function uX(e, t) {
	return (
		null == e ||
		!("array" !== t || !Array.isArray(e) || e.length) ||
		!(
			!(function (e) {
				return "string" === e || "url" === e || "hex" === e || "email" === e || "date" === e || "pattern" === e;
			})(t) ||
			"string" != typeof e ||
			e
		)
	);
}
function cX(e, t, n) {
	var r = 0,
		i = e.length;
	!(function s(o) {
		if (o && o.length) n(o);
		else {
			var a = r;
			(r += 1), a < i ? t(e[a], s) : n([]);
		}
	})([]);
}
"undefined" != typeof process && process.env;
var hX = (function (e) {
	var t, n;
	function r(t, n) {
		var r;
		return ((r = e.call(this, "Async Validation Error") || this).errors = t), (r.fields = n), r;
	}
	return (n = e), ((t = r).prototype = Object.create(n.prototype)), (t.prototype.constructor = t), tX(t, n), r;
})(iX(Error));
function dX(e, t, n, r, i) {
	if (t.first) {
		var s = new Promise(function (t, s) {
			cX(
				(function (e) {
					var t = [];
					return (
						Object.keys(e).forEach(function (n) {
							t.push.apply(t, e[n] || []);
						}),
						t
					);
				})(e),
				n,
				function (e) {
					return r(e), e.length ? s(new hX(e, aX(e))) : t(i);
				}
			);
		});
		return (
			s.catch(function (e) {
				return e;
			}),
			s
		);
	}
	var o = !0 === t.firstFields ? Object.keys(e) : t.firstFields || [],
		a = Object.keys(e),
		l = a.length,
		u = 0,
		c = [],
		h = new Promise(function (t, s) {
			var h = function (e) {
				if ((c.push.apply(c, e), ++u === l)) return r(c), c.length ? s(new hX(c, aX(c))) : t(i);
			};
			a.length || (r(c), t(i)),
				a.forEach(function (t) {
					var r = e[t];
					-1 !== o.indexOf(t)
						? cX(r, n, h)
						: (function (e, t, n) {
								var r = [],
									i = 0,
									s = e.length;
								function o(e) {
									r.push.apply(r, e || []), ++i === s && n(r);
								}
								e.forEach(function (e) {
									t(e, o);
								});
						  })(r, n, h);
				});
		});
	return (
		h.catch(function (e) {
			return e;
		}),
		h
	);
}
function pX(e, t) {
	return function (n) {
		var r, i;
		return (
			(r = e.fullFields
				? (function (e, t) {
						for (var n = e, r = 0; r < t.length; r++) {
							if (null == n) return n;
							n = n[t[r]];
						}
						return n;
				  })(t, e.fullFields)
				: t[n.field || e.fullField]),
			(i = n) && void 0 !== i.message ? ((n.field = n.field || e.fullField), (n.fieldValue = r), n) : { message: "function" == typeof n ? n() : n, fieldValue: r, field: n.field || e.fullField }
		);
	};
}
function fX(e, t) {
	if (t)
		for (var n in t)
			if (t.hasOwnProperty(n)) {
				var r = t[n];
				"object" == typeof r && "object" == typeof e[n] ? (e[n] = QY({}, e[n], r)) : (e[n] = r);
			}
	return e;
}
var mX = function (e, t, n, r, i, s) {
		!e.required || (n.hasOwnProperty(e.field) && !uX(t, s || e.type)) || r.push(lX(i.messages.required, e.fullField));
	},
	vX = {
		email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
		url: new RegExp(
			"^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$",
			"i"
		),
		hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
	},
	gX = {
		integer: function (e) {
			return gX.number(e) && parseInt(e, 10) === e;
		},
		float: function (e) {
			return gX.number(e) && !gX.integer(e);
		},
		array: function (e) {
			return Array.isArray(e);
		},
		regexp: function (e) {
			if (e instanceof RegExp) return !0;
			try {
				return !!new RegExp(e);
			} catch (Kj) {
				return !1;
			}
		},
		date: function (e) {
			return "function" == typeof e.getTime && "function" == typeof e.getMonth && "function" == typeof e.getYear && !isNaN(e.getTime());
		},
		number: function (e) {
			return !isNaN(e) && "number" == typeof e;
		},
		object: function (e) {
			return "object" == typeof e && !gX.array(e);
		},
		method: function (e) {
			return "function" == typeof e;
		},
		email: function (e) {
			return "string" == typeof e && e.length <= 320 && !!e.match(vX.email);
		},
		url: function (e) {
			return "string" == typeof e && e.length <= 2048 && !!e.match(vX.url);
		},
		hex: function (e) {
			return "string" == typeof e && !!e.match(vX.hex);
		}
	},
	yX = {
		required: mX,
		whitespace: function (e, t, n, r, i) {
			(/^\s+$/.test(t) || "" === t) && r.push(lX(i.messages.whitespace, e.fullField));
		},
		type: function (e, t, n, r, i) {
			if (e.required && void 0 === t) mX(e, t, n, r, i);
			else {
				var s = e.type;
				["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"].indexOf(s) > -1 ? gX[s](t) || r.push(lX(i.messages.types[s], e.fullField, e.type)) : s && typeof t !== e.type && r.push(lX(i.messages.types[s], e.fullField, e.type));
			}
		},
		range: function (e, t, n, r, i) {
			var s = "number" == typeof e.len,
				o = "number" == typeof e.min,
				a = "number" == typeof e.max,
				l = t,
				u = null,
				c = "number" == typeof t,
				h = "string" == typeof t,
				d = Array.isArray(t);
			if ((c ? (u = "number") : h ? (u = "string") : d && (u = "array"), !u)) return !1;
			d && (l = t.length),
				h && (l = t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length),
				s
					? l !== e.len && r.push(lX(i.messages[u].len, e.fullField, e.len))
					: o && !a && l < e.min
					? r.push(lX(i.messages[u].min, e.fullField, e.min))
					: a && !o && l > e.max
					? r.push(lX(i.messages[u].max, e.fullField, e.max))
					: o && a && (l < e.min || l > e.max) && r.push(lX(i.messages[u].range, e.fullField, e.min, e.max));
		},
		enum: function (e, t, n, r, i) {
			(e.enum = Array.isArray(e.enum) ? e.enum : []), -1 === e.enum.indexOf(t) && r.push(lX(i.messages.enum, e.fullField, e.enum.join(", ")));
		},
		pattern: function (e, t, n, r, i) {
			if (e.pattern)
				if (e.pattern instanceof RegExp) (e.pattern.lastIndex = 0), e.pattern.test(t) || r.push(lX(i.messages.pattern.mismatch, e.fullField, t, e.pattern));
				else if ("string" == typeof e.pattern) {
					new RegExp(e.pattern).test(t) || r.push(lX(i.messages.pattern.mismatch, e.fullField, t, e.pattern));
				}
		}
	},
	bX = function (e, t, n, r, i) {
		var s = e.type,
			o = [];
		if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
			if (uX(t, s) && !e.required) return n();
			yX.required(e, t, r, o, i, s), uX(t, s) || yX.type(e, t, r, o, i);
		}
		n(o);
	},
	xX = {
		string: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t, "string") && !e.required) return n();
				yX.required(e, t, r, s, i, "string"), uX(t, "string") || (yX.type(e, t, r, s, i), yX.range(e, t, r, s, i), yX.pattern(e, t, r, s, i), !0 === e.whitespace && yX.whitespace(e, t, r, s, i));
			}
			n(s);
		},
		method: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && yX.type(e, t, r, s, i);
			}
			n(s);
		},
		number: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (("" === t && (t = void 0), uX(t) && !e.required)) return n();
				yX.required(e, t, r, s, i), void 0 !== t && (yX.type(e, t, r, s, i), yX.range(e, t, r, s, i));
			}
			n(s);
		},
		boolean: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && yX.type(e, t, r, s, i);
			}
			n(s);
		},
		regexp: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), uX(t) || yX.type(e, t, r, s, i);
			}
			n(s);
		},
		integer: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && (yX.type(e, t, r, s, i), yX.range(e, t, r, s, i));
			}
			n(s);
		},
		float: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && (yX.type(e, t, r, s, i), yX.range(e, t, r, s, i));
			}
			n(s);
		},
		array: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (null == t && !e.required) return n();
				yX.required(e, t, r, s, i, "array"), null != t && (yX.type(e, t, r, s, i), yX.range(e, t, r, s, i));
			}
			n(s);
		},
		object: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && yX.type(e, t, r, s, i);
			}
			n(s);
		},
		enum: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i), void 0 !== t && yX.enum(e, t, r, s, i);
			}
			n(s);
		},
		pattern: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t, "string") && !e.required) return n();
				yX.required(e, t, r, s, i), uX(t, "string") || yX.pattern(e, t, r, s, i);
			}
			n(s);
		},
		date: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t, "date") && !e.required) return n();
				var o;
				if ((yX.required(e, t, r, s, i), !uX(t, "date"))) (o = t instanceof Date ? t : new Date(t)), yX.type(e, o, r, s, i), o && yX.range(e, o.getTime(), r, s, i);
			}
			n(s);
		},
		url: bX,
		hex: bX,
		email: bX,
		required: function (e, t, n, r, i) {
			var s = [],
				o = Array.isArray(t) ? "array" : typeof t;
			yX.required(e, t, r, s, i, o), n(s);
		},
		any: function (e, t, n, r, i) {
			var s = [];
			if (e.required || (!e.required && r.hasOwnProperty(e.field))) {
				if (uX(t) && !e.required) return n();
				yX.required(e, t, r, s, i);
			}
			n(s);
		}
	};
function _X() {
	return {
		default: "Validation error on field %s",
		required: "%s is required",
		enum: "%s must be one of %s",
		whitespace: "%s cannot be empty",
		date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" },
		types: {
			string: "%s is not a %s",
			method: "%s is not a %s (function)",
			array: "%s is not an %s",
			object: "%s is not an %s",
			number: "%s is not a %s",
			date: "%s is not a %s",
			boolean: "%s is not a %s",
			integer: "%s is not an %s",
			float: "%s is not a %s",
			regexp: "%s is not a valid %s",
			email: "%s is not a valid %s",
			url: "%s is not a valid %s",
			hex: "%s is not a valid %s"
		},
		string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" },
		number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" },
		array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" },
		pattern: { mismatch: "%s value %s does not match pattern %s" },
		clone: function () {
			var e = JSON.parse(JSON.stringify(this));
			return (e.clone = this.clone), e;
		}
	};
}
var wX = _X(),
	CX = (function () {
		function e(e) {
			(this.rules = null), (this._messages = wX), this.define(e);
		}
		var t = e.prototype;
		return (
			(t.define = function (e) {
				var t = this;
				if (!e) throw new Error("Cannot configure a schema with no rules");
				if ("object" != typeof e || Array.isArray(e)) throw new Error("Rules must be an object");
				(this.rules = {}),
					Object.keys(e).forEach(function (n) {
						var r = e[n];
						t.rules[n] = Array.isArray(r) ? r : [r];
					});
			}),
			(t.messages = function (e) {
				return e && (this._messages = fX(_X(), e)), this._messages;
			}),
			(t.validate = function (t, n, r) {
				var i = this;
				void 0 === n && (n = {}), void 0 === r && (r = function () {});
				var s = t,
					o = n,
					a = r;
				if (("function" == typeof o && ((a = o), (o = {})), !this.rules || 0 === Object.keys(this.rules).length)) return a && a(null, s), Promise.resolve(s);
				if (o.messages) {
					var l = this.messages();
					l === wX && (l = _X()), fX(l, o.messages), (o.messages = l);
				} else o.messages = this.messages();
				var u = {};
				(o.keys || Object.keys(this.rules)).forEach(function (e) {
					var n = i.rules[e],
						r = s[e];
					n.forEach(function (n) {
						var o = n;
						"function" == typeof o.transform && (s === t && (s = QY({}, s)), (r = s[e] = o.transform(r))),
							((o = "function" == typeof o ? { validator: o } : QY({}, o)).validator = i.getValidationMethod(o)),
							o.validator && ((o.field = e), (o.fullField = o.fullField || e), (o.type = i.getType(o)), (u[e] = u[e] || []), u[e].push({ rule: o, value: r, source: s, field: e }));
					});
				});
				var c = {};
				return dX(
					u,
					o,
					function (t, n) {
						var r,
							i = t.rule,
							a = !(("object" !== i.type && "array" !== i.type) || ("object" != typeof i.fields && "object" != typeof i.defaultField));
						function l(e, t) {
							return QY({}, t, { fullField: i.fullField + "." + e, fullFields: i.fullFields ? [].concat(i.fullFields, [e]) : [e] });
						}
						function u(r) {
							void 0 === r && (r = []);
							var u = Array.isArray(r) ? r : [r];
							!o.suppressWarning && u.length && e.warning("async-validator:", u), u.length && void 0 !== i.message && (u = [].concat(i.message));
							var h = u.map(pX(i, s));
							if (o.first && h.length) return (c[i.field] = 1), n(h);
							if (a) {
								if (i.required && !t.value) return void 0 !== i.message ? (h = [].concat(i.message).map(pX(i, s))) : o.error && (h = [o.error(i, lX(o.messages.required, i.field))]), n(h);
								var d = {};
								i.defaultField &&
									Object.keys(t.value).map(function (e) {
										d[e] = i.defaultField;
									}),
									(d = QY({}, d, t.rule.fields));
								var p = {};
								Object.keys(d).forEach(function (e) {
									var t = d[e],
										n = Array.isArray(t) ? t : [t];
									p[e] = n.map(l.bind(null, e));
								});
								var f = new e(p);
								f.messages(o.messages),
									t.rule.options && ((t.rule.options.messages = o.messages), (t.rule.options.error = o.error)),
									f.validate(t.value, t.rule.options || o, function (e) {
										var t = [];
										h && h.length && t.push.apply(t, h), e && e.length && t.push.apply(t, e), n(t.length ? t : null);
									});
							} else n(h);
						}
						if (((a = a && (i.required || (!i.required && t.value))), (i.field = t.field), i.asyncValidator)) r = i.asyncValidator(i, t.value, u, t.source, o);
						else if (i.validator) {
							try {
								r = i.validator(i, t.value, u, t.source, o);
							} catch (h) {
								null == console.error || console.error(h),
									setTimeout(function () {
										throw h;
									}, 0),
									u(h.message);
							}
							!0 === r ? u() : !1 === r ? u("function" == typeof i.message ? i.message(i.fullField || i.field) : i.message || (i.fullField || i.field) + " fails") : r instanceof Array ? u(r) : r instanceof Error && u(r.message);
						}
						r &&
							r.then &&
							r.then(
								function () {
									return u();
								},
								function (e) {
									return u(e);
								}
							);
					},
					function (e) {
						!(function (e) {
							var t = [],
								n = {};
							function r(e) {
								var n;
								Array.isArray(e) ? (t = (n = t).concat.apply(n, e)) : t.push(e);
							}
							for (var i = 0; i < e.length; i++) r(e[i]);
							t.length ? ((n = aX(t)), a(t, n)) : a(null, s);
						})(e);
					},
					s
				);
			}),
			(t.getType = function (e) {
				if ((void 0 === e.type && e.pattern instanceof RegExp && (e.type = "pattern"), "function" != typeof e.validator && e.type && !xX.hasOwnProperty(e.type))) throw new Error(lX("Unknown rule type %s", e.type));
				return e.type || "string";
			}),
			(t.getValidationMethod = function (e) {
				if ("function" == typeof e.validator) return e.validator;
				var t = Object.keys(e),
					n = t.indexOf("message");
				return -1 !== n && t.splice(n, 1), 1 === t.length && "required" === t[0] ? xX.required : xX[this.getType(e)] || void 0;
			}),
			e
		);
	})();
(CX.register = function (e, t) {
	if ("function" != typeof t) throw new Error("Cannot register a validator by type, validator is not a function");
	xX[e] = t;
}),
	(CX.warning = oX),
	(CX.messages = wX),
	(CX.validators = xX);
const SX = uN({
	label: String,
	labelWidth: { type: [String, Number], default: "" },
	prop: { type: [String, Array] },
	required: { type: Boolean, default: void 0 },
	rules: { type: [Object, Array] },
	error: String,
	validateStatus: { type: String, values: ["", "error", "validating", "success"] },
	for: String,
	inlineMessage: { type: [String, Boolean], default: "" },
	showMessage: { type: Boolean, default: !0 },
	size: { type: String, values: CN }
});
var EX = Tn({
	name: "ElLabelWrap",
	props: { isAutoWidth: Boolean, updateAll: Boolean },
	setup(e, { slots: t }) {
		const n = vn(GN, void 0);
		vn(YN) || $R("ElLabelWrap", "usage: <el-form-item><label-wrap /></el-form-item>");
		const r = BD("form"),
			i = Qe(),
			s = Qe(0),
			o = (r = "update") => {
				ns(() => {
					t.default &&
						e.isAutoWidth &&
						("update" === r
							? (s.value = (() => {
									var e;
									if (null == (e = i.value) ? void 0 : e.firstElementChild) {
										const e = window.getComputedStyle(i.value.firstElementChild).width;
										return Math.ceil(Number.parseFloat(e));
									}
									return 0;
							  })())
							: "remove" === r && (null == n || n.deregisterLabelWidth(s.value)));
				});
			},
			a = () => o("update");
		return (
			Vn(() => {
				a();
			}),
			$n(() => {
				o("remove");
			}),
			zn(() => a()),
			ds(s, (t, r) => {
				e.updateAll && (null == n || n.registerLabelWidth(t, r));
			}),
			pR(
				ht(() => {
					var e, t;
					return null != (t = null == (e = i.value) ? void 0 : e.firstElementChild) ? t : null;
				}),
				a
			),
			() => {
				var o, a;
				if (!t) return null;
				const { isAutoWidth: l } = e;
				if (l) {
					const e = null == n ? void 0 : n.autoLabelWidth,
						a = {};
					if (e && "auto" !== e) {
						const t = Math.max(0, Number.parseInt(e, 10) - s.value),
							r = "left" === n.labelPosition ? "marginRight" : "marginLeft";
						t && (a[r] = `${t}px`);
					}
					return ri("div", { ref: i, class: [r.be("item", "label-wrap")], style: a }, [null == (o = t.default) ? void 0 : o.call(t)]);
				}
				return ri(Hr, { ref: i }, [null == (a = t.default) ? void 0 : a.call(t)]);
			}
		);
	}
});
const TX = ["role", "aria-labelledby"];
var kX = IB(
	Tn(
		c(u({}, { name: "ElFormItem" }), {
			props: SX,
			setup(e, { expose: t }) {
				const n = e,
					r = gs(),
					i = vn(GN, void 0),
					s = vn(YN, void 0),
					o = hD(void 0, { formItem: !1 }),
					a = BD("form-item"),
					l = gD().value,
					d = Qe([]),
					p = Qe(""),
					f = (function (e, t = 200, n = {}) {
						if (t <= 0) return e;
						const r = Qe(e.value),
							i = ZI(
								() => {
									r.value = e.value;
								},
								t,
								n
							);
						return ds(e, () => i()), r;
					})(p, 100),
					m = Qe(""),
					v = Qe();
				let g,
					y = !1;
				const b = ht(() => {
						if ("top" === (null == i ? void 0 : i.labelPosition)) return {};
						const e = KR(n.labelWidth || (null == i ? void 0 : i.labelWidth) || "");
						return e ? { width: e } : {};
					}),
					x = ht(() => {
						if ("top" === (null == i ? void 0 : i.labelPosition) || (null == i ? void 0 : i.inline)) return {};
						if (!n.label && !n.labelWidth && A) return {};
						const e = KR(n.labelWidth || (null == i ? void 0 : i.labelWidth) || "");
						return n.label || r.label ? {} : { marginLeft: e };
					}),
					_ = ht(() => [
						a.b(),
						a.m(o.value),
						a.is("error", "error" === p.value),
						a.is("validating", "validating" === p.value),
						a.is("success", "success" === p.value),
						a.is("required", L.value || n.required),
						a.is("no-asterisk", null == i ? void 0 : i.hideRequiredAsterisk),
						{ [a.m("feedback")]: null == i ? void 0 : i.statusIcon }
					]),
					w = ht(() => (YI(n.inlineMessage) ? n.inlineMessage : (null == i ? void 0 : i.inlineMessage) || !1)),
					C = ht(() => [a.e("error"), { [a.em("error", "inline")]: w.value }]),
					S = ht(() => (n.prop ? (SR(n.prop) ? n.prop : n.prop.join(".")) : "")),
					E = ht(() => !(!n.label && !r.label)),
					T = ht(() => (n.for || 1 === d.value.length ? d.value[0] : void 0)),
					k = ht(() => !T.value && E.value),
					A = !!s,
					M = ht(() => {
						const e = null == i ? void 0 : i.model;
						if (e && n.prop) return UR(e, n.prop).value;
					}),
					I = ht(() => {
						const e = n.rules ? zE(n.rules) : [],
							t = null == i ? void 0 : i.rules;
						if (t && n.prop) {
							const r = UR(t, n.prop).value;
							r && e.push(...zE(r));
						}
						return void 0 !== n.required && e.push({ required: !!n.required }), e;
					}),
					R = ht(() => I.value.length > 0),
					L = ht(() => I.value.some((e) => !0 === e.required)),
					O = ht(() => {
						var e;
						return "error" === f.value && n.showMessage && (null == (e = null == i ? void 0 : i.showMessage) || e);
					}),
					P = ht(() => `${n.label || ""}${(null == i ? void 0 : i.labelSuffix) || ""}`),
					N = (e) => {
						p.value = e;
					},
					D = async (e) => {
						const t = S.value;
						return new CX({ [t]: e })
							.validate({ [t]: M.value }, { firstFields: !0 })
							.then(() => (N("success"), null == i || i.emit("validate", n.prop, !0, ""), !0))
							.catch(
								(e) => (
									((e) => {
										var t, r;
										const { errors: s, fields: o } = e;
										(s && o) || console.error(e), N("error"), (m.value = s ? (null != (r = null == (t = null == s ? void 0 : s[0]) ? void 0 : t.message) ? r : `${n.prop} is required`) : ""), null == i || i.emit("validate", n.prop, !1, m.value);
									})(e),
									Promise.reject(e)
								)
							);
					},
					B = async (e, t) => {
						if (y) return (y = !1), !1;
						const n = CR(t);
						if (!R.value) return null == t || t(!1), !1;
						const r = ((e) =>
							I.value
								.filter((t) => !t.trigger || !e || (Array.isArray(t.trigger) ? t.trigger.includes(e) : t.trigger === e))
								.map((e) => {
									var t = e,
										{ trigger: n } = t;
									return h(t, ["trigger"]);
								}))(e);
						return 0 === r.length
							? (null == t || t(!0), !0)
							: (N("validating"),
							  D(r)
									.then(() => (null == t || t(!0), !0))
									.catch((e) => {
										const { fields: r } = e;
										return null == t || t(!1, r), !n && Promise.reject(r);
									}));
					},
					F = () => {
						N(""), (m.value = "");
					},
					H = async () => {
						const e = null == i ? void 0 : i.model;
						if (!e || !n.prop) return;
						const t = UR(e, n.prop);
						rk(t.value, g) || (y = !0), (t.value = ET(g)), await ns(), F();
					};
				ds(
					() => n.error,
					(e) => {
						(m.value = e || ""), N(e ? "error" : "");
					},
					{ immediate: !0 }
				),
					ds(
						() => n.validateStatus,
						(e) => N(e || "")
					);
				const V = Fe(
					c(u({}, at(n)), {
						$el: v,
						size: o,
						validateState: p,
						labelId: l,
						inputIds: d,
						isGroup: k,
						addInputId: (e) => {
							d.value.includes(e) || d.value.push(e);
						},
						removeInputId: (e) => {
							d.value = d.value.filter((t) => t !== e);
						},
						resetField: H,
						clearValidate: F,
						validate: B
					})
				);
				return (
					mn(YN, V),
					Vn(() => {
						n.prop && (null == i || i.addField(V), (g = ET(M.value)));
					}),
					$n(() => {
						null == i || i.removeField(V);
					}),
					t({ size: o, validateMessage: m, validateState: p, validate: B, clearValidate: F, resetField: H }),
					(e, t) => {
						var n;
						return (
							Wr(),
							Kr(
								"div",
								{ ref_key: "formItemRef", ref: v, class: gt(it(_)), role: it(k) ? "group" : void 0, "aria-labelledby": it(k) ? it(l) : void 0 },
								[
									ri(
										it(EX),
										{ "is-auto-width": "auto" === it(b).width, "update-all": "auto" === (null == (n = it(i)) ? void 0 : n.labelWidth) },
										{
											default: cn(() => [
												it(E)
													? (Wr(),
													  qr(Nr(it(T) ? "label" : "div"), { key: 0, id: it(l), for: it(T), class: gt(it(a).e("label")), style: pt(it(b)) }, { default: cn(() => [mi(e.$slots, "label", { label: it(P) }, () => [oi(bt(it(P)), 1)])]), _: 3 }, 8, [
															"id",
															"for",
															"class",
															"style"
													  ]))
													: ai("v-if", !0)
											]),
											_: 3
										},
										8,
										["is-auto-width", "update-all"]
									),
									ni(
										"div",
										{ class: gt(it(a).e("content")), style: pt(it(x)) },
										[
											mi(e.$slots, "default"),
											ri(lo, { name: `${it(a).namespace.value}-zoom-in-top` }, { default: cn(() => [it(O) ? mi(e.$slots, "error", { key: 0, error: m.value }, () => [ni("div", { class: gt(it(C)) }, bt(m.value), 3)]) : ai("v-if", !0)]), _: 3 }, 8, ["name"])
										],
										6
									)
								],
								10,
								TX
							)
						);
					}
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]
);
const AX = mN(JY, { FormItem: kX }),
	MX = gN(kX),
	IX = uN({
		urlList: { type: Array, default: () => [] },
		zIndex: { type: Number },
		initialIndex: { type: Number, default: 0 },
		infinite: { type: Boolean, default: !0 },
		hideOnClickModal: { type: Boolean, default: !1 },
		teleported: { type: Boolean, default: !1 },
		closeOnPressEscape: { type: Boolean, default: !0 }
	}),
	RX = ["src"];
const LX = mN(
		IB(
			Tn(
				c(u({}, { name: "ElImageViewer" }), {
					props: IX,
					emits: { close: () => !0, switch: (e) => "number" == typeof e },
					setup(e, { emit: t }) {
						const n = e,
							r = { CONTAIN: { name: "contain", icon: Ye(kO) }, ORIGINAL: { name: "original", icon: Ye(_P) } },
							i = LN() ? "DOMMouseScroll" : "mousewheel",
							{ t: s } = CD(),
							o = BD("image-viewer"),
							{ nextZIndex: a } = HD(),
							l = Qe(),
							h = Qe([]),
							d = new k(p);
						var p;
						const f = Qe(!0),
							m = Qe(n.initialIndex),
							v = et(r.CONTAIN),
							g = Qe({ scale: 1, deg: 0, offsetX: 0, offsetY: 0, enableTransition: !1 }),
							y = ht(() => {
								const { urlList: e } = n;
								return e.length <= 1;
							}),
							b = ht(() => 0 === m.value),
							x = ht(() => m.value === n.urlList.length - 1),
							_ = ht(() => n.urlList[m.value]),
							w = ht(() => {
								const { scale: e, deg: t, offsetX: n, offsetY: i, enableTransition: s } = g.value;
								let o = n / e,
									a = i / e;
								switch (t % 360) {
									case 90:
									case -270:
										[o, a] = [a, -o];
										break;
									case 180:
									case -180:
										[o, a] = [-o, -a];
										break;
									case 270:
									case -90:
										[o, a] = [-a, o];
								}
								const l = { transform: `scale(${e}) rotate(${t}deg) translate(${o}px, ${a}px)`, transition: s ? "transform .3s" : "" };
								return v.value.name === r.CONTAIN.name && (l.maxWidth = l.maxHeight = "100%"), l;
							}),
							C = ht(() => (XI(n.zIndex) ? n.zIndex : a()));
						function S() {
							d.stop(), t("close");
						}
						function E() {
							f.value = !1;
						}
						function T(e) {
							(f.value = !1), (e.target.alt = s("el.image.error"));
						}
						function A(e) {
							if (f.value || 0 !== e.button || !l.value) return;
							g.value.enableTransition = !1;
							const { offsetX: t, offsetY: n } = g.value,
								r = e.pageX,
								i = e.pageY,
								s = hk((e) => {
									g.value = c(u({}, g.value), { offsetX: t + e.pageX - r, offsetY: n + e.pageY - i });
								}),
								o = iR(document, "mousemove", s);
							iR(document, "mouseup", () => {
								o();
							}),
								e.preventDefault();
						}
						function M() {
							g.value = { scale: 1, deg: 0, offsetX: 0, offsetY: 0, enableTransition: !1 };
						}
						function I() {
							if (f.value) return;
							const e = VR(r),
								t = Object.values(r),
								n = v.value.name,
								i = (t.findIndex((e) => e.name === n) + 1) % e.length;
							(v.value = r[e[i]]), M();
						}
						function R() {
							if (b.value && !n.infinite) return;
							const e = n.urlList.length;
							m.value = (m.value - 1 + e) % e;
						}
						function L() {
							if (x.value && !n.infinite) return;
							const e = n.urlList.length;
							m.value = (m.value + 1) % e;
						}
						function O(e, t = {}) {
							if (f.value) return;
							const { zoomRate: n, rotateDeg: r, enableTransition: i } = u({ zoomRate: 1.4, rotateDeg: 90, enableTransition: !0 }, t);
							switch (e) {
								case "zoomOut":
									g.value.scale > 0.2 && (g.value.scale = Number.parseFloat((g.value.scale / n).toFixed(3)));
									break;
								case "zoomIn":
									g.value.scale < 7 && (g.value.scale = Number.parseFloat((g.value.scale * n).toFixed(3)));
									break;
								case "clockwise":
									g.value.deg += r;
									break;
								case "anticlockwise":
									g.value.deg -= r;
							}
							g.value.enableTransition = i;
						}
						return (
							ds(_, () => {
								ns(() => {
									const e = h.value[0];
									(null == e ? void 0 : e.complete) || (f.value = !0);
								});
							}),
							ds(m, (e) => {
								M(), t("switch", e);
							}),
							Vn(() => {
								var e, t;
								!(function () {
									const e = hk((e) => {
											switch (e.code) {
												case bN.esc:
													n.closeOnPressEscape && S();
													break;
												case bN.space:
													I();
													break;
												case bN.left:
													R();
													break;
												case bN.up:
													O("zoomIn");
													break;
												case bN.right:
													L();
													break;
												case bN.down:
													O("zoomOut");
											}
										}),
										t = hk((e) => {
											O((e.wheelDelta ? e.wheelDelta : -e.detail) > 0 ? "zoomIn" : "zoomOut", { zoomRate: 1.2, enableTransition: !1 });
										});
									d.run(() => {
										iR(document, "keydown", e), iR(document, i, t);
									});
								})(),
									null == (t = null == (e = l.value) ? void 0 : e.focus) || t.call(e);
							}),
							(e, t) => (
								Wr(),
								qr(
									Lr,
									{ to: "body", disabled: !e.teleported },
									[
										ri(
											lo,
											{ name: "viewer-fade", appear: "" },
											{
												default: cn(() => [
													ni(
														"div",
														{ ref_key: "wrapper", ref: l, tabindex: -1, class: gt(it(o).e("wrapper")), style: pt({ zIndex: it(C) }) },
														[
															ni("div", { class: gt(it(o).e("mask")), onClick: t[0] || (t[0] = zo((t) => e.hideOnClickModal && S(), ["self"])) }, null, 2),
															ai(" CLOSE "),
															ni("span", { class: gt([it(o).e("btn"), it(o).e("close")]), onClick: S }, [ri(it(OB), null, { default: cn(() => [ri(it(aO))]), _: 1 })], 2),
															ai(" ARROW "),
															it(y)
																? ai("v-if", !0)
																: (Wr(),
																  Kr(
																		Hr,
																		{ key: 0 },
																		[
																			ni("span", { class: gt([it(o).e("btn"), it(o).e("prev"), it(o).is("disabled", !e.infinite && it(b))]), onClick: R }, [ri(it(OB), null, { default: cn(() => [ri(it(uL))]), _: 1 })], 2),
																			ni("span", { class: gt([it(o).e("btn"), it(o).e("next"), it(o).is("disabled", !e.infinite && it(x))]), onClick: L }, [ri(it(OB), null, { default: cn(() => [ri(it(pL))]), _: 1 })], 2)
																		],
																		64
																  )),
															ai(" ACTIONS "),
															ni(
																"div",
																{ class: gt([it(o).e("btn"), it(o).e("actions")]) },
																[
																	ni(
																		"div",
																		{ class: gt(it(o).e("actions__inner")) },
																		[
																			ri(it(OB), { onClick: t[1] || (t[1] = (e) => O("zoomOut")) }, { default: cn(() => [ri(it(aN))]), _: 1 }),
																			ri(it(OB), { onClick: t[2] || (t[2] = (e) => O("zoomIn")) }, { default: cn(() => [ri(it(rN))]), _: 1 }),
																			ni("i", { class: gt(it(o).e("actions__divider")) }, null, 2),
																			ri(it(OB), { onClick: I }, { default: cn(() => [(Wr(), qr(Nr(it(v).icon)))]), _: 1 }),
																			ni("i", { class: gt(it(o).e("actions__divider")) }, null, 2),
																			ri(it(OB), { onClick: t[3] || (t[3] = (e) => O("anticlockwise")) }, { default: cn(() => [ri(it(pP))]), _: 1 }),
																			ri(it(OB), { onClick: t[4] || (t[4] = (e) => O("clockwise")) }, { default: cn(() => [ri(it(gP))]), _: 1 })
																		],
																		2
																	)
																],
																2
															),
															ai(" CANVAS "),
															ni(
																"div",
																{ class: gt(it(o).e("canvas")) },
																[
																	(Wr(!0),
																	Kr(
																		Hr,
																		null,
																		pi(e.urlList, (e, t) =>
																			yr((Wr(), Kr("img", { ref_for: !0, ref: (e) => (h.value[t] = e), key: e, src: e, style: pt(it(w)), class: gt(it(o).e("img")), onLoad: E, onError: T, onMousedown: A }, null, 46, RX)), [[Wo, t === m.value]])
																		),
																		128
																	))
																],
																2
															),
															mi(e.$slots, "default")
														],
														6
													)
												]),
												_: 3
											}
										)
									],
									8,
									["disabled"]
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]
		)
	),
	OX = uN({
		hideOnClickModal: { type: Boolean, default: !1 },
		src: { type: String, default: "" },
		fit: { type: String, values: ["", "contain", "cover", "fill", "none", "scale-down"], default: "" },
		loading: { type: String, values: ["eager", "lazy"] },
		lazy: { type: Boolean, default: !1 },
		scrollContainer: { type: [String, Object] },
		previewSrcList: { type: Array, default: () => [] },
		previewTeleported: { type: Boolean, default: !1 },
		zIndex: { type: Number },
		initialIndex: { type: Number, default: 0 },
		infinite: { type: Boolean, default: !0 },
		closeOnPressEscape: { type: Boolean, default: !0 }
	}),
	PX = { error: (e) => e instanceof Event, switch: (e) => XI(e), close: () => !0 },
	NX = ["src", "loading"],
	DX = { key: 0 };
const BX = mN(
		IB(
			Tn(
				c(u({}, { name: "ElImage", inheritAttrs: !1 }), {
					props: OX,
					emits: PX,
					setup(e, { emit: t }) {
						const n = e;
						let r = "";
						const { t: i } = CD(),
							s = BD("image"),
							o = ys(),
							a = HN(),
							l = Qe(),
							u = Qe(!1),
							c = Qe(!0),
							h = Qe(!1),
							d = Qe(),
							p = Qe(),
							f = GI && "loading" in HTMLImageElement.prototype;
						let m, v;
						const g = ht(() => o.style),
							y = ht(() => {
								const { fit: e } = n;
								return GI && e ? { objectFit: e } : {};
							}),
							b = ht(() => {
								const { previewSrcList: e } = n;
								return Array.isArray(e) && e.length > 0;
							}),
							x = ht(() => {
								const { previewSrcList: e, initialIndex: t } = n;
								let r = t;
								return t > e.length - 1 && (r = 0), r;
							}),
							_ = ht(() => "eager" !== n.loading && ((!f && "lazy" === n.loading) || n.lazy)),
							w = () => {
								GI && ((c.value = !0), (u.value = !1), (l.value = n.src));
							};
						function C() {
							(c.value = !1), (u.value = !1);
						}
						function S(e) {
							(c.value = !1), (u.value = !0), t("error", e);
						}
						function E() {
							((e, t) => {
								if (!GI || !e || !t) return !1;
								const n = e.getBoundingClientRect();
								let r;
								return (r = t instanceof Element ? t.getBoundingClientRect() : { top: 0, right: window.innerWidth, bottom: window.innerHeight, left: 0 }), n.top < r.bottom && n.bottom > r.top && n.right > r.left && n.left < r.right;
							})(d.value, p.value) && (w(), A());
						}
						const T = JI(E, 200);
						async function k() {
							var e;
							if (!GI) return;
							await ns();
							const { scrollContainer: t } = n;
							HR(t) ? (p.value = t) : SR(t) && "" !== t ? (p.value = null != (e = document.querySelector(t)) ? e : void 0) : d.value && (p.value = ZR(d.value)), p.value && ((m = iR(p, "scroll", T)), setTimeout(() => E(), 100));
						}
						function A() {
							GI && p.value && T && (null == m || m(), (p.value = void 0));
						}
						function M(e) {
							if (e.ctrlKey) return e.deltaY < 0 || e.deltaY > 0 ? (e.preventDefault(), !1) : void 0;
						}
						function I() {
							b.value && ((v = iR("wheel", M, { passive: !1 })), (r = document.body.style.overflow), (document.body.style.overflow = "hidden"), (h.value = !0));
						}
						function R() {
							null == v || v(), (document.body.style.overflow = r), (h.value = !1), t("close");
						}
						function L(e) {
							t("switch", e);
						}
						return (
							ds(
								() => n.src,
								() => {
									_.value ? ((c.value = !0), (u.value = !1), A(), k()) : w();
								}
							),
							Vn(() => {
								_.value ? k() : w();
							}),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{ ref_key: "container", ref: d, class: gt([it(s).b(), e.$attrs.class]), style: pt(it(g)) },
									[
										void 0 === l.value || u.value ? ai("v-if", !0) : (Wr(), Kr("img", hi({ key: 0 }, it(a), { src: l.value, loading: e.loading, style: it(y), class: [it(s).e("inner"), it(b) ? it(s).e("preview") : ""], onClick: I, onLoad: C, onError: S }), null, 16, NX)),
										c.value
											? mi(e.$slots, "placeholder", { key: 1 }, () => [ni("div", { class: gt(it(s).e("placeholder")) }, null, 2)])
											: u.value
											? mi(e.$slots, "error", { key: 2 }, () => [ni("div", { class: gt(it(s).e("error")) }, bt(it(i)("el.image.error")), 3)])
											: ai("v-if", !0),
										it(b)
											? (Wr(),
											  Kr(
													Hr,
													{ key: 3 },
													[
														h.value
															? (Wr(),
															  qr(
																	it(LX),
																	{
																		key: 0,
																		"z-index": e.zIndex,
																		"initial-index": it(x),
																		infinite: e.infinite,
																		"url-list": e.previewSrcList,
																		"hide-on-click-modal": e.hideOnClickModal,
																		teleported: e.previewTeleported,
																		"close-on-press-escape": e.closeOnPressEscape,
																		onClose: R,
																		onSwitch: L
																	},
																	{ default: cn(() => [e.$slots.viewer ? (Wr(), Kr("div", DX, [mi(e.$slots, "viewer")])) : ai("v-if", !0)]), _: 3 },
																	8,
																	["z-index", "initial-index", "infinite", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"]
															  ))
															: ai("v-if", !0)
													],
													64
											  ))
											: ai("v-if", !0)
									],
									6
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]
		)
	),
	FX = uN({
		id: { type: String, default: void 0 },
		step: { type: Number, default: 1 },
		stepStrictly: Boolean,
		max: { type: Number, default: Number.POSITIVE_INFINITY },
		min: { type: Number, default: Number.NEGATIVE_INFINITY },
		modelValue: Number,
		disabled: Boolean,
		size: cD,
		controls: { type: Boolean, default: !0 },
		controlsPosition: { type: String, default: "", values: ["", "right"] },
		valueOnClear: { type: [String, Number, null], validator: (e) => null === e || XI(e) || ["min", "max"].includes(e), default: null },
		name: String,
		label: String,
		placeholder: String,
		precision: { type: Number, validator: (e) => e >= 0 && e === Number.parseInt(`${e}`, 10) }
	}),
	HX = { change: (e, t) => e !== t, blur: (e) => e instanceof FocusEvent, focus: (e) => e instanceof FocusEvent, input: (e) => XI(e) || ik(e), [_N]: (e) => XI(e) || ik(e) },
	VX = ["aria-label", "onKeydown"],
	UX = ["aria-label", "onKeydown"];
const zX = mN(
		IB(
			Tn(
				c(u({}, { name: "ElInputNumber" }), {
					props: FX,
					emits: HX,
					setup(e, { expose: t, emit: n }) {
						const r = e,
							{ t: i } = CD(),
							s = BD("input-number"),
							o = Qe(),
							a = Fe({ currentValue: r.modelValue, userInput: null }),
							{ formItem: l } = yD(),
							u = ht(() => XI(r.modelValue) && y(r.modelValue, -1) < r.min),
							c = ht(() => XI(r.modelValue) && y(r.modelValue) > r.max),
							h = ht(() => {
								const e = g(r.step);
								return BR(r.precision) ? Math.max(g(r.modelValue), e) : (r.precision, r.precision);
							}),
							d = ht(() => r.controls && "right" === r.controlsPosition),
							p = hD(),
							f = dD(),
							m = ht(() => {
								if (null !== a.userInput) return a.userInput;
								let e = a.currentValue;
								if (ik(e)) return "";
								if (XI(e)) {
									if (Number.isNaN(e)) return "";
									BR(r.precision) || (e = e.toFixed(r.precision));
								}
								return e;
							}),
							v = (e, t) => {
								if ((BR(t) && (t = h.value), 0 === t)) return Math.round(e);
								let n = String(e);
								const r = n.indexOf(".");
								if (-1 === r) return e;
								if (!n.replace(".", "").split("")[r + t]) return e;
								const i = n.length;
								return "5" === n.charAt(i - 1) && (n = `${n.slice(0, Math.max(0, i - 1))}6`), Number.parseFloat(Number(n).toFixed(t));
							},
							g = (e) => {
								if (ik(e)) return 0;
								const t = e.toString(),
									n = t.indexOf(".");
								let r = 0;
								return -1 !== n && (r = t.length - n - 1), r;
							},
							y = (e, t = 1) => (XI(e) ? v(e + r.step * t) : a.currentValue),
							b = () => {
								if (f.value || c.value) return;
								const e = r.modelValue || 0,
									t = y(e);
								w(t);
							},
							x = () => {
								if (f.value || u.value) return;
								const e = r.modelValue || 0,
									t = y(e, -1);
								w(t);
							},
							_ = (e, t) => {
								const { max: i, min: s, step: o, precision: a, stepStrictly: l, valueOnClear: u } = r;
								let c = Number(e);
								if (ik(e) || Number.isNaN(c)) return null;
								if ("" === e) {
									if (null === u) return null;
									c = SR(u) ? { min: s, max: i }[u] : u;
								}
								return l && (c = Math.round(c / o) * o), BR(a) || (c = v(c, a)), (c > i || c < s) && ((c = c > i ? i : s), t && n("update:modelValue", c)), c;
							},
							w = (e) => {
								var t;
								const r = a.currentValue,
									i = _(e);
								r !== i && ((a.userInput = null), n("update:modelValue", i), n("input", i), n("change", i, r), null == (t = null == l ? void 0 : l.validate) || t.call(l, "change").catch((e) => {}), (a.currentValue = i));
							},
							C = (e) => (a.userInput = e),
							S = (e) => {
								const t = "" !== e ? Number(e) : "";
								((XI(t) && !Number.isNaN(t)) || "" === e) && w(t), (a.userInput = null);
							},
							E = (e) => {
								n("focus", e);
							},
							T = (e) => {
								var t;
								n("blur", e), null == (t = null == l ? void 0 : l.validate) || t.call(l, "blur").catch((e) => {});
							};
						return (
							ds(
								() => r.modelValue,
								(e) => {
									(a.currentValue = _(e, !0)), (a.userInput = null);
								},
								{ immediate: !0 }
							),
							Vn(() => {
								var e;
								const { min: t, max: i, modelValue: s } = r,
									l = null == (e = o.value) ? void 0 : e.input;
								if (
									(l.setAttribute("role", "spinbutton"),
									Number.isFinite(i) ? l.setAttribute("aria-valuemax", String(i)) : l.removeAttribute("aria-valuemax"),
									Number.isFinite(t) ? l.setAttribute("aria-valuemin", String(t)) : l.removeAttribute("aria-valuemin"),
									l.setAttribute("aria-valuenow", String(a.currentValue)),
									l.setAttribute("aria-disabled", String(f.value)),
									!XI(s) && null != s)
								) {
									let e = Number(s);
									Number.isNaN(e) && (e = null), n("update:modelValue", e);
								}
							}),
							zn(() => {
								var e;
								const t = null == (e = o.value) ? void 0 : e.input;
								null == t || t.setAttribute("aria-valuenow", `${a.currentValue}`);
							}),
							t({
								focus: () => {
									var e, t;
									null == (t = null == (e = o.value) ? void 0 : e.focus) || t.call(e);
								},
								blur: () => {
									var e, t;
									null == (t = null == (e = o.value) ? void 0 : e.blur) || t.call(e);
								}
							}),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{ class: gt([it(s).b(), it(s).m(it(p)), it(s).is("disabled", it(f)), it(s).is("without-controls", !e.controls), it(s).is("controls-right", it(d))]), onDragstart: t[0] || (t[0] = zo(() => {}, ["prevent"])) },
									[
										e.controls
											? yr(
													(Wr(),
													Kr(
														"span",
														{ key: 0, role: "button", "aria-label": it(i)("el.inputNumber.decrease"), class: gt([it(s).e("decrease"), it(s).is("disabled", it(u))]), onKeydown: jo(x, ["enter"]) },
														[ri(it(OB), null, { default: cn(() => [it(d) ? (Wr(), qr(it(sL), { key: 0 })) : (Wr(), qr(it($O), { key: 1 }))]), _: 1 })],
														42,
														VX
													)),
													[[it(SU), x]]
											  )
											: ai("v-if", !0),
										e.controls
											? yr(
													(Wr(),
													Kr(
														"span",
														{ key: 1, role: "button", "aria-label": it(i)("el.inputNumber.increase"), class: gt([it(s).e("increase"), it(s).is("disabled", it(c))]), onKeydown: jo(b, ["enter"]) },
														[ri(it(OB), null, { default: cn(() => [it(d) ? (Wr(), qr(it(gL), { key: 0 })) : (Wr(), qr(it(sP), { key: 1 }))]), _: 1 })],
														42,
														UX
													)),
													[[it(SU), b]]
											  )
											: ai("v-if", !0),
										ri(
											it(WB),
											{
												id: e.id,
												ref_key: "input",
												ref: o,
												type: "number",
												step: e.step,
												"model-value": it(m),
												placeholder: e.placeholder,
												disabled: it(f),
												size: it(p),
												max: e.max,
												min: e.min,
												name: e.name,
												label: e.label,
												"validate-event": !1,
												onKeydown: [jo(zo(b, ["prevent"]), ["up"]), jo(zo(x, ["prevent"]), ["down"])],
												onBlur: T,
												onFocus: E,
												onInput: C,
												onChange: S
											},
											null,
											8,
											["id", "step", "model-value", "placeholder", "disabled", "size", "max", "min", "name", "label", "onKeydown"]
										)
									],
									34
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]
		)
	),
	$X = uN({ type: { type: String, values: ["primary", "success", "warning", "info", "danger", "default"], default: "default" }, underline: { type: Boolean, default: !0 }, disabled: { type: Boolean, default: !1 }, href: { type: String, default: "" }, icon: { type: cN, default: "" } }),
	jX = { click: (e) => e instanceof MouseEvent },
	WX = ["href"];
const GX = mN(
	IB(
		Tn(
			c(u({}, { name: "ElLink" }), {
				props: $X,
				emits: jX,
				setup(e, { emit: t }) {
					const n = e,
						r = BD("link");
					function i(e) {
						n.disabled || t("click", e);
					}
					return (e, t) => (
						Wr(),
						Kr(
							"a",
							{ class: gt([it(r).b(), it(r).m(e.type), it(r).is("disabled", e.disabled), it(r).is("underline", e.underline && !e.disabled)]), href: e.disabled || !e.href ? void 0 : e.href, onClick: i },
							[
								e.icon ? (Wr(), qr(it(OB), { key: 0 }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 })) : ai("v-if", !0),
								e.$slots.default ? (Wr(), Kr("span", { key: 1, class: gt(it(r).e("inner")) }, [mi(e.$slots, "default")], 2)) : ai("v-if", !0),
								e.$slots.icon ? mi(e.$slots, "icon", { key: 2 }) : ai("v-if", !0)
							],
							10,
							WX
						)
					);
				}
			})
		),
		[["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]
	)
);
class YX {
	constructor(e, t) {
		(this.parent = e), (this.domNode = t), (this.subIndex = 0), (this.subIndex = 0), this.init();
	}
	init() {
		(this.subMenuItems = this.domNode.querySelectorAll("li")), this.addListeners();
	}
	gotoSubIndex(e) {
		e === this.subMenuItems.length ? (e = 0) : e < 0 && (e = this.subMenuItems.length - 1), this.subMenuItems[e].focus(), (this.subIndex = e);
	}
	addListeners() {
		const e = this.parent.domNode;
		Array.prototype.forEach.call(this.subMenuItems, (t) => {
			t.addEventListener("keydown", (t) => {
				let n = !1;
				switch (t.code) {
					case bN.down:
						this.gotoSubIndex(this.subIndex + 1), (n = !0);
						break;
					case bN.up:
						this.gotoSubIndex(this.subIndex - 1), (n = !0);
						break;
					case bN.tab:
						kI(e, "mouseleave");
						break;
					case bN.enter:
					case bN.space:
						(n = !0), t.currentTarget.click();
				}
				return n && (t.preventDefault(), t.stopPropagation()), !1;
			});
		});
	}
}
class XX {
	constructor(e, t) {
		(this.domNode = e), (this.submenu = null), (this.submenu = null), this.init(t);
	}
	init(e) {
		this.domNode.setAttribute("tabindex", "0");
		const t = this.domNode.querySelector(`.${e}-menu`);
		t && (this.submenu = new YX(this, t)), this.addListeners();
	}
	addListeners() {
		this.domNode.addEventListener("keydown", (e) => {
			let t = !1;
			switch (e.code) {
				case bN.down:
					kI(e.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), (t = !0);
					break;
				case bN.up:
					kI(e.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), (t = !0);
					break;
				case bN.tab:
					kI(e.currentTarget, "mouseleave");
					break;
				case bN.enter:
				case bN.space:
					(t = !0), e.currentTarget.click();
			}
			t && e.preventDefault();
		});
	}
}
class KX {
	constructor(e, t) {
		(this.domNode = e), this.init(t);
	}
	init(e) {
		const t = this.domNode.childNodes;
		Array.from(t).forEach((t) => {
			1 === t.nodeType && new XX(t, e);
		});
	}
}
var qX = IB(
	Tn({
		name: "ElMenuCollapseTransition",
		setup() {
			const e = BD("menu");
			return {
				listeners: {
					onBeforeEnter: (e) => (e.style.opacity = "0.2"),
					onEnter(t, n) {
						GR(t, `${e.namespace.value}-opacity-transition`), (t.style.opacity = "1"), n();
					},
					onAfterEnter(t) {
						YR(t, `${e.namespace.value}-opacity-transition`), (t.style.opacity = "");
					},
					onBeforeLeave(t) {
						t.dataset || (t.dataset = {}),
							WR(t, e.m("collapse"))
								? (YR(t, e.m("collapse")), (t.dataset.oldOverflow = t.style.overflow), (t.dataset.scrollWidth = t.clientWidth.toString()), GR(t, e.m("collapse")))
								: (GR(t, e.m("collapse")), (t.dataset.oldOverflow = t.style.overflow), (t.dataset.scrollWidth = t.clientWidth.toString()), YR(t, e.m("collapse"))),
							(t.style.width = `${t.scrollWidth}px`),
							(t.style.overflow = "hidden");
					},
					onLeave(e) {
						GR(e, "horizontal-collapse-transition"), (e.style.width = `${e.dataset.scrollWidth}px`);
					}
				}
			};
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), qr(lo, hi({ mode: "out-in" }, e.listeners), { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 16);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]
	]
);
function ZX(e, t) {
	const n = ht(() => {
		let n = e.parent;
		const r = [t.value];
		for (; "ElMenu" !== n.type.name; ) n.props.index && r.unshift(n.props.index), (n = n.parent);
		return r;
	});
	return {
		parentMenu: ht(() => {
			let t = e.parent;
			for (; t && !["ElMenu", "ElSubMenu"].includes(t.type.name); ) t = t.parent;
			return t;
		}),
		indexPath: n
	};
}
function JX(e) {
	return ht(() => {
		const t = e.backgroundColor;
		return t ? new jV(t).shade(20).toString() : "";
	});
}
const QX = (e, t) => {
		const n = BD("menu");
		return ht(() => n.cssVarBlock({ "text-color": e.textColor || "", "hover-text-color": e.textColor || "", "bg-color": e.backgroundColor || "", "hover-bg-color": JX(e).value || "", "active-color": e.activeTextColor || "", level: `${t}` }));
	},
	eK = uN({ index: { type: String, required: !0 }, showTimeout: { type: Number, default: 300 }, hideTimeout: { type: Number, default: 300 }, popperClass: String, disabled: Boolean, popperAppendToBody: { type: Boolean, default: void 0 }, popperOffset: { type: Number, default: 6 } });
var tK = Tn({
	name: "ElSubMenu",
	props: eK,
	setup(e, { slots: t, expose: n }) {
		const r = Si(),
			{ indexPath: i, parentMenu: s } = ZX(
				r,
				ht(() => e.index)
			),
			o = BD("menu"),
			a = BD("sub-menu"),
			l = vn("rootMenu");
		l || $R("ElSubMenu", "can not inject root menu");
		const u = vn(`subMenu:${s.value.uid}`);
		u || $R("ElSubMenu", "can not inject sub menu");
		const c = Qe({}),
			h = Qe({});
		let d;
		const p = Qe(!1),
			f = Qe(),
			m = Qe(null),
			v = ht(() => ("horizontal" === k.value && y.value ? "bottom-start" : "right-start")),
			g = ht(() => (("horizontal" === k.value && y.value) || ("vertical" === k.value && !l.props.collapse) ? sL : pL)),
			y = ht(() => 0 === u.level),
			b = ht(() => (void 0 === e.popperAppendToBody ? y.value : Boolean(e.popperAppendToBody))),
			x = ht(() => (l.props.collapse ? `${o.namespace.value}-zoom-in-left` : `${o.namespace.value}-zoom-in-top`)),
			_ = ht(() => ("horizontal" === k.value && y.value ? ["bottom-start", "bottom-end", "top-start", "top-end", "right-start", "left-start"] : ["right-start", "left-start", "bottom-start", "bottom-end", "top-start", "top-end"])),
			w = ht(() => l.openedMenus.includes(e.index)),
			C = ht(() => {
				let e = !1;
				return (
					Object.values(c.value).forEach((t) => {
						t.active && (e = !0);
					}),
					Object.values(h.value).forEach((t) => {
						t.active && (e = !0);
					}),
					e
				);
			}),
			S = ht(() => l.props.backgroundColor || ""),
			E = ht(() => l.props.activeTextColor || ""),
			T = ht(() => l.props.textColor || ""),
			k = ht(() => l.props.mode),
			A = Fe({ index: e.index, indexPath: i, active: C }),
			M = ht(() => ("horizontal" !== k.value ? { color: T.value } : { borderBottomColor: C.value ? (l.props.activeTextColor ? E.value : "") : "transparent", color: C.value ? E.value : T.value })),
			I = (e) => {
				var t, n, r;
				e || null == (r = null == (n = null == (t = m.value) ? void 0 : t.popperRef) ? void 0 : n.popperInstanceRef) || r.destroy();
			},
			R = () => {
				("hover" === l.props.menuTrigger && "horizontal" === l.props.mode) || (l.props.collapse && "vertical" === l.props.mode) || e.disabled || l.handleSubMenuClick({ index: e.index, indexPath: i.value, active: C.value });
			},
			L = (t, n = e.showTimeout) => {
				var r;
				("focus" !== t.type || t.relatedTarget) &&
					(("click" === l.props.menuTrigger && "horizontal" === l.props.mode) ||
						(!l.props.collapse && "vertical" === l.props.mode) ||
						e.disabled ||
						((u.mouseInChild.value = !0),
						null == d || d(),
						({ stop: d } = eR(() => {
							l.openMenu(e.index, i.value);
						}, n)),
						b.value && (null == (r = s.value.vnode.el) || r.dispatchEvent(new MouseEvent("mouseenter")))));
			},
			O = (t = !1) => {
				var n, s;
				("click" === l.props.menuTrigger && "horizontal" === l.props.mode) ||
					(!l.props.collapse && "vertical" === l.props.mode) ||
					(null == d || d(), (u.mouseInChild.value = !1), ({ stop: d } = eR(() => !p.value && l.closeMenu(e.index, i.value), e.hideTimeout)), b.value && t && "ElSubMenu" === (null == (n = r.parent) ? void 0 : n.type.name) && (null == (s = u.handleMouseleave) || s.call(u, !0)));
			};
		ds(
			() => l.props.collapse,
			(e) => I(Boolean(e))
		);
		{
			const e = (e) => {
					h.value[e.index] = e;
				},
				t = (e) => {
					delete h.value[e.index];
				};
			mn(`subMenu:${r.uid}`, { addSubMenu: e, removeSubMenu: t, handleMouseleave: O, mouseInChild: p, level: u.level + 1 });
		}
		return (
			n({ opened: w }),
			Vn(() => {
				l.addSubMenu(A), u.addSubMenu(A);
			}),
			$n(() => {
				u.removeSubMenu(A), l.removeSubMenu(A);
			}),
			() => {
				var n;
				const r = [null == (n = t.title) ? void 0 : n.call(t), xs(OB, { class: a.e("icon-arrow") }, { default: () => xs(g.value) })],
					i = QX(l.props, u.level + 1),
					s = l.isMenuPopup
						? xs(
								QH,
								{ ref: m, visible: w.value, effect: "light", pure: !0, offset: e.popperOffset, showArrow: !1, persistent: !0, popperClass: e.popperClass, placement: v.value, teleported: b.value, fallbackPlacements: _.value, transition: x.value, gpuAcceleration: !1 },
								{
									content: () => {
										var n;
										return xs("div", { class: [o.m(k.value), o.m("popup-container"), e.popperClass], onMouseenter: (e) => L(e, 100), onMouseleave: () => O(!0), onFocus: (e) => L(e, 100) }, [
											xs("ul", { class: [o.b(), o.m("popup"), o.m(`popup-${v.value}`)], style: i.value }, [null == (n = t.default) ? void 0 : n.call(t)])
										]);
									},
									default: () => xs("div", { class: a.e("title"), style: [M.value, { backgroundColor: S.value }], onClick: R }, r)
								}
						  )
						: xs(Hr, {}, [
								xs("div", { class: a.e("title"), style: [M.value, { backgroundColor: S.value }], ref: f, onClick: R }, r),
								xs(
									ej,
									{},
									{
										default: () => {
											var e;
											return yr(xs("ul", { role: "menu", class: [o.b(), o.m("inline")], style: i.value }, [null == (e = t.default) ? void 0 : e.call(t)]), [[Wo, w.value]]);
										}
									}
								)
						  ]);
				return xs("li", { class: [a.b(), a.is("active", C.value), a.is("opened", w.value), a.is("disabled", e.disabled)], role: "menuitem", ariaHaspopup: !0, ariaExpanded: w.value, onMouseenter: L, onMouseleave: () => O(!0), onFocus: L }, [s]);
			}
		);
	}
});
const nK = uN({
		mode: { type: String, values: ["horizontal", "vertical"], default: "vertical" },
		defaultActive: { type: String, default: "" },
		defaultOpeneds: { type: Array, default: () => [] },
		uniqueOpened: Boolean,
		router: Boolean,
		menuTrigger: { type: String, values: ["hover", "click"], default: "hover" },
		collapse: Boolean,
		backgroundColor: String,
		textColor: String,
		activeTextColor: String,
		collapseTransition: { type: Boolean, default: !0 },
		ellipsis: { type: Boolean, default: !0 }
	}),
	rK = (e) => Array.isArray(e) && e.every((e) => SR(e));
var iK = Tn({
	name: "ElMenu",
	props: nK,
	emits: { close: (e, t) => SR(e) && rK(t), open: (e, t) => SR(e) && rK(t), select: (e, t, n, r) => SR(e) && rK(t) && ER(n) && (void 0 === r || r instanceof Promise) },
	setup(e, { emit: t, slots: n, expose: r }) {
		const i = Si(),
			s = i.appContext.config.globalProperties.$router,
			o = Qe(),
			a = BD("menu"),
			l = BD("sub-menu"),
			u = Qe(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []),
			c = Qe(e.defaultActive),
			h = Qe({}),
			d = Qe({}),
			p = ht(() => "horizontal" === e.mode || ("vertical" === e.mode && e.collapse)),
			f = () => {
				const t = c.value && h.value[c.value];
				if (!t || "horizontal" === e.mode || e.collapse) return;
				t.indexPath.forEach((e) => {
					const t = d.value[e];
					t && m(e, t.indexPath);
				});
			},
			m = (n, r) => {
				u.value.includes(n) || (e.uniqueOpened && (u.value = u.value.filter((e) => r.includes(e))), u.value.push(n), t("open", n, r));
			},
			v = (e, n) => {
				const r = u.value.indexOf(e);
				-1 !== r && u.value.splice(r, 1), t("close", e, n);
			},
			g = ({ index: e, indexPath: t }) => {
				u.value.includes(e) ? v(e, t) : m(e, t);
			},
			y = (n) => {
				("horizontal" === e.mode || e.collapse) && (u.value = []);
				const { index: r, indexPath: i } = n;
				if (void 0 !== r && void 0 !== i)
					if (e.router && s) {
						const e = n.route || r,
							o = s.push(e).then((e) => (e || (c.value = r), e));
						t("select", r, i, { index: r, indexPath: i, route: e }, o);
					} else (c.value = r), t("select", r, i, { index: r, indexPath: i });
			},
			b = () => {
				ns(() => i.proxy.$forceUpdate());
			};
		ds(
			() => e.defaultActive,
			(t) => {
				h.value[t] || (c.value = ""),
					((t) => {
						const n = h.value,
							r = n[t] || (c.value && n[c.value]) || n[e.defaultActive];
						r ? ((c.value = r.index), f()) : (c.value = t);
					})(t);
			}
		),
			ds(h.value, () => f()),
			ds(
				() => e.collapse,
				(e) => {
					e && (u.value = []);
				}
			);
		{
			const t = (e) => {
					d.value[e.index] = e;
				},
				n = (e) => {
					delete d.value[e.index];
				},
				r = (e) => {
					h.value[e.index] = e;
				},
				s = (e) => {
					delete h.value[e.index];
				};
			mn("rootMenu", Fe({ props: e, openedMenus: u, items: h, subMenus: d, activeIndex: c, isMenuPopup: p, addMenuItem: r, removeMenuItem: s, addSubMenu: t, removeSubMenu: n, openMenu: m, closeMenu: v, handleMenuItemClick: y, handleSubMenuClick: g })),
				mn(`subMenu:${i.uid}`, { addSubMenu: t, removeSubMenu: n, mouseInChild: Qe(!1), level: 0 });
		}
		Vn(() => {
			f(), "horizontal" === e.mode && new KX(i.vnode.el, a.namespace.value);
		});
		r({
			open: (e) => {
				const { indexPath: t } = d.value[e];
				t.forEach((e) => m(e, t));
			},
			close: v,
			handleResize: b
		});
		const x = (e) => {
			const t = Array.isArray(e) ? e : [e],
				n = [];
			return (
				t.forEach((e) => {
					Array.isArray(e.children) ? n.push(...x(e.children)) : n.push(e);
				}),
				n
			);
		};
		return () => {
			var t, r, i, s;
			let u = null != (r = null == (t = n.default) ? void 0 : t.call(n)) ? r : [];
			const c = [];
			if ("horizontal" === e.mode && o.value) {
				const t = Array.from(null != (s = null == (i = o.value) ? void 0 : i.childNodes) ? s : []).filter((e) => "#text" !== e.nodeName || e.nodeValue),
					n = x(u),
					r = 64,
					a = Number.parseInt(getComputedStyle(o.value).paddingLeft, 10),
					h = Number.parseInt(getComputedStyle(o.value).paddingRight, 10),
					d = o.value.clientWidth - a - h;
				let p = 0,
					f = 0;
				t.forEach((e, t) => {
					(p += e.offsetWidth || 0), p <= d - r && (f = t + 1);
				});
				const m = n.slice(0, f),
					v = n.slice(f);
				(null == v ? void 0 : v.length) && e.ellipsis && ((u = m), c.push(xs(tK, { index: "sub-menu-more", class: l.e("hide-arrow") }, { title: () => xs(OB, { class: l.e("icon-more") }, { default: () => xs(ZO) }), default: () => v })));
			}
			const h = QX(e, 0),
				d = ((p = xs("ul", { key: String(e.collapse), role: "menubar", ref: o, style: h.value, class: { [a.b()]: !0, [a.m(e.mode)]: !0, [a.m("collapse")]: e.collapse } }, [...u, ...c])), e.ellipsis ? ((f = p), "horizontal" === e.mode ? yr(f, [[ez, b]]) : f) : p);
			var p, f;
			return e.collapseTransition && "vertical" === e.mode ? xs(qX, () => d) : d;
		};
	}
});
const sK = uN({ index: { type: [String, null], default: null }, route: { type: [String, Object] }, disabled: Boolean });
var oK = IB(
	Tn({
		name: "ElMenuItem",
		components: { ElTooltip: QH },
		props: sK,
		emits: { click: (e) => SR(e.index) && Array.isArray(e.indexPath) },
		setup(e, { emit: t }) {
			const n = Si(),
				r = vn("rootMenu"),
				i = BD("menu"),
				s = BD("menu-item");
			r || $R("ElMenuItem", "can not inject root menu");
			const { parentMenu: o, indexPath: a } = ZX(n, ut(e, "index")),
				l = vn(`subMenu:${o.value.uid}`);
			l || $R("ElMenuItem", "can not inject sub menu");
			const u = ht(() => e.index === r.activeIndex),
				c = Fe({ index: e.index, indexPath: a, active: u });
			return (
				Vn(() => {
					l.addSubMenu(c), r.addMenuItem(c);
				}),
				$n(() => {
					l.removeSubMenu(c), r.removeMenuItem(c);
				}),
				{
					Effect: JB,
					parentMenu: o,
					rootMenu: r,
					active: u,
					nsMenu: i,
					nsMenuItem: s,
					handleClick: () => {
						e.disabled || (r.handleMenuItemClick({ index: e.index, indexPath: a.value, route: e.route }), t("click", c));
					}
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-tooltip");
				return (
					Wr(),
					Kr(
						"li",
						{ class: gt([e.nsMenuItem.b(), e.nsMenuItem.is("active", e.active), e.nsMenuItem.is("disabled", e.disabled)]), role: "menuitem", tabindex: "-1", onClick: t[0] || (t[0] = (...t) => e.handleClick && e.handleClick(...t)) },
						[
							"ElMenu" === e.parentMenu.type.name && e.rootMenu.props.collapse && e.$slots.title
								? (Wr(),
								  qr(
										o,
										{ key: 0, effect: e.Effect.DARK, placement: "right", "fallback-placements": ["left"], persistent: "" },
										{ content: cn(() => [mi(e.$slots, "title")]), default: cn(() => [ni("div", { class: gt(e.nsMenu.be("tooltip", "trigger")) }, [mi(e.$slots, "default")], 2)]), _: 3 },
										8,
										["effect"]
								  ))
								: (Wr(), Kr(Hr, { key: 1 }, [mi(e.$slots, "default"), mi(e.$slots, "title")], 64))
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]
	]
);
var aK = IB(Tn({ name: "ElMenuItemGroup", props: { title: String }, setup: () => ({ ns: BD("menu-item-group") }) }), [
	[
		"render",
		function (e, t, n, r, i, s) {
			return Wr(), Kr("li", { class: gt(e.ns.b()) }, [ni("div", { class: gt(e.ns.e("title")) }, [e.$slots.title ? mi(e.$slots, "title", { key: 1 }) : (Wr(), Kr(Hr, { key: 0 }, [oi(bt(e.title), 1)], 64))], 2), ni("ul", null, [mi(e.$slots, "default")])], 2);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]
]);
const lK = mN(iK, { MenuItem: oK, MenuItemGroup: aK, SubMenu: tK }),
	uK = gN(oK),
	cK = gN(aK);
gN(tK);
const hK = uN({ icon: { type: cN, default: () => _L }, title: String, content: { type: String, default: "" } });
const dK = mN(
		IB(
			Tn(
				c(u({}, { name: "ElPageHeader" }), {
					props: hK,
					emits: { back: () => !0 },
					setup(e, { emit: t }) {
						const { t: n } = CD(),
							r = BD("page-header");
						function i() {
							t("back");
						}
						return (e, t) => (
							Wr(),
							Kr(
								"div",
								{ class: gt(it(r).b()) },
								[
									ni(
										"div",
										{ class: gt(it(r).e("left")), onClick: i },
										[
											e.icon || e.$slots.icon ? (Wr(), Kr("div", { key: 0, class: gt(it(r).e("icon")) }, [mi(e.$slots, "icon", {}, () => [e.icon ? (Wr(), qr(it(OB), { key: 0 }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 })) : ai("v-if", !0)])], 2)) : ai("v-if", !0),
											ni("div", { class: gt(it(r).e("title")) }, [mi(e.$slots, "title", {}, () => [oi(bt(e.title || it(n)("el.pageHeader.title")), 1)])], 2)
										],
										2
									),
									ni("div", { class: gt(it(r).e("content")) }, [mi(e.$slots, "content", {}, () => [oi(bt(e.content), 1)])], 2)
								],
								2
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]
		)
	),
	pK = uN({ disabled: Boolean, currentPage: { type: Number, default: 1 }, prevText: { type: String } }),
	fK = { click: (e) => e instanceof MouseEvent },
	mK = ["disabled", "aria-disabled"],
	vK = { key: 0 };
var gK = IB(
	Tn(
		c(u({}, { name: "ElPaginationPrev" }), {
			props: pK,
			emits: fK,
			setup(e) {
				const t = e,
					n = ht(() => t.disabled || t.currentPage <= 1);
				return (e, t) => (
					Wr(),
					Kr(
						"button",
						{ type: "button", class: "btn-prev", disabled: it(n), "aria-disabled": it(n), onClick: t[0] || (t[0] = (t) => e.$emit("click", t)) },
						[e.prevText ? (Wr(), Kr("span", vK, bt(e.prevText), 1)) : (Wr(), qr(it(OB), { key: 1 }, { default: cn(() => [ri(it(uL))]), _: 1 }))],
						8,
						mK
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]
);
const yK = uN({ disabled: Boolean, currentPage: { type: Number, default: 1 }, pageCount: { type: Number, default: 50 }, nextText: { type: String } }),
	bK = ["disabled", "aria-disabled"],
	xK = { key: 0 };
var _K = IB(
	Tn(
		c(u({}, { name: "ElPaginationNext" }), {
			props: yK,
			emits: ["click"],
			setup(e) {
				const t = e,
					n = ht(() => t.disabled || t.currentPage === t.pageCount || 0 === t.pageCount);
				return (e, t) => (
					Wr(),
					Kr(
						"button",
						{ type: "button", class: "btn-next", disabled: it(n), "aria-disabled": it(n), onClick: t[0] || (t[0] = (t) => e.$emit("click", t)) },
						[e.nextText ? (Wr(), Kr("span", xK, bt(e.nextText), 1)) : (Wr(), qr(it(OB), { key: 1 }, { default: cn(() => [ri(it(pL))]), _: 1 }))],
						8,
						bK
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]
);
var wK = IB(
	Tn({
		name: "ElOption",
		componentName: "ElOption",
		props: { value: { required: !0, type: [String, Number, Boolean, Object] }, label: [String, Number], created: Boolean, disabled: { type: Boolean, default: !1 } },
		setup(e) {
			const t = BD("select"),
				n = Fe({ index: -1, groupDisabled: !1, visible: !0, hitState: !1, hover: !1 }),
				{
					currentLabel: r,
					itemSelected: i,
					isDisabled: s,
					select: o,
					hoverItem: a
				} = (function (e, t) {
					const n = vn("ElSelect"),
						r = vn("ElSelectGroup", { disabled: !1 }),
						i = ht(() => "[object object]" === Object.prototype.toString.call(e.value).toLowerCase()),
						s = ht(() => (n.props.multiple ? h(n.props.modelValue, e.value) : d(e.value, n.props.modelValue))),
						o = ht(() => {
							if (n.props.multiple) {
								const e = n.props.modelValue || [];
								return !s.value && e.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
							}
							return !1;
						}),
						a = ht(() => e.label || (i.value ? "" : e.value)),
						l = ht(() => e.value || e.label || ""),
						u = ht(() => e.disabled || t.groupDisabled || o.value),
						c = Si(),
						h = (e = [], t) => {
							if (i.value) {
								const r = n.props.valueKey;
								return e && e.some((e) => XS(e, r) === XS(t, r));
							}
							return e && e.includes(t);
						},
						d = (e, t) => {
							if (i.value) {
								const { valueKey: r } = n.props;
								return XS(e, r) === XS(t, r);
							}
							return e === t;
						};
					ds(
						() => a.value,
						() => {
							e.created || n.props.remote || n.setSelected();
						}
					),
						ds(
							() => e.value,
							(t, r) => {
								const { remote: i, valueKey: s } = n.props;
								if (!e.created && !i) {
									if (s && "object" == typeof t && "object" == typeof r && t[s] === r[s]) return;
									n.setSelected();
								}
							}
						),
						ds(
							() => r.disabled,
							() => {
								t.groupDisabled = r.disabled;
							},
							{ immediate: !0 }
						);
					const { queryChange: p } = Ge(n);
					return (
						ds(p, (r) => {
							const { query: i } = it(r),
								s = new RegExp(((e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"))(i), "i");
							(t.visible = s.test(a.value) || e.created), t.visible || n.filteredOptionsCount--;
						}),
						{
							select: n,
							currentLabel: a,
							currentValue: l,
							itemSelected: s,
							isDisabled: u,
							hoverItem: () => {
								e.disabled || r.disabled || (n.hoverIndex = n.optionsArray.indexOf(c.proxy));
							}
						}
					);
				})(e, n),
				{ visible: l, hover: u } = at(n),
				c = Si().proxy,
				h = c.value;
			return (
				o.onOptionCreate(c),
				$n(() => {
					const { selected: e } = o,
						t = (o.props.multiple ? e : [e]).some((e) => e.value === c.value);
					o.cachedOptions.get(h) !== c ||
						t ||
						ns(() => {
							o.cachedOptions.delete(h);
						}),
						o.onOptionDestroy(h, c);
				}),
				{
					ns: t,
					currentLabel: r,
					itemSelected: i,
					isDisabled: s,
					select: o,
					hoverItem: a,
					visible: l,
					hover: u,
					selectOptionClick: function () {
						!0 !== e.disabled && !0 !== n.groupDisabled && o.handleOptionSelect(c, !0);
					},
					states: n
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return yr(
					(Wr(),
					Kr(
						"li",
						{
							class: gt([e.ns.be("dropdown", "item"), e.ns.is("disabled", e.isDisabled), { selected: e.itemSelected, hover: e.hover }]),
							onMouseenter: t[0] || (t[0] = (...t) => e.hoverItem && e.hoverItem(...t)),
							onClick: t[1] || (t[1] = zo((...t) => e.selectOptionClick && e.selectOptionClick(...t), ["stop"]))
						},
						[mi(e.$slots, "default", {}, () => [ni("span", null, bt(e.currentLabel), 1)])],
						34
					)),
					[[Wo, e.visible]]
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]
	]
);
const CK = Tn({
	name: "ElSelectDropdown",
	componentName: "ElSelectDropdown",
	setup() {
		const e = vn("ElSelect"),
			t = BD("select"),
			n = ht(() => e.props.popperClass),
			r = ht(() => e.props.multiple),
			i = ht(() => e.props.fitInputWidth),
			s = Qe("");
		function o() {
			var t;
			s.value = `${null == (t = e.selectWrapper) ? void 0 : t.getBoundingClientRect().width}px`;
		}
		return (
			Vn(() => {
				o(), pR(e.selectWrapper, o);
			}),
			{ ns: t, minWidth: s, popperClass: n, isMultiple: r, isFitInputWidth: i }
		);
	}
});
const SK = (e, t, n) => {
		const { t: r } = CD(),
			i = BD("select"),
			s = Qe(null),
			o = Qe(null),
			a = Qe(null),
			l = Qe(null),
			u = Qe(null),
			c = Qe(null),
			h = Qe(-1),
			d = et({ query: "" }),
			p = et(""),
			f = vn(GN, {}),
			m = vn(YN, {}),
			v = ht(() => !e.filterable || e.multiple || !t.visible),
			g = ht(() => e.disabled || f.disabled),
			y = ht(() => {
				const n = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : void 0 !== e.modelValue && null !== e.modelValue && "" !== e.modelValue;
				return e.clearable && !g.value && t.inputHovering && n;
			}),
			b = ht(() => (e.remote && e.filterable ? "" : e.suffixIcon)),
			x = ht(() => i.is("reverse", b.value && t.visible)),
			_ = ht(() => (e.remote ? 300 : 0)),
			w = ht(() =>
				e.loading
					? e.loadingText || r("el.select.loading")
					: (!e.remote || "" !== t.query || 0 !== t.options.size) && (e.filterable && t.query && t.options.size > 0 && 0 === t.filteredOptionsCount ? e.noMatchText || r("el.select.noMatch") : 0 === t.options.size ? e.noDataText || r("el.select.noData") : null)
			),
			C = ht(() => Array.from(t.options.values())),
			S = ht(() => Array.from(t.cachedOptions.values())),
			E = ht(() => {
				const n = C.value.filter((e) => !e.created).some((e) => e.currentLabel === t.query);
				return e.filterable && e.allowCreate && "" !== t.query && !n;
			}),
			T = hD(),
			k = ht(() => (["small"].includes(T.value) ? "small" : "default")),
			A = ht({
				get: () => t.visible && !1 !== w.value,
				set(e) {
					t.visible = e;
				}
			});
		ds([() => g.value, () => T.value, () => f.size], () => {
			ns(() => {
				M();
			});
		}),
			ds(
				() => e.placeholder,
				(e) => {
					t.cachedPlaceHolder = t.currentPlaceholder = e;
				}
			),
			ds(
				() => e.modelValue,
				(n, r) => {
					var i;
					e.multiple && (M(), (n && n.length > 0) || (o.value && "" !== t.query) ? (t.currentPlaceholder = "") : (t.currentPlaceholder = t.cachedPlaceHolder), e.filterable && !e.reserveKeyword && ((t.query = ""), I(t.query))),
						O(),
						e.filterable && !e.multiple && (t.inputLength = 20),
						rk(n, r) || null == (i = m.validate) || i.call(m, "change").catch((e) => {});
				},
				{ flush: "post", deep: !0 }
			),
			ds(
				() => t.visible,
				(r) => {
					var i, s, l;
					r
						? (null == (s = null == (i = a.value) ? void 0 : i.updatePopper) || s.call(i),
						  e.filterable &&
								((t.filteredOptionsCount = t.optionsCount),
								(t.query = e.remote ? "" : t.selectedLabel),
								e.multiple ? null == (l = o.value) || l.focus() : t.selectedLabel && ((t.currentPlaceholder = `${t.selectedLabel}`), (t.selectedLabel = "")),
								I(t.query),
								e.multiple || e.remote || ((d.value.query = ""), rt(d), rt(p))))
						: (o.value && o.value.blur(),
						  (t.query = ""),
						  (t.previousQuery = null),
						  (t.selectedLabel = ""),
						  (t.inputLength = 20),
						  (t.menuVisibleOnFocus = !1),
						  N(),
						  ns(() => {
								o.value && "" === o.value.value && 0 === t.selected.length && (t.currentPlaceholder = t.cachedPlaceHolder);
						  }),
						  e.multiple ||
								(t.selected && (e.filterable && e.allowCreate && t.createdSelected && t.createdLabel ? (t.selectedLabel = t.createdLabel) : (t.selectedLabel = t.selected.currentLabel), e.filterable && (t.query = t.selectedLabel)),
								e.filterable && (t.currentPlaceholder = t.cachedPlaceHolder))),
						n.emit("visible-change", r);
				}
			),
			ds(
				() => t.options.entries(),
				() => {
					var n, r, i;
					if (!GI) return;
					null == (r = null == (n = a.value) ? void 0 : n.updatePopper) || r.call(n), e.multiple && M();
					const s = (null == (i = u.value) ? void 0 : i.querySelectorAll("input")) || [];
					Array.from(s).includes(document.activeElement) || O(), e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && L();
				},
				{ flush: "post" }
			),
			ds(
				() => t.hoverIndex,
				(e) => {
					"number" == typeof e && e > -1 && (h.value = C.value[e] || {}),
						C.value.forEach((e) => {
							e.hover = h.value === e;
						});
				}
			);
		const M = () => {
				(e.collapseTags && !e.filterable) ||
					ns(() => {
						var e, n;
						if (!s.value) return;
						const r = s.value.$el.querySelector("input"),
							i = l.value,
							o = ((u = T.value || f.size), SN[u || "default"]);
						var u;
						(r.style.height = `${0 === t.selected.length ? o : Math.max(i ? i.clientHeight + (i.clientHeight > o ? 6 : 0) : 0, o) - 2}px`),
							(t.tagInMultiLine = Number.parseFloat(r.style.height) >= o),
							t.visible && !1 !== w.value && (null == (n = null == (e = a.value) ? void 0 : e.updatePopper) || n.call(e));
					});
			},
			I = (n) => {
				t.previousQuery === n ||
					t.isOnComposition ||
					(null !== t.previousQuery || ("function" != typeof e.filterMethod && "function" != typeof e.remoteMethod)
						? ((t.previousQuery = n),
						  ns(() => {
								var e, n;
								t.visible && (null == (n = null == (e = a.value) ? void 0 : e.updatePopper) || n.call(e));
						  }),
						  (t.hoverIndex = -1),
						  e.multiple &&
								e.filterable &&
								ns(() => {
									const n = 15 * o.value.value.length + 20;
									(t.inputLength = e.collapseTags ? Math.min(50, n) : n), R(), M();
								}),
						  e.remote && "function" == typeof e.remoteMethod ? ((t.hoverIndex = -1), e.remoteMethod(n)) : "function" == typeof e.filterMethod ? (e.filterMethod(n), rt(p)) : ((t.filteredOptionsCount = t.optionsCount), (d.value.query = n), rt(d), rt(p)),
						  e.defaultFirstOption && (e.filterable || e.remote) && t.filteredOptionsCount && L())
						: (t.previousQuery = n));
			},
			R = () => {
				"" !== t.currentPlaceholder && (t.currentPlaceholder = o.value.value ? "" : t.cachedPlaceHolder);
			},
			L = () => {
				const e = C.value.filter((e) => e.visible && !e.disabled && !e.states.groupDisabled),
					n = e.find((e) => e.created),
					r = e[0];
				t.hoverIndex = z(C.value, n || r);
			},
			O = () => {
				var n;
				if (!e.multiple) {
					const r = P(e.modelValue);
					return (null == (n = r.props) ? void 0 : n.created) ? ((t.createdLabel = r.props.value), (t.createdSelected = !0)) : (t.createdSelected = !1), (t.selectedLabel = r.currentLabel), (t.selected = r), void (e.filterable && (t.query = t.selectedLabel));
				}
				t.selectedLabel = "";
				const r = [];
				Array.isArray(e.modelValue) &&
					e.modelValue.forEach((e) => {
						r.push(P(e));
					}),
					(t.selected = r),
					ns(() => {
						M();
					});
			},
			P = (n) => {
				let r;
				const i = "object" === MR(n).toLowerCase(),
					s = "null" === MR(n).toLowerCase(),
					o = "undefined" === MR(n).toLowerCase();
				for (let l = t.cachedOptions.size - 1; l >= 0; l--) {
					const t = S.value[l];
					if (i ? XS(t.value, e.valueKey) === XS(n, e.valueKey) : t.value === n) {
						r = { value: n, currentLabel: t.currentLabel, isDisabled: t.isDisabled };
						break;
					}
				}
				if (r) return r;
				const a = { value: n, currentLabel: i ? n.label : s || o ? "" : n };
				return e.multiple && (a.hitState = !1), a;
			},
			N = () => {
				setTimeout(() => {
					const n = e.valueKey;
					e.multiple
						? t.selected.length > 0
							? (t.hoverIndex = Math.min.apply(
									null,
									t.selected.map((e) => C.value.findIndex((t) => XS(t, n) === XS(e, n)))
							  ))
							: (t.hoverIndex = -1)
						: (t.hoverIndex = C.value.findIndex((e) => Y(e) === Y(t.selected)));
				}, 300);
			},
			D = () => {
				var e;
				t.inputWidth = null == (e = s.value) ? void 0 : e.$el.getBoundingClientRect().width;
			},
			B = QT(() => {
				e.filterable && t.query !== t.selectedLabel && ((t.query = t.selectedLabel), I(t.query));
			}, _.value),
			F = QT((e) => {
				I(e.target.value);
			}, _.value),
			H = (t) => {
				rk(e.modelValue, t) || n.emit("change", t);
			},
			V = (r) => {
				r.stopPropagation();
				const i = e.multiple ? [] : "";
				if ("string" != typeof i) for (const e of t.selected) e.isDisabled && i.push(e.value);
				n.emit(_N, i), H(i), (t.visible = !1), n.emit("clear");
			},
			U = (r, i) => {
				var s;
				if (e.multiple) {
					const i = (e.modelValue || []).slice(),
						a = z(i, r.value);
					a > -1 ? i.splice(a, 1) : (e.multipleLimit <= 0 || i.length < e.multipleLimit) && i.push(r.value), n.emit(_N, i), H(i), r.created && ((t.query = ""), I(""), (t.inputLength = 20)), e.filterable && (null == (s = o.value) || s.focus());
				} else n.emit(_N, r.value), H(r.value), (t.visible = !1);
				(t.isSilentBlur = i),
					$(),
					t.visible ||
						ns(() => {
							j(r);
						});
			},
			z = (t = [], n) => {
				if (!ER(n)) return t.indexOf(n);
				const r = e.valueKey;
				let i = -1;
				return t.some((e, t) => XS(e, r) === XS(n, r) && ((i = t), !0)), i;
			},
			$ = () => {
				t.softFocus = !0;
				const e = o.value || s.value;
				e && (null == e || e.focus());
			},
			j = (e) => {
				var t, n, r, s, o;
				const l = Array.isArray(e) ? e[0] : e;
				let u = null;
				if (null == l ? void 0 : l.value) {
					const e = C.value.filter((e) => e.value === l.value);
					e.length > 0 && (u = e[0].$el);
				}
				if (a.value && u) {
					const e = null == (s = null == (r = null == (n = null == (t = a.value) ? void 0 : t.popperRef) ? void 0 : n.contentRef) ? void 0 : r.querySelector) ? void 0 : s.call(r, `.${i.be("dropdown", "wrap")}`);
					e && eL(e, u);
				}
				null == (o = c.value) || o.handleScroll();
			},
			W = (e) => {
				if (!Array.isArray(t.selected)) return;
				const n = t.selected[t.selected.length - 1];
				return n ? (!0 === e || !1 === e ? ((n.hitState = e), e) : ((n.hitState = !n.hitState), n.hitState)) : void 0;
			},
			G = () => {
				var n;
				e.automaticDropdown || g.value || (t.menuVisibleOnFocus ? (t.menuVisibleOnFocus = !1) : (t.visible = !t.visible), t.visible && (null == (n = o.value || s.value) || n.focus()));
			},
			Y = (t) => (ER(t.value) ? XS(t.value, e.valueKey) : t.value),
			X = ht(() => C.value.filter((e) => e.visible).every((e) => e.disabled)),
			K = (e) => {
				if (t.visible) {
					if (0 !== t.options.size && 0 !== t.filteredOptionsCount && !t.isOnComposition && !X.value) {
						"next" === e ? (t.hoverIndex++, t.hoverIndex === t.options.size && (t.hoverIndex = 0)) : "prev" === e && (t.hoverIndex--, t.hoverIndex < 0 && (t.hoverIndex = t.options.size - 1));
						const n = C.value[t.hoverIndex];
						(!0 !== n.disabled && !0 !== n.states.groupDisabled && n.visible) || K(e), ns(() => j(h.value));
					}
				} else t.visible = !0;
			};
		return {
			optionsArray: C,
			selectSize: T,
			handleResize: () => {
				var t, n;
				D(), null == (n = null == (t = a.value) ? void 0 : t.updatePopper) || n.call(t), e.multiple && !e.filterable && M();
			},
			debouncedOnInputChange: B,
			debouncedQueryChange: F,
			deletePrevTag: (r) => {
				if (r.target.value.length <= 0 && !W()) {
					const t = e.modelValue.slice();
					t.pop(), n.emit(_N, t), H(t);
				}
				1 === r.target.value.length && 0 === e.modelValue.length && (t.currentPlaceholder = t.cachedPlaceHolder);
			},
			deleteTag: (r, i) => {
				const s = t.selected.indexOf(i);
				if (s > -1 && !g.value) {
					const t = e.modelValue.slice();
					t.splice(s, 1), n.emit(_N, t), H(t), n.emit("remove-tag", i.value);
				}
				r.stopPropagation();
			},
			deleteSelected: V,
			handleOptionSelect: U,
			scrollToOption: j,
			readonly: v,
			resetInputHeight: M,
			showClose: y,
			iconComponent: b,
			iconReverse: x,
			showNewOption: E,
			collapseTagSize: k,
			setSelected: O,
			managePlaceholder: R,
			selectDisabled: g,
			emptyText: w,
			toggleLastOptionHitState: W,
			resetInputState: (e) => {
				e.code !== bN.backspace && W(!1), (t.inputLength = 15 * o.value.value.length + 20), M();
			},
			handleComposition: (e) => {
				const n = e.target.value;
				if ("compositionend" === e.type) (t.isOnComposition = !1), ns(() => I(n));
				else {
					const e = n[n.length - 1] || "";
					t.isOnComposition = !ON(e);
				}
			},
			onOptionCreate: (e) => {
				t.optionsCount++, t.filteredOptionsCount++, t.options.set(e.value, e), t.cachedOptions.set(e.value, e);
			},
			onOptionDestroy: (e, n) => {
				t.options.get(e) === n && (t.optionsCount--, t.filteredOptionsCount--, t.options.delete(e));
			},
			handleMenuEnter: () => {
				ns(() => j(t.selected));
			},
			handleFocus: (r) => {
				t.softFocus ? (t.softFocus = !1) : ((e.automaticDropdown || e.filterable) && (e.filterable && !t.visible && (t.menuVisibleOnFocus = !0), (t.visible = !0)), n.emit("focus", r));
			},
			blur: () => {
				var e;
				(t.visible = !1), null == (e = s.value) || e.blur();
			},
			handleBlur: (e) => {
				ns(() => {
					t.isSilentBlur ? (t.isSilentBlur = !1) : n.emit("blur", e);
				}),
					(t.softFocus = !1);
			},
			handleClearClick: (e) => {
				V(e);
			},
			handleClose: () => {
				t.visible = !1;
			},
			handleKeydownEscape: (e) => {
				t.visible && (e.preventDefault(), e.stopPropagation(), (t.visible = !1));
			},
			toggleMenu: G,
			selectOption: () => {
				t.visible ? C.value[t.hoverIndex] && U(C.value[t.hoverIndex], void 0) : G();
			},
			getValueKey: Y,
			navigateOptions: K,
			dropMenuVisible: A,
			queryChange: d,
			groupQueryChange: p,
			reference: s,
			input: o,
			tooltipRef: a,
			tags: l,
			selectWrapper: u,
			scrollbar: c
		};
	},
	EK = Tn({
		name: "ElSelect",
		componentName: "ElSelect",
		components: {
			ElInput: WB,
			ElSelectMenu: IB(CK, [
				[
					"render",
					function (e, t, n, r, i, s) {
						return Wr(), Kr("div", { class: gt([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]), style: pt({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth }) }, [mi(e.$slots, "default")], 6);
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]
			]),
			ElOption: wK,
			ElTag: P$,
			ElScrollbar: ZB,
			ElTooltip: QH,
			ElIcon: OB
		},
		directives: { ClickOutside: CU },
		props: {
			name: String,
			id: String,
			modelValue: { type: [Array, String, Number, Boolean, Object], default: void 0 },
			autocomplete: { type: String, default: "off" },
			automaticDropdown: Boolean,
			size: { type: String, validator: EN },
			effect: { type: String, default: "light" },
			disabled: Boolean,
			clearable: Boolean,
			filterable: Boolean,
			allowCreate: Boolean,
			loading: Boolean,
			popperClass: { type: String, default: "" },
			remote: Boolean,
			loadingText: String,
			noMatchText: String,
			noDataText: String,
			remoteMethod: Function,
			filterMethod: Function,
			multiple: Boolean,
			multipleLimit: { type: Number, default: 0 },
			placeholder: { type: String },
			defaultFirstOption: Boolean,
			reserveKeyword: { type: Boolean, default: !0 },
			valueKey: { type: String, default: "value" },
			collapseTags: Boolean,
			collapseTagsTooltip: { type: Boolean, default: !1 },
			teleported: VH.teleported,
			persistent: { type: Boolean, default: !0 },
			clearIcon: { type: [String, Object], default: QL },
			fitInputWidth: { type: Boolean, default: !1 },
			suffixIcon: { type: [String, Object], default: gL },
			tagType: c(u({}, L$.type), { default: "info" })
		},
		emits: [_N, "change", "remove-tag", "clear", "visible-change", "focus", "blur"],
		setup(e, t) {
			const n = BD("select"),
				r = BD("input"),
				{ t: i } = CD(),
				s = (function (e) {
					const { t: t } = CD();
					return Fe({
						options: new Map(),
						cachedOptions: new Map(),
						createdLabel: null,
						createdSelected: !1,
						selected: e.multiple ? [] : {},
						inputLength: 20,
						inputWidth: 0,
						optionsCount: 0,
						filteredOptionsCount: 0,
						visible: !1,
						softFocus: !1,
						selectedLabel: "",
						hoverIndex: -1,
						query: "",
						previousQuery: null,
						inputHovering: !1,
						cachedPlaceHolder: "",
						currentPlaceholder: t("el.select.placeholder"),
						menuVisibleOnFocus: !1,
						isOnComposition: !1,
						isSilentBlur: !1,
						prefixWidth: 11,
						tagInMultiLine: !1
					});
				})(e),
				{
					optionsArray: o,
					selectSize: a,
					readonly: l,
					handleResize: u,
					collapseTagSize: c,
					debouncedOnInputChange: h,
					debouncedQueryChange: d,
					deletePrevTag: p,
					deleteTag: f,
					deleteSelected: m,
					handleOptionSelect: v,
					scrollToOption: g,
					setSelected: y,
					resetInputHeight: b,
					managePlaceholder: x,
					showClose: _,
					selectDisabled: w,
					iconComponent: C,
					iconReverse: S,
					showNewOption: E,
					emptyText: T,
					toggleLastOptionHitState: k,
					resetInputState: A,
					handleComposition: M,
					onOptionCreate: I,
					onOptionDestroy: R,
					handleMenuEnter: L,
					handleFocus: O,
					blur: P,
					handleBlur: N,
					handleClearClick: D,
					handleClose: B,
					handleKeydownEscape: F,
					toggleMenu: H,
					selectOption: V,
					getValueKey: U,
					navigateOptions: z,
					dropMenuVisible: $,
					reference: j,
					input: W,
					tooltipRef: G,
					tags: Y,
					selectWrapper: X,
					scrollbar: K,
					queryChange: q,
					groupQueryChange: Z
				} = SK(e, s, t),
				{ focus: J } =
					((Q = j),
					{
						focus: () => {
							var e, t;
							null == (t = null == (e = Q.value) ? void 0 : e.focus) || t.call(e);
						}
					});
			var Q;
			const {
					inputWidth: ee,
					selected: te,
					inputLength: ne,
					filteredOptionsCount: re,
					visible: ie,
					softFocus: se,
					selectedLabel: oe,
					hoverIndex: ae,
					query: le,
					inputHovering: ue,
					currentPlaceholder: ce,
					menuVisibleOnFocus: he,
					isOnComposition: de,
					isSilentBlur: pe,
					options: fe,
					cachedOptions: me,
					optionsCount: ve,
					prefixWidth: ge,
					tagInMultiLine: ye
				} = at(s),
				be = ht(() => {
					const t = [n.b()],
						r = it(a);
					return r && t.push(n.m(r)), e.disabled && t.push(n.m("disabled")), t;
				}),
				xe = ht(() => ({ maxWidth: it(ee) - 32 + "px", width: "100%" }));
			mn(
				"ElSelect",
				Fe({ props: e, options: fe, optionsArray: o, cachedOptions: me, optionsCount: ve, filteredOptionsCount: re, hoverIndex: ae, handleOptionSelect: v, onOptionCreate: I, onOptionDestroy: R, selectWrapper: X, selected: te, setSelected: y, queryChange: q, groupQueryChange: Z })
			),
				Vn(() => {
					(s.cachedPlaceHolder = ce.value = e.placeholder || i("el.select.placeholder")),
						e.multiple && Array.isArray(e.modelValue) && e.modelValue.length > 0 && (ce.value = ""),
						pR(X, u),
						e.remote && e.multiple && b(),
						ns(() => {
							const e = j.value && j.value.$el;
							if (e && ((ee.value = e.getBoundingClientRect().width), t.slots.prefix)) {
								const t = e.querySelector(`.${r.e("prefix")}`);
								ge.value = Math.max(t.getBoundingClientRect().width + 5, 30);
							}
						}),
						y();
				}),
				e.multiple && !Array.isArray(e.modelValue) && t.emit(_N, []),
				!e.multiple && Array.isArray(e.modelValue) && t.emit(_N, "");
			const _e = ht(() => {
				var e, t;
				return null == (t = null == (e = G.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef;
			});
			return {
				tagInMultiLine: ye,
				prefixWidth: ge,
				selectSize: a,
				readonly: l,
				handleResize: u,
				collapseTagSize: c,
				debouncedOnInputChange: h,
				debouncedQueryChange: d,
				deletePrevTag: p,
				deleteTag: f,
				deleteSelected: m,
				handleOptionSelect: v,
				scrollToOption: g,
				inputWidth: ee,
				selected: te,
				inputLength: ne,
				filteredOptionsCount: re,
				visible: ie,
				softFocus: se,
				selectedLabel: oe,
				hoverIndex: ae,
				query: le,
				inputHovering: ue,
				currentPlaceholder: ce,
				menuVisibleOnFocus: he,
				isOnComposition: de,
				isSilentBlur: pe,
				options: fe,
				resetInputHeight: b,
				managePlaceholder: x,
				showClose: _,
				selectDisabled: w,
				iconComponent: C,
				iconReverse: S,
				showNewOption: E,
				emptyText: T,
				toggleLastOptionHitState: k,
				resetInputState: A,
				handleComposition: M,
				handleMenuEnter: L,
				handleFocus: O,
				blur: P,
				handleBlur: N,
				handleClearClick: D,
				handleClose: B,
				handleKeydownEscape: F,
				toggleMenu: H,
				selectOption: V,
				getValueKey: U,
				navigateOptions: z,
				dropMenuVisible: $,
				focus: J,
				reference: j,
				input: W,
				tooltipRef: G,
				popperPaneRef: _e,
				tags: Y,
				selectWrapper: X,
				scrollbar: K,
				wrapperKls: be,
				selectTagsStyle: xe,
				nsSelect: n
			};
		}
	}),
	TK = { class: "select-trigger" },
	kK = ["disabled", "autocomplete"],
	AK = { style: { height: "100%", display: "flex", "justify-content": "center", "align-items": "center" } };
var MK = IB(EK, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-tag"),
				a = Or("el-tooltip"),
				l = Or("el-icon"),
				u = Or("el-input"),
				c = Or("el-option"),
				h = Or("el-scrollbar"),
				d = Or("el-select-menu"),
				p = Dr("click-outside");
			return yr(
				(Wr(),
				Kr(
					"div",
					{ ref: "selectWrapper", class: gt(e.wrapperKls), onClick: t[23] || (t[23] = zo((...t) => e.toggleMenu && e.toggleMenu(...t), ["stop"])) },
					[
						ri(
							a,
							{
								ref: "tooltipRef",
								visible: e.dropMenuVisible,
								"onUpdate:visible": t[22] || (t[22] = (t) => (e.dropMenuVisible = t)),
								placement: "bottom-start",
								teleported: e.teleported,
								"popper-class": [e.nsSelect.e("popper"), e.popperClass],
								"fallback-placements": ["bottom-start", "top-start", "right", "left"],
								effect: e.effect,
								pure: "",
								trigger: "click",
								transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
								"stop-popper-mouse-event": !1,
								"gpu-acceleration": !1,
								persistent: e.persistent,
								onShow: e.handleMenuEnter
							},
							{
								default: cn(() => [
									ni("div", TK, [
										e.multiple
											? (Wr(),
											  Kr(
													"div",
													{ key: 0, ref: "tags", class: gt(e.nsSelect.e("tags")), style: pt(e.selectTagsStyle) },
													[
														e.collapseTags && e.selected.length
															? (Wr(),
															  Kr(
																	"span",
																	{ key: 0, class: gt([e.nsSelect.b("tags-wrapper"), { "has-prefix": e.prefixWidth && e.selected.length }]) },
																	[
																		ri(
																			o,
																			{ closable: !e.selectDisabled && !e.selected[0].isDisabled, size: e.collapseTagSize, hit: e.selected[0].hitState, type: e.tagType, "disable-transitions": "", onClose: t[0] || (t[0] = (t) => e.deleteTag(t, e.selected[0])) },
																			{ default: cn(() => [ni("span", { class: gt(e.nsSelect.e("tags-text")), style: pt({ maxWidth: e.inputWidth - 123 + "px" }) }, bt(e.selected[0].currentLabel), 7)]), _: 1 },
																			8,
																			["closable", "size", "hit", "type"]
																		),
																		e.selected.length > 1
																			? (Wr(),
																			  qr(
																					o,
																					{ key: 0, closable: !1, size: e.collapseTagSize, type: e.tagType, "disable-transitions": "" },
																					{
																						default: cn(() => [
																							e.collapseTagsTooltip
																								? (Wr(),
																								  qr(
																										a,
																										{ key: 0, disabled: e.dropMenuVisible, "fallback-placements": ["bottom", "top", "right", "left"], effect: e.effect, placement: "bottom", teleported: !1 },
																										{
																											default: cn(() => [ni("span", { class: gt(e.nsSelect.e("tags-text")) }, "+ " + bt(e.selected.length - 1), 3)]),
																											content: cn(() => [
																												ni(
																													"div",
																													{ class: gt(e.nsSelect.e("collapse-tags")) },
																													[
																														(Wr(!0),
																														Kr(
																															Hr,
																															null,
																															pi(
																																e.selected,
																																(t, n) => (
																																	Wr(),
																																	Kr(
																																		"div",
																																		{ key: n, class: gt(e.nsSelect.e("collapse-tag")) },
																																		[
																																			(Wr(),
																																			qr(
																																				o,
																																				{
																																					key: e.getValueKey(t),
																																					class: "in-tooltip",
																																					closable: !e.selectDisabled && !t.isDisabled,
																																					size: e.collapseTagSize,
																																					hit: t.hitState,
																																					type: e.tagType,
																																					"disable-transitions": "",
																																					style: { margin: "2px" },
																																					onClose: (n) => e.deleteTag(n, t)
																																				},
																																				{
																																					default: cn(() => [ni("span", { class: gt(e.nsSelect.e("tags-text")), style: pt({ maxWidth: e.inputWidth - 75 + "px" }) }, bt(t.currentLabel), 7)]),
																																					_: 2
																																				},
																																				1032,
																																				["closable", "size", "hit", "type", "onClose"]
																																			))
																																		],
																																		2
																																	)
																																)
																															),
																															128
																														))
																													],
																													2
																												)
																											]),
																											_: 1
																										},
																										8,
																										["disabled", "effect"]
																								  ))
																								: (Wr(), Kr("span", { key: 1, class: gt(e.nsSelect.e("tags-text")) }, "+ " + bt(e.selected.length - 1), 3))
																						]),
																						_: 1
																					},
																					8,
																					["size", "type"]
																			  ))
																			: ai("v-if", !0)
																	],
																	2
															  ))
															: ai("v-if", !0),
														ai(" <div> "),
														e.collapseTags
															? ai("v-if", !0)
															: (Wr(),
															  qr(
																	lo,
																	{ key: 1, onAfterLeave: e.resetInputHeight },
																	{
																		default: cn(() => [
																			ni(
																				"span",
																				{ class: gt([e.nsSelect.b("tags-wrapper"), { "has-prefix": e.prefixWidth && e.selected.length }]) },
																				[
																					(Wr(!0),
																					Kr(
																						Hr,
																						null,
																						pi(
																							e.selected,
																							(t) => (
																								Wr(),
																								qr(
																									o,
																									{ key: e.getValueKey(t), closable: !e.selectDisabled && !t.isDisabled, size: e.collapseTagSize, hit: t.hitState, type: e.tagType, "disable-transitions": "", onClose: (n) => e.deleteTag(n, t) },
																									{ default: cn(() => [ni("span", { class: gt(e.nsSelect.e("tags-text")), style: pt({ maxWidth: e.inputWidth - 75 + "px" }) }, bt(t.currentLabel), 7)]), _: 2 },
																									1032,
																									["closable", "size", "hit", "type", "onClose"]
																								)
																							)
																						),
																						128
																					))
																				],
																				2
																			)
																		]),
																		_: 1
																	},
																	8,
																	["onAfterLeave"]
															  )),
														ai(" </div> "),
														e.filterable
															? yr(
																	(Wr(),
																	Kr(
																		"input",
																		{
																			key: 2,
																			ref: "input",
																			"onUpdate:modelValue": t[1] || (t[1] = (t) => (e.query = t)),
																			type: "text",
																			class: gt([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
																			disabled: e.selectDisabled,
																			autocomplete: e.autocomplete,
																			style: pt({ marginLeft: (e.prefixWidth && !e.selected.length) || e.tagInMultiLine ? `${e.prefixWidth}px` : "", flexGrow: 1, width: e.inputLength / (e.inputWidth - 32) + "%", maxWidth: e.inputWidth - 42 + "px" }),
																			onFocus: t[2] || (t[2] = (...t) => e.handleFocus && e.handleFocus(...t)),
																			onBlur: t[3] || (t[3] = (...t) => e.handleBlur && e.handleBlur(...t)),
																			onKeyup: t[4] || (t[4] = (...t) => e.managePlaceholder && e.managePlaceholder(...t)),
																			onKeydown: [
																				t[5] || (t[5] = (...t) => e.resetInputState && e.resetInputState(...t)),
																				t[6] ||
																					(t[6] = jo(
																						zo((t) => e.navigateOptions("next"), ["prevent"]),
																						["down"]
																					)),
																				t[7] ||
																					(t[7] = jo(
																						zo((t) => e.navigateOptions("prev"), ["prevent"]),
																						["up"]
																					)),
																				t[8] || (t[8] = jo((...t) => e.handleKeydownEscape && e.handleKeydownEscape(...t), ["esc"])),
																				t[9] ||
																					(t[9] = jo(
																						zo((...t) => e.selectOption && e.selectOption(...t), ["stop", "prevent"]),
																						["enter"]
																					)),
																				t[10] || (t[10] = jo((...t) => e.deletePrevTag && e.deletePrevTag(...t), ["delete"])),
																				t[11] || (t[11] = jo((t) => (e.visible = !1), ["tab"]))
																			],
																			onCompositionstart: t[12] || (t[12] = (...t) => e.handleComposition && e.handleComposition(...t)),
																			onCompositionupdate: t[13] || (t[13] = (...t) => e.handleComposition && e.handleComposition(...t)),
																			onCompositionend: t[14] || (t[14] = (...t) => e.handleComposition && e.handleComposition(...t)),
																			onInput: t[15] || (t[15] = (...t) => e.debouncedQueryChange && e.debouncedQueryChange(...t))
																		},
																		null,
																		46,
																		kK
																	)),
																	[[Po, e.query]]
															  )
															: ai("v-if", !0)
													],
													6
											  ))
											: ai("v-if", !0),
										ri(
											u,
											{
												id: e.id,
												ref: "reference",
												modelValue: e.selectedLabel,
												"onUpdate:modelValue": t[16] || (t[16] = (t) => (e.selectedLabel = t)),
												type: "text",
												placeholder: e.currentPlaceholder,
												name: e.name,
												autocomplete: e.autocomplete,
												size: e.selectSize,
												disabled: e.selectDisabled,
												readonly: e.readonly,
												"validate-event": !1,
												class: gt([e.nsSelect.is("focus", e.visible)]),
												tabindex: e.multiple && e.filterable ? -1 : void 0,
												onFocus: e.handleFocus,
												onBlur: e.handleBlur,
												onInput: e.debouncedOnInputChange,
												onPaste: e.debouncedOnInputChange,
												onCompositionstart: e.handleComposition,
												onCompositionupdate: e.handleComposition,
												onCompositionend: e.handleComposition,
												onKeydown: [
													t[17] ||
														(t[17] = jo(
															zo((t) => e.navigateOptions("next"), ["stop", "prevent"]),
															["down"]
														)),
													t[18] ||
														(t[18] = jo(
															zo((t) => e.navigateOptions("prev"), ["stop", "prevent"]),
															["up"]
														)),
													jo(zo(e.selectOption, ["stop", "prevent"]), ["enter"]),
													jo(e.handleKeydownEscape, ["esc"]),
													t[19] || (t[19] = jo((t) => (e.visible = !1), ["tab"]))
												],
												onMouseenter: t[20] || (t[20] = (t) => (e.inputHovering = !0)),
												onMouseleave: t[21] || (t[21] = (t) => (e.inputHovering = !1))
											},
											fi(
												{
													suffix: cn(() => [
														e.iconComponent && !e.showClose ? (Wr(), qr(l, { key: 0, class: gt([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
														e.showClose && e.clearIcon ? (Wr(), qr(l, { key: 1, class: gt([e.nsSelect.e("caret"), e.nsSelect.e("icon")]), onClick: e.handleClearClick }, { default: cn(() => [(Wr(), qr(Nr(e.clearIcon)))]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)
													]),
													_: 2
												},
												[e.$slots.prefix ? { name: "prefix", fn: cn(() => [ni("div", AK, [mi(e.$slots, "prefix")])]) } : void 0]
											),
											1032,
											["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"]
										)
									])
								]),
								content: cn(() => [
									ri(d, null, {
										default: cn(() => [
											yr(
												ri(
													h,
													{ ref: "scrollbar", tag: "ul", "wrap-class": e.nsSelect.be("dropdown", "wrap"), "view-class": e.nsSelect.be("dropdown", "list"), class: gt([e.nsSelect.is("empty", !e.allowCreate && Boolean(e.query) && 0 === e.filteredOptionsCount)]) },
													{ default: cn(() => [e.showNewOption ? (Wr(), qr(c, { key: 0, value: e.query, created: !0 }, null, 8, ["value"])) : ai("v-if", !0), mi(e.$slots, "default")]), _: 3 },
													8,
													["wrap-class", "view-class", "class"]
												),
												[[Wo, e.options.size > 0 && !e.loading]]
											),
											e.emptyText && (!e.allowCreate || e.loading || (e.allowCreate && 0 === e.options.size))
												? (Wr(), Kr(Hr, { key: 0 }, [e.$slots.empty ? mi(e.$slots, "empty", { key: 0 }) : (Wr(), Kr("p", { key: 1, class: gt(e.nsSelect.be("dropdown", "empty")) }, bt(e.emptyText), 3))], 64))
												: ai("v-if", !0)
										]),
										_: 3
									})
								]),
								_: 3
							},
							8,
							["visible", "teleported", "popper-class", "effect", "transition", "persistent", "onShow"]
						)
					],
					2
				)),
				[[p, e.handleClose, e.popperPaneRef]]
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]
]);
var IK = IB(
	Tn({
		name: "ElOptionGroup",
		componentName: "ElOptionGroup",
		props: { label: String, disabled: { type: Boolean, default: !1 } },
		setup(e) {
			const t = BD("select"),
				n = Qe(!0),
				r = Si(),
				i = Qe([]);
			mn("ElSelectGroup", Fe(u({}, at(e))));
			const s = vn("ElSelect");
			Vn(() => {
				i.value = o(r.subTree);
			});
			const o = (e) => {
					const t = [];
					return (
						Array.isArray(e.children) &&
							e.children.forEach((e) => {
								var n;
								e.type && "ElOption" === e.type.name && e.component && e.component.proxy ? t.push(e.component.proxy) : (null == (n = e.children) ? void 0 : n.length) && t.push(...o(e));
							}),
						t
					);
				},
				{ groupQueryChange: a } = Ge(s);
			return (
				ds(a, () => {
					n.value = i.value.some((e) => !0 === e.visible);
				}),
				{ visible: n, ns: t }
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return yr((Wr(), Kr("ul", { class: gt(e.ns.be("group", "wrap")) }, [ni("li", { class: gt(e.ns.be("group", "title")) }, bt(e.label), 3), ni("li", null, [ni("ul", { class: gt(e.ns.b("group")) }, [mi(e.$slots, "default")], 2)])], 2)), [[Wo, e.visible]]);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]
	]
);
const RK = mN(MK, { Option: wK, OptionGroup: IK }),
	LK = gN(wK),
	OK = gN(IK),
	PK = () => vn(XN, {}),
	NK = uN({ pageSize: { type: Number, required: !0 }, pageSizes: { type: Array, default: () => [10, 20, 30, 40, 50, 100] }, popperClass: { type: String }, disabled: Boolean, size: { type: String, default: "default" } });
var DK = IB(
	Tn(
		c(u({}, { name: "ElPaginationSizes" }), {
			props: NK,
			emits: ["page-size-change"],
			setup(e, { emit: t }) {
				const n = e,
					{ t: r } = CD(),
					i = BD("pagination"),
					s = PK(),
					o = Qe(n.pageSize);
				ds(
					() => n.pageSizes,
					(e, r) => {
						if (!rk(e, r) && Array.isArray(e)) {
							const r = e.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
							t("page-size-change", r);
						}
					}
				),
					ds(
						() => n.pageSize,
						(e) => {
							o.value = e;
						}
					);
				const a = ht(() => n.pageSizes);
				function l(e) {
					var t;
					e !== o.value && ((o.value = e), null == (t = s.handleSizeChange) || t.call(s, Number(e)));
				}
				return (e, t) => (
					Wr(),
					Kr(
						"span",
						{ class: gt(it(i).e("sizes")) },
						[
							ri(
								it(RK),
								{ "model-value": o.value, disabled: e.disabled, "popper-class": e.popperClass, size: e.size, onChange: l },
								{
									default: cn(() => [
										(Wr(!0),
										Kr(
											Hr,
											null,
											pi(it(a), (e) => (Wr(), qr(it(LK), { key: e, value: e, label: e + it(r)("el.pagination.pagesize") }, null, 8, ["value", "label"]))),
											128
										))
									]),
									_: 1
								},
								8,
								["model-value", "disabled", "popper-class", "size"]
							)
						],
						2
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]
);
const BK = ["disabled"];
var FK = IB(
	Tn(
		c(u({}, { name: "ElPaginationJumper" }), {
			setup(e) {
				const { t: t } = CD(),
					n = BD("pagination"),
					{ pageCount: r, disabled: i, currentPage: s, changeEvent: o } = PK(),
					a = Qe(),
					l = ht(() => {
						var e;
						return null != (e = a.value) ? e : null == s ? void 0 : s.value;
					});
				function u(e) {
					a.value = +e;
				}
				function c(e) {
					(e = Math.trunc(+e)), null == o || o(+e), (a.value = void 0);
				}
				return (e, s) => (
					Wr(),
					Kr(
						"span",
						{ class: gt(it(n).e("jump")), disabled: it(i) },
						[
							oi(bt(it(t)("el.pagination.goto")) + " ", 1),
							ri(it(WB), { size: "small", class: gt([it(n).e("editor"), it(n).is("in-pagination")]), min: 1, max: it(r), disabled: it(i), "model-value": it(l), type: "number", "onUpdate:modelValue": u, onChange: c }, null, 8, ["class", "max", "disabled", "model-value"]),
							oi(" " + bt(it(t)("el.pagination.pageClassifier")), 1)
						],
						10,
						BK
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]
);
const HK = uN({ total: { type: Number, default: 1e3 } }),
	VK = ["disabled"];
var UK = IB(
	Tn(
		c(u({}, { name: "ElPaginationTotal" }), {
			props: HK,
			setup(e) {
				const { t: t } = CD(),
					n = BD("pagination"),
					{ disabled: r } = PK();
				return (e, i) => (Wr(), Kr("span", { class: gt(it(n).e("total")), disabled: it(r) }, bt(it(t)("el.pagination.total", { total: e.total })), 11, VK));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]
);
const zK = uN({ currentPage: { type: Number, default: 1 }, pageCount: { type: Number, required: !0 }, pagerCount: { type: Number, default: 7 }, disabled: Boolean }),
	$K = ["onKeyup"],
	jK = ["aria-current"],
	WK = ["aria-current"],
	GK = ["aria-current"];
var YK = IB(
	Tn(
		c(u({}, { name: "ElPaginationPager" }), {
			props: zK,
			emits: ["change"],
			setup(e, { emit: t }) {
				const n = e,
					r = BD("pager"),
					i = BD("icon"),
					s = Qe(!1),
					o = Qe(!1),
					a = Qe(!1),
					l = Qe(!1),
					u = ht(() => {
						const e = n.pagerCount,
							t = (e - 1) / 2,
							r = Number(n.currentPage),
							i = Number(n.pageCount);
						let s = !1,
							o = !1;
						i > e && (r > e - t && (s = !0), r < i - t && (o = !0));
						const a = [];
						if (s && !o) {
							for (let t = i - (e - 2); t < i; t++) a.push(t);
						} else if (!s && o) for (let n = 2; n < e; n++) a.push(n);
						else if (s && o) {
							const t = Math.floor(e / 2) - 1;
							for (let e = r - t; e <= r + t; e++) a.push(e);
						} else for (let n = 2; n < i; n++) a.push(n);
						return a;
					});
				function c(e) {
					n.disabled || ("left" === e ? (a.value = !0) : (l.value = !0));
				}
				function h(e) {
					const r = e.target;
					if ("li" === r.tagName.toLowerCase() && Array.from(r.classList).includes("number")) {
						const e = Number(r.textContent);
						e !== n.currentPage && t("change", e);
					}
				}
				function d(e) {
					const r = e.target;
					if ("ul" === r.tagName.toLowerCase() || n.disabled) return;
					let i = Number(r.textContent);
					const s = n.pageCount,
						o = n.currentPage,
						a = n.pagerCount - 2;
					r.className.includes("more") && (r.className.includes("quickprev") ? (i = o - a) : r.className.includes("quicknext") && (i = o + a)), Number.isNaN(+i) || (i < 1 && (i = 1), i > s && (i = s)), i !== o && t("change", i);
				}
				return (
					cs(() => {
						const e = (n.pagerCount - 1) / 2;
						(s.value = !1), (o.value = !1), n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - e && (s.value = !0), n.currentPage < n.pageCount - e && (o.value = !0));
					}),
					(e, t) => (
						Wr(),
						Kr(
							"ul",
							{ class: gt(it(r).b()), onClick: d, onKeyup: jo(h, ["enter"]) },
							[
								e.pageCount > 0 ? (Wr(), Kr("li", { key: 0, class: gt([[it(r).is("active", 1 === e.currentPage), it(r).is("disabled", e.disabled)], "number"]), "aria-current": 1 === e.currentPage, tabindex: "0" }, " 1 ", 10, jK)) : ai("v-if", !0),
								s.value
									? (Wr(),
									  Kr(
											"li",
											{ key: 1, class: gt(["more", "btn-quickprev", it(i).b(), it(r).is("disabled", e.disabled)]), onMouseenter: t[0] || (t[0] = (e) => c("left")), onMouseleave: t[1] || (t[1] = (e) => (a.value = !1)) },
											[a.value ? (Wr(), qr(it(hO), { key: 0 })) : (Wr(), qr(it(YO), { key: 1 }))],
											34
									  ))
									: ai("v-if", !0),
								(Wr(!0),
								Kr(
									Hr,
									null,
									pi(it(u), (t) => (Wr(), Kr("li", { key: t, class: gt([[it(r).is("active", e.currentPage === t), it(r).is("disabled", e.disabled)], "number"]), "aria-current": e.currentPage === t, tabindex: "0" }, bt(t), 11, WK))),
									128
								)),
								o.value
									? (Wr(),
									  Kr(
											"li",
											{ key: 2, class: gt(["more", "btn-quicknext", it(i).b(), it(r).is("disabled", e.disabled)]), onMouseenter: t[2] || (t[2] = (e) => c("right")), onMouseleave: t[3] || (t[3] = (e) => (l.value = !1)) },
											[l.value ? (Wr(), qr(it(mO), { key: 0 })) : (Wr(), qr(it(YO), { key: 1 }))],
											34
									  ))
									: ai("v-if", !0),
								e.pageCount > 1 ? (Wr(), Kr("li", { key: 3, class: gt([[it(r).is("active", e.currentPage === e.pageCount), it(r).is("disabled", e.disabled)], "number"]), "aria-current": e.currentPage === e.pageCount, tabindex: "0" }, bt(e.pageCount), 11, GK)) : ai("v-if", !0)
							],
							42,
							$K
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]
);
const XK = (e) => "number" != typeof e,
	KK = uN({
		total: Number,
		pageSize: Number,
		defaultPageSize: Number,
		currentPage: Number,
		defaultCurrentPage: Number,
		pageCount: Number,
		pagerCount: { type: Number, validator: (e) => "number" == typeof e && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 == 1, default: 7 },
		layout: { type: String, default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ") },
		pageSizes: { type: Array, default: () => [10, 20, 30, 40, 50, 100] },
		popperClass: { type: String, default: "" },
		prevText: { type: String, default: "" },
		nextText: { type: String, default: "" },
		small: Boolean,
		background: Boolean,
		disabled: Boolean,
		hideOnSinglePage: Boolean
	});
const qK = mN(
		Tn({
			name: "ElPagination",
			props: KK,
			emits: { "update:current-page": (e) => "number" == typeof e, "update:page-size": (e) => "number" == typeof e, "size-change": (e) => "number" == typeof e, "current-change": (e) => "number" == typeof e, "prev-click": (e) => "number" == typeof e, "next-click": (e) => "number" == typeof e },
			setup(e, { emit: t, slots: n }) {
				const { t: r } = CD(),
					i = BD("pagination"),
					s = Si().vnode.props || {},
					o = "onUpdate:currentPage" in s || "onUpdate:current-page" in s || "onCurrentChange" in s,
					a = "onUpdate:pageSize" in s || "onUpdate:page-size" in s || "onSizeChange" in s,
					l = ht(() => {
						if (XK(e.total) && XK(e.pageCount)) return !1;
						if (!XK(e.currentPage) && !o) return !1;
						if (e.layout.includes("sizes"))
							if (XK(e.pageCount)) {
								if (!XK(e.total) && !XK(e.pageSize) && !a) return !1;
							} else if (!a) return !1;
						return !0;
					}),
					u = Qe(XK(e.defaultPageSize) ? 10 : e.defaultPageSize),
					c = Qe(XK(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage),
					h = ht({
						get: () => (XK(e.pageSize) ? u.value : e.pageSize),
						set(n) {
							XK(e.pageSize) && (u.value = n), a && (t("update:page-size", n), t("size-change", n));
						}
					}),
					d = ht(() => {
						let t = 0;
						return XK(e.pageCount) ? XK(e.total) || (t = Math.max(1, Math.ceil(e.total / h.value))) : (t = e.pageCount), t;
					}),
					p = ht({
						get: () => (XK(e.currentPage) ? c.value : e.currentPage),
						set(n) {
							let r = n;
							n < 1 ? (r = 1) : n > d.value && (r = d.value), XK(e.currentPage) && (c.value = r), o && (t("update:current-page", r), t("current-change", r));
						}
					});
				function f(e) {
					p.value = e;
				}
				function m() {
					e.disabled || ((p.value -= 1), t("prev-click", p.value));
				}
				function v() {
					e.disabled || ((p.value += 1), t("next-click", p.value));
				}
				function g(e, t) {
					e && (e.props || (e.props = {}), (e.props.class = [e.props.class, t].join(" ")));
				}
				return (
					ds(d, (e) => {
						p.value > e && (p.value = e);
					}),
					mn(XN, {
						pageCount: d,
						disabled: ht(() => e.disabled),
						currentPage: p,
						changeEvent: f,
						handleSizeChange: function (e) {
							h.value = e;
							const t = d.value;
							p.value > t && (p.value = t);
						}
					}),
					() => {
						var t, s;
						if (!l.value) return r("el.pagination.deprecationWarning"), null;
						if (!e.layout) return null;
						if (e.hideOnSinglePage && d.value <= 1) return null;
						const o = [],
							a = [],
							u = xs("div", { class: i.e("rightwrapper") }, a),
							c = {
								prev: xs(gK, { disabled: e.disabled, currentPage: p.value, prevText: e.prevText, onClick: m }),
								jumper: xs(FK),
								pager: xs(YK, { currentPage: p.value, pageCount: d.value, pagerCount: e.pagerCount, onChange: f, disabled: e.disabled }),
								next: xs(_K, { disabled: e.disabled, currentPage: p.value, pageCount: d.value, nextText: e.nextText, onClick: v }),
								sizes: xs(DK, { pageSize: h.value, pageSizes: e.pageSizes, popperClass: e.popperClass, disabled: e.disabled, size: e.small ? "small" : "default" }),
								slot: null != (s = null == (t = null == n ? void 0 : n.default) ? void 0 : t.call(n)) ? s : null,
								total: xs(UK, { total: XK(e.total) ? 0 : e.total })
							},
							y = e.layout.split(",").map((e) => e.trim());
						let b = !1;
						return (
							y.forEach((e) => {
								"->" !== e ? (b ? a.push(c[e]) : o.push(c[e])) : (b = !0);
							}),
							g(o[0], i.is("first")),
							g(o[o.length - 1], i.is("last")),
							b && a.length > 0 && (g(a[0], i.is("first")), g(a[a.length - 1], i.is("last")), o.push(u)),
							xs("div", { role: "pagination", "aria-label": "pagination", class: [i.b(), i.is("background", e.background), { [i.m("small")]: e.small }] }, o)
						);
					}
				);
			}
		})
	),
	ZK = [...CV, "text"],
	JK = uN({
		title: String,
		confirmButtonText: String,
		cancelButtonText: String,
		confirmButtonType: { type: String, values: ZK, default: "primary" },
		cancelButtonType: { type: String, values: ZK, default: "text" },
		icon: { type: cN, default: uP },
		iconColor: { type: String, default: "#f90" },
		hideIcon: { type: Boolean, default: !1 },
		hideAfter: { type: Number, default: 200 },
		onConfirm: { type: Function },
		onCancel: { type: Function },
		teleported: VH.teleported,
		persistent: VH.persistent
	});
const QK = mN(
		IB(
			Tn(
				c(u({}, { name: "ElPopconfirm" }), {
					props: JK,
					setup(e) {
						const t = e,
							{ t: n } = CD(),
							r = BD("popconfirm"),
							i = Qe(),
							s = () => {
								var e, t;
								null == (t = null == (e = i.value) ? void 0 : e.onClose) || t.call(e);
							},
							o = (e) => {
								var n;
								null == (n = t.onConfirm) || n.call(t, e), s();
							},
							a = (e) => {
								var n;
								null == (n = t.onCancel) || n.call(t, e), s();
							},
							l = ht(() => t.confirmButtonText || n("el.popconfirm.confirmButtonText")),
							u = ht(() => t.cancelButtonText || n("el.popconfirm.cancelButtonText"));
						return (e, t) => (
							Wr(),
							qr(
								it(QH),
								{ ref_key: "tooltipRef", ref: i, trigger: "click", effect: "light", "popper-class": `${it(r).namespace.value}-popover`, teleported: e.teleported, "fallback-placements": ["bottom", "top", "right", "left"], "hide-after": e.hideAfter, persistent: e.persistent },
								{
									content: cn(() => [
										ni(
											"div",
											{ class: gt(it(r).b()) },
											[
												ni(
													"div",
													{ class: gt(it(r).e("main")) },
													[!e.hideIcon && e.icon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(r).e("icon")), style: pt({ color: e.iconColor }) }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 }, 8, ["class", "style"])) : ai("v-if", !0), oi(" " + bt(e.title), 1)],
													2
												),
												ni(
													"div",
													{ class: gt(it(r).e("action")) },
													[
														ri(it(qV), { size: "small", type: "text" === e.cancelButtonType ? "" : e.cancelButtonType, text: "text" === e.cancelButtonType, onClick: a }, { default: cn(() => [oi(bt(it(u)), 1)]), _: 1 }, 8, ["type", "text"]),
														ri(it(qV), { size: "small", type: "text" === e.confirmButtonType ? "" : e.confirmButtonType, text: "text" === e.confirmButtonType, onClick: o }, { default: cn(() => [oi(bt(it(l)), 1)]), _: 1 }, 8, ["type", "text"])
													],
													2
												)
											],
											2
										)
									]),
									default: cn(() => [e.$slots.reference ? mi(e.$slots, "reference", { key: 0 }) : ai("v-if", !0)]),
									_: 3
								},
								8,
								["popper-class", "teleported", "hide-after", "persistent"]
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]
		)
	),
	eq = uN({
		trigger: UH.trigger,
		placement: qG.placement,
		disabled: UH.disabled,
		visible: VH.visible,
		transition: VH.transition,
		popperOptions: qG.popperOptions,
		tabindex: qG.tabindex,
		content: VH.content,
		popperStyle: VH.popperStyle,
		popperClass: VH.popperClass,
		enterable: c(u({}, VH.enterable), { default: !0 }),
		effect: c(u({}, VH.effect), { default: "light" }),
		teleported: VH.teleported,
		title: String,
		width: { type: [String, Number], default: 150 },
		offset: { type: Number, default: void 0 },
		showAfter: { type: Number, default: 0 },
		hideAfter: { type: Number, default: 200 },
		autoClose: { type: Number, default: 0 },
		showArrow: { type: Boolean, default: !0 },
		persistent: { type: Boolean, default: !0 }
	});
var tq = IB(
	Tn({
		name: "ElPopover",
		components: { ElTooltip: QH },
		props: eq,
		emits: ["update:visible", "before-enter", "before-leave", "after-enter", "after-leave"],
		setup(e, { emit: t }) {
			const n = BD("popover"),
				r = Qe(null),
				i = ht(() => {
					var e;
					return null == (e = it(r)) ? void 0 : e.popperRef;
				}),
				s = ht(() => (SR(e.width) ? e.width : `${e.width}px`)),
				o = ht(() => [{ width: s.value }, e.popperStyle]),
				a = ht(() => [n.b(), e.popperClass, { [n.m("plain")]: !!e.content }]),
				l = ht(() => "el-fade-in-linear" === e.transition);
			return {
				ns: n,
				kls: a,
				gpuAcceleration: l,
				style: o,
				tooltipRef: r,
				popperRef: i,
				hide: () => {
					var e;
					null == (e = r.value) || e.hide();
				},
				beforeEnter: () => {
					t("before-enter");
				},
				beforeLeave: () => {
					t("before-leave");
				},
				afterEnter: () => {
					t("after-enter");
				},
				afterLeave: () => {
					t("update:visible", !1), t("after-leave");
				}
			};
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-tooltip");
				return (
					Wr(),
					qr(
						o,
						hi({ ref: "tooltipRef" }, e.$attrs, {
							trigger: e.trigger,
							placement: e.placement,
							disabled: e.disabled,
							visible: e.visible,
							transition: e.transition,
							"popper-options": e.popperOptions,
							tabindex: e.tabindex,
							content: e.content,
							offset: e.offset,
							"show-after": e.showAfter,
							"hide-after": e.hideAfter,
							"auto-close": e.autoClose,
							"show-arrow": e.showArrow,
							"aria-label": e.title,
							effect: e.effect,
							enterable: e.enterable,
							"popper-class": e.kls,
							"popper-style": e.style,
							teleported: e.teleported,
							persistent: e.persistent,
							"gpu-acceleration": e.gpuAcceleration,
							onBeforeShow: e.beforeEnter,
							onBeforeHide: e.beforeLeave,
							onShow: e.afterEnter,
							onHide: e.afterLeave
						}),
						{
							content: cn(() => [e.title ? (Wr(), Kr("div", { key: 0, class: gt(e.ns.e("title")), role: "title" }, bt(e.title), 3)) : ai("v-if", !0), mi(e.$slots, "default", {}, () => [oi(bt(e.content), 1)])]),
							default: cn(() => [e.$slots.reference ? mi(e.$slots, "reference", { key: 0 }) : ai("v-if", !0)]),
							_: 3
						},
						16,
						[
							"trigger",
							"placement",
							"disabled",
							"visible",
							"transition",
							"popper-options",
							"tabindex",
							"content",
							"offset",
							"show-after",
							"hide-after",
							"auto-close",
							"show-arrow",
							"aria-label",
							"effect",
							"enterable",
							"popper-class",
							"popper-style",
							"teleported",
							"persistent",
							"gpu-acceleration",
							"onBeforeShow",
							"onBeforeHide",
							"onShow",
							"onHide"
						]
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/index.vue"]
	]
);
const nq = (e, t) => {
	const n = t.arg || t.value,
		r = null == n ? void 0 : n.popperRef;
	r && (r.triggerRef = e);
};
var rq = {
	mounted(e, t) {
		nq(e, t);
	},
	updated(e, t) {
		nq(e, t);
	}
};
(tq.install = (e) => {
	e.component(tq.name, tq);
}),
	(rq.install = (e) => {
		e.directive("popover", rq);
	});
const iq = rq;
tq.directive = iq;
const sq = tq,
	oq = iq,
	aq = uN({
		type: { type: String, default: "line", values: ["line", "circle", "dashboard"] },
		percentage: { type: Number, default: 0, validator: (e) => e >= 0 && e <= 100 },
		status: { type: String, default: "", values: ["", "success", "exception", "warning"] },
		indeterminate: { type: Boolean, default: !1 },
		duration: { type: Number, default: 3 },
		strokeWidth: { type: Number, default: 6 },
		strokeLinecap: { type: String, default: "round" },
		textInside: { type: Boolean, default: !1 },
		width: { type: Number, default: 126 },
		showText: { type: Boolean, default: !0 },
		color: { type: [String, Array, Function], default: "" },
		format: { type: Function, default: (e) => `${e}%` }
	}),
	lq = ["aria-valuenow"],
	uq = { viewBox: "0 0 100 100" },
	cq = ["d", "stroke", "stroke-width"],
	hq = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"],
	dq = { key: 0 };
const pq = mN(
		IB(
			Tn(
				c(u({}, { name: "ElProgress" }), {
					props: aq,
					setup(e) {
						const t = e,
							n = { success: "#13ce66", exception: "#ff4949", warning: "#e6a23c", default: "#20a0ff" },
							r = BD("progress"),
							i = ht(() => ({ width: `${t.percentage}%`, animationDuration: `${t.duration}s`, backgroundColor: g(t.percentage) })),
							s = ht(() => ((t.strokeWidth / t.width) * 100).toFixed(1)),
							o = ht(() => (["circle", "dashboard"].includes(t.type) ? Number.parseInt("" + (50 - Number.parseFloat(s.value) / 2), 10) : 0)),
							a = ht(() => {
								const e = o.value,
									n = "dashboard" === t.type;
								return `\n                    M 50 50\n                    m 0 ${n ? "" : "-"}${e}\n                    a ${e} ${e} 0 1 1 0 ${n ? "-" : ""}${2 * e}\n                    a ${e} ${e} 0 1 1 0 ${n ? "" : "-"}${2 * e}\n                    `;
							}),
							l = ht(() => 2 * Math.PI * o.value),
							u = ht(() => ("dashboard" === t.type ? 0.75 : 1)),
							c = ht(() => `${(-1 * l.value * (1 - u.value)) / 2}px`),
							h = ht(() => ({ strokeDasharray: `${l.value * u.value}px, ${l.value}px`, strokeDashoffset: c.value })),
							d = ht(() => ({ strokeDasharray: `${l.value * u.value * (t.percentage / 100)}px, ${l.value}px`, strokeDashoffset: c.value, transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s" })),
							p = ht(() => {
								let e;
								return (e = t.color ? g(t.percentage) : n[t.status] || n.default), e;
							}),
							f = ht(() => ("warning" === t.status ? QP : "line" === t.type ? ("success" === t.status ? WL : QL) : "success" === t.status ? BL : aO)),
							m = ht(() => ("line" === t.type ? 12 + 0.4 * t.strokeWidth : 0.111111 * t.width + 2)),
							v = ht(() => t.format(t.percentage));
						const g = (e) => {
							var n;
							const { color: r } = t;
							if (CR(r)) return r(e);
							if (SR(r)) return r;
							{
								const t = (function (e) {
									const t = 100 / e.length;
									return e.map((e, n) => (SR(e) ? { color: e, percentage: (n + 1) * t } : e)).sort((e, t) => e.percentage - t.percentage);
								})(r);
								for (const n of t) if (n.percentage > e) return n.color;
								return null == (n = t[t.length - 1]) ? void 0 : n.color;
							}
						};
						return (e, t) => (
							Wr(),
							Kr(
								"div",
								{ class: gt([it(r).b(), it(r).m(e.type), it(r).is(e.status), { [it(r).m("without-text")]: !e.showText, [it(r).m("text-inside")]: e.textInside }]), role: "progressbar", "aria-valuenow": e.percentage, "aria-valuemin": "0", "aria-valuemax": "100" },
								[
									"line" === e.type
										? (Wr(),
										  Kr(
												"div",
												{ key: 0, class: gt(it(r).b("bar")) },
												[
													ni(
														"div",
														{ class: gt(it(r).be("bar", "outer")), style: pt({ height: `${e.strokeWidth}px` }) },
														[
															ni(
																"div",
																{ class: gt([it(r).be("bar", "inner"), { [it(r).bem("bar", "inner", "indeterminate")]: e.indeterminate }]), style: pt(it(i)) },
																[
																	(e.showText || e.$slots.default) && e.textInside
																		? (Wr(), Kr("div", { key: 0, class: gt(it(r).be("bar", "innerText")) }, [mi(e.$slots, "default", { percentage: e.percentage }, () => [ni("span", null, bt(it(v)), 1)])], 2))
																		: ai("v-if", !0)
																],
																6
															)
														],
														6
													)
												],
												2
										  ))
										: (Wr(),
										  Kr(
												"div",
												{ key: 1, class: gt(it(r).b("circle")), style: pt({ height: `${e.width}px`, width: `${e.width}px` }) },
												[
													(Wr(),
													Kr("svg", uq, [
														ni("path", { class: gt(it(r).be("circle", "track")), d: it(a), stroke: `var(${it(r).cssVarName("fill-color-light")}, #e5e9f2)`, "stroke-width": it(s), fill: "none", style: pt(it(h)) }, null, 14, cq),
														ni("path", { class: gt(it(r).be("circle", "path")), d: it(a), stroke: it(p), fill: "none", opacity: e.percentage ? 1 : 0, "stroke-linecap": e.strokeLinecap, "stroke-width": it(s), style: pt(it(d)) }, null, 14, hq)
													]))
												],
												6
										  )),
									(!e.showText && !e.$slots.default) || e.textInside
										? ai("v-if", !0)
										: (Wr(),
										  Kr(
												"div",
												{ key: 2, class: gt(it(r).e("text")), style: pt({ fontSize: `${it(m)}px` }) },
												[mi(e.$slots, "default", { percentage: e.percentage }, () => [e.status ? (Wr(), qr(it(OB), { key: 1 }, { default: cn(() => [(Wr(), qr(Nr(it(f))))]), _: 1 })) : (Wr(), Kr("span", dq, bt(it(v)), 1))])],
												6
										  ))
								],
								10,
								lq
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]
		)
	),
	fq = uN({
		modelValue: { type: Number, default: 0 },
		id: { type: String, default: void 0 },
		lowThreshold: { type: Number, default: 2 },
		highThreshold: { type: Number, default: 4 },
		max: { type: Number, default: 5 },
		colors: { type: [Array, Object], default: () => ["", "", ""] },
		voidColor: { type: String, default: "" },
		disabledVoidColor: { type: String, default: "" },
		icons: { type: [Array, Object], default: () => [BP, BP, BP] },
		voidIcon: { type: cN, default: () => UP },
		disabledVoidIcon: { type: cN, default: () => BP },
		disabled: { type: Boolean },
		allowHalf: { type: Boolean },
		showText: { type: Boolean },
		showScore: { type: Boolean },
		textColor: { type: String, default: "" },
		texts: { type: Array, default: () => ["Extremely bad", "Disappointed", "Fair", "Satisfied", "Surprise"] },
		scoreTemplate: { type: String, default: "{value}" },
		size: { type: String, validator: EN },
		label: { type: String, default: void 0 }
	}),
	mq = { change: (e) => XI(e), [_N]: (e) => XI(e) },
	vq = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"],
	gq = ["onMousemove", "onClick"];
const yq = mN(
		IB(
			Tn(
				c(u({}, { name: "ElRate" }), {
					props: fq,
					emits: mq,
					setup(e, { expose: t, emit: n }) {
						const r = e;
						function i(e, t) {
							const n = (e) => ER(e),
								r = Object.keys(t)
									.map((e) => +e)
									.filter((r) => {
										const i = t[r];
										return !!n(i) && i.excluded ? e < r : e <= r;
									})
									.sort((e, t) => e - t),
								i = t[r[0]];
							return (n(i) && i.value) || i;
						}
						const s = vn(GN, void 0),
							o = vn(YN, void 0),
							a = hD(),
							l = BD("rate"),
							{ inputId: u, isLabeledByFormItem: c } = bD(r, { formItemContext: o }),
							h = Qe(r.modelValue),
							d = Qe(-1),
							p = Qe(!0),
							f = ht(() => [l.b(), l.m(a.value)]),
							m = ht(() => r.disabled || (null == s ? void 0 : s.disabled)),
							v = ht(() => l.cssVarBlock({ "void-color": r.voidColor, "disabled-void-color": r.disabledVoidColor, "fill-color": x.value })),
							g = ht(() => {
								let e = "";
								return r.showScore ? (e = r.scoreTemplate.replace(/\{\s*value\s*\}/, m.value ? `${r.modelValue}` : `${h.value}`)) : r.showText && (e = r.texts[Math.ceil(h.value) - 1]), e;
							}),
							y = ht(() => 100 * r.modelValue - 100 * Math.floor(r.modelValue)),
							b = ht(() => (_R(r.colors) ? { [r.lowThreshold]: r.colors[0], [r.highThreshold]: { value: r.colors[1], excluded: !0 }, [r.max]: r.colors[2] } : r.colors)),
							x = ht(() => {
								const e = i(h.value, b.value);
								return ER(e) ? "" : e;
							}),
							_ = ht(() => {
								let e = "";
								return m.value ? (e = `${y.value}%`) : r.allowHalf && (e = "50%"), { color: x.value, width: e };
							}),
							w = ht(() => (_R(r.icons) ? { [r.lowThreshold]: r.icons[0], [r.highThreshold]: { value: r.icons[1], excluded: !0 }, [r.max]: r.icons[2] } : r.icons)),
							C = ht(() => i(r.modelValue, w.value)),
							S = ht(() => (m.value ? r.disabledVoidIcon : r.voidIcon)),
							E = ht(() => i(h.value, w.value)),
							T = ht(() => {
								const e = Array.from({ length: r.max }),
									t = h.value;
								return e.fill(E.value, 0, t), e.fill(S.value, t, r.max), e;
							});
						function k(e) {
							const t = m.value && y.value > 0 && e - 1 < r.modelValue && e > r.modelValue,
								n = r.allowHalf && p.value && e - 0.5 <= h.value && e > h.value;
							return t || n;
						}
						function A(e) {
							if (m.value) return;
							let t = h.value;
							const i = e.code;
							return (
								i === bN.up || i === bN.right ? (r.allowHalf ? (t += 0.5) : (t += 1), e.stopPropagation(), e.preventDefault()) : (i !== bN.left && i !== bN.down) || (r.allowHalf ? (t -= 0.5) : (t -= 1), e.stopPropagation(), e.preventDefault()),
								(t = t < 0 ? 0 : t),
								(t = t > r.max ? r.max : t),
								n(_N, t),
								n("change", t),
								t
							);
						}
						function M(e, t) {
							if (!m.value) {
								if (r.allowHalf) {
									let n = t.target;
									WR(n, l.e("item")) && (n = n.querySelector(`.${l.e("icon")}`)), (0 === n.clientWidth || WR(n, l.e("decimal"))) && (n = n.parentNode), (p.value = 2 * t.offsetX <= n.clientWidth), (h.value = p.value ? e - 0.5 : e);
								} else h.value = e;
								d.value = e;
							}
						}
						function I() {
							m.value || (r.allowHalf && (p.value = r.modelValue !== Math.floor(r.modelValue)), (h.value = r.modelValue), (d.value = -1));
						}
						return (
							ds(
								() => r.modelValue,
								(e) => {
									(h.value = e), (p.value = r.modelValue !== Math.floor(r.modelValue));
								}
							),
							r.modelValue || n(_N, 0),
							t({ setCurrentValue: M, resetCurrentValue: I }),
							(e, t) => (
								Wr(),
								Kr(
									"div",
									{
										id: it(u),
										class: gt([it(f), it(l).is("disabled", it(m))]),
										role: "slider",
										"aria-label": it(c) ? void 0 : e.label || "rating",
										"aria-labelledby": it(c) ? it(o).labelId : void 0,
										"aria-valuenow": h.value,
										"aria-valuetext": it(g) || void 0,
										"aria-valuemin": "0",
										"aria-valuemax": e.max,
										tabindex: "0",
										style: pt(it(v)),
										onKeydown: A
									},
									[
										(Wr(!0),
										Kr(
											Hr,
											null,
											pi(
												e.max,
												(e, t) => (
													Wr(),
													Kr(
														"span",
														{
															key: t,
															class: gt(it(l).e("item")),
															onMousemove: (t) => M(e, t),
															onMouseleave: I,
															onClick: (t) => {
																return (i = e), void (m.value || (r.allowHalf && p.value ? (n(_N, h.value), r.modelValue !== h.value && n("change", h.value)) : (n(_N, i), r.modelValue !== i && n("change", i))));
																var i;
															}
														},
														[
															ri(
																it(OB),
																{ class: gt([it(l).e("icon"), { hover: d.value === e }, it(l).is("active", e <= h.value)]) },
																{
																	default: cn(() => [
																		k(e) ? ai("v-if", !0) : (Wr(), qr(Nr(it(T)[e - 1]), { key: 0 })),
																		k(e) ? (Wr(), qr(it(OB), { key: 1, style: pt(it(_)), class: gt([it(l).e("icon"), it(l).e("decimal")]) }, { default: cn(() => [(Wr(), qr(Nr(it(C))))]), _: 1 }, 8, ["style", "class"])) : ai("v-if", !0)
																	]),
																	_: 2
																},
																1032,
																["class"]
															)
														],
														42,
														gq
													)
												)
											),
											128
										)),
										e.showText || e.showScore ? (Wr(), Kr("span", { key: 0, class: gt(it(l).e("text")) }, bt(it(g)), 3)) : ai("v-if", !0)
									],
									46,
									vq
								)
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]
		)
	),
	bq = { success: "icon-success", warning: "icon-warning", error: "icon-error", info: "icon-info" },
	xq = { [bq.success]: UL, [bq.warning]: QP, [bq.error]: KL, [bq.info]: NO },
	_q = uN({ title: { type: String, default: "" }, subTitle: { type: String, default: "" }, icon: { type: String, values: ["success", "warning", "info", "error"], default: "info" } });
const wq = mN(
		IB(
			Tn(
				c(u({}, { name: "ElResult" }), {
					props: _q,
					setup(e) {
						const t = e,
							n = BD("result"),
							r = ht(() => {
								const e = t.icon,
									n = e && bq[e] ? bq[e] : "icon-info";
								return { class: n, component: xq[n] || xq["icon-info"] };
							});
						return (e, t) => (
							Wr(),
							Kr(
								"div",
								{ class: gt(it(n).b()) },
								[
									ni("div", { class: gt(it(n).e("icon")) }, [mi(e.$slots, "icon", {}, () => [it(r).component ? (Wr(), qr(Nr(it(r).component), { key: 0, class: gt(it(r).class) }, null, 8, ["class"])) : ai("v-if", !0)])], 2),
									e.title || e.$slots.title ? (Wr(), Kr("div", { key: 0, class: gt(it(n).e("title")) }, [mi(e.$slots, "title", {}, () => [ni("p", null, bt(e.title), 1)])], 2)) : ai("v-if", !0),
									e.subTitle || e.$slots["sub-title"] ? (Wr(), Kr("div", { key: 1, class: gt(it(n).e("subtitle")) }, [mi(e.$slots, "sub-title", {}, () => [ni("p", null, bt(e.subTitle), 1)])], 2)) : ai("v-if", !0),
									e.$slots.extra ? (Wr(), Kr("div", { key: 2, class: gt(it(n).e("extra")) }, [mi(e.$slots, "extra")], 2)) : ai("v-if", !0)
								],
								2
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]
		)
	),
	Cq = uN({
		tag: { type: String, default: "div" },
		gutter: { type: Number, default: 0 },
		justify: { type: String, values: ["start", "center", "end", "space-around", "space-between", "space-evenly"], default: "start" },
		align: { type: String, values: ["top", "middle", "bottom"], default: "top" }
	});
const Sq = mN(
	IB(
		Tn(
			c(u({}, { name: "ElRow" }), {
				props: Cq,
				setup(e) {
					const t = e,
						n = BD("row"),
						r = ht(() => t.gutter);
					mn(qN, { gutter: r });
					const i = ht(() => {
						const e = {};
						return t.gutter ? ((e.marginRight = e.marginLeft = `-${t.gutter / 2}px`), e) : e;
					});
					return (e, r) => (Wr(), qr(Nr(e.tag), { class: gt([it(n).b(), it(n).is(`justify-${t.justify}`, "start" !== e.justify), it(n).is(`align-${t.align}`, "top" !== e.align)]), style: pt(it(i)) }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["class", "style"]));
				}
			})
		),
		[["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]
	)
);
var Eq =
	Number.isNaN ||
	function (e) {
		return "number" == typeof e && e != e;
	};
function Tq(e, t) {
	if (e.length !== t.length) return !1;
	for (var n = 0; n < e.length; n++) if (((r = e[n]), (i = t[n]), !(r === i || (Eq(r) && Eq(i))))) return !1;
	var r, i;
	return !0;
}
const kq = () => {
		const e = Si().proxy.$props;
		return ht(() => {
			const t = (e, t, n) => ({});
			return e.perfMode
				? VS(t)
				: (function (e, t) {
						void 0 === t && (t = Tq);
						var n = null;
						function r() {
							for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
							if (n && n.lastThis === this && t(r, n.lastArgs)) return n.lastResult;
							var s = e.apply(this, r);
							return (n = { lastResult: s, lastArgs: r, lastThis: this }), s;
						}
						return (
							(r.clear = function () {
								n = null;
							}),
							r
						);
				  })(t);
		});
	},
	Aq = "rtl",
	Mq = { horizontal: "left", vertical: "top" },
	Iq = { horizontal: "deltaX", vertical: "deltaY" },
	Rq = lN({ type: [Number, Function], required: !0 }),
	Lq = lN({ type: Number }),
	Oq = lN({ type: Number, default: 2 }),
	Pq = lN({ type: String, values: ["ltr", "rtl"], default: "ltr" }),
	Nq = lN({ type: Number, default: 0 }),
	Dq = lN({ type: Number, required: !0 }),
	Bq = lN({ type: String, values: ["horizontal", "vertical"], default: "vertical" }),
	Fq = uN({
		className: { type: String, default: "" },
		containerElement: { type: [String, Object], default: "div" },
		data: { type: Array, default: () => [] },
		direction: Pq,
		height: { type: [String, Number], required: !0 },
		innerElement: { type: [String, Object], default: "div" },
		style: { type: [Object, String, Array] },
		useIsScrolling: { type: Boolean, default: !1 },
		width: { type: [Number, String], required: !1 },
		perfMode: { type: Boolean, default: !0 },
		scrollbarAlwaysOn: { type: Boolean, default: !1 }
	}),
	Hq = uN(u({ cache: Oq, estimatedItemSize: Lq, layout: Bq, initScrollOffset: Nq, total: Dq, itemSize: Rq }, Fq)),
	Vq = { type: Number, default: 6 },
	Uq = { type: Number, default: 0 },
	zq = { type: Number, default: 2 },
	$q = uN(
		u(
			{
				columnCache: Oq,
				columnWidth: Rq,
				estimatedColumnWidth: Lq,
				estimatedRowHeight: Lq,
				initScrollLeft: Nq,
				initScrollTop: Nq,
				itemKey: { type: Function, default: ({ columnIndex: e, rowIndex: t }) => `${t}:${e}` },
				rowCache: Oq,
				rowHeight: Rq,
				totalColumn: Dq,
				totalRow: Dq,
				hScrollbarSize: Vq,
				vScrollbarSize: Vq,
				scrollbarStartGap: Uq,
				scrollbarEndGap: zq
			},
			Fq
		)
	),
	jq = uN({ alwaysOn: Boolean, class: String, layout: Bq, total: Dq, ratio: { type: Number, required: !0 }, clientSize: { type: Number, required: !0 }, scrollFrom: { type: Number, required: !0 }, scrollbarSize: Vq, startGap: Uq, endGap: zq, visible: Boolean }),
	Wq = (e, t) => (e < t ? "forward" : "backward"),
	Gq = (e) => "ltr" === e || e === Aq || "horizontal" === e,
	Yq = (e) => e === Aq;
let Xq = null;
function Kq(e = !1) {
	if (null === Xq || e) {
		const e = document.createElement("div"),
			t = e.style;
		(t.width = "50px"), (t.height = "50px"), (t.overflow = "scroll"), (t.direction = "rtl");
		const n = document.createElement("div"),
			r = n.style;
		return (r.width = "100px"), (r.height = "100px"), e.appendChild(n), document.body.appendChild(e), e.scrollLeft > 0 ? (Xq = "positive-descending") : ((e.scrollLeft = 1), (Xq = 0 === e.scrollLeft ? "negative" : "positive-ascending")), document.body.removeChild(e), Xq;
	}
	return Xq;
}
const qq = Tn({
		name: "ElVirtualScrollBar",
		props: jq,
		emits: ["scroll", "start-move", "stop-move"],
		setup(e, { emit: t }) {
			const n = ht(() => e.startGap + e.endGap),
				r = BD("virtual-scrollbar"),
				i = BD("scrollbar"),
				s = Qe(),
				o = Qe();
			let a = null,
				l = null;
			const u = Fe({ isDragging: !1, traveled: 0 }),
				c = ht(() => GB[e.layout]),
				h = ht(() => e.clientSize - it(n)),
				d = ht(() => ({ position: "absolute", width: `${"horizontal" === e.layout ? h.value : e.scrollbarSize}px`, height: `${"horizontal" === e.layout ? e.scrollbarSize : h.value}px`, [Mq[e.layout]]: "2px", right: "2px", bottom: "2px", borderRadius: "4px" })),
				p = ht(() => {
					const t = e.ratio,
						n = e.clientSize;
					if (t >= 100) return Number.POSITIVE_INFINITY;
					if (t >= 50) return (t * n) / 100;
					const r = n / 3;
					return Math.floor(Math.min(Math.max(t * n, 20), r));
				}),
				f = ht(() => {
					if (!Number.isFinite(p.value)) return { display: "none" };
					const t = `${p.value}px`;
					return (function ({ move: e, size: t, bar: n }, r) {
						const i = {},
							s = `translate${n.axis}(${e}px)`;
						return (i[n.size] = t), (i.transform = s), (i.msTransform = s), (i.webkitTransform = s), "horizontal" === r ? (i.height = "100%") : (i.width = "100%"), i;
					})({ bar: c.value, size: t, move: u.traveled }, e.layout);
				}),
				m = ht(() => Math.floor(e.clientSize - p.value - it(n))),
				v = () => {
					window.removeEventListener("mousemove", b), window.removeEventListener("mouseup", y), (document.onselectstart = l), (l = null);
					const e = it(o);
					e && (e.removeEventListener("touchmove", b), e.removeEventListener("touchend", y));
				},
				g = (e) => {
					e.stopImmediatePropagation(),
						e.ctrlKey ||
							[1, 2].includes(e.button) ||
							((u.isDragging = !0),
							(u[c.value.axis] = e.currentTarget[c.value.offset] - (e[c.value.client] - e.currentTarget.getBoundingClientRect()[c.value.direction])),
							t("start-move"),
							(() => {
								window.addEventListener("mousemove", b), window.addEventListener("mouseup", y);
								const e = it(o);
								e && ((l = document.onselectstart), (document.onselectstart = () => !1), e.addEventListener("touchmove", b), e.addEventListener("touchend", y));
							})());
				},
				y = () => {
					(u.isDragging = !1), (u[c.value.axis] = 0), t("stop-move"), v();
				},
				b = (n) => {
					const { isDragging: r } = u;
					if (!r) return;
					if (!o.value || !s.value) return;
					const i = u[c.value.axis];
					if (!i) return;
					NN(a);
					const l = -1 * (s.value.getBoundingClientRect()[c.value.direction] - n[c.value.client]) - (o.value[c.value.offset] - i);
					a = PN(() => {
						(u.traveled = Math.max(e.startGap, Math.min(l, m.value))), t("scroll", l, m.value);
					});
				},
				x = (e) => {
					const n = Math.abs(e.target.getBoundingClientRect()[c.value.direction] - e[c.value.client]) - o.value[c.value.offset] / 2;
					(u.traveled = Math.max(0, Math.min(n, m.value))), t("scroll", n, m.value);
				};
			return (
				ds(
					() => e.scrollFrom,
					(e) => {
						u.isDragging || (u.traveled = Math.ceil(e * m.value));
					}
				),
				$n(() => {
					v();
				}),
				() => xs("div", { role: "presentation", ref: s, class: [r.b(), e.class, (e.alwaysOn || u.isDragging) && "always-on"], style: d.value, onMousedown: zo(x, ["stop", "prevent"]), onTouchstartPrevent: g }, xs("div", { ref: o, class: i.e("thumb"), style: f.value, onMousedown: g }, []))
			);
		}
	}),
	Zq = ({ name: e, getOffset: t, getItemSize: n, getItemOffset: r, getEstimatedTotalSize: i, getStartIndexForOffset: s, getStopIndexForStartIndex: o, initCache: a, clearCache: l, validateProps: h }) =>
		Tn({
			name: null != e ? e : "ElVirtualList",
			props: Hq,
			emits: ["itemRendered", "scroll"],
			setup(e, { emit: d, expose: p }) {
				h(e);
				const f = Si(),
					m = BD("vl"),
					v = Qe(a(e, f)),
					g = kq(),
					y = Qe(),
					b = Qe(),
					x = Qe(),
					_ = Qe({ isScrolling: !1, scrollDir: "forward", scrollOffset: XI(e.initScrollOffset) ? e.initScrollOffset : 0, updateRequested: !1, isScrollbarDragging: !1, scrollbarAlwaysOn: e.scrollbarAlwaysOn }),
					w = ht(() => {
						const { total: t, cache: n } = e,
							{ isScrolling: r, scrollDir: i, scrollOffset: a } = it(_);
						if (0 === t) return [0, 0, 0, 0];
						const l = s(e, a, it(v)),
							u = o(e, l, a, it(v)),
							c = r && "backward" !== i ? 1 : Math.max(1, n),
							h = r && "forward" !== i ? 1 : Math.max(1, n);
						return [Math.max(0, l - c), Math.max(0, Math.min(t - 1, u + h)), l, u];
					}),
					C = ht(() => i(e, it(v))),
					S = ht(() => Gq(e.layout)),
					E = ht(() => [
						{ position: "relative", ["overflow-" + (S.value ? "x" : "y")]: "scroll", WebkitOverflowScrolling: "touch", willChange: "transform" },
						{ direction: e.direction, height: XI(e.height) ? `${e.height}px` : e.height, width: XI(e.width) ? `${e.width}px` : e.width },
						e.style
					]),
					T = ht(() => {
						const e = it(C),
							t = it(S);
						return { height: t ? "100%" : `${e}px`, pointerEvents: it(_).isScrolling ? "none" : void 0, width: t ? `${e}px` : "100%" };
					}),
					k = ht(() => (S.value ? e.width : e.height)),
					{ onWheel: A } = (({ atEndEdge: e, atStartEdge: t, layout: n }, r) => {
						let i,
							s = 0;
						const o = (n) => (n < 0 && t.value) || (n > 0 && e.value);
						return {
							hasReachedEdge: o,
							onWheel: (e) => {
								NN(i);
								const t = e[Iq[n.value]];
								(o(s) && o(s + t)) ||
									((s += t),
									LN() || e.preventDefault(),
									(i = PN(() => {
										r(s), (s = 0);
									})));
							}
						};
					})({ atStartEdge: ht(() => _.value.scrollOffset <= 0), atEndEdge: ht(() => _.value.scrollOffset >= C.value), layout: ht(() => e.layout) }, (e) => {
						var t, n;
						null == (n = (t = x.value).onMouseUp) || n.call(t), I(Math.min(_.value.scrollOffset + e, C.value - k.value));
					}),
					M = () => {
						const { total: t } = e;
						if (t > 0) {
							const [e, t, n, r] = it(w);
							d("itemRendered", e, t, n, r);
						}
						const { scrollDir: n, scrollOffset: r, updateRequested: i } = it(_);
						d("scroll", n, r, i);
					},
					I = (e) => {
						(e = Math.max(e, 0)) !== it(_).scrollOffset && ((_.value = c(u({}, it(_)), { scrollOffset: e, scrollDir: Wq(it(_).scrollOffset, e), updateRequested: !0 })), ns(L));
					},
					R = (n, r = "auto") => {
						const { scrollOffset: i } = it(_);
						(n = Math.max(0, Math.min(n, e.total - 1))), I(t(e, n, r, i, it(v)));
					},
					L = () => {
						(_.value.isScrolling = !1),
							ns(() => {
								g.value(-1, null, null);
							});
					},
					O = () => {
						const e = y.value;
						e && (e.scrollTop = 0);
					};
				Vn(() => {
					if (!GI) return;
					const { initScrollOffset: t } = e,
						n = it(y);
					XI(t) && n && (it(S) ? (n.scrollLeft = t) : (n.scrollTop = t)), M();
				}),
					zn(() => {
						const { direction: t, layout: n } = e,
							{ scrollOffset: r, updateRequested: i } = it(_),
							s = it(y);
						if (i && s)
							if ("horizontal" === n)
								if (t === Aq)
									switch (Kq()) {
										case "negative":
											s.scrollLeft = -r;
											break;
										case "positive-ascending":
											s.scrollLeft = r;
											break;
										default: {
											const { clientWidth: e, scrollWidth: t } = s;
											s.scrollLeft = t - e - r;
											break;
										}
									}
								else s.scrollLeft = r;
							else s.scrollTop = r;
					});
				const P = {
					ns: m,
					clientSize: k,
					estimatedTotalSize: C,
					windowStyle: E,
					windowRef: y,
					innerRef: b,
					innerStyle: T,
					itemsToRender: w,
					scrollbarRef: x,
					states: _,
					getItemStyle: (t) => {
						const { direction: i, itemSize: s, layout: o } = e,
							a = g.value(l && s, l && o, l && i);
						let u;
						if (xR(a, String(t))) u = a[t];
						else {
							const s = r(e, t, it(v)),
								o = n(e, t, it(v)),
								l = it(S),
								c = i === Aq,
								h = l ? s : 0;
							a[t] = u = { position: "absolute", left: c ? void 0 : `${h}px`, right: c ? `${h}px` : void 0, top: l ? 0 : `${s}px`, height: l ? "100%" : `${o}px`, width: l ? `${o}px` : "100%" };
						}
						return u;
					},
					onScroll: (t) => {
						it(S)
							? ((t) => {
									const { clientWidth: n, scrollLeft: r, scrollWidth: i } = t.currentTarget,
										s = it(_);
									if (s.scrollOffset === r) return;
									const { direction: o } = e;
									let a = r;
									if (o === Aq)
										switch (Kq()) {
											case "negative":
												a = -r;
												break;
											case "positive-descending":
												a = i - n - r;
										}
									(a = Math.max(0, Math.min(a, i - n))), (_.value = c(u({}, s), { isScrolling: !0, scrollDir: Wq(s.scrollOffset, a), scrollOffset: a, updateRequested: !1 })), ns(L);
							  })(t)
							: ((e) => {
									const { clientHeight: t, scrollHeight: n, scrollTop: r } = e.currentTarget,
										i = it(_);
									if (i.scrollOffset === r) return;
									const s = Math.max(0, Math.min(r, n - t));
									(_.value = c(u({}, i), { isScrolling: !0, scrollDir: Wq(i.scrollOffset, s), scrollOffset: s, updateRequested: !1 })), ns(L);
							  })(t),
							M();
					},
					onScrollbarScroll: (e, t) => {
						const n = ((C.value - k.value) / t) * e;
						I(Math.min(C.value - k.value, n));
					},
					onWheel: A,
					scrollTo: I,
					scrollToItem: R,
					resetScrollTop: O
				};
				return p({ windowRef: y, innerRef: b, getItemStyleCache: g, scrollTo: I, scrollToItem: R, resetScrollTop: O, states: _ }), P;
			},
			render(e) {
				var t;
				const { $slots: n, className: r, clientSize: i, containerElement: s, data: o, getItemStyle: a, innerElement: l, itemsToRender: u, innerStyle: c, layout: h, total: d, onScroll: p, onScrollbarScroll: f, onWheel: m, states: v, useIsScrolling: g, windowStyle: y, ns: b } = e,
					[x, _] = u,
					w = Nr(s),
					C = Nr(l),
					S = [];
				if (d > 0) for (let A = x; A <= _; A++) S.push(null == (t = n.default) ? void 0 : t.call(n, { data: o, key: A, index: A, isScrolling: g ? v.isScrolling : void 0, style: a(A) }));
				const E = [xs(C, { style: c, ref: "innerRef" }, SR(C) ? S : { default: () => S })],
					T = xs(qq, { ref: "scrollbarRef", clientSize: i, layout: h, onScroll: f, ratio: (100 * i) / this.estimatedTotalSize, scrollFrom: v.scrollOffset / (this.estimatedTotalSize - i), total: d }),
					k = xs(w, { class: ["el-vl__window", r], style: y, onScroll: p, onWheel: m, ref: "windowRef", key: 0 }, SR(w) ? [E] : { default: () => [E] });
				return xs("div", { key: 0, class: [b.e("wrapper"), v.scrollbarAlwaysOn ? "always-on" : ""] }, [k, T]);
			}
		}),
	Jq = Zq({
		name: "ElFixedSizeList",
		getItemOffset: ({ itemSize: e }, t) => t * e,
		getItemSize: ({ itemSize: e }) => e,
		getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
		getOffset: ({ height: e, total: t, itemSize: n, layout: r, width: i }, s, o, a) => {
			const l = Gq(r) ? i : e,
				u = Math.max(0, t * n - l),
				c = Math.min(u, s * n),
				h = Math.max(0, (s + 1) * n - l);
			switch (("smart" === o && (o = a >= h - l && a <= c + l ? "auto" : "center"), o)) {
				case "start":
					return c;
				case "end":
					return h;
				case "center": {
					const e = Math.round(h + (c - h) / 2);
					return e < Math.ceil(l / 2) ? 0 : e > u + Math.floor(l / 2) ? u : e;
				}
				case "auto":
				default:
					return a >= h && a <= c ? a : a < h ? h : c;
			}
		},
		getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
		getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: r, width: i }, s, o) => {
			const a = s * n,
				l = Gq(r) ? i : e,
				u = Math.ceil((l + o - a) / n);
			return Math.max(0, Math.min(t - 1, s + u - 1));
		},
		initCache() {},
		clearCache: !0,
		validateProps() {}
	}),
	Qq = (e, t, n) => {
		const { itemSize: r } = e,
			{ items: i, lastVisitedIndex: s } = n;
		if (t > s) {
			let e = 0;
			if (s >= 0) {
				const t = i[s];
				e = t.offset + t.size;
			}
			for (let n = s + 1; n <= t; n++) {
				const t = r(n);
				(i[n] = { offset: e, size: t }), (e += t);
			}
			n.lastVisitedIndex = t;
		}
		return i[t];
	},
	eZ = (e, t, n, r, i) => {
		for (; n <= r; ) {
			const s = n + Math.floor((r - n) / 2),
				o = Qq(e, s, t).offset;
			if (o === i) return s;
			o < i ? (n = s + 1) : o > i && (r = s - 1);
		}
		return Math.max(0, n - 1);
	},
	tZ = (e, t, n, r) => {
		const { total: i } = e;
		let s = 1;
		for (; n < i && Qq(e, n, t).offset < r; ) (n += s), (s *= 2);
		return eZ(e, t, Math.floor(n / 2), Math.min(n, i - 1), r);
	},
	nZ = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: r }) => {
		let i = 0;
		if ((r >= e && (r = e - 1), r >= 0)) {
			const e = t[r];
			i = e.offset + e.size;
		}
		return i + (e - r - 1) * n;
	},
	rZ = Zq({
		name: "ElDynamicSizeList",
		getItemOffset: (e, t, n) => Qq(e, t, n).offset,
		getItemSize: (e, t, { items: n }) => n[t].size,
		getEstimatedTotalSize: nZ,
		getOffset: (e, t, n, r, i) => {
			const { height: s, layout: o, width: a } = e,
				l = Gq(o) ? a : s,
				u = Qq(e, t, i),
				c = nZ(e, i),
				h = Math.max(0, Math.min(c - l, u.offset)),
				d = Math.max(0, u.offset - l + u.size);
			switch (("smart" === n && (n = r >= d - l && r <= h + l ? "auto" : "center"), n)) {
				case "start":
					return h;
				case "end":
					return d;
				case "center":
					return Math.round(d + (h - d) / 2);
				case "auto":
				default:
					return r >= d && r <= h ? r : r < d ? d : h;
			}
		},
		getStartIndexForOffset: (e, t, n) =>
			((e, t, n) => {
				const { items: r, lastVisitedIndex: i } = t;
				return (i > 0 ? r[i].offset : 0) >= n ? eZ(e, t, 0, i, n) : tZ(e, t, Math.max(0, i), n);
			})(e, n, t),
		getStopIndexForStartIndex: (e, t, n, r) => {
			const { height: i, total: s, layout: o, width: a } = e,
				l = Gq(o) ? a : i,
				u = Qq(e, t, r),
				c = n + l;
			let h = u.offset + u.size,
				d = t;
			for (; d < s - 1 && h < c; ) d++, (h += Qq(e, d, r).size);
			return d;
		},
		initCache({ estimatedItemSize: e = 50 }, t) {
			const n = {
				items: {},
				estimatedItemSize: e,
				lastVisitedIndex: -1,
				clearCacheAfterIndex: (e, r = !0) => {
					var i, s;
					(n.lastVisitedIndex = Math.min(n.lastVisitedIndex, e - 1)), null == (i = t.exposed) || i.getItemStyleCache(-1), r && (null == (s = t.proxy) || s.$forceUpdate());
				}
			};
			return n;
		},
		clearCache: !1,
		validateProps: ({ itemSize: e }) => {}
	}),
	iZ = ({
		name: e,
		clearCache: t,
		getColumnPosition: n,
		getColumnStartIndexForOffset: r,
		getColumnStopIndexForStartIndex: i,
		getEstimatedTotalHeight: s,
		getEstimatedTotalWidth: o,
		getColumnOffset: a,
		getRowOffset: l,
		getRowPosition: h,
		getRowStartIndexForOffset: d,
		getRowStopIndexForStartIndex: p,
		initCache: f,
		injectToInstance: m,
		validateProps: v
	}) =>
		Tn({
			name: null != e ? e : "ElVirtualList",
			props: $q,
			emits: ["itemRendered", "scroll"],
			setup(e, { emit: g, expose: y, slots: b }) {
				const x = BD("vl");
				v(e);
				const _ = Si(),
					w = Qe(f(e, _));
				null == m || m(_, w);
				const C = Qe(),
					S = Qe(),
					E = Qe(),
					T = Qe(null),
					k = Qe({ isScrolling: !1, scrollLeft: XI(e.initScrollLeft) ? e.initScrollLeft : 0, scrollTop: XI(e.initScrollTop) ? e.initScrollTop : 0, updateRequested: !1, xAxisScrollDir: "forward", yAxisScrollDir: "forward" }),
					A = kq(),
					M = ht(() => Number.parseInt(`${e.height}`, 10)),
					I = ht(() => Number.parseInt(`${e.width}`, 10)),
					R = ht(() => {
						const { totalColumn: t, totalRow: n, columnCache: s } = e,
							{ isScrolling: o, xAxisScrollDir: a, scrollLeft: l } = it(k);
						if (0 === t || 0 === n) return [0, 0, 0, 0];
						const u = r(e, l, it(w)),
							c = i(e, u, l, it(w)),
							h = o && "backward" !== a ? 1 : Math.max(1, s),
							d = o && "forward" !== a ? 1 : Math.max(1, s);
						return [Math.max(0, u - h), Math.max(0, Math.min(t - 1, c + d)), u, c];
					}),
					L = ht(() => {
						const { totalColumn: t, totalRow: n, rowCache: r } = e,
							{ isScrolling: i, yAxisScrollDir: s, scrollTop: o } = it(k);
						if (0 === t || 0 === n) return [0, 0, 0, 0];
						const a = d(e, o, it(w)),
							l = p(e, a, o, it(w)),
							u = i && "backward" !== s ? 1 : Math.max(1, r),
							c = i && "forward" !== s ? 1 : Math.max(1, r);
						return [Math.max(0, a - u), Math.max(0, Math.min(n - 1, l + c)), a, l];
					}),
					O = ht(() => s(e, it(w))),
					P = ht(() => o(e, it(w))),
					N = ht(() => {
						var t;
						return [{ position: "relative", overflow: "hidden", WebkitOverflowScrolling: "touch", willChange: "transform" }, { direction: e.direction, height: XI(e.height) ? `${e.height}px` : e.height, width: XI(e.width) ? `${e.width}px` : e.width }, null != (t = e.style) ? t : {}];
					}),
					D = ht(() => {
						const e = `${it(P)}px`;
						return { height: `${it(O)}px`, pointerEvents: it(k).isScrolling ? "none" : void 0, width: e };
					}),
					B = () => {
						const { totalColumn: t, totalRow: n } = e;
						if (t > 0 && n > 0) {
							const [e, t, n, r] = it(R),
								[i, s, o, a] = it(L);
							g("itemRendered", { columnCacheStart: e, columnCacheEnd: t, rowCacheStart: i, rowCacheEnd: s, columnVisibleStart: n, columnVisibleEnd: r, rowVisibleStart: o, rowVisibleEnd: a });
						}
						const { scrollLeft: r, scrollTop: i, updateRequested: s, xAxisScrollDir: o, yAxisScrollDir: a } = it(k);
						g("scroll", { xAxisScrollDir: o, scrollLeft: r, yAxisScrollDir: a, scrollTop: i, updateRequested: s });
					},
					F = (t) => {
						const { clientHeight: n, clientWidth: r, scrollHeight: i, scrollLeft: s, scrollTop: o, scrollWidth: a } = t.currentTarget,
							l = it(k);
						if (l.scrollTop === o && l.scrollLeft === s) return;
						let h = s;
						if (Yq(e.direction))
							switch (Kq()) {
								case "negative":
									h = -s;
									break;
								case "positive-descending":
									h = a - r - s;
							}
						(k.value = c(u({}, l), { isScrolling: !0, scrollLeft: h, scrollTop: Math.max(0, Math.min(o, i - n)), updateRequested: !0, xAxisScrollDir: Wq(l.scrollLeft, h), yAxisScrollDir: Wq(l.scrollTop, o) })), ns(() => j()), W(), B();
					},
					H = (e, t) => {
						const n = it(M),
							r = ((O.value - n) / t) * e;
						z({ scrollTop: Math.min(O.value - n, r) });
					},
					V = (e, t) => {
						const n = it(I),
							r = ((P.value - n) / t) * e;
						z({ scrollLeft: Math.min(P.value - n, r) });
					},
					{ onWheel: U } = (({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: r }, i) => {
						let s = null,
							o = 0,
							a = 0;
						const l = (i, s) => {
							const o = (i < 0 && t.value) || (i > 0 && e.value),
								a = (s < 0 && r.value) || (s > 0 && n.value);
							return o && a;
						};
						return {
							hasReachedEdge: l,
							onWheel: (e) => {
								NN(s);
								let t = e.deltaX,
									n = e.deltaY;
								Math.abs(t) > Math.abs(n) ? (n = 0) : (t = 0),
									e.shiftKey && 0 !== n && ((t = n), (n = 0)),
									(l(o, a) && l(o + t, a + n)) ||
										((o += t),
										(a += n),
										LN() || e.preventDefault(),
										(s = PN(() => {
											i(o, a), (o = 0), (a = 0);
										})));
							}
						};
					})({ atXStartEdge: ht(() => k.value.scrollLeft <= 0), atXEndEdge: ht(() => k.value.scrollLeft >= P.value), atYStartEdge: ht(() => k.value.scrollTop <= 0), atYEndEdge: ht(() => k.value.scrollTop >= O.value) }, (e, t) => {
						var n, r, i, s;
						null == (r = null == (n = S.value) ? void 0 : n.onMouseUp) || r.call(n), null == (s = null == (i = S.value) ? void 0 : i.onMouseUp) || s.call(i);
						const o = it(I),
							a = it(M);
						z({ scrollLeft: Math.min(k.value.scrollLeft + e, P.value - o), scrollTop: Math.min(k.value.scrollTop + t, O.value - a) });
					}),
					z = ({ scrollLeft: e = k.value.scrollLeft, scrollTop: t = k.value.scrollTop }) => {
						(e = Math.max(e, 0)), (t = Math.max(t, 0));
						const n = it(k);
						(t === n.scrollTop && e === n.scrollLeft) || ((k.value = c(u({}, n), { xAxisScrollDir: Wq(n.scrollLeft, e), yAxisScrollDir: Wq(n.scrollTop, t), scrollLeft: e, scrollTop: t, updateRequested: !0 })), ns(() => j()), W(), B());
					},
					$ = (r, i) => {
						const { columnWidth: s, direction: o, rowHeight: a } = e,
							l = A.value(t && s, t && a, t && o),
							u = `${r},${i}`;
						if (xR(l, u)) return l[u];
						{
							const [, t] = n(e, i, it(w)),
								s = it(w),
								a = Yq(o),
								[c, d] = h(e, r, s),
								[p] = n(e, i, s);
							return (l[u] = { position: "absolute", left: a ? void 0 : `${t}px`, right: a ? `${t}px` : void 0, top: `${d}px`, height: `${c}px`, width: `${p}px` }), l[u];
						}
					},
					j = () => {
						(k.value.isScrolling = !1),
							ns(() => {
								A.value(-1, null, null);
							});
					};
				Vn(() => {
					if (!GI) return;
					const { initScrollLeft: t, initScrollTop: n } = e,
						r = it(C);
					r && (XI(t) && (r.scrollLeft = t), XI(n) && (r.scrollTop = n)), B();
				});
				const W = () => {
						const { direction: t } = e,
							{ scrollLeft: n, scrollTop: r, updateRequested: i } = it(k),
							s = it(C);
						if (i && s) {
							if (t === Aq)
								switch (Kq()) {
									case "negative":
										s.scrollLeft = -n;
										break;
									case "positive-ascending":
										s.scrollLeft = n;
										break;
									default: {
										const { clientWidth: e, scrollWidth: t } = s;
										s.scrollLeft = t - e - n;
										break;
									}
								}
							else s.scrollLeft = Math.max(0, n);
							s.scrollTop = Math.max(0, r);
						}
					},
					{ resetAfterColumnIndex: G, resetAfterRowIndex: Y, resetAfter: X } = _.proxy;
				y({
					windowRef: C,
					innerRef: T,
					getItemStyleCache: A,
					scrollTo: z,
					scrollToItem: (t = 0, n = 0, r = "auto") => {
						const i = it(k);
						(n = Math.max(0, Math.min(n, e.totalColumn - 1))), (t = Math.max(0, Math.min(t, e.totalRow - 1)));
						const u = QR(),
							c = it(w),
							h = s(e, c),
							d = o(e, c);
						z({ scrollLeft: a(e, n, r, i.scrollLeft, c, d > e.width ? u : 0), scrollTop: l(e, t, r, i.scrollTop, c, h > e.height ? u : 0) });
					},
					states: k,
					resetAfterColumnIndex: G,
					resetAfterRowIndex: Y,
					resetAfter: X
				});
				const K = () => {
					const t = Nr(e.innerElement),
						n = (() => {
							var t;
							const [n, r] = it(R),
								[i, s] = it(L),
								{ data: o, totalColumn: a, totalRow: l, useIsScrolling: u, itemKey: c } = e,
								h = [];
							if (l > 0 && a > 0)
								for (let e = i; e <= s; e++) for (let i = n; i <= r; i++) h.push(null == (t = b.default) ? void 0 : t.call(b, { columnIndex: i, data: o, key: c({ columnIndex: i, data: o, rowIndex: e }), isScrolling: u ? it(k).isScrolling : void 0, style: $(e, i), rowIndex: e }));
							return h;
						})();
					return [xs(t, { style: it(D), ref: T }, SR(t) ? n : { default: () => n })];
				};
				return () => {
					const t = Nr(e.containerElement),
						{ horizontalScrollbar: n, verticalScrollbar: r } = (() => {
							const { scrollbarAlwaysOn: t, scrollbarStartGap: n, scrollbarEndGap: r, totalColumn: i, totalRow: s } = e,
								o = it(I),
								a = it(M),
								l = it(P),
								u = it(O),
								{ scrollLeft: c, scrollTop: h } = it(k);
							return {
								horizontalScrollbar: xs(qq, { ref: S, alwaysOn: t, startGap: n, endGap: r, class: x.e("horizontal"), clientSize: o, layout: "horizontal", onScroll: V, ratio: (100 * o) / l, scrollFrom: c / (l - o), total: s, visible: !0 }),
								verticalScrollbar: xs(qq, { ref: E, alwaysOn: t, startGap: n, endGap: r, class: x.e("vertical"), clientSize: a, layout: "vertical", onScroll: H, ratio: (100 * a) / u, scrollFrom: h / (u - a), total: i, visible: !0 })
							};
						})(),
						i = K();
					return xs("div", { key: 0, class: x.e("wrapper") }, [xs(t, { class: e.className, style: it(N), onScroll: F, onWheel: U, ref: C }, SR(t) ? i : { default: () => i }), n, r]);
				};
			}
		}),
	sZ = iZ({
		name: "ElFixedSizeGrid",
		getColumnPosition: ({ columnWidth: e }, t) => [e, t * e],
		getRowPosition: ({ rowHeight: e }, t) => [e, t * e],
		getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
		getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
		getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, r, i, s, o, a) => {
			n = Number(n);
			const l = Math.max(0, e * t - n),
				u = Math.min(l, r * t),
				c = Math.max(0, r * t - n + a + t);
			switch (("smart" === i && (i = s >= c - n && s <= u + n ? "auto" : "center"), i)) {
				case "start":
					return u;
				case "end":
					return c;
				case "center": {
					const e = Math.round(c + (u - c) / 2);
					return e < Math.ceil(n / 2) ? 0 : e > l + Math.floor(n / 2) ? l : e;
				}
				case "auto":
				default:
					return s >= c && s <= u ? s : c > u || s < c ? c : u;
			}
		},
		getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, r, i, s, o, a) => {
			t = Number(t);
			const l = Math.max(0, n * e - t),
				u = Math.min(l, r * e),
				c = Math.max(0, r * e - t + a + e);
			switch (("smart" === i && (i = s >= c - t && s <= u + t ? "auto" : "center"), i)) {
				case "start":
					return u;
				case "end":
					return c;
				case "center": {
					const e = Math.round(c + (u - c) / 2);
					return e < Math.ceil(t / 2) ? 0 : e > l + Math.floor(t / 2) ? l : e;
				}
				case "auto":
				default:
					return s >= c && s <= u ? s : c > u || s < c ? c : u;
			}
		},
		getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
		getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, r, i) => {
			const s = r * e,
				o = Math.ceil((n + i - s) / e);
			return Math.max(0, Math.min(t - 1, r + o - 1));
		},
		getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
		getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, r, i) => {
			const s = r * e,
				o = Math.ceil((n + i - s) / e);
			return Math.max(0, Math.min(t - 1, r + o - 1));
		},
		initCache: () => {},
		clearCache: !0,
		validateProps: ({ columnWidth: e, rowHeight: t }) => {}
	}),
	{ max: oZ, min: aZ, floor: lZ } = Math,
	uZ = { column: "columnWidth", row: "rowHeight" },
	cZ = { column: "lastVisitedColumnIndex", row: "lastVisitedRowIndex" },
	hZ = (e, t, n, r) => {
		const [i, s, o] = [n[r], e[uZ[r]], n[cZ[r]]];
		if (t > o) {
			let e = 0;
			if (o >= 0) {
				const t = i[o];
				e = t.offset + t.size;
			}
			for (let n = o + 1; n <= t; n++) {
				const t = s(n);
				(i[n] = { offset: e, size: t }), (e += t);
			}
			n[cZ[r]] = t;
		}
		return i[t];
	},
	dZ = (e, t, n, r, i, s) => {
		for (; n <= r; ) {
			const o = n + lZ((r - n) / 2),
				a = hZ(e, o, t, s).offset;
			if (a === i) return o;
			a < i ? (n = o + 1) : (r = o - 1);
		}
		return oZ(0, n - 1);
	},
	pZ = (e, t, n, r) => {
		const [i, s] = [t[r], t[cZ[r]]];
		return (s > 0 ? i[s].offset : 0) >= n
			? dZ(e, t, 0, s, n, r)
			: ((e, t, n, r, i) => {
					const s = "column" === i ? e.totalColumn : e.totalRow;
					let o = 1;
					for (; n < s && hZ(e, n, t, i).offset < r; ) (n += o), (o *= 2);
					return dZ(e, t, lZ(n / 2), aZ(n, s - 1), r, i);
			  })(e, t, oZ(0, s), n, r);
	},
	fZ = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: r }) => {
		let i = 0;
		if ((n >= e && (n = e - 1), n >= 0)) {
			const e = r[n];
			i = e.offset + e.size;
		}
		return i + (e - n - 1) * t;
	},
	mZ = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: r }) => {
		let i = 0;
		if ((r > e && (r = e - 1), r >= 0)) {
			const e = t[r];
			i = e.offset + e.size;
		}
		return i + (e - r - 1) * n;
	},
	vZ = { column: mZ, row: fZ },
	gZ = (e, t, n, r, i, s, o) => {
		const [a, l] = ["row" === s ? e.height : e.width, vZ[s]],
			u = hZ(e, t, i, s),
			c = l(e, i),
			h = oZ(0, aZ(c - a, u.offset)),
			d = oZ(0, u.offset - a + o + u.size);
		switch (("smart" === n && (n = r >= d - a && r <= h + a ? "auto" : "center"), n)) {
			case "start":
				return h;
			case "end":
				return d;
			case "center":
				return Math.round(d + (h - d) / 2);
			case "auto":
			default:
				return r >= d && r <= h ? r : d > h || r < d ? d : h;
		}
	},
	yZ = iZ({
		name: "ElDynamicSizeGrid",
		getColumnPosition: (e, t, n) => {
			const r = hZ(e, t, n, "column");
			return [r.size, r.offset];
		},
		getRowPosition: (e, t, n) => {
			const r = hZ(e, t, n, "row");
			return [r.size, r.offset];
		},
		getColumnOffset: (e, t, n, r, i, s) => gZ(e, t, n, r, i, "column", s),
		getRowOffset: (e, t, n, r, i, s) => gZ(e, t, n, r, i, "row", s),
		getColumnStartIndexForOffset: (e, t, n) => pZ(e, n, t, "column"),
		getColumnStopIndexForStartIndex: (e, t, n, r) => {
			const i = hZ(e, t, r, "column"),
				s = n + e.width;
			let o = i.offset + i.size,
				a = t;
			for (; a < e.totalColumn - 1 && o < s; ) a++, (o += hZ(e, t, r, "column").size);
			return a;
		},
		getEstimatedTotalHeight: fZ,
		getEstimatedTotalWidth: mZ,
		getRowStartIndexForOffset: (e, t, n) => pZ(e, n, t, "row"),
		getRowStopIndexForStartIndex: (e, t, n, r) => {
			const { totalRow: i, height: s } = e,
				o = hZ(e, t, r, "row"),
				a = n + s;
			let l = o.size + o.offset,
				u = t;
			for (; u < i - 1 && l < a; ) u++, (l += hZ(e, u, r, "row").size);
			return u;
		},
		injectToInstance: (e, t) => {
			const n = ({ columnIndex: n, rowIndex: r }, i) => {
				var s, o;
				(i = !!BR(i) || i),
					XI(n) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, n - 1)),
					XI(r) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, r - 1)),
					null == (s = e.exposed) || s.getItemStyleCache.value(-1, null, null),
					i && (null == (o = e.proxy) || o.$forceUpdate());
			};
			Object.assign(e.proxy, {
				resetAfterColumnIndex: (e, t) => {
					n({ columnIndex: e }, t);
				},
				resetAfterRowIndex: (e, t) => {
					n({ rowIndex: e }, t);
				},
				resetAfter: n
			});
		},
		initCache: ({ estimatedColumnWidth: e = 50, estimatedRowHeight: t = 50 }) => ({ column: {}, estimatedColumnWidth: e, estimatedRowHeight: t, lastVisitedColumnIndex: -1, lastVisitedRowIndex: -1, row: {} }),
		clearCache: !1,
		validateProps: ({ columnWidth: e, rowHeight: t }) => {}
	});
var bZ = IB(Tn({ props: { item: { type: Object, required: !0 }, style: Object, height: Number }, setup: () => ({ ns: BD("select") }) }), [
	[
		"render",
		function (e, t, n, r, i, s) {
			return e.item.isTitle
				? (Wr(), Kr("div", { key: 0, class: gt(e.ns.be("group", "title")), style: pt([e.style, { lineHeight: `${e.height}px` }]) }, bt(e.item.label), 7))
				: (Wr(), Kr("div", { key: 1, class: gt(e.ns.be("group", "split")), style: pt(e.style) }, [ni("span", { class: gt(e.ns.be("group", "split-dash")), style: pt({ top: e.height / 2 + "px" }) }, null, 6)], 6));
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]
]);
const xZ = {
		allowCreate: Boolean,
		autocomplete: { type: String, default: "none" },
		automaticDropdown: Boolean,
		clearable: Boolean,
		clearIcon: { type: [String, Object], default: QL },
		effect: { type: String, default: "light" },
		collapseTags: Boolean,
		collapseTagsTooltip: { type: Boolean, default: !1 },
		defaultFirstOption: Boolean,
		disabled: Boolean,
		estimatedOptionHeight: { type: Number, default: void 0 },
		filterable: Boolean,
		filterMethod: Function,
		height: { type: Number, default: 170 },
		itemHeight: { type: Number, default: 34 },
		id: String,
		loading: Boolean,
		loadingText: String,
		label: String,
		modelValue: [Array, String, Number, Boolean, Object],
		multiple: Boolean,
		multipleLimit: { type: Number, default: 0 },
		name: String,
		noDataText: String,
		noMatchText: String,
		remoteMethod: Function,
		reserveKeyword: { type: Boolean, default: !0 },
		options: { type: Array, required: !0 },
		placeholder: { type: String },
		teleported: VH.teleported,
		persistent: { type: Boolean, default: !0 },
		popperClass: { type: String, default: "" },
		popperOptions: { type: Object, default: () => ({}) },
		remote: Boolean,
		size: { type: String, validator: EN },
		valueKey: { type: String, default: "value" },
		scrollbarAlwaysOn: { type: Boolean, default: !1 }
	},
	_Z = Tn({
		props: { data: Array, disabled: Boolean, hovering: Boolean, item: Object, index: Number, style: Object, selected: Boolean, created: Boolean },
		emits: ["select", "hover"],
		setup(e, { emit: t }) {
			const n = BD("select"),
				{ hoverItem: r, selectOptionClick: i } = (function (e, { emit: t }) {
					return {
						hoverItem: () => {
							e.disabled || t("hover", e.index);
						},
						selectOptionClick: () => {
							e.disabled || t("select", e.item, e.index);
						}
					};
				})(e, { emit: t });
			return { ns: n, hoverItem: r, selectOptionClick: i };
		}
	}),
	wZ = ["aria-selected"];
var CZ = IB(_Z, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return (
				Wr(),
				Kr(
					"li",
					{
						"aria-selected": e.selected,
						style: pt(e.style),
						class: gt([e.ns.be("dropdown", "option-item"), e.ns.is("selected", e.selected), e.ns.is("disabled", e.disabled), e.ns.is("created", e.created), { hover: e.hovering }]),
						onMouseenter: t[0] || (t[0] = (...t) => e.hoverItem && e.hoverItem(...t)),
						onClick: t[1] || (t[1] = zo((...t) => e.selectOptionClick && e.selectOptionClick(...t), ["stop"]))
					},
					[mi(e.$slots, "default", { item: e.item, index: e.index, disabled: e.disabled }, () => [ni("span", null, bt(e.item.label), 1)])],
					46,
					wZ
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]
]);
var SZ = Tn({
	name: "ElSelectDropdown",
	props: { data: { type: Array, required: !0 }, hoveringIndex: Number, width: Number },
	setup(e, { slots: t, expose: n }) {
		const r = vn("ElSelectV2Injection"),
			i = BD("select"),
			s = Qe([]),
			o = Qe(),
			a = ht(() => BR(r.props.estimatedOptionHeight)),
			l = ht(() => (a.value ? { itemSize: r.props.itemHeight } : { estimatedSize: r.props.estimatedOptionHeight, itemSize: (e) => s.value[e] })),
			u = (e, t) => {
				const { valueKey: n } = r.props;
				return r.props.multiple
					? ((e = [], t) => {
							const {
								props: { valueKey: n }
							} = r;
							return ER(t) ? e && e.some((e) => XS(e, n) === XS(t, n)) : e.includes(t);
					  })(e, XS(t, n))
					: ((e, t) => {
							if (ER(t)) {
								const { valueKey: n } = r.props;
								return XS(e, n) === XS(t, n);
							}
							return e === t;
					  })(e, XS(t, n));
			},
			c = (e, t) => {
				const { disabled: n, multiple: i, multipleLimit: s } = r.props;
				return n || (!t && !!i && s > 0 && e.length >= s);
			},
			h = (t) => e.hoveringIndex === t;
		n({
			listRef: o,
			isSized: a,
			isItemDisabled: c,
			isItemHovering: h,
			isItemSelected: u,
			scrollToItem: (e) => {
				const t = o.value;
				t && t.scrollToItem(e);
			},
			resetScrollTop: () => {
				const e = o.value;
				e && e.resetScrollTop();
			}
		});
		const d = (e) => {
				const { index: n, data: i, style: s } = e,
					o = it(a),
					{ itemSize: d, estimatedSize: p } = it(l),
					{ modelValue: f } = r.props,
					{ onSelect: m, onHover: v } = r,
					g = i[n];
				if ("Group" === g.type) return ri(bZ, { item: g, style: s, height: o ? d : p }, null);
				const y = u(f, g),
					b = c(f, y),
					x = h(n);
				return ri(CZ, hi(e, { selected: y, disabled: g.disabled || b, created: !!g.created, hovering: x, item: g, onSelect: m, onHover: v }), {
					default: (e) => {
						var n;
						return (null == (n = t.default) ? void 0 : n.call(t, e)) || ri("span", null, [g.label]);
					}
				});
			},
			{ onKeyboardNavigate: p, onKeyboardSelect: f } = r,
			m = (e) => {
				const { code: t } = e,
					{ tab: n, esc: i, down: s, up: o, enter: a } = bN;
				switch ((t !== n && (e.preventDefault(), e.stopPropagation()), t)) {
					case n:
					case i:
						r.expanded = !1;
						break;
					case s:
						p("forward");
						break;
					case o:
						p("backward");
						break;
					case a:
						f();
				}
			};
		return () => {
			var n;
			const { data: s, width: u } = e,
				{ height: c, multiple: h, scrollbarAlwaysOn: p } = r.props;
			if (0 === s.length) return ri("div", { class: i.b("dropdown"), style: { width: `${u}px` } }, [null == (n = t.empty) ? void 0 : n.call(t)]);
			const f = it(a) ? Jq : rZ;
			return ri("div", { class: [i.b("dropdown"), i.is("multiple", h)] }, [ri(f, hi({ ref: o }, it(l), { className: i.be("dropdown", "list"), scrollbarAlwaysOn: p, data: s, height: c, width: u, total: s.length, onKeydown: m }), { default: (e) => ri(d, e, null) })]);
		};
	}
});
function EZ(e, t) {
	const n = Qe(0),
		r = Qe(null),
		i = ht(() => e.allowCreate && e.filterable);
	return {
		createNewOption: function (s) {
			if (i.value)
				if (
					s &&
					s.length > 0 &&
					!(function (n) {
						const r = (e) => e.value === n;
						return (e.options && e.options.some(r)) || t.createdOptions.some(r);
					})(s)
				) {
					const e = { value: s, label: s, created: !0, disabled: !1 };
					t.createdOptions.length >= n.value ? (t.createdOptions[n.value] = e) : t.createdOptions.push(e);
				} else if (e.multiple) t.createdOptions.length = n.value;
				else {
					const e = r.value;
					(t.createdOptions.length = 0), e && e.created && t.createdOptions.push(e);
				}
		},
		removeNewOption: function (r) {
			if (!i.value || !r || !r.created || (r.created && e.reserveKeyword && t.inputValue === r.label)) return;
			const s = t.createdOptions.findIndex((e) => e.value === r.value);
			~s && (t.createdOptions.splice(s, 1), n.value--);
		},
		selectNewOption: function (t) {
			i.value && (e.multiple && t.created ? n.value++ : (r.value = t));
		},
		clearAllNewOption: function () {
			i.value && ((t.createdOptions.length = 0), (n.value = 0));
		}
	};
}
const TZ = { larget: 51, default: 42, small: 33 },
	kZ = (e, t) => {
		const { t: n } = CD(),
			r = BD("select-v2"),
			i = BD("input"),
			{ form: s, formItem: o } = yD(),
			a = Fe({
				inputValue: "",
				displayInputValue: "",
				calculatedWidth: 0,
				cachedPlaceholder: "",
				cachedOptions: [],
				createdOptions: [],
				createdLabel: "",
				createdSelected: !1,
				currentPlaceholder: "",
				hoveringIndex: -1,
				comboBoxHovering: !1,
				isOnComposition: !1,
				isSilentBlur: !1,
				isComposing: !1,
				inputLength: 20,
				selectWidth: 200,
				initialInputHeight: 0,
				previousQuery: null,
				previousValue: "",
				query: "",
				selectedLabel: "",
				softFocus: !1,
				tagInMultiLine: !1
			}),
			l = Qe(-1),
			h = Qe(-1),
			d = Qe(null),
			p = Qe(null),
			f = Qe(null),
			m = Qe(null),
			v = Qe(null),
			g = Qe(null),
			y = Qe(null),
			b = Qe(!1),
			x = ht(() => e.disabled || (null == s ? void 0 : s.disabled)),
			_ = ht(() => {
				const t = 34 * I.value.length;
				return t > e.height ? e.height : t;
			}),
			w = ht(() => void 0 !== e.modelValue && null !== e.modelValue && "" !== e.modelValue),
			C = ht(() => {
				const t = e.multiple ? Array.isArray(e.modelValue) && e.modelValue.length > 0 : w.value;
				return e.clearable && !x.value && a.comboBoxHovering && t;
			}),
			S = ht(() => (e.remote && e.filterable ? "" : gL)),
			E = ht(() => S.value && r.is("reverse", b.value)),
			T = ht(() => (null == o ? void 0 : o.validateState) || ""),
			k = ht(() => fN[T.value]),
			A = ht(() => (e.remote ? 300 : 0)),
			M = ht(() => {
				const t = I.value;
				return e.loading ? e.loadingText || n("el.select.loading") : (!e.remote || "" !== a.inputValue || 0 !== t.length) && (e.filterable && a.inputValue && t.length > 0 ? e.noMatchText || n("el.select.noMatch") : 0 === t.length ? e.noDataText || n("el.select.noData") : null);
			}),
			I = ht(() => {
				const t = (e) => {
					const t = a.inputValue;
					return !t || e.label.includes(t);
				};
				return e.loading
					? []
					: ((e) => {
							const t = [];
							return (
								e.forEach((e) => {
									_R(e.options)
										? (t.push({ label: e.label, isTitle: !0, type: "Group" }),
										  e.options.forEach((e) => {
												t.push(e);
										  }),
										  t.push({ type: "Group" }))
										: t.push(e);
								}),
								t
							);
					  })(
							e.options
								.concat(a.createdOptions)
								.map((n) => {
									if (_R(n.options)) {
										const e = n.options.filter(t);
										if (e.length > 0) return c(u({}, n), { options: e });
									} else if (e.remote || t(n)) return n;
									return null;
								})
								.filter((e) => null !== e)
					  );
			}),
			R = ht(() => I.value.every((e) => e.disabled)),
			L = hD(),
			O = ht(() => ("small" === L.value ? "small" : "default")),
			P = ht(() => {
				const e = g.value,
					t = O.value || "default",
					n = e ? Number.parseInt(getComputedStyle(e).paddingLeft) : 0,
					r = e ? Number.parseInt(getComputedStyle(e).paddingRight) : 0;
				return a.selectWidth - r - n - TZ[t];
			}),
			N = () => {
				var e, t, n;
				h.value = (null == (n = null == (t = null == (e = v.value) ? void 0 : e.getBoundingClientRect) ? void 0 : t.call(e)) ? void 0 : n.width) || 200;
			},
			D = ht(() => ({ width: `${0 === a.calculatedWidth ? 11 : Math.ceil(a.calculatedWidth) + 11}px` })),
			B = ht(() => (_R(e.modelValue) ? 0 === e.modelValue.length && !a.displayInputValue : !e.filterable || 0 === a.displayInputValue.length)),
			F = ht(() => {
				const t = e.placeholder || n("el.select.placeholder");
				return e.multiple ? t : a.selectedLabel || t;
			}),
			H = ht(() => {
				var e, t;
				return null == (t = null == (e = m.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef;
			}),
			V = ht(() => {
				if (e.multiple) {
					const t = e.modelValue.length;
					if (e.modelValue.length > 0) return I.value.findIndex((n) => n.value === e.modelValue[t - 1]);
				} else if (e.modelValue) return I.value.findIndex((t) => t.value === e.modelValue);
				return -1;
			}),
			U = ht({
				get: () => b.value && !1 !== M.value,
				set(e) {
					b.value = e;
				}
			}),
			{ createNewOption: z, removeNewOption: $, selectNewOption: j, clearAllNewOption: W } = EZ(e, a),
			{
				handleCompositionStart: G,
				handleCompositionUpdate: Y,
				handleCompositionEnd: X
			} = (function (e) {
				const t = Qe(!1);
				return {
					handleCompositionStart: () => {
						t.value = !0;
					},
					handleCompositionUpdate: (e) => {
						const n = e.target.value,
							r = n[n.length - 1] || "";
						t.value = !ON(r);
					},
					handleCompositionEnd: (n) => {
						t.value && ((t.value = !1), CR(e) && e(n));
					}
				};
			})((e) => he(e)),
			K = () => {
				var e, t, n;
				null == (t = (e = p.value).focus) || t.call(e), null == (n = m.value) || n.updatePopper();
			},
			q = () => {
				if (!e.automaticDropdown)
					return x.value
						? void 0
						: (a.isComposing && (a.softFocus = !0),
						  ns(() => {
								var e, t;
								(b.value = !b.value), null == (t = null == (e = p.value) ? void 0 : e.focus) || t.call(e);
						  }));
			},
			Z = () => (
				e.filterable && a.inputValue !== a.selectedLabel && (a.query = a.selectedLabel),
				Q(a.inputValue),
				ns(() => {
					z(a.inputValue);
				})
			),
			J = QT(Z, A.value),
			Q = (t) => {
				a.previousQuery !== t && ((a.previousQuery = t), e.filterable && CR(e.filterMethod) ? e.filterMethod(t) : e.filterable && e.remote && CR(e.remoteMethod) && e.remoteMethod(t));
			},
			ee = (n) => {
				t(_N, n),
					((n) => {
						rk(e.modelValue, n) || t("change", n);
					})(n),
					(a.previousValue = n.toString());
			},
			te = (t) => (ER(t) ? XS(t, e.valueKey) : t),
			ne = () => {
				if (!e.collapseTags || e.filterable)
					return ns(() => {
						var e, t;
						if (!p.value) return;
						const n = g.value;
						(v.value.height = n.offsetHeight), b.value && !1 !== M.value && (null == (t = null == (e = m.value) ? void 0 : e.updatePopper) || t.call(e));
					});
			},
			re = () => {
				var t, n;
				if ((ie(), N(), null == (n = null == (t = m.value) ? void 0 : t.updatePopper) || n.call(t), e.multiple)) return ne();
			},
			ie = () => {
				const e = g.value;
				e && (a.selectWidth = e.getBoundingClientRect().width);
			},
			se = (t, n, r = !0) => {
				var i, s;
				if (e.multiple) {
					let r = e.modelValue.slice();
					const o = ((t = [], n) => {
						if (!ER(n)) return t.indexOf(n);
						const r = e.valueKey;
						let i = -1;
						return t.some((e, t) => XS(e, r) === XS(n, r) && ((i = t), !0)), i;
					})(r, te(t));
					o > -1 ? ((r = [...r.slice(0, o), ...r.slice(o + 1)]), a.cachedOptions.splice(o, 1), $(t)) : (e.multipleLimit <= 0 || r.length < e.multipleLimit) && ((r = [...r, te(t)]), a.cachedOptions.push(t), j(t), ue(n)),
						ee(r),
						t.created && ((a.query = ""), Q(""), (a.inputLength = 20)),
						e.filterable && !e.reserveKeyword && (null == (s = (i = p.value).focus) || s.call(i), ae("")),
						e.filterable && (a.calculatedWidth = y.value.getBoundingClientRect().width),
						ne(),
						ce();
				} else (l.value = n), (a.selectedLabel = t.label), ee(te(t)), (b.value = !1), (a.isComposing = !1), (a.isSilentBlur = r), j(t), t.created || W(), ue(n);
			},
			oe = () => (
				(a.softFocus = !1),
				ns(() => {
					var e, n;
					null == (n = null == (e = p.value) ? void 0 : e.blur) || n.call(e), y.value && (a.calculatedWidth = y.value.getBoundingClientRect().width), a.isSilentBlur ? (a.isSilentBlur = !1) : a.isComposing && t("blur"), (a.isComposing = !1);
				})
			),
			ae = (e) => {
				(a.displayInputValue = e), (a.inputValue = e);
			},
			le = (e, t) => {
				const n = I.value;
				if (!["forward", "backward"].includes(e) || x.value || n.length <= 0 || R.value) return;
				if (!b.value) return q();
				void 0 === t && (t = a.hoveringIndex);
				let r = -1;
				"forward" === e ? ((r = t + 1), r >= n.length && (r = 0)) : "backward" === e && ((r = t - 1), r < 0 && (r = n.length - 1));
				const i = n[r];
				if (i.disabled || "Group" === i.type) return le(e, r);
				ue(r), de(r);
			},
			ue = (e) => {
				a.hoveringIndex = e;
			},
			ce = () => {
				var e;
				const t = p.value;
				t && (null == (e = t.focus) || e.call(t));
			},
			he = (t) => {
				const n = t.target.value;
				if ((ae(n), a.displayInputValue.length > 0 && !b.value && (b.value = !0), (a.calculatedWidth = y.value.getBoundingClientRect().width), e.multiple && ne(), !e.remote)) return Z();
				J();
			},
			de = (e) => {
				f.value.scrollToItem(e);
			},
			pe = () => {
				if (((a.hoveringIndex = -1), e.multiple))
					if (e.modelValue.length > 0) {
						let t = !1;
						(a.cachedOptions.length = 0),
							(a.previousValue = e.modelValue.toString()),
							e.modelValue.forEach((e) => {
								const n = I.value.findIndex((t) => te(t) === e);
								~n && (a.cachedOptions.push(I.value[n]), t || ue(n), (t = !0));
							});
					} else (a.cachedOptions = []), (a.previousValue = "");
				else if (w.value) {
					a.previousValue = e.modelValue;
					const t = I.value,
						n = t.findIndex((t) => te(t) === te(e.modelValue));
					~n ? ((a.selectedLabel = t[n].label), ue(n)) : (a.selectedLabel = `${e.modelValue}`);
				} else (a.selectedLabel = ""), (a.previousValue = "");
				W(), N();
			};
		return (
			ds(b, (e) => {
				var n, r;
				t("visible-change", e), e ? null == (r = (n = m.value).update) || r.call(n) : ((a.displayInputValue = ""), (a.previousQuery = null), z(""));
			}),
			ds(
				() => e.modelValue,
				(e, t) => {
					var n;
					(e && e.toString() === a.previousValue) || pe(), rk(e, t) || null == (n = null == o ? void 0 : o.validate) || n.call(o, "change").catch((e) => {});
				},
				{ deep: !0 }
			),
			ds(
				() => e.options,
				() => {
					const e = p.value;
					(!e || (e && document.activeElement !== e)) && pe();
				},
				{ deep: !0 }
			),
			ds(I, () => ns(f.value.resetScrollTop)),
			Vn(() => {
				pe();
			}),
			pR(v, re),
			{
				collapseTagSize: O,
				currentPlaceholder: F,
				expanded: b,
				emptyText: M,
				popupHeight: _,
				debounce: A,
				filteredOptions: I,
				iconComponent: S,
				iconReverse: E,
				inputWrapperStyle: D,
				popperSize: h,
				dropdownMenuVisible: U,
				hasModelValue: w,
				shouldShowPlaceholder: B,
				selectDisabled: x,
				selectSize: L,
				showClearBtn: C,
				states: a,
				tagMaxWidth: P,
				nsSelectV2: r,
				nsInput: i,
				calculatorRef: y,
				controlRef: d,
				inputRef: p,
				menuRef: f,
				popper: m,
				selectRef: v,
				selectionRef: g,
				popperRef: H,
				validateState: T,
				validateIcon: k,
				debouncedOnInputChange: J,
				deleteTag: (n, r) => {
					const { valueKey: i } = e,
						s = e.modelValue.indexOf(XS(r, i));
					if (s > -1 && !x.value) {
						const n = [...e.modelValue.slice(0, s), ...e.modelValue.slice(s + 1)];
						return a.cachedOptions.splice(s, 1), ee(n), t("remove-tag", XS(r, i)), (a.softFocus = !0), $(r), ns(K);
					}
					n.stopPropagation();
				},
				getLabel: (e) => (ER(e) ? e.label : e),
				getValueKey: te,
				handleBlur: oe,
				handleClear: () => {
					let n;
					return (n = _R(e.modelValue) ? [] : ""), (a.softFocus = !0), e.multiple ? (a.cachedOptions = []) : (a.selectedLabel = ""), (b.value = !1), ee(n), t("clear"), W(), ns(K);
				},
				handleClickOutside: () => ((b.value = !1), oe()),
				handleDel: (t) => {
					if (0 === a.displayInputValue.length) {
						t.preventDefault();
						const n = e.modelValue.slice();
						n.pop(), $(a.cachedOptions.pop()), ee(n);
					}
				},
				handleEsc: () => {
					a.displayInputValue.length > 0 ? ae("") : (b.value = !1);
				},
				handleFocus: (e) => {
					const n = a.isComposing;
					(a.isComposing = !0), a.softFocus ? (a.softFocus = !1) : n || t("focus", e);
				},
				handleMenuEnter: () => (
					(a.inputValue = a.displayInputValue),
					ns(() => {
						~V.value && (ue(V.value), de(a.hoveringIndex));
					})
				),
				handleResize: re,
				toggleMenu: q,
				scrollTo: de,
				onInput: he,
				onKeyboardNavigate: le,
				onKeyboardSelect: () => {
					if (!b.value) return q();
					~a.hoveringIndex && I.value[a.hoveringIndex] && se(I.value[a.hoveringIndex], a.hoveringIndex, !1);
				},
				onSelect: se,
				onHover: ue,
				onUpdateInputValue: ae,
				handleCompositionStart: G,
				handleCompositionEnd: X,
				handleCompositionUpdate: Y
			}
		);
	},
	AZ = Tn({
		name: "ElSelectV2",
		components: { ElSelectMenu: SZ, ElTag: P$, ElTooltip: QH, ElIcon: OB },
		directives: { ClickOutside: CU, ModelText: Po },
		props: xZ,
		emits: [_N, "change", "remove-tag", "clear", "visible-change", "focus", "blur"],
		setup(e, { emit: t }) {
			const n = kZ(e, t);
			return mn("ElSelectV2Injection", { props: Fe(c(u({}, at(e)), { height: n.popupHeight })), onSelect: n.onSelect, onHover: n.onHover, onKeyboardNavigate: n.onKeyboardNavigate, onKeyboardSelect: n.onKeyboardSelect }), n;
		}
	}),
	MZ = { key: 0 },
	IZ = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"],
	RZ = ["textContent"],
	LZ = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"],
	OZ = ["textContent"];
var PZ = IB(AZ, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-tag"),
				a = Or("el-tooltip"),
				l = Or("el-icon"),
				u = Or("el-select-menu"),
				c = Dr("model-text"),
				h = Dr("click-outside");
			return yr(
				(Wr(),
				Kr(
					"div",
					{
						ref: "selectRef",
						class: gt([e.nsSelectV2.b(), e.nsSelectV2.m(e.selectSize)]),
						onClick: t[24] || (t[24] = zo((...t) => e.toggleMenu && e.toggleMenu(...t), ["stop"])),
						onMouseenter: t[25] || (t[25] = (t) => (e.states.comboBoxHovering = !0)),
						onMouseleave: t[26] || (t[26] = (t) => (e.states.comboBoxHovering = !1))
					},
					[
						ri(
							a,
							{
								ref: "popper",
								visible: e.dropdownMenuVisible,
								"onUpdate:visible": t[22] || (t[22] = (t) => (e.dropdownMenuVisible = t)),
								teleported: e.teleported,
								"popper-class": [e.nsSelectV2.e("popper"), e.popperClass],
								"gpu-acceleration": !1,
								"stop-popper-mouse-event": !1,
								"popper-options": e.popperOptions,
								"fallback-placements": ["bottom-start", "top-start", "right", "left"],
								effect: e.effect,
								placement: "bottom-start",
								pure: "",
								transition: `${e.nsSelectV2.namespace.value}-zoom-in-top`,
								trigger: "click",
								persistent: e.persistent,
								onBeforeShow: e.handleMenuEnter,
								onHide: t[23] || (t[23] = (t) => (e.states.inputValue = e.states.displayInputValue))
							},
							{
								default: cn(() => {
									var n;
									return [
										ni(
											"div",
											{
												ref: "selectionRef",
												class: gt([e.nsSelectV2.e("wrapper"), e.nsSelectV2.is("focused", e.states.isComposing), e.nsSelectV2.is("hovering", e.states.comboBoxHovering), e.nsSelectV2.is("filterable", e.filterable), e.nsSelectV2.is("disabled", e.selectDisabled)])
											},
											[
												e.$slots.prefix ? (Wr(), Kr("div", MZ, [mi(e.$slots, "prefix")])) : ai("v-if", !0),
												e.multiple
													? (Wr(),
													  Kr(
															"div",
															{ key: 1, class: gt(e.nsSelectV2.e("selection")) },
															[
																e.collapseTags && e.modelValue.length > 0
																	? (Wr(),
																	  Kr(
																			"div",
																			{ key: 0, class: gt(e.nsSelectV2.e("selected-item")) },
																			[
																				ri(
																					o,
																					{
																						closable: !e.selectDisabled && !(null == (n = e.states.cachedOptions[0]) ? void 0 : n.disable),
																						size: e.collapseTagSize,
																						type: "info",
																						"disable-transitions": "",
																						onClose: t[0] || (t[0] = (t) => e.deleteTag(t, e.states.cachedOptions[0]))
																					},
																					{
																						default: cn(() => {
																							var t;
																							return [ni("span", { class: gt(e.nsSelectV2.e("tags-text")), style: pt({ maxWidth: `${e.tagMaxWidth}px` }) }, bt(null == (t = e.states.cachedOptions[0]) ? void 0 : t.label), 7)];
																						}),
																						_: 1
																					},
																					8,
																					["closable", "size"]
																				),
																				e.modelValue.length > 1
																					? (Wr(),
																					  qr(
																							o,
																							{ key: 0, closable: !1, size: e.collapseTagSize, type: "info", "disable-transitions": "" },
																							{
																								default: cn(() => [
																									e.collapseTagsTooltip
																										? (Wr(),
																										  qr(
																												a,
																												{ key: 0, disabled: e.dropdownMenuVisible, "fallback-placements": ["bottom", "top", "right", "left"], effect: e.effect, placement: "bottom", teleported: !1 },
																												{
																													default: cn(() => [ni("span", { class: gt(e.nsSelectV2.e("tags-text")), style: pt({ maxWidth: `${e.tagMaxWidth}px` }) }, "+ " + bt(e.modelValue.length - 1), 7)]),
																													content: cn(() => [
																														ni(
																															"div",
																															{ class: gt(e.nsSelectV2.e("selection")) },
																															[
																																(Wr(!0),
																																Kr(
																																	Hr,
																																	null,
																																	pi(
																																		e.states.cachedOptions,
																																		(t, n) => (
																																			Wr(),
																																			Kr(
																																				"div",
																																				{ key: n, class: gt(e.nsSelectV2.e("selected-item")) },
																																				[
																																					(Wr(),
																																					qr(
																																						o,
																																						{
																																							key: e.getValueKey(t),
																																							closable: !e.selectDisabled && !t.disabled,
																																							size: e.collapseTagSize,
																																							class: "in-tooltip",
																																							type: "info",
																																							"disable-transitions": "",
																																							onClose: (n) => e.deleteTag(n, t)
																																						},
																																						{
																																							default: cn(() => [
																																								ni("span", { class: gt(e.nsSelectV2.e("tags-text")), style: pt({ maxWidth: `${e.tagMaxWidth}px` }) }, bt(e.getLabel(t)), 7)
																																							]),
																																							_: 2
																																						},
																																						1032,
																																						["closable", "size", "onClose"]
																																					))
																																				],
																																				2
																																			)
																																		)
																																	),
																																	128
																																))
																															],
																															2
																														)
																													]),
																													_: 1
																												},
																												8,
																												["disabled", "effect"]
																										  ))
																										: (Wr(), Kr("span", { key: 1, class: gt(e.nsSelectV2.e("tags-text")), style: pt({ maxWidth: `${e.tagMaxWidth}px` }) }, "+ " + bt(e.modelValue.length - 1), 7))
																								]),
																								_: 1
																							},
																							8,
																							["size"]
																					  ))
																					: ai("v-if", !0)
																			],
																			2
																	  ))
																	: (Wr(!0),
																	  Kr(
																			Hr,
																			{ key: 1 },
																			pi(
																				e.states.cachedOptions,
																				(t, n) => (
																					Wr(),
																					Kr(
																						"div",
																						{ key: n, class: gt(e.nsSelectV2.e("selected-item")) },
																						[
																							(Wr(),
																							qr(
																								o,
																								{ key: e.getValueKey(t), closable: !e.selectDisabled && !t.disabled, size: e.collapseTagSize, type: "info", "disable-transitions": "", onClose: (n) => e.deleteTag(n, t) },
																								{ default: cn(() => [ni("span", { class: gt(e.nsSelectV2.e("tags-text")), style: pt({ maxWidth: `${e.tagMaxWidth}px` }) }, bt(e.getLabel(t)), 7)]), _: 2 },
																								1032,
																								["closable", "size", "onClose"]
																							))
																						],
																						2
																					)
																				)
																			),
																			128
																	  )),
																ni(
																	"div",
																	{ class: gt([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-wrapper")]), style: pt(e.inputWrapperStyle) },
																	[
																		yr(
																			ni(
																				"input",
																				{
																					id: e.id,
																					ref: "inputRef",
																					autocomplete: e.autocomplete,
																					"aria-autocomplete": "list",
																					"aria-haspopup": "listbox",
																					autocapitalize: "off",
																					"aria-expanded": e.expanded,
																					"aria-labelledby": e.label,
																					class: gt([e.nsSelectV2.is(e.selectSize), e.nsSelectV2.e("combobox-input")]),
																					disabled: e.disabled,
																					role: "combobox",
																					readonly: !e.filterable,
																					spellcheck: "false",
																					type: "text",
																					name: e.name,
																					unselectable: e.expanded ? "on" : void 0,
																					"onUpdate:modelValue": t[1] || (t[1] = (...t) => e.onUpdateInputValue && e.onUpdateInputValue(...t)),
																					onFocus: t[2] || (t[2] = (...t) => e.handleFocus && e.handleFocus(...t)),
																					onInput: t[3] || (t[3] = (...t) => e.onInput && e.onInput(...t)),
																					onCompositionstart: t[4] || (t[4] = (...t) => e.handleCompositionStart && e.handleCompositionStart(...t)),
																					onCompositionupdate: t[5] || (t[5] = (...t) => e.handleCompositionUpdate && e.handleCompositionUpdate(...t)),
																					onCompositionend: t[6] || (t[6] = (...t) => e.handleCompositionEnd && e.handleCompositionEnd(...t)),
																					onKeydown: [
																						t[7] ||
																							(t[7] = jo(
																								zo((t) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]),
																								["up"]
																							)),
																						t[8] ||
																							(t[8] = jo(
																								zo((t) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]),
																								["down"]
																							)),
																						t[9] ||
																							(t[9] = jo(
																								zo((...t) => e.onKeyboardSelect && e.onKeyboardSelect(...t), ["stop", "prevent"]),
																								["enter"]
																							)),
																						t[10] ||
																							(t[10] = jo(
																								zo((...t) => e.handleEsc && e.handleEsc(...t), ["stop", "prevent"]),
																								["esc"]
																							)),
																						t[11] ||
																							(t[11] = jo(
																								zo((...t) => e.handleDel && e.handleDel(...t), ["stop"]),
																								["delete"]
																							))
																					]
																				},
																				null,
																				42,
																				IZ
																			),
																			[[c, e.states.displayInputValue]]
																		),
																		e.filterable ? (Wr(), Kr("span", { key: 0, ref: "calculatorRef", "aria-hidden": "true", class: gt(e.nsSelectV2.e("input-calculator")), textContent: bt(e.states.displayInputValue) }, null, 10, RZ)) : ai("v-if", !0)
																	],
																	6
																)
															],
															2
													  ))
													: (Wr(),
													  Kr(
															Hr,
															{ key: 2 },
															[
																ni(
																	"div",
																	{ class: gt([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-wrapper")]) },
																	[
																		yr(
																			ni(
																				"input",
																				{
																					id: e.id,
																					ref: "inputRef",
																					"aria-autocomplete": "list",
																					"aria-haspopup": "listbox",
																					"aria-labelledby": e.label,
																					"aria-expanded": e.expanded,
																					autocapitalize: "off",
																					autocomplete: e.autocomplete,
																					class: gt(e.nsSelectV2.e("combobox-input")),
																					disabled: e.disabled,
																					name: e.name,
																					role: "combobox",
																					readonly: !e.filterable,
																					spellcheck: "false",
																					type: "text",
																					unselectable: e.expanded ? "on" : void 0,
																					onCompositionstart: t[12] || (t[12] = (...t) => e.handleCompositionStart && e.handleCompositionStart(...t)),
																					onCompositionupdate: t[13] || (t[13] = (...t) => e.handleCompositionUpdate && e.handleCompositionUpdate(...t)),
																					onCompositionend: t[14] || (t[14] = (...t) => e.handleCompositionEnd && e.handleCompositionEnd(...t)),
																					onFocus: t[15] || (t[15] = (...t) => e.handleFocus && e.handleFocus(...t)),
																					onInput: t[16] || (t[16] = (...t) => e.onInput && e.onInput(...t)),
																					onKeydown: [
																						t[17] ||
																							(t[17] = jo(
																								zo((t) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]),
																								["up"]
																							)),
																						t[18] ||
																							(t[18] = jo(
																								zo((t) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]),
																								["down"]
																							)),
																						t[19] ||
																							(t[19] = jo(
																								zo((...t) => e.onKeyboardSelect && e.onKeyboardSelect(...t), ["stop", "prevent"]),
																								["enter"]
																							)),
																						t[20] ||
																							(t[20] = jo(
																								zo((...t) => e.handleEsc && e.handleEsc(...t), ["stop", "prevent"]),
																								["esc"]
																							))
																					],
																					"onUpdate:modelValue": t[21] || (t[21] = (...t) => e.onUpdateInputValue && e.onUpdateInputValue(...t))
																				},
																				null,
																				42,
																				LZ
																			),
																			[[c, e.states.displayInputValue]]
																		)
																	],
																	2
																),
																e.filterable
																	? (Wr(), Kr("span", { key: 0, ref: "calculatorRef", "aria-hidden": "true", class: gt([e.nsSelectV2.e("selected-item"), e.nsSelectV2.e("input-calculator")]), textContent: bt(e.states.displayInputValue) }, null, 10, OZ))
																	: ai("v-if", !0)
															],
															64
													  )),
												e.shouldShowPlaceholder
													? (Wr(), Kr("span", { key: 3, class: gt([e.nsSelectV2.e("placeholder"), e.nsSelectV2.is("transparent", e.states.isComposing || (e.placeholder && e.multiple ? 0 === e.modelValue.length : !e.hasModelValue))]) }, bt(e.currentPlaceholder), 3))
													: ai("v-if", !0),
												ni(
													"span",
													{ class: gt(e.nsSelectV2.e("suffix")) },
													[
														e.iconComponent ? yr((Wr(), qr(l, { key: 0, class: gt([e.nsSelectV2.e("caret"), e.nsInput.e("icon"), e.iconReverse]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])), [[Wo, !e.showClearBtn]]) : ai("v-if", !0),
														e.showClearBtn && e.clearIcon
															? (Wr(), qr(l, { key: 1, class: gt([e.nsSelectV2.e("caret"), e.nsInput.e("icon")]), onClick: zo(e.handleClear, ["prevent", "stop"]) }, { default: cn(() => [(Wr(), qr(Nr(e.clearIcon)))]), _: 1 }, 8, ["class", "onClick"]))
															: ai("v-if", !0),
														e.validateState && e.validateIcon ? (Wr(), qr(l, { key: 2, class: gt([e.nsInput.e("icon"), e.nsInput.e("validateIcon")]) }, { default: cn(() => [(Wr(), qr(Nr(e.validateIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)
													],
													2
												)
											],
											2
										)
									];
								}),
								content: cn(() => [
									ri(
										u,
										{ ref: "menuRef", data: e.filteredOptions, width: e.popperSize, "hovering-index": e.states.hoveringIndex, "scrollbar-always-on": e.scrollbarAlwaysOn },
										{ default: cn((t) => [mi(e.$slots, "default", yt(ii(t)))]), empty: cn(() => [mi(e.$slots, "empty", {}, () => [ni("p", { class: gt(e.nsSelectV2.e("empty")) }, bt(e.emptyText ? e.emptyText : ""), 3)])]), _: 3 },
										8,
										["data", "width", "hovering-index", "scrollbar-always-on"]
									)
								]),
								_: 3
							},
							8,
							["visible", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"]
						)
					],
					34
				)),
				[[h, e.handleClickOutside, e.popperRef]]
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]
]);
PZ.install = (e) => {
	e.component(PZ.name, PZ);
};
const NZ = PZ,
	DZ = uN({ animated: { type: Boolean, default: !1 }, count: { type: Number, default: 1 }, rows: { type: Number, default: 3 }, loading: { type: Boolean, default: !0 }, throttle: { type: Number } }),
	BZ = uN({ variant: { type: String, values: ["circle", "rect", "h1", "h3", "text", "caption", "p", "image", "button"], default: "text" } });
var FZ = IB(
	Tn(
		c(u({}, { name: "ElSkeletonItem" }), {
			props: BZ,
			setup(e) {
				const t = BD("skeleton");
				return (e, n) => (Wr(), Kr("div", { class: gt([it(t).e("item"), it(t).e(e.variant)]) }, ["image" === e.variant ? (Wr(), qr(it(tP), { key: 0 })) : ai("v-if", !0)], 2));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]
);
const HZ = mN(
		IB(
			Tn(
				c(u({}, { name: "ElSkeleton" }), {
					props: DZ,
					setup(e, { expose: t }) {
						const n = e,
							r = BD("skeleton"),
							i = ((e, t = 0) => {
								if (0 === t) return e;
								const n = Qe(!1);
								let r = 0;
								const i = () => {
									r && clearTimeout(r),
										(r = window.setTimeout(() => {
											n.value = e.value;
										}, t));
								};
								return (
									Vn(i),
									ds(
										() => e.value,
										(e) => {
											e ? i() : (n.value = e);
										}
									),
									n
								);
							})(ut(n, "loading"), n.throttle);
						return (
							t({ uiLoading: i }),
							(e, t) =>
								it(i)
									? (Wr(),
									  Kr(
											"div",
											hi({ key: 0, class: [it(r).b(), it(r).is("animated", e.animated)] }, e.$attrs),
											[
												(Wr(!0),
												Kr(
													Hr,
													null,
													pi(
														e.count,
														(t) => (
															Wr(),
															Kr(
																Hr,
																{ key: t },
																[
																	e.loading
																		? mi(e.$slots, "template", { key: t }, () => [
																				ri(FZ, { class: gt(it(r).is("first")), variant: "p" }, null, 8, ["class"]),
																				(Wr(!0),
																				Kr(
																					Hr,
																					null,
																					pi(e.rows, (t) => (Wr(), qr(FZ, { key: t, class: gt([it(r).e("paragraph"), it(r).is("last", t === e.rows && e.rows > 1)]), variant: "p" }, null, 8, ["class"]))),
																					128
																				))
																		  ])
																		: ai("v-if", !0)
																],
																64
															)
														)
													),
													128
												))
											],
											16
									  ))
									: mi(e.$slots, "default", yt(hi({ key: 1 }, e.$attrs)))
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]
		),
		{ SkeletonItem: FZ }
	),
	VZ = gN(FZ),
	{ left: UZ, down: zZ, right: $Z, up: jZ, home: WZ, end: GZ, pageUp: YZ, pageDown: XZ } = bN,
	KZ = (e, t, n) => {
		const { disabled: r, min: i, max: s, step: o, showTooltip: a, precision: l, sliderSize: u, formatTooltip: c, emitChange: h, resetSize: d, updateDragging: p } = vn("SliderProvider"),
			{
				tooltip: f,
				tooltipVisible: m,
				formatValue: v,
				displayTooltip: g,
				hideTooltip: y
			} = ((e, t, n) => {
				const r = Qe(),
					i = Qe(!1),
					s = ht(() => t.value instanceof Function),
					o = ht(() => (s.value && t.value(e.modelValue)) || e.modelValue),
					a = QT(() => {
						n.value && (i.value = !0);
					}, 50),
					l = QT(() => {
						n.value && (i.value = !1);
					}, 50);
				return { tooltip: r, tooltipVisible: i, formatValue: o, displayTooltip: a, hideTooltip: l };
			})(e, c, a),
			b = Qe(),
			x = ht(() => ((e.modelValue - i.value) / (s.value - i.value)) * 100 + "%"),
			_ = ht(() => (e.vertical ? { bottom: x.value } : { left: x.value })),
			w = (e) => {
				r.value || ((t.newPosition = Number.parseFloat(x.value) + (e / (s.value - i.value)) * 100), k(t.newPosition), h());
			},
			C = (e) => {
				let t, n;
				return e.type.startsWith("touch") ? ((n = e.touches[0].clientY), (t = e.touches[0].clientX)) : ((n = e.clientY), (t = e.clientX)), { clientX: t, clientY: n };
			},
			S = (n) => {
				(t.dragging = !0), (t.isClick = !0);
				const { clientX: r, clientY: i } = C(n);
				e.vertical ? (t.startY = i) : (t.startX = r), (t.startPosition = Number.parseFloat(x.value)), (t.newPosition = t.startPosition);
			},
			E = (n) => {
				if (t.dragging) {
					let r;
					(t.isClick = !1), g(), d();
					const { clientX: i, clientY: s } = C(n);
					e.vertical ? ((t.currentY = s), (r = ((t.startY - t.currentY) / u.value) * 100)) : ((t.currentX = i), (r = ((t.currentX - t.startX) / u.value) * 100)), (t.newPosition = t.startPosition + r), k(t.newPosition);
				}
			},
			T = () => {
				t.dragging &&
					(setTimeout(() => {
						(t.dragging = !1), t.hovering || y(), t.isClick || (k(t.newPosition), h());
					}, 0),
					window.removeEventListener("mousemove", E),
					window.removeEventListener("touchmove", E),
					window.removeEventListener("mouseup", T),
					window.removeEventListener("touchend", T),
					window.removeEventListener("contextmenu", T));
			},
			k = async (r) => {
				if (null === r || Number.isNaN(+r)) return;
				r < 0 ? (r = 0) : r > 100 && (r = 100);
				const a = 100 / ((s.value - i.value) / o.value);
				let u = Math.round(r / a) * a * (s.value - i.value) * 0.01 + i.value;
				(u = Number.parseFloat(u.toFixed(l.value))), n(_N, u), t.dragging || e.modelValue === t.oldValue || (t.oldValue = e.modelValue), await ns(), t.dragging && g(), f.value.updatePopper();
			};
		return (
			ds(
				() => t.dragging,
				(e) => {
					p(e);
				}
			),
			{
				button: b,
				tooltip: f,
				tooltipVisible: m,
				showTooltip: a,
				wrapperStyle: _,
				formatValue: v,
				handleMouseEnter: () => {
					(t.hovering = !0), g();
				},
				handleMouseLeave: () => {
					(t.hovering = !1), t.dragging || y();
				},
				onButtonDown: (e) => {
					r.value || (e.preventDefault(), S(e), window.addEventListener("mousemove", E), window.addEventListener("touchmove", E), window.addEventListener("mouseup", T), window.addEventListener("touchend", T), window.addEventListener("contextmenu", T), b.value.focus());
				},
				onKeyDown: (e) => {
					let t = !0;
					[UZ, zZ].includes(e.key) ? w(-o.value) : [$Z, jZ].includes(e.key) ? w(o.value) : e.key === WZ ? r.value || (k(0), h()) : e.key === GZ ? r.value || (k(100), h()) : e.key === XZ ? w(4 * -o.value) : e.key === YZ ? w(4 * o.value) : (t = !1), t && e.preventDefault();
				},
				setPosition: k
			}
		);
	};
var qZ = IB(
	Tn({
		name: "ElSliderButton",
		components: { ElTooltip: QH },
		props: { modelValue: { type: Number, default: 0 }, vertical: { type: Boolean, default: !1 }, tooltipClass: { type: String, default: "" } },
		emits: [_N],
		setup(e, { emit: t }) {
			const n = BD("slider"),
				r = Fe({ hovering: !1, dragging: !1, isClick: !1, startX: 0, currentX: 0, startY: 0, currentY: 0, startPosition: 0, newPosition: 0, oldValue: e.modelValue }),
				{ button: i, tooltip: s, showTooltip: o, tooltipVisible: a, wrapperStyle: l, formatValue: u, handleMouseEnter: c, handleMouseLeave: h, onButtonDown: d, onKeyDown: p, setPosition: f } = KZ(e, r, t),
				{ hovering: m, dragging: v } = at(r);
			return { ns: n, button: i, tooltip: s, tooltipVisible: a, showTooltip: o, wrapperStyle: l, formatValue: u, handleMouseEnter: c, handleMouseLeave: h, onButtonDown: d, onKeyDown: p, setPosition: f, hovering: m, dragging: v };
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-tooltip");
				return (
					Wr(),
					Kr(
						"div",
						{
							ref: "button",
							class: gt([e.ns.e("button-wrapper"), { hover: e.hovering, dragging: e.dragging }]),
							style: pt(e.wrapperStyle),
							tabindex: "0",
							onMouseenter: t[1] || (t[1] = (...t) => e.handleMouseEnter && e.handleMouseEnter(...t)),
							onMouseleave: t[2] || (t[2] = (...t) => e.handleMouseLeave && e.handleMouseLeave(...t)),
							onMousedown: t[3] || (t[3] = (...t) => e.onButtonDown && e.onButtonDown(...t)),
							onTouchstart: t[4] || (t[4] = (...t) => e.onButtonDown && e.onButtonDown(...t)),
							onFocus: t[5] || (t[5] = (...t) => e.handleMouseEnter && e.handleMouseEnter(...t)),
							onBlur: t[6] || (t[6] = (...t) => e.handleMouseLeave && e.handleMouseLeave(...t)),
							onKeydown: t[7] || (t[7] = (...t) => e.onKeyDown && e.onKeyDown(...t))
						},
						[
							ri(
								o,
								{ ref: "tooltip", visible: e.tooltipVisible, "onUpdate:visible": t[0] || (t[0] = (t) => (e.tooltipVisible = t)), placement: "top", "stop-popper-mouse-event": !1, "popper-class": e.tooltipClass, disabled: !e.showTooltip, persistent: "" },
								{ content: cn(() => [ni("span", null, bt(e.formatValue), 1)]), default: cn(() => [ni("div", { class: gt([e.ns.e("button"), { hover: e.hovering, dragging: e.dragging }]) }, null, 2)]), _: 1 },
								8,
								["visible", "popper-class", "disabled"]
							)
						],
						38
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]
	]
);
const ZZ = Tn({
	name: "ElMarker",
	props: { mark: { type: [String, Object], default: () => {} } },
	setup: (e) => ({ ns: BD("slider"), label: ht(() => ("string" == typeof e.mark ? e.mark : e.mark.label)) }),
	render() {
		var e;
		return xs("div", { class: this.ns.e("marks-text"), style: null == (e = this.mark) ? void 0 : e.style }, this.label);
	}
});
const JZ = (e, t, n) => {
		const r = vn(GN, {}),
			i = vn(YN, {}),
			s = et(),
			o = Qe(),
			a = Qe(),
			l = { firstButton: o, secondButton: a },
			u = ht(() => e.disabled || r.disabled || !1),
			c = ht(() => Math.min(t.firstValue, t.secondValue)),
			h = ht(() => Math.max(t.firstValue, t.secondValue)),
			d = ht(() => (e.range ? (100 * (h.value - c.value)) / (e.max - e.min) + "%" : (100 * (t.firstValue - e.min)) / (e.max - e.min) + "%")),
			p = ht(() => (e.range ? (100 * (c.value - e.min)) / (e.max - e.min) + "%" : "0%")),
			f = ht(() => (e.vertical ? { height: e.height } : {})),
			m = ht(() => (e.vertical ? { height: d.value, bottom: p.value } : { width: d.value, left: p.value })),
			v = () => {
				s.value && (t.sliderSize = s.value["client" + (e.vertical ? "Height" : "Width")]);
			},
			g = (n) => {
				const r = ((n) => {
					const r = e.min + (n * (e.max - e.min)) / 100;
					if (!e.range) return o;
					let i;
					return (i = Math.abs(c.value - r) < Math.abs(h.value - r) ? (t.firstValue < t.secondValue ? "firstButton" : "secondButton") : t.firstValue > t.secondValue ? "firstButton" : "secondButton"), l[i];
				})(n);
				return r.value.setPosition(n), r;
			},
			y = (e) => {
				n(_N, e), n("input", e);
			},
			b = async () => {
				await ns(), n("change", e.range ? [c.value, h.value] : e.modelValue);
			},
			x = (n) => {
				var r, i, o, a, l, c;
				if (u.value || t.dragging) return;
				v();
				let h = 0;
				if (e.vertical) {
					const e = null != (o = null == (i = null == (r = n.touches) ? void 0 : r.item(0)) ? void 0 : i.clientY) ? o : n.clientY;
					h = ((s.value.getBoundingClientRect().bottom - e) / t.sliderSize) * 100;
				} else {
					h = (((null != (c = null == (l = null == (a = n.touches) ? void 0 : a.item(0)) ? void 0 : l.clientX) ? c : n.clientX) - s.value.getBoundingClientRect().left) / t.sliderSize) * 100;
				}
				return h < 0 || h > 100 ? void 0 : g(h);
			};
		return {
			elFormItem: i,
			slider: s,
			firstButton: o,
			secondButton: a,
			sliderDisabled: u,
			minValue: c,
			maxValue: h,
			runwayStyle: f,
			barStyle: m,
			resetSize: v,
			setPosition: g,
			emitChange: b,
			onSliderWrapperPrevent: (e) => {
				var t, n;
				((null == (t = l.firstButton.value) ? void 0 : t.dragging) || (null == (n = l.secondButton.value) ? void 0 : n.dragging)) && e.preventDefault();
			},
			onSliderClick: (e) => {
				x(e) && b();
			},
			onSliderDown: async (e) => {
				const t = x(e);
				t && (await ns(), t.value.onButtonDown(e));
			},
			setFirstValue: (n) => {
				(t.firstValue = n), y(e.range ? [c.value, h.value] : n);
			},
			setSecondValue: (n) => {
				(t.secondValue = n), e.range && y([c.value, h.value]);
			}
		};
	},
	QZ = Tn({
		name: "ElSlider",
		components: { ElInputNumber: zX, SliderButton: qZ, SliderMarker: IB(ZZ, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/marker.vue"]]) },
		props: {
			modelValue: { type: [Number, Array], default: 0 },
			id: { type: String, default: void 0 },
			min: { type: Number, default: 0 },
			max: { type: Number, default: 100 },
			step: { type: Number, default: 1 },
			showInput: { type: Boolean, default: !1 },
			showInputControls: { type: Boolean, default: !0 },
			size: { type: String, validator: EN },
			inputSize: { type: String, validator: EN },
			showStops: { type: Boolean, default: !1 },
			showTooltip: { type: Boolean, default: !0 },
			formatTooltip: { type: Function, default: void 0 },
			disabled: { type: Boolean, default: !1 },
			range: { type: Boolean, default: !1 },
			vertical: { type: Boolean, default: !1 },
			height: { type: String, default: "" },
			debounce: { type: Number, default: 300 },
			label: { type: String, default: void 0 },
			rangeStartLabel: { type: String, default: void 0 },
			rangeEndLabel: { type: String, default: void 0 },
			formatValueText: { type: Function, default: void 0 },
			tooltipClass: { type: String, default: void 0 },
			marks: Object
		},
		emits: [_N, "change", "input"],
		setup(e, { emit: t }) {
			const n = BD("slider"),
				{ t: r } = CD(),
				i = Fe({ firstValue: 0, secondValue: 0, oldValue: 0, dragging: !1, sliderSize: 1 }),
				{ elFormItem: s, slider: o, firstButton: a, secondButton: l, sliderDisabled: h, minValue: d, maxValue: p, runwayStyle: f, barStyle: m, resetSize: v, emitChange: g, onSliderWrapperPrevent: y, onSliderClick: b, onSliderDown: x, setFirstValue: _, setSecondValue: w } = JZ(e, i, t),
				{ stops: C, getStopStyle: S } = ((e, t, n, r) => ({
					stops: ht(() => {
						if (!e.showStops || e.min > e.max) return [];
						if (0 === e.step) return [];
						const i = (e.max - e.min) / e.step,
							s = (100 * e.step) / (e.max - e.min),
							o = Array.from({ length: i - 1 }).map((e, t) => (t + 1) * s);
						return e.range ? o.filter((t) => t < (100 * (n.value - e.min)) / (e.max - e.min) || t > (100 * (r.value - e.min)) / (e.max - e.min)) : o.filter((n) => n > (100 * (t.firstValue - e.min)) / (e.max - e.min));
					}),
					getStopStyle: (t) => (e.vertical ? { bottom: `${t}%` } : { left: `${t}%` })
				}))(e, i, d, p),
				{ inputId: E, isLabeledByFormItem: T } = bD(e, { formItemContext: s }),
				k = hD(),
				A = ht(() => e.inputSize || k.value),
				M = ht(() => e.label || r("el.slider.defaultLabel", { min: e.min, max: e.max })),
				I = ht(() => (e.range ? e.rangeStartLabel || r("el.slider.defaultRangeStartLabel") : M.value)),
				R = ht(() => (e.formatValueText ? e.formatValueText(F.value) : `${F.value}`)),
				L = ht(() => e.rangeEndLabel || r("el.slider.defaultRangeEndLabel")),
				O = ht(() => (e.formatValueText ? e.formatValueText(H.value) : `${H.value}`)),
				P = ht(() => [n.b(), n.m(k.value), n.is("vertical", e.vertical), { [n.m("with-input")]: e.showInput }]),
				N = ((e) =>
					ht(() =>
						e.marks
							? Object.keys(e.marks)
									.map(parseFloat)
									.sort((e, t) => e - t)
									.filter((t) => t <= e.max && t >= e.min)
									.map((t) => ({ point: t, position: (100 * (t - e.min)) / (e.max - e.min), mark: e.marks[t] }))
							: []
					))(e);
			eJ(e, i, d, p, t, s);
			const D = ht(() => {
					const t = [e.min, e.max, e.step].map((e) => {
						const t = `${e}`.split(".")[1];
						return t ? t.length : 0;
					});
					return Math.max.apply(null, t);
				}),
				{ sliderWrapper: B } = tJ(e, i, v),
				{ firstValue: F, secondValue: H, oldValue: V, dragging: U, sliderSize: z } = at(i);
			return (
				mn(
					"SliderProvider",
					c(u({}, at(e)), {
						sliderSize: z,
						disabled: h,
						precision: D,
						emitChange: g,
						resetSize: v,
						updateDragging: (e) => {
							i.dragging = e;
						}
					})
				),
				{
					ns: n,
					firstValue: F,
					secondValue: H,
					oldValue: V,
					dragging: U,
					sliderSize: z,
					inputId: E,
					isLabeledByFormItem: T,
					elFormItem: s,
					slider: o,
					groupLabel: M,
					firstButton: a,
					firstButtonLabel: I,
					firstValueText: R,
					secondButton: l,
					secondButtonLabel: L,
					secondValueText: O,
					sliderDisabled: h,
					runwayStyle: f,
					barStyle: m,
					emitChange: g,
					onSliderClick: b,
					onSliderWrapperPrevent: y,
					onSliderDown: x,
					getStopStyle: S,
					setFirstValue: _,
					setSecondValue: w,
					stops: C,
					markList: N,
					sliderWrapper: B,
					sliderWrapperSize: k,
					sliderInputSize: A,
					sliderKls: P
				}
			);
		}
	}),
	eJ = (e, t, n, r, i, s) => {
		const o = (e) => {
				i(_N, e), i("input", e);
			},
			a = () => (e.range ? ![n.value, r.value].every((e, n) => e === t.oldValue[n]) : e.modelValue !== t.oldValue),
			l = () => {
				var n, r;
				if (e.min > e.max) return void $R("Slider", "min should not be greater than max.");
				const i = e.modelValue;
				e.range && Array.isArray(i)
					? i[1] < e.min
						? o([e.min, e.min])
						: i[0] > e.max
						? o([e.max, e.max])
						: i[0] < e.min
						? o([e.min, i[1]])
						: i[1] > e.max
						? o([i[0], e.max])
						: ((t.firstValue = i[0]), (t.secondValue = i[1]), a() && (null == (n = s.validate) || n.call(s, "change").catch((e) => {}), (t.oldValue = i.slice())))
					: e.range || "number" != typeof i || Number.isNaN(i) || (i < e.min ? o(e.min) : i > e.max ? o(e.max) : ((t.firstValue = i), a() && (null == (r = s.validate) || r.call(s, "change").catch((e) => {}), (t.oldValue = i))));
			};
		l(),
			ds(
				() => t.dragging,
				(e) => {
					e || l();
				}
			),
			ds(
				() => e.modelValue,
				(e, n) => {
					t.dragging || (Array.isArray(e) && Array.isArray(n) && e.every((e, t) => e === n[t]) && t.firstValue === e[0] && t.secondValue === e[1]) || l();
				},
				{ deep: !0 }
			),
			ds(
				() => [e.min, e.max],
				() => {
					l();
				}
			);
	},
	tJ = (e, t, n) => {
		const r = Qe();
		return (
			Vn(async () => {
				e.range
					? (Array.isArray(e.modelValue) ? ((t.firstValue = Math.max(e.min, e.modelValue[0])), (t.secondValue = Math.min(e.max, e.modelValue[1]))) : ((t.firstValue = e.min), (t.secondValue = e.max)), (t.oldValue = [t.firstValue, t.secondValue]))
					: ("number" != typeof e.modelValue || Number.isNaN(e.modelValue) ? (t.firstValue = e.min) : (t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue))), (t.oldValue = t.firstValue)),
					window.addEventListener("resize", n),
					await ns(),
					n();
			}),
			$n(() => {
				window.removeEventListener("resize", n);
			}),
			{ sliderWrapper: r }
		);
	},
	nJ = ["id", "role", "aria-label", "aria-labelledby"],
	rJ = { key: 1 };
var iJ = IB(QZ, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("slider-button"),
				a = Or("slider-marker"),
				l = Or("el-input-number");
			return (
				Wr(),
				Kr(
					"div",
					{
						id: e.range ? e.inputId : void 0,
						ref: "sliderWrapper",
						class: gt(e.sliderKls),
						role: e.range ? "group" : void 0,
						"aria-label": e.range && !e.isLabeledByFormItem ? e.groupLabel : void 0,
						"aria-labelledby": e.range && e.isLabeledByFormItem ? e.elFormItem.labelId : void 0,
						onTouchstart: t[2] || (t[2] = (...t) => e.onSliderWrapperPrevent && e.onSliderWrapperPrevent(...t)),
						onTouchmove: t[3] || (t[3] = (...t) => e.onSliderWrapperPrevent && e.onSliderWrapperPrevent(...t))
					},
					[
						ni(
							"div",
							{
								ref: "slider",
								class: gt([e.ns.e("runway"), { "show-input": e.showInput && !e.range }, e.ns.is("disabled", e.sliderDisabled)]),
								style: pt(e.runwayStyle),
								onMousedown: t[0] || (t[0] = (...t) => e.onSliderDown && e.onSliderDown(...t)),
								onTouchstart: t[1] || (t[1] = (...t) => e.onSliderDown && e.onSliderDown(...t))
							},
							[
								ni("div", { class: gt(e.ns.e("bar")), style: pt(e.barStyle) }, null, 6),
								ri(
									o,
									{
										id: e.range ? void 0 : e.inputId,
										ref: "firstButton",
										"model-value": e.firstValue,
										vertical: e.vertical,
										"tooltip-class": e.tooltipClass,
										role: "slider",
										"aria-label": e.range || !e.isLabeledByFormItem ? e.firstButtonLabel : void 0,
										"aria-labelledby": !e.range && e.isLabeledByFormItem ? e.elFormItem.labelId : void 0,
										"aria-valuemin": e.min,
										"aria-valuemax": e.range ? e.secondValue : e.max,
										"aria-valuenow": e.firstValue,
										"aria-valuetext": e.firstValueText,
										"aria-orientation": e.vertical ? "vertical" : "horizontal",
										"aria-disabled": e.sliderDisabled,
										"onUpdate:modelValue": e.setFirstValue
									},
									null,
									8,
									["id", "model-value", "vertical", "tooltip-class", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]
								),
								e.range
									? (Wr(),
									  qr(
											o,
											{
												key: 0,
												ref: "secondButton",
												"model-value": e.secondValue,
												vertical: e.vertical,
												"tooltip-class": e.tooltipClass,
												role: "slider",
												"aria-label": e.secondButtonLabel,
												"aria-valuemin": e.firstValue,
												"aria-valuemax": e.max,
												"aria-valuenow": e.secondValue,
												"aria-valuetext": e.secondValueText,
												"aria-orientation": e.vertical ? "vertical" : "horizontal",
												"aria-disabled": e.sliderDisabled,
												"onUpdate:modelValue": e.setSecondValue
											},
											null,
											8,
											["model-value", "vertical", "tooltip-class", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]
									  ))
									: ai("v-if", !0),
								e.showStops
									? (Wr(),
									  Kr("div", rJ, [
											(Wr(!0),
											Kr(
												Hr,
												null,
												pi(e.stops, (t, n) => (Wr(), Kr("div", { key: n, class: gt(e.ns.e("stop")), style: pt(e.getStopStyle(t)) }, null, 6))),
												128
											))
									  ]))
									: ai("v-if", !0),
								e.markList.length > 0
									? (Wr(),
									  Kr(
											Hr,
											{ key: 2 },
											[
												ni("div", null, [
													(Wr(!0),
													Kr(
														Hr,
														null,
														pi(e.markList, (t, n) => (Wr(), Kr("div", { key: n, style: pt(e.getStopStyle(t.position)), class: gt([e.ns.e("stop"), e.ns.e("marks-stop")]) }, null, 6))),
														128
													))
												]),
												ni(
													"div",
													{ class: gt(e.ns.e("marks")) },
													[
														(Wr(!0),
														Kr(
															Hr,
															null,
															pi(e.markList, (t, n) => (Wr(), qr(a, { key: n, mark: t.mark, style: pt(e.getStopStyle(t.position)) }, null, 8, ["mark", "style"]))),
															128
														))
													],
													2
												)
											],
											64
									  ))
									: ai("v-if", !0)
							],
							38
						),
						e.showInput && !e.range
							? (Wr(),
							  qr(
									l,
									{
										key: 0,
										ref: "input",
										"model-value": e.firstValue,
										class: gt(e.ns.e("input")),
										step: e.step,
										disabled: e.sliderDisabled,
										controls: e.showInputControls,
										min: e.min,
										max: e.max,
										debounce: e.debounce,
										size: e.sliderInputSize,
										"onUpdate:modelValue": e.setFirstValue,
										onChange: e.emitChange
									},
									null,
									8,
									["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"]
							  ))
							: ai("v-if", !0)
					],
					42,
					nJ
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/index.vue"]
]);
iJ.install = (e) => {
	e.component(iJ.name, iJ);
};
const sJ = iJ;
var oJ = IB(
	Tn({
		props: uN({ prefixCls: { type: String, default: "" } }),
		setup(e) {
			const t = BD("space");
			return { classes: ht(() => `${e.prefixCls || t.b()}__item`) };
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("div", { class: gt(e.classes) }, [mi(e.$slots, "default")], 2);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/space/src/item.vue"]
	]
);
const aJ = { small: 8, default: 12, large: 16 };
const lJ = mN(
		Tn({
			name: "ElSpace",
			props: uN({
				direction: { type: String, values: ["horizontal", "vertical"], default: "horizontal" },
				class: { type: [String, Object, Array], default: "" },
				style: { type: [String, Array, Object], default: "" },
				alignment: { type: String, default: "center" },
				prefixCls: { type: String },
				spacer: { type: [Object, String, Number, Array], default: null, validator: (e) => Zr(e) || XI(e) || SR(e) },
				wrap: { type: Boolean, default: !1 },
				fill: { type: Boolean, default: !1 },
				fillRatio: { type: Number, default: 100 },
				size: { type: [String, Array, Number], values: CN, validator: (e) => XI(e) || (_R(e) && 2 === e.length && e.every((e) => XI(e))) }
			}),
			setup(e, { slots: t }) {
				const {
					classes: n,
					containerStyle: r,
					itemStyle: i
				} = (function (e) {
					const t = BD("space"),
						n = ht(() => [t.b(), t.m(e.direction), e.class]),
						r = Qe(0),
						i = Qe(0),
						s = ht(() => [e.wrap || e.fill ? { flexWrap: "wrap", marginBottom: `-${i.value}px` } : {}, { alignItems: e.alignment }, e.style]),
						o = ht(() => [{ paddingBottom: `${i.value}px`, marginRight: `${r.value}px` }, e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {}]);
					return (
						cs(() => {
							const { size: t = "small", wrap: n, direction: s, fill: o } = e;
							if (Array.isArray(t)) {
								const [e = 0, n = 0] = t;
								(r.value = e), (i.value = n);
							} else {
								let e;
								(e = XI(t) ? t : aJ[t] || aJ.small), (n || o) && "horizontal" === s ? (r.value = i.value = e) : "horizontal" === s ? ((r.value = e), (i.value = 0)) : ((i.value = e), (r.value = 0));
							}
						}),
						{ classes: n, containerStyle: s, itemStyle: o }
					);
				})(e);
				return () => {
					var s;
					const { spacer: o, prefixCls: a, direction: l } = e,
						u = mi(t, "default", { key: 0 }, () => []);
					if (0 === (null != (s = u.children) ? s : []).length) return null;
					if (_R(u.children)) {
						let e = [];
						if (
							(u.children.forEach((t, n) => {
								kN(t)
									? _R(t.children) &&
									  t.children.forEach((t, n) => {
											e.push(ri(oJ, { style: i.value, prefixCls: a, key: `nested-${n}` }, { default: () => [t] }, TN.PROPS | TN.STYLE, ["style", "prefixCls"]));
									  })
									: AN(t) && e.push(ri(oJ, { style: i.value, prefixCls: a, key: `LoopKey${n}` }, { default: () => [t] }, TN.PROPS | TN.STYLE, ["style", "prefixCls"]));
							}),
							o)
						) {
							const t = e.length - 1;
							e = e.reduce((e, n, r) => {
								const s = [...e, n];
								return r !== t && s.push(ri("span", { style: [i.value, "vertical" === l ? "width: 100%" : null], key: r }, [Zr(o) ? o : oi(o, TN.TEXT)], TN.STYLE)), s;
							}, []);
						}
						return ri("div", { class: n.value, style: r.value }, e, TN.STYLE | TN.CLASS);
					}
					return u.children;
				};
			}
		})
	),
	uJ = uN({
		space: { type: [Number, String], default: "" },
		active: { type: Number, default: 0 },
		direction: { type: String, default: "horizontal", values: ["horizontal", "vertical"] },
		alignCenter: { type: Boolean },
		simple: { type: Boolean },
		finishStatus: { type: String, values: ["wait", "process", "finish", "error", "success"], default: "finish" },
		processStatus: { type: String, values: ["wait", "process", "finish", "error", "success"], default: "process" }
	}),
	cJ = { change: (e, t) => [e, t].every(XI) };
var hJ = IB(
	Tn(
		c(u({}, { name: "ElSteps" }), {
			props: uJ,
			emits: cJ,
			setup(e, { emit: t }) {
				const n = e,
					r = BD("steps"),
					i = Qe([]);
				return (
					ds(i, () => {
						i.value.forEach((e, t) => {
							e.setIndex(t);
						});
					}),
					mn("ElSteps", { props: n, steps: i }),
					ds(
						() => n.active,
						(e, n) => {
							t("change", e, n);
						}
					),
					(e, t) => (Wr(), Kr("div", { class: gt([it(r).b(), it(r).m(e.simple ? "simple" : e.direction)]) }, [mi(e.$slots, "default")], 2))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]
);
const dJ = uN({ title: { type: String, default: "" }, icon: { type: cN }, description: { type: String, default: "" }, status: { type: String, values: ["", "wait", "process", "finish", "error", "success"], default: "" } });
var pJ = IB(
	Tn(
		c(u({}, { name: "ElStep" }), {
			props: dJ,
			setup(e) {
				const t = e,
					n = BD("step"),
					r = Qe(-1),
					i = Qe({}),
					s = Qe(""),
					o = vn("ElSteps"),
					a = Si();
				Vn(() => {
					ds(
						[() => o.props.active, () => o.props.processStatus, () => o.props.finishStatus],
						([e]) => {
							g(e);
						},
						{ immediate: !0 }
					);
				}),
					$n(() => {
						o.steps.value = o.steps.value.filter((e) => e.uid !== (null == a ? void 0 : a.uid));
					});
				const l = ht(() => t.status || s.value),
					u = ht(() => {
						const e = o.steps.value[r.value - 1];
						return e ? e.currentStatus : "wait";
					}),
					c = ht(() => o.props.alignCenter),
					h = ht(() => "vertical" === o.props.direction),
					d = ht(() => o.props.simple),
					p = ht(() => o.steps.value.length),
					f = ht(() => {
						var e;
						return (null == (e = o.steps.value[p.value - 1]) ? void 0 : e.uid) === (null == a ? void 0 : a.uid);
					}),
					m = ht(() => (d.value ? "" : o.props.space)),
					v = ht(() => {
						const e = { flexBasis: "number" == typeof m.value ? `${m.value}px` : m.value ? m.value : 100 / (p.value - (c.value ? 0 : 1)) + "%" };
						return h.value || (f.value && (e.maxWidth = 100 / p.value + "%")), e;
					}),
					g = (e) => {
						e > r.value ? (s.value = o.props.finishStatus) : e === r.value && "error" !== u.value ? (s.value = o.props.processStatus) : (s.value = "wait");
						const t = o.steps.value[p.value - 1];
						t && t.calcProgress(s.value);
					},
					y = Fe({
						uid: ht(() => (null == a ? void 0 : a.uid)),
						currentStatus: l,
						setIndex: (e) => {
							r.value = e;
						},
						calcProgress: (e) => {
							let t = 100;
							const n = {};
							(n.transitionDelay = 150 * r.value + "ms"),
								e === o.props.processStatus ? (t = 0) : "wait" === e && ((t = 0), (n.transitionDelay = -150 * r.value + "ms")),
								(n.borderWidth = t && !d.value ? "1px" : 0),
								(n["vertical" === o.props.direction ? "height" : "width"] = `${t}%`),
								(i.value = n);
						}
					});
				return (
					(o.steps.value = [...o.steps.value, y]),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ style: pt(it(v)), class: gt([it(n).b(), it(n).is(it(d) ? "simple" : it(o).props.direction), it(n).is("flex", it(f) && !it(m) && !it(c)), it(n).is("center", it(c) && !it(h) && !it(d))]) },
							[
								ai(" icon & line "),
								ni(
									"div",
									{ class: gt([it(n).e("head"), it(n).is(it(l))]) },
									[
										it(d) ? ai("v-if", !0) : (Wr(), Kr("div", { key: 0, class: gt(it(n).e("line")) }, [ni("i", { class: gt(it(n).e("line-inner")), style: pt(i.value) }, null, 6)], 2)),
										ni(
											"div",
											{ class: gt([it(n).e("icon"), it(n).is(e.icon ? "icon" : "text")]) },
											[
												"success" !== it(l) && "error" !== it(l)
													? mi(e.$slots, "icon", { key: 0 }, () => [
															e.icon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(n).e("icon-inner")) }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
															e.icon || it(d) ? ai("v-if", !0) : (Wr(), Kr("div", { key: 1, class: gt(it(n).e("icon-inner")) }, bt(r.value + 1), 3))
													  ])
													: (Wr(), qr(it(OB), { key: 1, class: gt([it(n).e("icon-inner"), it(n).is("status")]) }, { default: cn(() => ["success" === it(l) ? (Wr(), qr(it(BL), { key: 0 })) : (Wr(), qr(it(aO), { key: 1 }))]), _: 1 }, 8, ["class"]))
											],
											2
										)
									],
									2
								),
								ai(" title & description "),
								ni(
									"div",
									{ class: gt(it(n).e("main")) },
									[
										ni("div", { class: gt([it(n).e("title"), it(n).is(it(l))]) }, [mi(e.$slots, "title", {}, () => [oi(bt(e.title), 1)])], 2),
										it(d) ? (Wr(), Kr("div", { key: 0, class: gt(it(n).e("arrow")) }, null, 2)) : (Wr(), Kr("div", { key: 1, class: gt([it(n).e("description"), it(n).is(it(l))]) }, [mi(e.$slots, "description", {}, () => [oi(bt(e.description), 1)])], 2))
									],
									2
								)
							],
							6
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]
);
const fJ = mN(hJ, { Step: pJ }),
	mJ = gN(pJ),
	vJ = uN({
		modelValue: { type: [Boolean, String, Number], default: !1 },
		value: { type: [Boolean, String, Number], default: !1 },
		disabled: { type: Boolean, default: !1 },
		width: { type: [String, Number], default: "" },
		inlinePrompt: { type: Boolean, default: !1 },
		activeIcon: { type: cN, default: "" },
		inactiveIcon: { type: cN, default: "" },
		activeText: { type: String, default: "" },
		inactiveText: { type: String, default: "" },
		activeColor: { type: String, default: "" },
		inactiveColor: { type: String, default: "" },
		borderColor: { type: String, default: "" },
		activeValue: { type: [Boolean, String, Number], default: !0 },
		inactiveValue: { type: [Boolean, String, Number], default: !1 },
		name: { type: String, default: "" },
		validateEvent: { type: Boolean, default: !0 },
		id: String,
		loading: { type: Boolean, default: !1 },
		beforeChange: { type: Function },
		size: { type: String, validator: EN },
		tabindex: { type: [String, Number] }
	}),
	gJ = Tn({
		name: "ElSwitch",
		components: { ElIcon: OB, Loading: HO },
		props: vJ,
		emits: { [_N]: (e) => YI(e) || SR(e) || XI(e), change: (e) => YI(e) || SR(e) || XI(e), input: (e) => YI(e) || SR(e) || XI(e) },
		setup(e, { emit: t }) {
			const { formItem: n } = yD(),
				r = dD(ht(() => e.loading)),
				i = BD("switch"),
				{ inputId: s } = bD(e, { formItemContext: n }),
				o = hD(),
				a = Qe(!1 !== e.modelValue),
				l = Qe(),
				u = Qe(),
				c = ht(() => [i.b(), i.m(o.value), i.is("disabled", r.value), i.is("checked", p.value)]),
				h = ht(() => ({ width: KR(e.width) }));
			ds(
				() => e.modelValue,
				() => {
					a.value = !0;
				}
			),
				ds(
					() => e.value,
					() => {
						a.value = !1;
					}
				);
			const d = ht(() => (a.value ? e.modelValue : e.value)),
				p = ht(() => d.value === e.activeValue);
			[e.activeValue, e.inactiveValue].includes(d.value) || (t(_N, e.inactiveValue), t("change", e.inactiveValue), t("input", e.inactiveValue)),
				ds(p, () => {
					var t;
					(l.value.checked = p.value), (e.activeColor || e.inactiveColor) && m(), e.validateEvent && (null == (t = null == n ? void 0 : n.validate) || t.call(n, "change").catch((e) => {}));
				});
			const f = () => {
					const n = p.value ? e.inactiveValue : e.activeValue;
					t(_N, n),
						t("change", n),
						t("input", n),
						ns(() => {
							l.value.checked = p.value;
						});
				},
				m = () => {
					const t = p.value ? e.activeColor : e.inactiveColor,
						n = u.value;
					e.borderColor ? (n.style.borderColor = e.borderColor) : e.borderColor || (n.style.borderColor = t), (n.style.backgroundColor = t), (n.children[0].style.color = t);
				};
			return (
				Vn(() => {
					(e.activeColor || e.inactiveColor || e.borderColor) && m(), (l.value.checked = p.value);
				}),
				{
					ns: i,
					input: l,
					inputId: s,
					core: u,
					switchDisabled: r,
					checked: p,
					switchKls: c,
					coreStyle: h,
					handleChange: f,
					switchValue: () => {
						if (r.value) return;
						const { beforeChange: t } = e;
						if (!t) return void f();
						const n = t();
						[TR(n), YI(n)].some((e) => e) || $R("ElSwitch", "beforeChange must return type `Promise<boolean>` or `boolean`"),
							TR(n)
								? n
										.then((e) => {
											e && f();
										})
										.catch((e) => {})
								: n && f();
					},
					focus: () => {
						var e, t;
						null == (t = null == (e = l.value) ? void 0 : e.focus) || t.call(e);
					}
				}
			);
		}
	}),
	yJ = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex"],
	bJ = ["aria-hidden"],
	xJ = ["aria-hidden"],
	_J = ["aria-hidden"],
	wJ = ["aria-hidden"];
const CJ = mN(
	IB(gJ, [
		[
			"render",
			function (e, t, n, r, i, s) {
				const o = Or("el-icon"),
					a = Or("loading");
				return (
					Wr(),
					Kr(
						"div",
						{ class: gt(e.switchKls), onClick: t[2] || (t[2] = zo((...t) => e.switchValue && e.switchValue(...t), ["prevent"])) },
						[
							ni(
								"input",
								{
									id: e.inputId,
									ref: "input",
									class: gt(e.ns.e("input")),
									type: "checkbox",
									role: "switch",
									"aria-checked": e.checked,
									"aria-disabled": e.switchDisabled,
									name: e.name,
									"true-value": e.activeValue,
									"false-value": e.inactiveValue,
									disabled: e.switchDisabled,
									tabindex: e.tabindex,
									onChange: t[0] || (t[0] = (...t) => e.handleChange && e.handleChange(...t)),
									onKeydown: t[1] || (t[1] = jo((...t) => e.switchValue && e.switchValue(...t), ["enter"]))
								},
								null,
								42,
								yJ
							),
							e.inlinePrompt || (!e.inactiveIcon && !e.inactiveText)
								? ai("v-if", !0)
								: (Wr(),
								  Kr(
										"span",
										{ key: 0, class: gt([e.ns.e("label"), e.ns.em("label", "left"), e.ns.is("active", !e.checked)]) },
										[
											e.inactiveIcon ? (Wr(), qr(o, { key: 0 }, { default: cn(() => [(Wr(), qr(Nr(e.inactiveIcon)))]), _: 1 })) : ai("v-if", !0),
											!e.inactiveIcon && e.inactiveText ? (Wr(), Kr("span", { key: 1, "aria-hidden": e.checked }, bt(e.inactiveText), 9, bJ)) : ai("v-if", !0)
										],
										2
								  )),
							ni(
								"span",
								{ ref: "core", class: gt(e.ns.e("core")), style: pt(e.coreStyle) },
								[
									e.inlinePrompt
										? (Wr(),
										  Kr(
												"div",
												{ key: 0, class: gt(e.ns.e("inner")) },
												[
													e.activeIcon || e.inactiveIcon
														? (Wr(),
														  Kr(
																Hr,
																{ key: 0 },
																[
																	e.activeIcon ? (Wr(), qr(o, { key: 0, class: gt([e.ns.is("icon"), e.checked ? e.ns.is("show") : e.ns.is("hide")]) }, { default: cn(() => [(Wr(), qr(Nr(e.activeIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
																	e.inactiveIcon ? (Wr(), qr(o, { key: 1, class: gt([e.ns.is("icon"), e.checked ? e.ns.is("hide") : e.ns.is("show")]) }, { default: cn(() => [(Wr(), qr(Nr(e.inactiveIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)
																],
																64
														  ))
														: e.activeText || e.inactiveIcon
														? (Wr(),
														  Kr(
																Hr,
																{ key: 1 },
																[
																	e.activeText ? (Wr(), Kr("span", { key: 0, class: gt([e.ns.is("text"), e.checked ? e.ns.is("show") : e.ns.is("hide")]), "aria-hidden": !e.checked }, bt(e.activeText.substring(0, 3)), 11, xJ)) : ai("v-if", !0),
																	e.inactiveText ? (Wr(), Kr("span", { key: 1, class: gt([e.ns.is("text"), e.checked ? e.ns.is("hide") : e.ns.is("show")]), "aria-hidden": e.checked }, bt(e.inactiveText.substring(0, 3)), 11, _J)) : ai("v-if", !0)
																],
																64
														  ))
														: ai("v-if", !0)
												],
												2
										  ))
										: ai("v-if", !0),
									ni("div", { class: gt(e.ns.e("action")) }, [e.loading ? (Wr(), qr(o, { key: 0, class: gt(e.ns.is("loading")) }, { default: cn(() => [ri(a)]), _: 1 }, 8, ["class"])) : ai("v-if", !0)], 2)
								],
								6
							),
							e.inlinePrompt || (!e.activeIcon && !e.activeText)
								? ai("v-if", !0)
								: (Wr(),
								  Kr(
										"span",
										{ key: 1, class: gt([e.ns.e("label"), e.ns.em("label", "right"), e.ns.is("active", e.checked)]) },
										[e.activeIcon ? (Wr(), qr(o, { key: 0 }, { default: cn(() => [(Wr(), qr(Nr(e.activeIcon)))]), _: 1 })) : ai("v-if", !0), !e.activeIcon && e.activeText ? (Wr(), Kr("span", { key: 1, "aria-hidden": !e.checked }, bt(e.activeText), 9, wJ)) : ai("v-if", !0)],
										2
								  ))
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]
	])
);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var SJ = /["'&<>]/,
	EJ = function (e) {
		var t,
			n = "" + e,
			r = SJ.exec(n);
		if (!r) return n;
		var i = "",
			s = 0,
			o = 0;
		for (s = r.index; s < n.length; s++) {
			switch (n.charCodeAt(s)) {
				case 34:
					t = "&quot;";
					break;
				case 38:
					t = "&amp;";
					break;
				case 39:
					t = "&#39;";
					break;
				case 60:
					t = "&lt;";
					break;
				case 62:
					t = "&gt;";
					break;
				default:
					continue;
			}
			o !== s && (i += n.substring(o, s)), (o = s + 1), (i += t);
		}
		return o !== s ? i + n.substring(o, s) : i;
	};
const TJ = function (e) {
		let t = e.target;
		for (; t && "HTML" !== t.tagName.toUpperCase(); ) {
			if ("TD" === t.tagName.toUpperCase()) return t;
			t = t.parentNode;
		}
		return null;
	},
	kJ = function (e) {
		return null !== e && "object" == typeof e;
	},
	AJ = function (e, t, n, r, i) {
		if (!t && !r && (!i || (Array.isArray(i) && !i.length))) return e;
		n = "string" == typeof n ? ("descending" === n ? -1 : 1) : n && n < 0 ? -1 : 1;
		const s = r
			? null
			: function (n, r) {
					return i ? (Array.isArray(i) || (i = [i]), i.map((t) => ("string" == typeof t ? XS(n, t) : t(n, r, e)))) : ("$key" !== t && kJ(n) && "$value" in n && (n = n.$value), [kJ(n) ? XS(n, t) : n]);
			  };
		return e
			.map((e, t) => ({ value: e, index: t, key: s ? s(e, t) : null }))
			.sort((e, t) => {
				let i = (function (e, t) {
					if (r) return r(e.value, t.value);
					for (let n = 0, r = e.key.length; n < r; n++) {
						if (e.key[n] < t.key[n]) return -1;
						if (e.key[n] > t.key[n]) return 1;
					}
					return 0;
				})(e, t);
				return i || (i = e.index - t.index), i * +n;
			})
			.map((e) => e.value);
	},
	MJ = function (e, t) {
		let n = null;
		return (
			e.columns.forEach((e) => {
				e.id === t && (n = e);
			}),
			n
		);
	},
	IJ = function (e, t, n) {
		const r = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
		return r ? MJ(e, r[0]) : null;
	},
	RJ = (e, t) => {
		if (!e) throw new Error("Row is required when get row identity");
		if ("string" == typeof t) {
			if (!t.includes(".")) return `${e[t]}`;
			const n = t.split(".");
			let r = e;
			for (const e of n) r = r[e];
			return `${r}`;
		}
		if ("function" == typeof t) return t.call(null, e);
	},
	LJ = function (e, t) {
		const n = {};
		return (
			(e || []).forEach((e, r) => {
				n[RJ(e, t)] = { row: e, index: r };
			}),
			n
		);
	};
function OJ(e) {
	return "" === e || (void 0 !== e && ((e = Number.parseInt(e, 10)), Number.isNaN(e) && (e = ""))), e;
}
function PJ(e) {
	return "" === e || (void 0 !== e && ((e = OJ(e)), Number.isNaN(e) && (e = 80))), e;
}
function NJ(e) {
	return "number" == typeof e ? e : "string" == typeof e ? (/^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e) : null;
}
function DJ(e, t, n) {
	let r = !1;
	const i = e.indexOf(t),
		s = -1 !== i,
		o = () => {
			e.push(t), (r = !0);
		},
		a = () => {
			e.splice(i, 1), (r = !0);
		};
	return "boolean" == typeof n ? (n && !s ? o() : !n && s && a()) : s ? a() : o(), r;
}
function BJ(e, t, n = "children", r = "hasChildren") {
	const i = (e) => !(Array.isArray(e) && e.length);
	function s(e, o, a) {
		t(e, o, a),
			o.forEach((e) => {
				if (e[r]) return void t(e, null, a + 1);
				const o = e[n];
				i(o) || s(e, o, a + 1);
			});
	}
	e.forEach((e) => {
		if (e[r]) return void t(e, null, 0);
		const o = e[n];
		i(o) || s(e, o, 0);
	});
}
let FJ;
const HJ = (e, t, n, r) => {
		let i,
			s = 0,
			o = e;
		if (r) {
			if (r[e].colSpan > 1) return {};
			for (let t = 0; t < e; t++) s += r[t].colSpan;
			o = s + r[e].colSpan - 1;
		} else s = e;
		const a = n.states.columns;
		switch (t) {
			case "left":
				o < n.states.fixedLeafColumnsLength.value && (i = "left");
				break;
			case "right":
				s >= a.value.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
				break;
			default:
				o < n.states.fixedLeafColumnsLength.value ? (i = "left") : s >= a.value.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
		}
		return i ? { direction: i, start: s, after: o } : {};
	},
	VJ = (e, t, n, r, i) => {
		const s = [],
			{ direction: o, start: a } = HJ(t, n, r, i);
		if (o) {
			const t = "left" === o;
			s.push(`${e}-fixed-column--${o}`), t && a === r.states.fixedLeafColumnsLength.value - 1 ? s.push("is-last-column") : t || a !== r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value || s.push("is-first-column");
		}
		return s;
	};
function UJ(e, t) {
	return e + (null === t.realWidth || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
}
const zJ = (e, t, n, r) => {
		const { direction: i, start: s = 0 } = HJ(e, t, n, r);
		if (!i) return;
		const o = {},
			a = "left" === i,
			l = n.states.columns.value;
		return (
			a
				? (o.left = l.slice(0, e).reduce(UJ, 0))
				: (o.right = l
						.slice(s + 1)
						.reverse()
						.reduce(UJ, 0)),
			o
		);
	},
	$J = (e, t) => {
		e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`));
	};
const jJ = (e) => {
	const t = [];
	return (
		e.forEach((e) => {
			e.children ? t.push.apply(t, jJ(e.children)) : t.push(e);
		}),
		t
	);
};
function WJ() {
	var e;
	const t = Si(),
		{ size: n } = at(null == (e = t.proxy) ? void 0 : e.$props),
		r = Qe(null),
		i = Qe([]),
		s = Qe([]),
		o = Qe(!1),
		a = Qe([]),
		l = Qe([]),
		c = Qe([]),
		h = Qe([]),
		d = Qe([]),
		p = Qe([]),
		f = Qe([]),
		m = Qe([]),
		v = Qe(0),
		g = Qe(0),
		y = Qe(0),
		b = Qe(!1),
		x = Qe([]),
		_ = Qe(!1),
		w = Qe(!1),
		C = Qe(null),
		S = Qe({}),
		E = Qe(null),
		T = Qe(null),
		k = Qe(null),
		A = Qe(null),
		M = Qe(null);
	ds(i, () => t.state && R(!1), { deep: !0 });
	const I = () => {
			(h.value = a.value.filter((e) => !0 === e.fixed || "left" === e.fixed)), (d.value = a.value.filter((e) => "right" === e.fixed)), h.value.length > 0 && a.value[0] && "selection" === a.value[0].type && !a.value[0].fixed && ((a.value[0].fixed = !0), h.value.unshift(a.value[0]));
			const e = a.value.filter((e) => !e.fixed);
			l.value = [].concat(h.value).concat(e).concat(d.value);
			const t = jJ(e),
				n = jJ(h.value),
				r = jJ(d.value);
			(v.value = t.length), (g.value = n.length), (y.value = r.length), (c.value = [].concat(n).concat(t).concat(r)), (o.value = h.value.length > 0 || d.value.length > 0);
		},
		R = (e, n = !1) => {
			e && I(), n ? t.state.doLayout() : t.state.debouncedUpdateLayout();
		},
		L = (e) => {
			var n;
			if (!t || !t.store) return 0;
			const { treeData: r } = t.store.states;
			let i = 0;
			const s = null == (n = r.value[e]) ? void 0 : n.children;
			return (
				s &&
					((i += s.length),
					s.forEach((e) => {
						i += L(e);
					})),
				i
			);
		},
		O = (e, t, n) => {
			T.value && T.value !== e && (T.value.order = null), (T.value = e), (k.value = t), (A.value = n);
		},
		P = () => {
			let e = it(s);
			Object.keys(S.value).forEach((t) => {
				const n = S.value[t];
				if (!n || 0 === n.length) return;
				const r = MJ({ columns: c.value }, t);
				r && r.filterMethod && (e = e.filter((e) => n.some((t) => r.filterMethod.call(null, t, e, r))));
			}),
				(E.value = e);
		},
		N = () => {
			i.value = ((e, t) => {
				const n = t.sortingColumn;
				return n && "string" != typeof n.sortable ? AJ(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy) : e;
			})(E.value, { sortingColumn: T.value, sortProp: k.value, sortOrder: A.value });
		},
		{
			setExpandRowKeys: D,
			toggleRowExpansion: B,
			updateExpandRows: F,
			states: H,
			isRowExpanded: V
		} = (function (e) {
			const t = Si(),
				n = Qe(!1),
				r = Qe([]);
			return {
				updateExpandRows: () => {
					const t = e.data.value || [],
						i = e.rowKey.value;
					if (n.value) r.value = t.slice();
					else if (i) {
						const e = LJ(r.value, i);
						r.value = t.reduce((t, n) => {
							const r = RJ(n, i);
							return e[r] && t.push(n), t;
						}, []);
					} else r.value = [];
				},
				toggleRowExpansion: (e, n) => {
					DJ(r.value, e, n) && t.emit("expand-change", e, r.value.slice());
				},
				setExpandRowKeys: (n) => {
					t.store.assertRowKey();
					const i = e.data.value || [],
						s = e.rowKey.value,
						o = LJ(i, s);
					r.value = n.reduce((e, t) => {
						const n = o[t];
						return n && e.push(n.row), e;
					}, []);
				},
				isRowExpanded: (t) => {
					const n = e.rowKey.value;
					return n ? !!LJ(r.value, n)[RJ(t, n)] : r.value.includes(t);
				},
				states: { expandRows: r, defaultExpandAll: n }
			};
		})({ data: i, rowKey: r }),
		{
			updateTreeExpandKeys: U,
			toggleTreeExpansion: z,
			updateTreeData: $,
			loadOrToggle: j,
			states: W
		} = (function (e) {
			const t = Qe([]),
				n = Qe({}),
				r = Qe(16),
				i = Qe(!1),
				s = Qe({}),
				o = Qe("hasChildren"),
				a = Qe("children"),
				l = Si(),
				c = ht(() => {
					if (!e.rowKey.value) return {};
					const t = e.data.value || [];
					return d(t);
				}),
				h = ht(() => {
					const t = e.rowKey.value,
						n = Object.keys(s.value),
						r = {};
					return n.length
						? (n.forEach((e) => {
								if (s.value[e].length) {
									const n = { children: [] };
									s.value[e].forEach((e) => {
										const i = RJ(e, t);
										n.children.push(i), e[o.value] && !r[i] && (r[i] = { children: [] });
									}),
										(r[e] = n);
								}
						  }),
						  r)
						: r;
				}),
				d = (t) => {
					const n = e.rowKey.value,
						r = {};
					return (
						BJ(
							t,
							(e, t, s) => {
								const o = RJ(e, n);
								Array.isArray(t) ? (r[o] = { children: t.map((e) => RJ(e, n)), level: s }) : i.value && (r[o] = { children: [], lazy: !0, level: s });
							},
							a.value,
							o.value
						),
						r
					);
				},
				p = (e = !1, r = ((e) => (null == (e = l.store) ? void 0 : e.states.defaultExpandAll.value))()) => {
					var s;
					const o = c.value,
						a = h.value,
						d = Object.keys(o),
						p = {};
					if (d.length) {
						const s = it(n),
							l = [],
							c = (n, i) => {
								if (e) return t.value ? r || t.value.includes(i) : !(!r && !(null == n ? void 0 : n.expanded));
								{
									const e = r || (t.value && t.value.includes(i));
									return !(!(null == n ? void 0 : n.expanded) && !e);
								}
							};
						d.forEach((e) => {
							const t = s[e],
								n = u({}, o[e]);
							if (((n.expanded = c(t, e)), n.lazy)) {
								const { loaded: r = !1, loading: i = !1 } = t || {};
								(n.loaded = !!r), (n.loading = !!i), l.push(e);
							}
							p[e] = n;
						});
						const h = Object.keys(a);
						i.value &&
							h.length &&
							l.length &&
							h.forEach((e) => {
								const t = s[e],
									n = a[e].children;
								if (l.includes(e)) {
									if (0 !== p[e].children.length) throw new Error("[ElTable]children must be an empty array.");
									p[e].children = n;
								} else {
									const { loaded: r = !1, loading: i = !1 } = t || {};
									p[e] = { lazy: !0, loaded: !!r, loading: !!i, expanded: c(t, e), children: n, level: "" };
								}
							});
					}
					(n.value = p), null == (s = l.store) || s.updateTableScrollY();
				};
			ds(
				() => t.value,
				() => {
					p(!0);
				}
			),
				ds(
					() => c.value,
					() => {
						p();
					}
				),
				ds(
					() => h.value,
					() => {
						p();
					}
				);
			const f = (t, r) => {
					l.store.assertRowKey();
					const i = e.rowKey.value,
						s = RJ(t, i),
						o = s && n.value[s];
					if (s && o && "expanded" in o) {
						const e = o.expanded;
						(r = void 0 === r ? !o.expanded : r), (n.value[s].expanded = r), e !== r && l.emit("expand-change", t, r), l.store.updateTableScrollY();
					}
				},
				m = (e, t, r) => {
					const { load: i } = l.props;
					i &&
						!n.value[t].loaded &&
						((n.value[t].loading = !0),
						i(e, r, (r) => {
							if (!Array.isArray(r)) throw new TypeError("[ElTable] data must be an array");
							(n.value[t].loading = !1), (n.value[t].loaded = !0), (n.value[t].expanded = !0), r.length && (s.value[t] = r), l.emit("expand-change", e, !0);
						}));
				};
			return {
				loadData: m,
				loadOrToggle: (t) => {
					l.store.assertRowKey();
					const r = e.rowKey.value,
						s = RJ(t, r),
						o = n.value[s];
					i.value && o && "loaded" in o && !o.loaded ? m(t, s, o) : f(t, void 0);
				},
				toggleTreeExpansion: f,
				updateTreeExpandKeys: (e) => {
					(t.value = e), p();
				},
				updateTreeData: p,
				normalize: d,
				states: { expandRowKeys: t, treeData: n, indent: r, lazy: i, lazyTreeNodeMap: s, lazyColumnIdentifier: o, childrenColumnName: a }
			};
		})({ data: i, rowKey: r }),
		{
			updateCurrentRowData: G,
			updateCurrentRow: Y,
			setCurrentRowKey: X,
			states: K
		} = (function (e) {
			const t = Si(),
				n = Qe(null),
				r = Qe(null),
				i = () => {
					n.value = null;
				},
				s = (n) => {
					const { data: i, rowKey: s } = e;
					let o = null;
					s.value && (o = (it(i) || []).find((e) => RJ(e, s.value) === n)), (r.value = o), t.emit("current-change", r.value, null);
				};
			return {
				setCurrentRowKey: (e) => {
					t.store.assertRowKey(), (n.value = e), s(e);
				},
				restoreCurrentRowKey: i,
				setCurrentRowByKey: s,
				updateCurrentRow: (e) => {
					const n = r.value;
					if (e && e !== n) return (r.value = e), void t.emit("current-change", r.value, n);
					!e && n && ((r.value = null), t.emit("current-change", null, n));
				},
				updateCurrentRowData: () => {
					const o = e.rowKey.value,
						a = e.data.value || [],
						l = r.value;
					if (!a.includes(l) && l) {
						if (o) {
							const e = RJ(l, o);
							s(e);
						} else r.value = null;
						null === r.value && t.emit("current-change", null, l);
					} else n.value && (s(n.value), i());
				},
				states: { _currentRowKey: n, currentRow: r }
			};
		})({ data: i, rowKey: r });
	return {
		assertRowKey: () => {
			if (!r.value) throw new Error("[ElTable] prop row-key is required");
		},
		updateColumns: I,
		scheduleLayout: R,
		isSelected: (e) => x.value.includes(e),
		clearSelection: () => {
			b.value = !1;
			x.value.length && ((x.value = []), t.emit("selection-change", []));
		},
		cleanSelection: () => {
			let e;
			if (r.value) {
				e = [];
				const t = LJ(x.value, r.value),
					n = LJ(i.value, r.value);
				for (const r in t) xR(t, r) && !n[r] && e.push(t[r].row);
			} else e = x.value.filter((e) => !i.value.includes(e));
			if (e.length) {
				const n = x.value.filter((t) => !e.includes(t));
				(x.value = n), t.emit("selection-change", n.slice());
			}
		},
		getSelectionRows: () => (x.value || []).slice(),
		toggleRowSelection: (e, n, r = !0) => {
			if (DJ(x.value, e, n)) {
				const n = (x.value || []).slice();
				r && t.emit("select", n, e), t.emit("selection-change", n);
			}
		},
		_toggleAllSelection: () => {
			var e, n;
			const r = w.value ? !b.value : !(b.value || x.value.length);
			b.value = r;
			let s = !1,
				o = 0;
			const a = null == (n = null == (e = null == t ? void 0 : t.store) ? void 0 : e.states) ? void 0 : n.rowKey.value;
			i.value.forEach((e, t) => {
				const n = t + o;
				C.value ? C.value.call(null, e, n) && DJ(x.value, e, r) && (s = !0) : DJ(x.value, e, r) && (s = !0), (o += L(RJ(e, a)));
			}),
				s && t.emit("selection-change", x.value ? x.value.slice() : []),
				t.emit("select-all", x.value);
		},
		toggleAllSelection: null,
		updateSelectionByRowKey: () => {
			const e = LJ(x.value, r.value);
			i.value.forEach((t) => {
				const n = RJ(t, r.value),
					i = e[n];
				i && (x.value[i.index] = t);
			});
		},
		updateAllSelected: () => {
			var e, n, s;
			if (0 === (null == (e = i.value) ? void 0 : e.length)) return void (b.value = !1);
			let o;
			r.value && (o = LJ(x.value, r.value));
			let a = !0,
				l = 0,
				u = 0;
			for (let h = 0, d = (i.value || []).length; h < d; h++) {
				const e = null == (s = null == (n = null == t ? void 0 : t.store) ? void 0 : n.states) ? void 0 : s.rowKey.value,
					d = h + u,
					p = i.value[h],
					f = C.value && C.value.call(null, p, d);
				if (((c = p), o ? o[RJ(c, r.value)] : x.value.includes(c))) l++;
				else if (!C.value || f) {
					a = !1;
					break;
				}
				u += L(RJ(p, e));
			}
			var c;
			0 === l && (a = !1), (b.value = a);
		},
		updateFilters: (e, t) => {
			Array.isArray(e) || (e = [e]);
			const n = {};
			return (
				e.forEach((e) => {
					(S.value[e.id] = t), (n[e.columnKey || e.id] = t);
				}),
				n
			);
		},
		updateCurrentRow: Y,
		updateSort: O,
		execFilter: P,
		execSort: N,
		execQuery: (e) => {
			(e && e.filter) || P(), N();
		},
		clearFilter: (e) => {
			const { tableHeaderRef: n } = t.refs;
			if (!n) return;
			const r = Object.assign({}, n.filterPanels),
				i = Object.keys(r);
			if (i.length)
				if (("string" == typeof e && (e = [e]), Array.isArray(e))) {
					const n = e.map((e) =>
						(function (e, t) {
							let n = null;
							for (let r = 0; r < e.columns.length; r++) {
								const i = e.columns[r];
								if (i.columnKey === t) {
									n = i;
									break;
								}
							}
							return n;
						})({ columns: c.value }, e)
					);
					i.forEach((e) => {
						const t = n.find((t) => t.id === e);
						t && (t.filteredValue = []);
					}),
						t.store.commit("filterChange", { column: n, values: [], silent: !0, multi: !0 });
				} else
					i.forEach((e) => {
						const t = c.value.find((t) => t.id === e);
						t && (t.filteredValue = []);
					}),
						(S.value = {}),
						t.store.commit("filterChange", { column: {}, values: [], silent: !0 });
		},
		clearSort: () => {
			T.value && (O(null, null, null), t.store.commit("changeSortCondition", { silent: !0 }));
		},
		toggleRowExpansion: B,
		setExpandRowKeysAdapter: (e) => {
			D(e), U(e);
		},
		setCurrentRowKey: X,
		toggleRowExpansionAdapter: (e, t) => {
			c.value.some(({ type: e }) => "expand" === e) ? B(e, t) : z(e, t);
		},
		isRowExpanded: V,
		updateExpandRows: F,
		updateCurrentRowData: G,
		loadOrToggle: j,
		updateTreeData: $,
		states: u(
			u(
				u(
					{
						tableSize: n,
						rowKey: r,
						data: i,
						_data: s,
						isComplex: o,
						_columns: a,
						originColumns: l,
						columns: c,
						fixedColumns: h,
						rightFixedColumns: d,
						leafColumns: p,
						fixedLeafColumns: f,
						rightFixedLeafColumns: m,
						leafColumnsLength: v,
						fixedLeafColumnsLength: g,
						rightFixedLeafColumnsLength: y,
						isAllSelected: b,
						selection: x,
						reserveSelection: _,
						selectOnIndeterminate: w,
						selectable: C,
						filters: S,
						filteredData: E,
						sortingColumn: T,
						sortProp: k,
						sortOrder: A,
						hoverRow: M
					},
					H
				),
				W
			),
			K
		)
	};
}
function GJ(e, t) {
	return e.map((e) => {
		var n;
		return e.id === t.id ? t : ((null == (n = e.children) ? void 0 : n.length) && (e.children = GJ(e.children, t)), e);
	});
}
function YJ(e) {
	e.forEach((e) => {
		var t, n;
		(e.no = null == (t = e.getColumnIndex) ? void 0 : t.call(e)), (null == (n = e.children) ? void 0 : n.length) && YJ(e.children);
	}),
		e.sort((e, t) => e.no - t.no);
}
function XJ() {
	const e = Si(),
		t = WJ(),
		n = BD("table"),
		r = {
			setData(t, n) {
				const r = it(t._data) !== n;
				(t.data.value = n),
					(t._data.value = n),
					e.store.execQuery(),
					e.store.updateCurrentRowData(),
					e.store.updateExpandRows(),
					e.store.updateTreeData(e.store.states.defaultExpandAll.value),
					it(t.reserveSelection) ? (e.store.assertRowKey(), e.store.updateSelectionByRowKey()) : r ? e.store.clearSelection() : e.store.cleanSelection(),
					e.store.updateAllSelected(),
					e.$ready && e.store.scheduleLayout();
			},
			insertColumn(t, n, r) {
				const i = it(t._columns);
				let s = [];
				r ? (r && !r.children && (r.children = []), r.children.push(n), (s = GJ(i, r))) : (i.push(n), (s = i)),
					YJ(s),
					(t._columns.value = s),
					"selection" === n.type && ((t.selectable.value = n.selectable), (t.reserveSelection.value = n.reserveSelection)),
					e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
			},
			removeColumn(t, n, r) {
				const i = it(t._columns) || [];
				if (r)
					r.children.splice(
						r.children.findIndex((e) => e.id === n.id),
						1
					),
						0 === r.children.length && delete r.children,
						(t._columns.value = GJ(i, r));
				else {
					const e = i.indexOf(n);
					e > -1 && (i.splice(e, 1), (t._columns.value = i));
				}
				e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
			},
			sort(t, n) {
				const { prop: r, order: i, init: s } = n;
				if (r) {
					const n = it(t.columns).find((e) => e.property === r);
					n && ((n.order = i), e.store.updateSort(n, r, i), e.store.commit("changeSortCondition", { init: s }));
				}
			},
			changeSortCondition(t, n) {
				const { sortingColumn: r, sortProp: i, sortOrder: s } = t;
				null === it(s) && ((t.sortingColumn.value = null), (t.sortProp.value = null));
				e.store.execQuery({ filter: !0 }), (n && (n.silent || n.init)) || e.emit("sort-change", { column: it(r), prop: it(i), order: it(s) }), e.store.updateTableScrollY();
			},
			filterChange(t, n) {
				const { column: r, values: i, silent: s } = n,
					o = e.store.updateFilters(r, i);
				e.store.execQuery(), s || e.emit("filter-change", o), e.store.updateTableScrollY();
			},
			toggleAllSelection() {
				e.store.toggleAllSelection();
			},
			rowSelectedChanged(t, n) {
				e.store.toggleRowSelection(n), e.store.updateAllSelected();
			},
			setHoverRow(e, t) {
				e.hoverRow.value = t;
			},
			setCurrentRow(t, n) {
				e.store.updateCurrentRow(n);
			}
		};
	return c(u({ ns: n }, t), {
		mutations: r,
		commit: function (t, ...n) {
			const r = e.store.mutations;
			if (!r[t]) throw new Error(`Action not found: ${t}`);
			r[t].apply(e, [e.store.states].concat(n));
		},
		updateTableScrollY: function () {
			ns(() => e.layout.updateScrollY.apply(e.layout));
		}
	});
}
const KJ = {
	rowKey: "rowKey",
	defaultExpandAll: "defaultExpandAll",
	selectOnIndeterminate: "selectOnIndeterminate",
	indent: "indent",
	lazy: "lazy",
	data: "data",
	"treeProps.hasChildren": { key: "lazyColumnIdentifier", default: "hasChildren" },
	"treeProps.children": { key: "childrenColumnName", default: "children" }
};
function qJ(e, t) {
	if (!e) throw new Error("Table is required.");
	const n = XJ();
	return (
		(n.toggleAllSelection = QT(n._toggleAllSelection, 10)),
		Object.keys(KJ).forEach((e) => {
			ZJ(JJ(t, e), e, n);
		}),
		(function (e, t) {
			Object.keys(KJ).forEach((n) => {
				ds(
					() => JJ(t, n),
					(t) => {
						ZJ(t, n, e);
					}
				);
			});
		})(n, t),
		n
	);
}
function ZJ(e, t, n) {
	let r = e,
		i = KJ[t];
	"object" == typeof KJ[t] && ((i = i.key), (r = r || KJ[t].default)), (n.states[i].value = r);
}
function JJ(e, t) {
	if (t.includes(".")) {
		const n = t.split(".");
		let r = e;
		return (
			n.forEach((e) => {
				r = r[e];
			}),
			r
		);
	}
	return e[t];
}
class QJ {
	constructor(e) {
		(this.observers = []),
			(this.table = null),
			(this.store = null),
			(this.columns = []),
			(this.fit = !0),
			(this.showHeader = !0),
			(this.height = Qe(null)),
			(this.scrollX = Qe(!1)),
			(this.scrollY = Qe(!1)),
			(this.bodyWidth = Qe(null)),
			(this.fixedWidth = Qe(null)),
			(this.rightFixedWidth = Qe(null)),
			(this.tableHeight = Qe(null)),
			(this.headerHeight = Qe(44)),
			(this.appendHeight = Qe(0)),
			(this.footerHeight = Qe(44)),
			(this.viewportHeight = Qe(null)),
			(this.bodyHeight = Qe(null)),
			(this.bodyScrollHeight = Qe(0)),
			(this.fixedBodyHeight = Qe(null)),
			(this.gutterWidth = 0);
		for (const t in e) xR(e, t) && (Je(this[t]) ? (this[t].value = e[t]) : (this[t] = e[t]));
		if (!this.table) throw new Error("Table is required for Table Layout");
		if (!this.store) throw new Error("Store is required for Table Layout");
	}
	updateScrollY() {
		if (null === this.height.value) return !1;
		const e = this.table.refs.bodyWrapper;
		if (this.table.vnode.el && e) {
			let t = !0;
			const n = this.scrollY.value;
			return (t = null !== this.bodyHeight.value && e.scrollHeight > this.bodyHeight.value), (this.scrollY.value = t), n !== t;
		}
		return !1;
	}
	setHeight(e, t = "height") {
		if (!GI) return;
		const n = this.table.vnode.el;
		if (((e = NJ(e)), (this.height.value = Number(e)), !n && (e || 0 === e))) return ns(() => this.setHeight(e, t));
		"number" == typeof e ? ((n.style[t] = `${e}px`), this.updateElsHeight()) : "string" == typeof e && ((n.style[t] = e), this.updateElsHeight());
	}
	setMaxHeight(e) {
		this.setHeight(e, "max-height");
	}
	getFlattenColumns() {
		const e = [];
		return (
			this.table.store.states.columns.value.forEach((t) => {
				t.isColumnGroup ? e.push.apply(e, t.columns) : e.push(t);
			}),
			e
		);
	}
	updateElsHeight() {
		var e, t;
		if (!this.table.$ready) return ns(() => this.updateElsHeight());
		const { tableWrapper: n, headerWrapper: r, appendWrapper: i, footerWrapper: s, tableHeader: o, tableBody: a } = this.table.refs;
		if (n && "none" === n.style.display) return;
		const { tableLayout: l } = this.table.props;
		if (((this.appendHeight.value = i ? i.offsetHeight : 0), this.showHeader && !r && "fixed" === l)) return;
		const u = o || null,
			c = this.headerDisplayNone(u),
			h = (null == r ? void 0 : r.offsetHeight) || 0,
			d = (this.headerHeight.value = this.showHeader ? h : 0);
		if (this.showHeader && !c && h > 0 && (this.table.store.states.columns.value || []).length > 0 && d < 2) return ns(() => this.updateElsHeight());
		const p = (this.tableHeight.value = null == (t = null == (e = this.table) ? void 0 : e.vnode.el) ? void 0 : t.clientHeight),
			f = (this.footerHeight.value = s ? s.offsetHeight : 0);
		null !== this.height.value && (null === this.bodyHeight.value && requestAnimationFrame(() => this.updateElsHeight()), (this.bodyHeight.value = p - d - f + (s ? 1 : 0)), (this.bodyScrollHeight.value = null == a ? void 0 : a.scrollHeight)),
			(this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value),
			(this.viewportHeight.value = this.scrollX.value ? p - this.gutterWidth : p),
			this.updateScrollY(),
			this.notifyObservers("scrollable");
	}
	headerDisplayNone(e) {
		if (!e) return !0;
		let t = e;
		for (; "DIV" !== t.tagName; ) {
			if ("none" === getComputedStyle(t).display) return !0;
			t = t.parentElement;
		}
		return !1;
	}
	updateColumnsWidth() {
		if (!GI) return;
		const e = this.fit,
			t = this.table.vnode.el.clientWidth;
		let n = 0;
		const r = this.getFlattenColumns(),
			i = r.filter((e) => "number" != typeof e.width);
		if (
			(r.forEach((e) => {
				"number" == typeof e.width && e.realWidth && (e.realWidth = null);
			}),
			i.length > 0 && e)
		) {
			if (
				(r.forEach((e) => {
					n += Number(e.width || e.minWidth || 80);
				}),
				n <= t)
			) {
				this.scrollX.value = !1;
				const e = t - n;
				if (1 === i.length) i[0].realWidth = Number(i[0].minWidth || 80) + e;
				else {
					const t = e / i.reduce((e, t) => e + Number(t.minWidth || 80), 0);
					let n = 0;
					i.forEach((e, r) => {
						if (0 === r) return;
						const i = Math.floor(Number(e.minWidth || 80) * t);
						(n += i), (e.realWidth = Number(e.minWidth || 80) + i);
					}),
						(i[0].realWidth = Number(i[0].minWidth || 80) + e - n);
				}
			} else
				(this.scrollX.value = !0),
					i.forEach((e) => {
						e.realWidth = Number(e.minWidth);
					});
			(this.bodyWidth.value = Math.max(n, t)), (this.table.state.resizeState.value.width = this.bodyWidth.value);
		} else
			r.forEach((e) => {
				e.width || e.minWidth ? (e.realWidth = Number(e.width || e.minWidth)) : (e.realWidth = 80), (n += e.realWidth);
			}),
				(this.scrollX.value = n > t),
				(this.bodyWidth.value = n);
		const s = this.store.states.fixedColumns.value;
		if (s.length > 0) {
			let e = 0;
			s.forEach((t) => {
				e += Number(t.realWidth || t.width);
			}),
				(this.fixedWidth.value = e);
		}
		const o = this.store.states.rightFixedColumns.value;
		if (o.length > 0) {
			let e = 0;
			o.forEach((t) => {
				e += Number(t.realWidth || t.width);
			}),
				(this.rightFixedWidth.value = e);
		}
		this.notifyObservers("columns");
	}
	addObserver(e) {
		this.observers.push(e);
	}
	removeObserver(e) {
		const t = this.observers.indexOf(e);
		-1 !== t && this.observers.splice(t, 1);
	}
	notifyObservers(e) {
		this.observers.forEach((t) => {
			var n, r;
			switch (e) {
				case "columns":
					null == (n = t.state) || n.onColumnsChange(this);
					break;
				case "scrollable":
					null == (r = t.state) || r.onScrollableChange(this);
					break;
				default:
					throw new Error(`Table Layout don't have event ${e}.`);
			}
		});
	}
}
const { CheckboxGroup: eQ } = qz,
	tQ = Tn({
		name: "ElTableFilterPanel",
		components: { ElCheckbox: qz, ElCheckboxGroup: eQ, ElScrollbar: ZB, ElTooltip: QH, ElIcon: OB, ArrowDown: sL, ArrowUp: gL },
		directives: { ClickOutside: CU },
		props: { placement: { type: String, default: "bottom-start" }, store: { type: Object }, column: { type: Object }, upDataColumn: { type: Function } },
		setup(e) {
			const t = Si(),
				{ t: n } = CD(),
				r = BD("table-filter"),
				i = null == t ? void 0 : t.parent;
			i.filterPanels.value[e.column.id] || (i.filterPanels.value[e.column.id] = t);
			const s = Qe(!1),
				o = Qe(null),
				a = ht(() => e.column && e.column.filters),
				l = ht({
					get: () => {
						var t;
						return ((null == (t = e.column) ? void 0 : t.filteredValue) || [])[0];
					},
					set: (e) => {
						u.value && (null != e ? u.value.splice(0, 1, e) : u.value.splice(0, 1));
					}
				}),
				u = ht({
					get: () => (e.column && e.column.filteredValue) || [],
					set(t) {
						e.column && e.upDataColumn("filteredValue", t);
					}
				}),
				c = ht(() => !e.column || e.column.filterMultiple),
				h = () => {
					s.value = !1;
				},
				d = (t) => {
					e.store.commit("filterChange", { column: e.column, values: t }), e.store.updateAllSelected();
				};
			ds(
				s,
				(t) => {
					e.column && e.upDataColumn("filterOpened", t);
				},
				{ immediate: !0 }
			);
			const p = ht(() => {
				var e, t;
				return null == (t = null == (e = o.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef;
			});
			return {
				tooltipVisible: s,
				multiple: c,
				filteredValue: u,
				filterValue: l,
				filters: a,
				handleConfirm: () => {
					d(u.value), h();
				},
				handleReset: () => {
					(u.value = []), d(u.value), h();
				},
				handleSelect: (e) => {
					(l.value = e), d(null != e ? u.value : []), h();
				},
				isActive: (e) => e.value === l.value,
				t: n,
				ns: r,
				showFilterPanel: (e) => {
					e.stopPropagation(), (s.value = !s.value);
				},
				hideFilterPanel: () => {
					s.value = !1;
				},
				popperPaneRef: p,
				tooltip: o
			};
		}
	}),
	nQ = { key: 0 },
	rQ = ["disabled"],
	iQ = ["label", "onClick"];
var sQ = IB(tQ, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-checkbox"),
				a = Or("el-checkbox-group"),
				l = Or("el-scrollbar"),
				u = Or("arrow-up"),
				c = Or("arrow-down"),
				h = Or("el-icon"),
				d = Or("el-tooltip"),
				p = Dr("click-outside");
			return (
				Wr(),
				qr(
					d,
					{
						ref: "tooltip",
						visible: e.tooltipVisible,
						"onUpdate:visible": t[5] || (t[5] = (t) => (e.tooltipVisible = t)),
						offset: 0,
						placement: e.placement,
						"show-arrow": !1,
						"stop-popper-mouse-event": !1,
						teleported: "",
						effect: "light",
						pure: "",
						"popper-class": e.ns.b(),
						persistent: ""
					},
					{
						content: cn(() => [
							e.multiple
								? (Wr(),
								  Kr("div", nQ, [
										ni(
											"div",
											{ class: gt(e.ns.e("content")) },
											[
												ri(
													l,
													{ "wrap-class": e.ns.e("wrap") },
													{
														default: cn(() => [
															ri(
																a,
																{ modelValue: e.filteredValue, "onUpdate:modelValue": t[0] || (t[0] = (t) => (e.filteredValue = t)), class: gt(e.ns.e("checkbox-group")) },
																{
																	default: cn(() => [
																		(Wr(!0),
																		Kr(
																			Hr,
																			null,
																			pi(e.filters, (e) => (Wr(), qr(o, { key: e.value, label: e.value }, { default: cn(() => [oi(bt(e.text), 1)]), _: 2 }, 1032, ["label"]))),
																			128
																		))
																	]),
																	_: 1
																},
																8,
																["modelValue", "class"]
															)
														]),
														_: 1
													},
													8,
													["wrap-class"]
												)
											],
											2
										),
										ni(
											"div",
											{ class: gt(e.ns.e("bottom")) },
											[
												ni(
													"button",
													{ class: gt({ [e.ns.is("disabled")]: 0 === e.filteredValue.length }), disabled: 0 === e.filteredValue.length, type: "button", onClick: t[1] || (t[1] = (...t) => e.handleConfirm && e.handleConfirm(...t)) },
													bt(e.t("el.table.confirmFilter")),
													11,
													rQ
												),
												ni("button", { type: "button", onClick: t[2] || (t[2] = (...t) => e.handleReset && e.handleReset(...t)) }, bt(e.t("el.table.resetFilter")), 1)
											],
											2
										)
								  ]))
								: (Wr(),
								  Kr(
										"ul",
										{ key: 1, class: gt(e.ns.e("list")) },
										[
											ni("li", { class: gt([e.ns.e("list-item"), { [e.ns.is("active")]: void 0 === e.filterValue || null === e.filterValue }]), onClick: t[3] || (t[3] = (t) => e.handleSelect(null)) }, bt(e.t("el.table.clearFilter")), 3),
											(Wr(!0),
											Kr(
												Hr,
												null,
												pi(e.filters, (t) => (Wr(), Kr("li", { key: t.value, class: gt([e.ns.e("list-item"), e.ns.is("active", e.isActive(t))]), label: t.value, onClick: (n) => e.handleSelect(t.value) }, bt(t.text), 11, iQ))),
												128
											))
										],
										2
								  ))
						]),
						default: cn(() => [
							yr(
								(Wr(),
								Kr(
									"span",
									{ class: gt([`${e.ns.namespace.value}-table__column-filter-trigger`, `${e.ns.namespace.value}-none-outline`]), onClick: t[4] || (t[4] = (...t) => e.showFilterPanel && e.showFilterPanel(...t)) },
									[ri(h, null, { default: cn(() => [e.column.filterOpened ? (Wr(), qr(u, { key: 0 })) : (Wr(), qr(c, { key: 1 }))]), _: 1 })],
									2
								)),
								[[p, e.hideFilterPanel, e.popperPaneRef]]
							)
						]),
						_: 1
					},
					8,
					["visible", "placement", "popper-class"]
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]
]);
function oQ(e) {
	const t = Si();
	Hn(() => {
		n.value.addObserver(t);
	}),
		Vn(() => {
			r(n.value), i(n.value);
		}),
		zn(() => {
			r(n.value), i(n.value);
		}),
		jn(() => {
			n.value.removeObserver(t);
		});
	const n = ht(() => {
			const t = e.layout;
			if (!t) throw new Error("Can not find table layout.");
			return t;
		}),
		r = (t) => {
			var n;
			const r = (null == (n = e.vnode.el) ? void 0 : n.querySelectorAll("colgroup > col")) || [];
			if (!r.length) return;
			const i = t.getFlattenColumns(),
				s = {};
			i.forEach((e) => {
				s[e.id] = e;
			});
			for (let e = 0, o = r.length; e < o; e++) {
				const t = r[e],
					n = t.getAttribute("name"),
					i = s[n];
				i && t.setAttribute("width", i.realWidth || i.width);
			}
		},
		i = (t) => {
			var n, r;
			const i = (null == (n = e.vnode.el) ? void 0 : n.querySelectorAll("colgroup > col[name=gutter]")) || [];
			for (let e = 0, o = i.length; e < o; e++) {
				i[e].setAttribute("width", t.scrollY.value ? t.gutterWidth : "0");
			}
			const s = (null == (r = e.vnode.el) ? void 0 : r.querySelectorAll("th.gutter")) || [];
			for (let e = 0, o = s.length; e < o; e++) {
				const n = s[e];
				(n.style.width = t.scrollY.value ? `${t.gutterWidth}px` : "0"), (n.style.display = t.scrollY.value ? "" : "none");
			}
		};
	return { tableLayout: n.value, onColumnsChange: r, onScrollableChange: i };
}
const aQ = Symbol("ElTable");
const lQ = (e) => {
	const t = [];
	return (
		e.forEach((e) => {
			e.children ? (t.push(e), t.push.apply(t, lQ(e.children))) : t.push(e);
		}),
		t
	);
};
function uQ(e) {
	const t = vn(aQ),
		n = ht(() =>
			((e) => {
				let t = 1;
				const n = (e, r) => {
					if ((r && ((e.level = r.level + 1), t < e.level && (t = e.level)), e.children)) {
						let t = 0;
						e.children.forEach((r) => {
							n(r, e), (t += r.colSpan);
						}),
							(e.colSpan = t);
					} else e.colSpan = 1;
				};
				e.forEach((e) => {
					(e.level = 1), n(e, void 0);
				});
				const r = [];
				for (let i = 0; i < t; i++) r.push([]);
				return (
					lQ(e).forEach((e) => {
						e.children ? ((e.rowSpan = 1), e.children.forEach((e) => (e.isSubColumn = !0))) : (e.rowSpan = t - e.level + 1), r[e.level - 1].push(e);
					}),
					r
				);
			})(e.store.states.originColumns.value)
		);
	return {
		isGroup: ht(() => {
			const e = n.value.length > 1;
			return e && t && (t.state.isGroup.value = !0), e;
		}),
		toggleAllSelection: (e) => {
			e.stopPropagation(), null == t || t.store.commit("toggleAllSelection");
		},
		columnRows: n
	};
}
var cQ = Tn({
	name: "ElTableHeader",
	components: { ElCheckbox: qz },
	props: { fixed: { type: String, default: "" }, store: { required: !0, type: Object }, border: Boolean, defaultSort: { type: Object, default: () => ({ prop: "", order: "" }) } },
	setup(e, { emit: t }) {
		const n = Si(),
			r = vn(aQ),
			i = BD("table"),
			s = Qe({}),
			{ onColumnsChange: o, onScrollableChange: a } = oQ(r);
		Vn(async () => {
			await ns(), await ns();
			const { prop: t, order: n } = e.defaultSort;
			null == r || r.store.commit("sort", { prop: t, order: n, init: !0 });
		});
		const {
				handleHeaderClick: l,
				handleHeaderContextMenu: u,
				handleMouseDown: c,
				handleMouseMove: h,
				handleMouseOut: d,
				handleSortClick: p,
				handleFilterClick: f
			} = (function (e, t) {
				const n = Si(),
					r = vn(aQ),
					i = (e) => {
						e.stopPropagation();
					},
					s = Qe(null),
					o = Qe(!1),
					a = Qe({}),
					l = (t, n, i) => {
						t.stopPropagation();
						const s =
							n.order === i
								? null
								: i ||
								  (({ order: e, sortOrders: t }) => {
										if ("" === e) return t[0];
										const n = t.indexOf(e || null);
										return t[n > t.length - 2 ? 0 : n + 1];
								  })(n);
						let o = t.target;
						for (; o && "TH" !== o.tagName; ) o = o.parentNode;
						if (o && "TH" === o.tagName && WR(o, "noclick")) return void YR(o, "noclick");
						if (!n.sortable) return;
						const a = e.store.states;
						let l,
							u = a.sortProp.value;
						const c = a.sortingColumn.value;
						(c !== n || (c === n && null === c.order)) && (c && (c.order = null), (a.sortingColumn.value = n), (u = n.property)), (l = n.order = s || null), (a.sortProp.value = u), (a.sortOrder.value = l), null == r || r.store.commit("changeSortCondition");
					};
				return {
					handleHeaderClick: (e, t) => {
						!t.filters && t.sortable ? l(e, t, !1) : t.filterable && !t.sortable && i(e), null == r || r.emit("header-click", t, e);
					},
					handleHeaderContextMenu: (e, t) => {
						null == r || r.emit("header-contextmenu", t, e);
					},
					handleMouseDown: (i, l) => {
						if (GI && !(l.children && l.children.length > 0) && s.value && e.border) {
							o.value = !0;
							const u = r;
							t("set-drag-visible", !0);
							const c = (null == u ? void 0 : u.vnode.el).getBoundingClientRect().left,
								h = n.vnode.el.querySelector(`th.${l.id}`),
								d = h.getBoundingClientRect(),
								p = d.left - c + 30;
							GR(h, "noclick"), (a.value = { startMouseLeft: i.clientX, startLeft: d.right - c, startColumnLeft: d.left - c, tableLeft: c });
							const f = null == u ? void 0 : u.refs.resizeProxy;
							(f.style.left = `${a.value.startLeft}px`),
								(document.onselectstart = function () {
									return !1;
								}),
								(document.ondragstart = function () {
									return !1;
								});
							const m = (e) => {
									const t = e.clientX - a.value.startMouseLeft,
										n = a.value.startLeft + t;
									f.style.left = `${Math.max(p, n)}px`;
								},
								v = () => {
									if (o.value) {
										const { startColumnLeft: n, startLeft: r } = a.value,
											c = Number.parseInt(f.style.left, 10) - n;
										(l.width = l.realWidth = c),
											null == u || u.emit("header-dragend", l.width, r - n, l, i),
											requestAnimationFrame(() => {
												e.store.scheduleLayout(!1, !0);
											}),
											(document.body.style.cursor = ""),
											(o.value = !1),
											(s.value = null),
											(a.value = {}),
											t("set-drag-visible", !1);
									}
									document.removeEventListener("mousemove", m),
										document.removeEventListener("mouseup", v),
										(document.onselectstart = null),
										(document.ondragstart = null),
										setTimeout(() => {
											YR(h, "noclick");
										}, 0);
								};
							document.addEventListener("mousemove", m), document.addEventListener("mouseup", v);
						}
					},
					handleMouseMove: (t, n) => {
						if (n.children && n.children.length > 0) return;
						let r = t.target;
						for (; r && "TH" !== r.tagName; ) r = r.parentNode;
						if (n && n.resizable && !o.value && e.border) {
							const e = r.getBoundingClientRect(),
								i = document.body.style;
							e.width > 12 && e.right - t.pageX < 8 ? ((i.cursor = "col-resize"), WR(r, "is-sortable") && (r.style.cursor = "col-resize"), (s.value = n)) : o.value || ((i.cursor = ""), WR(r, "is-sortable") && (r.style.cursor = "pointer"), (s.value = null));
						}
					},
					handleMouseOut: () => {
						GI && (document.body.style.cursor = "");
					},
					handleSortClick: l,
					handleFilterClick: i
				};
			})(e, t),
			{
				getHeaderRowStyle: m,
				getHeaderRowClass: v,
				getHeaderCellStyle: g,
				getHeaderCellClass: y
			} = (function (e) {
				const t = vn(aQ),
					n = BD("table");
				return {
					getHeaderRowStyle: (e) => {
						const n = null == t ? void 0 : t.props.headerRowStyle;
						return "function" == typeof n ? n.call(null, { rowIndex: e }) : n;
					},
					getHeaderRowClass: (e) => {
						const n = [],
							r = null == t ? void 0 : t.props.headerRowClassName;
						return "string" == typeof r ? n.push(r) : "function" == typeof r && n.push(r.call(null, { rowIndex: e })), n.join(" ");
					},
					getHeaderCellStyle: (n, r, i, s) => {
						var o;
						let a = null != (o = null == t ? void 0 : t.props.headerCellStyle) ? o : {};
						"function" == typeof a && (a = a.call(null, { rowIndex: n, columnIndex: r, row: i, column: s }));
						const l = s.isSubColumn ? null : zJ(r, s.fixed, e.store, i);
						return $J(l, "left"), $J(l, "right"), Object.assign({}, a, l);
					},
					getHeaderCellClass: (r, i, s, o) => {
						const a = o.isSubColumn ? [] : VJ(n.b(), i, o.fixed, e.store, s),
							l = [o.id, o.order, o.headerAlign, o.className, o.labelClassName, ...a];
						o.children || l.push("is-leaf"), o.sortable && l.push("is-sortable");
						const u = null == t ? void 0 : t.props.headerCellClassName;
						return "string" == typeof u ? l.push(u) : "function" == typeof u && l.push(u.call(null, { rowIndex: r, columnIndex: i, row: s, column: o })), l.push(n.e("cell")), l.filter((e) => Boolean(e)).join(" ");
					}
				};
			})(e),
			{ isGroup: b, toggleAllSelection: x, columnRows: _ } = uQ(e);
		return (
			(n.state = { onColumnsChange: o, onScrollableChange: a }),
			(n.filterPanels = s),
			{
				ns: i,
				filterPanels: s,
				onColumnsChange: o,
				onScrollableChange: a,
				columnRows: _,
				getHeaderRowClass: v,
				getHeaderRowStyle: m,
				getHeaderCellClass: y,
				getHeaderCellStyle: g,
				handleHeaderClick: l,
				handleHeaderContextMenu: u,
				handleMouseDown: c,
				handleMouseMove: h,
				handleMouseOut: d,
				handleSortClick: p,
				handleFilterClick: f,
				isGroup: b,
				toggleAllSelection: x
			}
		);
	},
	render() {
		const { ns: e, isGroup: t, columnRows: n, getHeaderCellStyle: r, getHeaderCellClass: i, getHeaderRowClass: s, getHeaderRowStyle: o, handleHeaderClick: a, handleHeaderContextMenu: l, handleMouseDown: u, handleMouseMove: c, handleSortClick: h, handleMouseOut: d, store: p, $parent: f } = this;
		let m = 1;
		return xs(
			"thead",
			{ class: { [e.is("group")]: t } },
			n.map((e, t) =>
				xs(
					"tr",
					{ class: s(t), key: t, style: o(t) },
					e.map(
						(n, s) => (
							n.rowSpan > m && (m = n.rowSpan),
							xs("th", { class: i(t, s, e, n), colspan: n.colSpan, key: `${n.id}-thead`, rowspan: n.rowSpan, style: r(t, s, e, n), onClick: (e) => a(e, n), onContextmenu: (e) => l(e, n), onMousedown: (e) => u(e, n), onMousemove: (e) => c(e, n), onMouseout: d }, [
								xs("div", { class: ["cell", n.filteredValue && n.filteredValue.length > 0 ? "highlight" : "", n.labelClassName] }, [
									n.renderHeader ? n.renderHeader({ column: n, $index: s, store: p, _self: f }) : n.label,
									n.sortable && xs("span", { onClick: (e) => h(e, n), class: "caret-wrapper" }, [xs("i", { onClick: (e) => h(e, n, "ascending"), class: "sort-caret ascending" }), xs("i", { onClick: (e) => h(e, n, "descending"), class: "sort-caret descending" })]),
									n.filterable &&
										xs(sQ, {
											store: p,
											placement: n.filterPlacement || "bottom-start",
											column: n,
											upDataColumn: (e, t) => {
												n[e] = t;
											}
										})
								])
							])
						)
					)
				)
			)
		);
	}
});
function hQ(e) {
	const t = vn(aQ),
		n = Qe(""),
		r = Qe(xs("div")),
		i = (n, r, i) => {
			var s;
			const o = t,
				a = TJ(n);
			let l;
			const u = null == (s = null == o ? void 0 : o.vnode.el) ? void 0 : s.dataset.prefix;
			a && ((l = IJ({ columns: e.store.states.columns.value }, a, u)), l && (null == o || o.emit(`cell-${i}`, r, l, a, n))), null == o || o.emit(`row-${i}`, r, l, n);
		};
	return {
		handleDoubleClick: (e, t) => {
			i(e, t, "dblclick");
		},
		handleClick: (t, n) => {
			e.store.commit("setCurrentRow", n), i(t, n, "click");
		},
		handleContextMenu: (e, t) => {
			i(e, t, "contextmenu");
		},
		handleMouseEnter: QT((t) => {
			e.store.commit("setHoverRow", t);
		}, 30),
		handleMouseLeave: QT(() => {
			e.store.commit("setHoverRow", null);
		}, 30),
		handleCellMouseEnter: (n, r) => {
			var i;
			const s = t,
				o = TJ(n),
				a = null == (i = null == s ? void 0 : s.vnode.el) ? void 0 : i.dataset.prefix;
			if (o) {
				const t = IJ({ columns: e.store.states.columns.value }, o, a),
					i = (s.hoverState = { cell: o, column: t, row: r });
				null == s || s.emit("cell-mouse-enter", i.row, i.column, i.cell, n);
			}
			const l = n.target.querySelector(".cell");
			if (!WR(l, `${a}-tooltip`) || !l.childNodes.length) return;
			const c = document.createRange();
			c.setStart(l, 0), c.setEnd(l, l.childNodes.length);
			(c.getBoundingClientRect().width + ((Number.parseInt(XR(l, "paddingLeft"), 10) || 0) + (Number.parseInt(XR(l, "paddingRight"), 10) || 0)) > l.offsetWidth || l.scrollWidth > l.offsetWidth) &&
				(function (e, t, n, r, i) {
					const { nextZIndex: s } = HD(),
						o = null == e ? void 0 : e.dataset.prefix,
						a = null == e ? void 0 : e.querySelector(`.${o}-scrollbar__wrap`);
					function l() {
						c && c.update();
					}
					FJ = () => {
						try {
							c && c.destroy(), h && (null == e || e.removeChild(h)), LI(t, "mouseenter", l), LI(t, "mouseleave", FJ), a && LI(a, "scroll", FJ), (FJ = void 0);
						} catch (Kj) {}
					};
					let c = null;
					const h = (function () {
							const t = "light" === i,
								r = document.createElement("div");
							return (r.className = `${o}-popper ${t ? "is-light" : "is-dark"}`), (n = EJ(n)), (r.innerHTML = n), (r.style.zIndex = String(s())), null == e || e.appendChild(r), r;
						})(),
						d = (function () {
							const e = document.createElement("div");
							return (e.className = `${o}-popper__arrow`), e;
						})();
					h.appendChild(d),
						(c = CH(
							t,
							h,
							u(
								{
									strategy: "absolute",
									modifiers: [
										{ name: "offset", options: { offset: [0, 8] } },
										{ name: "arrow", options: { element: d, padding: 10 } }
									]
								},
								r
							)
						)),
						RI(t, "mouseenter", l),
						RI(t, "mouseleave", FJ),
						a && RI(a, "scroll", FJ);
				})(null == t ? void 0 : t.refs.tableWrapper, o, o.innerText || o.textContent, { placement: "top", strategy: "fixed" }, r.tooltipEffect);
		},
		handleCellMouseLeave: (e) => {
			if (!TJ(e)) return;
			const n = null == t ? void 0 : t.hoverState;
			null == t || t.emit("cell-mouse-leave", null == n ? void 0 : n.row, null == n ? void 0 : n.column, null == n ? void 0 : n.cell, e);
		},
		tooltipContent: n,
		tooltipTrigger: r
	};
}
function dQ(e) {
	const t = vn(aQ),
		{ handleDoubleClick: n, handleClick: r, handleContextMenu: i, handleMouseEnter: s, handleMouseLeave: o, handleCellMouseEnter: a, handleCellMouseLeave: l, tooltipContent: h, tooltipTrigger: d } = hQ(e),
		{
			getRowStyle: p,
			getRowClass: f,
			getCellStyle: m,
			getCellClass: v,
			getSpan: g,
			getColspanRealWidth: y
		} = (function (e) {
			const t = vn(aQ),
				n = BD("table");
			return {
				getRowStyle: (e, n) => {
					const r = null == t ? void 0 : t.props.rowStyle;
					return "function" == typeof r ? r.call(null, { row: e, rowIndex: n }) : r || null;
				},
				getRowClass: (r, i) => {
					const s = [n.e("row")];
					(null == t ? void 0 : t.props.highlightCurrentRow) && r === e.store.states.currentRow.value && s.push("current-row"), e.stripe && i % 2 == 1 && s.push(n.em("row", "striped"));
					const o = null == t ? void 0 : t.props.rowClassName;
					return "string" == typeof o ? s.push(o) : "function" == typeof o && s.push(o.call(null, { row: r, rowIndex: i })), s;
				},
				getCellStyle: (n, r, i, s) => {
					const o = null == t ? void 0 : t.props.cellStyle;
					let a = null != o ? o : {};
					"function" == typeof o && (a = o.call(null, { rowIndex: n, columnIndex: r, row: i, column: s }));
					const l = s.isSubColumn ? null : zJ(r, null == e ? void 0 : e.fixed, e.store);
					return $J(l, "left"), $J(l, "right"), Object.assign({}, a, l);
				},
				getCellClass: (r, i, s, o) => {
					const a = o.isSubColumn ? [] : VJ(n.b(), i, null == e ? void 0 : e.fixed, e.store),
						l = [o.id, o.align, o.className, ...a],
						u = null == t ? void 0 : t.props.cellClassName;
					return "string" == typeof u ? l.push(u) : "function" == typeof u && l.push(u.call(null, { rowIndex: r, columnIndex: i, row: s, column: o })), l.push(n.e("cell")), l.filter((e) => Boolean(e)).join(" ");
				},
				getSpan: (e, n, r, i) => {
					let s = 1,
						o = 1;
					const a = null == t ? void 0 : t.props.spanMethod;
					if ("function" == typeof a) {
						const t = a({ row: e, column: n, rowIndex: r, columnIndex: i });
						Array.isArray(t) ? ((s = t[0]), (o = t[1])) : "object" == typeof t && ((s = t.rowspan), (o = t.colspan));
					}
					return { rowspan: s, colspan: o };
				},
				getColspanRealWidth: (e, t, n) => {
					if (t < 1) return e[n].realWidth;
					const r = e.map(({ realWidth: e, width: t }) => e || t).slice(n, n + t);
					return Number(r.reduce((e, t) => Number(e) + Number(t), -1));
				}
			};
		})(e),
		b = ht(() => e.store.states.columns.value.findIndex(({ type: e }) => "default" === e)),
		x = (e, n) => {
			const r = t.props.rowKey;
			return r ? RJ(e, r) : n;
		},
		_ = (h, d, _, C = !1) => {
			const { tooltipEffect: S, store: E } = e,
				{ indent: T, columns: k } = E.states,
				A = f(h, d);
			let M = !0;
			_ && (A.push(`el-table__row--level-${_.level}`), (M = _.display));
			return xs(
				"tr",
				{ style: [M ? null : { display: "none" }, p(h, d)], class: A, key: x(h, d), onDblclick: (e) => n(e, h), onClick: (e) => r(e, h), onContextmenu: (e) => i(e, h), onMouseenter: () => s(d), onMouseleave: o },
				k.value.map((n, r) => {
					const { rowspan: i, colspan: s } = g(h, n, d, r);
					if (!i || !s) return null;
					const o = u({}, n);
					o.realWidth = y(k.value, s, r);
					const p = { store: e.store, _self: e.context || t, column: o, row: h, $index: d, cellIndex: r, expanded: C };
					r === b.value &&
						_ &&
						((p.treeNode = { indent: _.level * T.value, level: _.level }), "boolean" == typeof _.expanded && ((p.treeNode.expanded = _.expanded), "loading" in _ && (p.treeNode.loading = _.loading), "noLazyChildren" in _ && (p.treeNode.noLazyChildren = _.noLazyChildren)));
					const f = `${d},${r}`,
						x = o.columnKey || o.rawColumnKey || "",
						E = w(r, n, p);
					return xs("td", { style: m(d, r, h, n), class: v(d, r, h, n), key: `${x}${f}`, rowspan: i, colspan: s, onMouseenter: (e) => a(e, c(u({}, h), { tooltipEffect: S })), onMouseleave: l }, [E]);
				})
			);
		},
		w = (e, t, n) => t.renderCell(n);
	return {
		wrappedRowRender: (n, r) => {
			const i = e.store,
				{ isRowExpanded: s, assertRowKey: o } = i,
				{ treeData: a, lazyTreeNodeMap: l, childrenColumnName: c, rowKey: h } = i.states,
				d = i.states.columns.value;
			if (d.some(({ type: e }) => "expand" === e)) {
				const e = s(n),
					o = _(n, r, void 0, e),
					a = t.renderExpanded;
				return e ? (a ? [[o, xs("tr", { key: `expanded-row__${o.key}` }, [xs("td", { colspan: d.length, class: "el-table__cell el-table__expanded-cell" }, [a({ row: n, $index: r, store: i, expanded: e })])])]] : (console.error("[Element Error]renderExpanded is required."), o)) : [[o]];
			}
			if (Object.keys(a.value).length) {
				o();
				const e = RJ(n, h.value);
				let t = a.value[e],
					i = null;
				t && ((i = { expanded: t.expanded, level: t.level, display: !0 }), "boolean" == typeof t.lazy && ("boolean" == typeof t.loaded && t.loaded && (i.noLazyChildren = !(t.children && t.children.length)), (i.loading = t.loading)));
				const s = [_(n, r, i)];
				if (t) {
					let i = 0;
					const o = (e, n) => {
						e &&
							e.length &&
							n &&
							e.forEach((e) => {
								const d = { display: n.display && n.expanded, level: n.level + 1, expanded: !1, noLazyChildren: !1, loading: !1 },
									p = RJ(e, h.value);
								if (null == p) throw new Error("For nested data item, row-key is required.");
								if (
									((t = u({}, a.value[p])),
									t &&
										((d.expanded = t.expanded),
										(t.level = t.level || d.level),
										(t.display = !(!t.expanded || !d.display)),
										"boolean" == typeof t.lazy && ("boolean" == typeof t.loaded && t.loaded && (d.noLazyChildren = !(t.children && t.children.length)), (d.loading = t.loading))),
									i++,
									s.push(_(e, r + i, d)),
									t)
								) {
									const n = l.value[p] || e[c.value];
									o(n, t);
								}
							});
					};
					t.display = !0;
					const d = l.value[e] || n[c.value];
					o(d, t);
				}
				return s;
			}
			return _(n, r, void 0);
		},
		tooltipContent: h,
		tooltipTrigger: d
	};
}
var pQ = Tn({
	name: "ElTableBody",
	props: { store: { required: !0, type: Object }, stripe: Boolean, tooltipEffect: String, context: { default: () => ({}), type: Object }, rowClassName: [String, Function], rowStyle: [Object, Function], fixed: { type: String, default: "" }, highlight: Boolean },
	setup(e) {
		const t = Si(),
			n = vn(aQ),
			r = BD("table"),
			{ wrappedRowRender: i, tooltipContent: s, tooltipTrigger: o } = dQ(e),
			{ onColumnsChange: a, onScrollableChange: l } = oQ(n);
		return (
			ds(e.store.states.hoverRow, (n, i) => {
				if (!e.store.states.isComplex.value || !GI) return;
				let s = window.requestAnimationFrame;
				s || (s = (e) => window.setTimeout(e, 16)),
					s(() => {
						var e;
						const s = null == (e = null == t ? void 0 : t.vnode.el) ? void 0 : e.querySelectorAll(`.${r.e("row")}`),
							o = s[i],
							a = s[n];
						o && YR(o, "hover-row"), a && GR(a, "hover-row");
					});
			}),
			jn(() => {
				var e;
				null == (e = FJ) || e();
			}),
			zn(() => {
				var e;
				null == (e = FJ) || e();
			}),
			{ ns: r, onColumnsChange: a, onScrollableChange: l, wrappedRowRender: i, tooltipContent: s, tooltipTrigger: o }
		);
	},
	render() {
		const { wrappedRowRender: e, store: t } = this;
		return xs("tbody", {}, [(t.states.data.value || []).reduce((t, n) => t.concat(e(n, t.length)), [])]);
	}
});
function fQ(e) {
	const t = "auto" === e.tableLayout;
	let n = e.columns || [];
	t && n.every((e) => void 0 === e.width) && (n = []);
	return xs(
		"colgroup",
		{},
		n.map((n) =>
			xs(
				"col",
				((n) => {
					const r = { key: `${e.tableLayout}_${n.id}`, style: {}, name: void 0 };
					return t ? (r.style = { width: `${n.width}px` }) : (r.name = n.id), r;
				})(n)
			)
		)
	);
}
function mQ(e) {
	const { columns: t } = (function () {
			const e = vn(aQ),
				t = null == e ? void 0 : e.store;
			return {
				leftFixedLeafCount: ht(() => t.states.fixedLeafColumnsLength.value),
				rightFixedLeafCount: ht(() => t.states.rightFixedColumns.value.length),
				columnsCount: ht(() => t.states.columns.value.length),
				leftFixedCount: ht(() => t.states.fixedColumns.value.length),
				rightFixedCount: ht(() => t.states.rightFixedColumns.value.length),
				columns: t.states.columns
			};
		})(),
		n = BD("table");
	return {
		getCellClasses: (t, r) => {
			const i = t[r],
				s = [n.e("cell"), i.id, i.align, i.labelClassName, ...VJ(n.b(), r, i.fixed, e.store)];
			return i.className && s.push(i.className), i.children || s.push(n.is("leaf")), s;
		},
		getCellStyles: (t, n) => {
			const r = zJ(n, t.fixed, e.store);
			return $J(r, "left"), $J(r, "right"), r;
		},
		columns: t
	};
}
fQ.props = ["columns", "tableLayout"];
var vQ = Tn({
	name: "ElTableFooter",
	props: { fixed: { type: String, default: "" }, store: { required: !0, type: Object }, summaryMethod: Function, sumText: String, border: Boolean, defaultSort: { type: Object, default: () => ({ prop: "", order: "" }) } },
	setup(e) {
		const { getCellClasses: t, getCellStyles: n, columns: r } = mQ(e);
		return { ns: BD("table"), getCellClasses: t, getCellStyles: n, columns: r };
	},
	render() {
		const { columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: r, sumText: i, ns: s } = this,
			o = this.store.states.data.value;
		let a = [];
		return (
			r
				? (a = r({ columns: e, data: o }))
				: e.forEach((e, t) => {
						if (0 === t) return void (a[t] = i);
						const n = o.map((t) => Number(t[e.property])),
							r = [];
						let s = !0;
						n.forEach((e) => {
							if (!Number.isNaN(+e)) {
								s = !1;
								const t = `${e}`.split(".")[1];
								r.push(t ? t.length : 0);
							}
						});
						const l = Math.max.apply(null, r);
						a[t] = s
							? ""
							: n.reduce((e, t) => {
									const n = Number(t);
									return Number.isNaN(+n) ? e : Number.parseFloat((e + t).toFixed(Math.min(l, 20)));
							  }, 0);
				  }),
			xs("table", { class: s.e("footer"), cellspacing: "0", cellpadding: "0", border: "0" }, [
				fQ({ columns: e }),
				xs("tbody", [xs("tr", {}, [...e.map((r, i) => xs("td", { key: i, colspan: r.colSpan, rowspan: r.rowSpan, class: n(e, i), style: t(r, i) }, [xs("div", { class: ["cell", r.labelClassName] }, [a[i]])]))])])
			])
		);
	}
});
function gQ(e, t, n, r) {
	const i = Qe(!1),
		s = Qe(null),
		o = Qe(!1),
		a = Qe({ width: null, height: null }),
		l = Qe(!1),
		u = Qe();
	cs(() => {
		t.setHeight(e.height);
	}),
		cs(() => {
			t.setMaxHeight(e.maxHeight);
		}),
		ds(
			() => [e.currentRowKey, n.states.rowKey],
			([e, t]) => {
				it(t) && n.setCurrentRowKey(`${e}`);
			},
			{ immediate: !0 }
		),
		ds(
			() => e.data,
			(e) => {
				r.store.commit("setData", e);
			},
			{ immediate: !0, deep: !0 }
		),
		cs(() => {
			e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
		});
	const c = ht(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0),
		h = ht(() => ({ width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : "" })),
		d = () => {
			c.value && t.updateElsHeight(), t.updateColumnsWidth(), requestAnimationFrame(f);
		};
	Vn(async () => {
		await ns(), n.updateColumns(), m(), requestAnimationFrame(d);
		const t = r.vnode.el;
		e.flexible && t && t.parentElement && (t.parentElement.style.minWidth = "0"),
			(a.value = { width: (u.value = t.offsetWidth), height: t.offsetHeight }),
			n.states.columns.value.forEach((e) => {
				e.filteredValue && e.filteredValue.length && r.store.commit("filterChange", { column: e, values: e.filteredValue, silent: !0 });
			}),
			(r.$ready = !0);
	});
	const p = (e) => {
			const { tableWrapper: n } = r.refs;
			((e, n) => {
				if (!e) return;
				const r = Array.from(e.classList).filter((e) => !e.startsWith("is-scrolling-"));
				r.push(t.scrollX.value ? n : "is-scrolling-none"), (e.className = r.join(" "));
			})(n, e);
		},
		f = function () {
			if (!r.refs.scrollBarRef) return;
			if (!t.scrollX.value) {
				const e = "is-scrolling-none";
				return void (
					((e) => {
						const { tableWrapper: t } = r.refs;
						return !(!t || !t.classList.contains(e));
					})(e) || p(e)
				);
			}
			const e = r.refs.scrollBarRef.wrap$;
			if (!e) return;
			const { scrollLeft: n, offsetWidth: i, scrollWidth: s } = e,
				{ headerWrapper: o, footerWrapper: a } = r.refs;
			o && (o.scrollLeft = n), a && (a.scrollLeft = n);
			p(n >= s - i - 1 ? "is-scrolling-right" : 0 === n ? "is-scrolling-left" : "is-scrolling-middle");
		},
		m = () => {
			r.refs.scrollBarRef && (r.refs.scrollBarRef.wrap$ && iR(r.refs.scrollBarRef.wrap$, "scroll", f, { passive: !0 }), e.fit ? pR(r.vnode.el, v) : iR(window, "resize", v));
		},
		v = () => {
			if (!r.$ready) return;
			let t = !1;
			const n = r.vnode.el,
				{ width: i, height: s } = a.value,
				o = (u.value = n.offsetWidth);
			i !== o && (t = !0);
			const l = n.offsetHeight;
			(e.height || c.value) && s !== l && (t = !0), t && ((a.value = { width: o, height: l }), d());
		},
		g = hD(),
		y = ht(() => {
			const { bodyWidth: e, scrollY: n, gutterWidth: r } = t;
			return e.value ? e.value - (n.value ? r : 0) + "px" : "";
		}),
		b = ht(() => (e.maxHeight ? "fixed" : e.tableLayout));
	function x(t, n, r) {
		const i = NJ(t),
			s = e.showHeader ? r : 0;
		if (null !== i) return SR(i) ? `calc(${i} - ${n}px - ${s}px)` : i - n - s;
	}
	const _ = ht(() => {
		const n = t.headerHeight.value || 0,
			r = t.bodyHeight.value,
			i = t.footerHeight.value || 0;
		return e.height ? r || void 0 : e.maxHeight ? x(e.maxHeight, i, n) : void 0;
	});
	return {
		isHidden: i,
		renderExpanded: s,
		setDragVisible: (e) => {
			o.value = e;
		},
		isGroup: l,
		handleMouseLeave: () => {
			r.store.commit("setHoverRow", null), r.hoverState && (r.hoverState = null);
		},
		handleHeaderFooterMousewheel: (e, t) => {
			const { pixelX: n, pixelY: i } = t;
			Math.abs(n) >= Math.abs(i) && (r.refs.bodyWrapper.scrollLeft += t.pixelX / 5);
		},
		tableSize: g,
		bodyHeight: ht(() => {
			const n = t.headerHeight.value || 0,
				r = t.bodyHeight.value,
				i = t.footerHeight.value || 0;
			if (e.height) return { height: r ? `${r}px` : "" };
			if (e.maxHeight) {
				const t = x(e.maxHeight, i, n);
				if (null !== t) return { "max-height": `${t}${XI(t) ? "px" : ""}` };
			}
			return {};
		}),
		height: _,
		emptyBlockStyle: ht(() => {
			if (e.data && e.data.length) return null;
			let n = "100%";
			return t.appendHeight.value && (n = `calc(100% - ${t.appendHeight.value}px)`), { width: u.value ? `${u.value}px` : "", height: n };
		}),
		handleFixedMousewheel: (e, t) => {
			const n = r.refs.bodyWrapper;
			if (Math.abs(t.spinY) > 0) {
				const r = n.scrollTop;
				t.pixelY < 0 && 0 !== r && e.preventDefault(), t.pixelY > 0 && n.scrollHeight - n.clientHeight > r && e.preventDefault(), (n.scrollTop += Math.ceil(t.pixelY / 5));
			} else n.scrollLeft += Math.ceil(t.pixelX / 5);
		},
		fixedHeight: ht(() =>
			e.maxHeight ? (e.showSummary ? { bottom: 0 } : { bottom: t.scrollX.value && e.data.length ? `${t.gutterWidth}px` : "" }) : e.showSummary ? { height: t.tableHeight.value ? `${t.tableHeight.value}px` : "" } : { height: t.viewportHeight.value ? `${t.viewportHeight.value}px` : "" }
		),
		fixedBodyHeight: ht(() => {
			if (e.height) return { height: t.fixedBodyHeight.value ? `${t.fixedBodyHeight.value}px` : "" };
			if (e.maxHeight) {
				let n = NJ(e.maxHeight);
				if ("number" == typeof n) return (n = t.scrollX.value ? n - t.gutterWidth : n), e.showHeader && (n -= t.headerHeight.value), (n -= t.footerHeight.value), { "max-height": `${n}px` };
			}
			return {};
		}),
		resizeProxyVisible: o,
		bodyWidth: y,
		resizeState: a,
		doLayout: d,
		tableBodyStyles: h,
		tableLayout: b,
		scrollbarViewStyle: { display: "block", verticalAlign: "middle" }
	};
}
var yQ = {
	data: { type: Array, default: () => [] },
	size: String,
	width: [String, Number],
	height: [String, Number],
	maxHeight: [String, Number],
	fit: { type: Boolean, default: !0 },
	stripe: Boolean,
	border: Boolean,
	rowKey: [String, Function],
	showHeader: { type: Boolean, default: !0 },
	showSummary: Boolean,
	sumText: String,
	summaryMethod: Function,
	rowClassName: [String, Function],
	rowStyle: [Object, Function],
	cellClassName: [String, Function],
	cellStyle: [Object, Function],
	headerRowClassName: [String, Function],
	headerRowStyle: [Object, Function],
	headerCellClassName: [String, Function],
	headerCellStyle: [Object, Function],
	highlightCurrentRow: Boolean,
	currentRowKey: [String, Number],
	emptyText: String,
	expandRowKeys: Array,
	defaultExpandAll: Boolean,
	defaultSort: Object,
	tooltipEffect: String,
	spanMethod: Function,
	selectOnIndeterminate: { type: Boolean, default: !0 },
	indent: { type: Number, default: 16 },
	treeProps: { type: Object, default: () => ({ hasChildren: "hasChildren", children: "children" }) },
	lazy: Boolean,
	load: Function,
	style: { type: Object, default: () => ({}) },
	className: { type: String, default: "" },
	tableLayout: { type: String, default: "fixed" },
	scrollbarAlwaysOn: { type: Boolean, default: !1 },
	flexible: Boolean
};
let bQ = 1;
const xQ = Tn({
		name: "ElTable",
		directives: { Mousewheel: QU },
		components: { TableHeader: cQ, TableBody: pQ, TableFooter: vQ, ElScrollbar: ZB, hColgroup: fQ },
		props: yQ,
		emits: [
			"select",
			"select-all",
			"selection-change",
			"cell-mouse-enter",
			"cell-mouse-leave",
			"cell-contextmenu",
			"cell-click",
			"cell-dblclick",
			"row-click",
			"row-contextmenu",
			"row-dblclick",
			"header-click",
			"header-contextmenu",
			"sort-change",
			"filter-change",
			"current-change",
			"header-dragend",
			"expand-change"
		],
		setup(e) {
			const { t: t } = CD(),
				n = BD("table"),
				r = Si();
			mn(aQ, r);
			const i = qJ(r, e);
			r.store = i;
			const s = new QJ({ store: r.store, table: r, fit: e.fit, showHeader: e.showHeader });
			r.layout = s;
			const o = ht(() => 0 === (i.states.data.value || []).length),
				{
					setCurrentRow: a,
					getSelectionRows: l,
					toggleRowSelection: u,
					clearSelection: c,
					clearFilter: h,
					toggleAllSelection: d,
					toggleRowExpansion: p,
					clearSort: f,
					sort: m
				} = (function (e) {
					return {
						setCurrentRow: (t) => {
							e.commit("setCurrentRow", t);
						},
						getSelectionRows: () => e.getSelectionRows(),
						toggleRowSelection: (t, n) => {
							e.toggleRowSelection(t, n, !1), e.updateAllSelected();
						},
						clearSelection: () => {
							e.clearSelection();
						},
						clearFilter: (t) => {
							e.clearFilter(t);
						},
						toggleAllSelection: () => {
							e.commit("toggleAllSelection");
						},
						toggleRowExpansion: (t, n) => {
							e.toggleRowExpansionAdapter(t, n);
						},
						clearSort: () => {
							e.clearSort();
						},
						sort: (t, n) => {
							e.commit("sort", { prop: t, order: n });
						}
					};
				})(i),
				{
					isHidden: v,
					renderExpanded: g,
					setDragVisible: y,
					isGroup: b,
					handleMouseLeave: x,
					handleHeaderFooterMousewheel: _,
					tableSize: w,
					bodyHeight: C,
					height: S,
					emptyBlockStyle: E,
					handleFixedMousewheel: T,
					fixedHeight: k,
					fixedBodyHeight: A,
					resizeProxyVisible: M,
					bodyWidth: I,
					resizeState: R,
					doLayout: L,
					tableBodyStyles: O,
					tableLayout: P,
					scrollbarViewStyle: N
				} = gQ(e, s, i, r),
				{
					scrollBarRef: D,
					scrollTo: B,
					setScrollLeft: F,
					setScrollTop: H
				} = (() => {
					const e = Qe(),
						t = (t, n) => {
							const r = e.value;
							r && XI(n) && ["Top", "Left"].includes(t) && r[`setScroll${t}`](n);
						};
					return {
						scrollBarRef: e,
						scrollTo: (t, n) => {
							const r = e.value;
							r && r.scrollTo(t, n);
						},
						setScrollTop: (e) => t("Top", e),
						setScrollLeft: (e) => t("Left", e)
					};
				})(),
				V = QT(L, 50),
				U = "el-table_" + bQ++;
			(r.tableId = U), (r.state = { isGroup: b, resizeState: R, doLayout: L, debouncedUpdateLayout: V });
			const z = ht(() => e.sumText || t("el.table.sumText")),
				$ = ht(() => e.emptyText || t("el.table.emptyText"));
			return {
				ns: n,
				layout: s,
				store: i,
				handleHeaderFooterMousewheel: _,
				handleMouseLeave: x,
				tableId: U,
				tableSize: w,
				isHidden: v,
				isEmpty: o,
				renderExpanded: g,
				resizeProxyVisible: M,
				resizeState: R,
				isGroup: b,
				bodyWidth: I,
				bodyHeight: C,
				height: S,
				tableBodyStyles: O,
				emptyBlockStyle: E,
				debouncedUpdateLayout: V,
				handleFixedMousewheel: T,
				fixedHeight: k,
				fixedBodyHeight: A,
				setCurrentRow: a,
				getSelectionRows: l,
				toggleRowSelection: u,
				clearSelection: c,
				clearFilter: h,
				toggleAllSelection: d,
				toggleRowExpansion: p,
				clearSort: f,
				doLayout: L,
				sort: m,
				t: t,
				setDragVisible: y,
				context: r,
				computedSumText: z,
				computedEmptyText: $,
				tableLayout: P,
				scrollbarViewStyle: N,
				scrollBarRef: D,
				scrollTo: B,
				setScrollLeft: F,
				setScrollTop: H
			};
		}
	}),
	_Q = ["data-prefix"],
	wQ = { ref: "hiddenColumns", class: "hidden-columns" };
var CQ = IB(xQ, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("hColgroup"),
				a = Or("table-header"),
				l = Or("table-body"),
				u = Or("el-scrollbar"),
				c = Or("table-footer"),
				h = Dr("mousewheel");
			return (
				Wr(),
				Kr(
					"div",
					{
						ref: "tableWrapper",
						class: gt([
							{
								[e.ns.m("fit")]: e.fit,
								[e.ns.m("striped")]: e.stripe,
								[e.ns.m("border")]: e.border || e.isGroup,
								[e.ns.m("hidden")]: e.isHidden,
								[e.ns.m("group")]: e.isGroup,
								[e.ns.m("fluid-height")]: e.maxHeight,
								[e.ns.m("scrollable-x")]: e.layout.scrollX.value,
								[e.ns.m("scrollable-y")]: e.layout.scrollY.value,
								[e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
								[e.ns.m("enable-row-transition")]: 0 !== (e.store.states.data.value || []).length && (e.store.states.data.value || []).length < 100,
								"has-footer": e.showSummary
							},
							e.ns.m(e.tableSize),
							e.className,
							e.ns.b(),
							e.ns.m(`layout-${e.tableLayout}`)
						]),
						style: pt(e.style),
						"data-prefix": e.ns.namespace.value,
						onMouseleave: t[0] || (t[0] = (t) => e.handleMouseLeave())
					},
					[
						ni(
							"div",
							{ class: gt(e.ns.e("inner-wrapper")) },
							[
								ni("div", wQ, [mi(e.$slots, "default")], 512),
								e.showHeader && "fixed" === e.tableLayout
									? yr(
											(Wr(),
											Kr(
												"div",
												{ key: 0, ref: "headerWrapper", class: gt(e.ns.e("header-wrapper")) },
												[
													ni(
														"table",
														{ ref: "tableHeader", class: gt(e.ns.e("header")), style: pt(e.tableBodyStyles), border: "0", cellpadding: "0", cellspacing: "0" },
														[
															ri(o, { columns: e.store.states.columns.value, "table-layout": e.tableLayout }, null, 8, ["columns", "table-layout"]),
															ri(a, { ref: "tableHeaderRef", border: e.border, "default-sort": e.defaultSort, store: e.store, onSetDragVisible: e.setDragVisible }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
														],
														6
													)
												],
												2
											)),
											[[h, e.handleHeaderFooterMousewheel]]
									  )
									: ai("v-if", !0),
								ni(
									"div",
									{ ref: "bodyWrapper", style: pt(e.bodyHeight), class: gt(e.ns.e("body-wrapper")) },
									[
										ri(
											u,
											{ ref: "scrollBarRef", height: e.maxHeight ? void 0 : e.height, "max-height": e.maxHeight ? e.height : void 0, "view-style": e.scrollbarViewStyle, always: e.scrollbarAlwaysOn },
											{
												default: cn(() => [
													ni(
														"table",
														{ ref: "tableBody", class: gt(e.ns.e("body")), cellspacing: "0", cellpadding: "0", border: "0", style: pt({ width: e.bodyWidth, tableLayout: e.tableLayout }) },
														[
															ri(o, { columns: e.store.states.columns.value, "table-layout": e.tableLayout }, null, 8, ["columns", "table-layout"]),
															e.showHeader && "auto" === e.tableLayout
																? (Wr(), qr(a, { key: 0, border: e.border, "default-sort": e.defaultSort, store: e.store, onSetDragVisible: e.setDragVisible }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"]))
																: ai("v-if", !0),
															ri(l, { context: e.context, highlight: e.highlightCurrentRow, "row-class-name": e.rowClassName, "tooltip-effect": e.tooltipEffect, "row-style": e.rowStyle, store: e.store, stripe: e.stripe }, null, 8, [
																"context",
																"highlight",
																"row-class-name",
																"tooltip-effect",
																"row-style",
																"store",
																"stripe"
															])
														],
														6
													),
													e.isEmpty
														? (Wr(), Kr("div", { key: 0, ref: "emptyBlock", style: pt(e.emptyBlockStyle), class: gt(e.ns.e("empty-block")) }, [ni("span", { class: gt(e.ns.e("empty-text")) }, [mi(e.$slots, "empty", {}, () => [oi(bt(e.computedEmptyText), 1)])], 2)], 6))
														: ai("v-if", !0),
													e.$slots.append ? (Wr(), Kr("div", { key: 1, ref: "appendWrapper", class: gt(e.ns.e("append-wrapper")) }, [mi(e.$slots, "append")], 2)) : ai("v-if", !0)
												]),
												_: 3
											},
											8,
											["height", "max-height", "view-style", "always"]
										)
									],
									6
								),
								e.border || e.isGroup ? (Wr(), Kr("div", { key: 1, class: gt(e.ns.e("border-left-patch")) }, null, 2)) : ai("v-if", !0)
							],
							2
						),
						e.showSummary
							? yr(
									(Wr(),
									Kr(
										"div",
										{ key: 0, ref: "footerWrapper", class: gt(e.ns.e("footer-wrapper")) },
										[ri(c, { border: e.border, "default-sort": e.defaultSort, store: e.store, style: pt(e.tableBodyStyles), "sum-text": e.computedSumText, "summary-method": e.summaryMethod }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])],
										2
									)),
									[
										[Wo, !e.isEmpty],
										[h, e.handleHeaderFooterMousewheel]
									]
							  )
							: ai("v-if", !0),
						yr(ni("div", { ref: "resizeProxy", class: gt(e.ns.e("column-resize-proxy")) }, null, 2), [[Wo, e.resizeProxyVisible]])
					],
					46,
					_Q
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]
]);
const SQ = { selection: "table-column--selection", expand: "table__expand-column" },
	EQ = { default: { order: "" }, selection: { width: 48, minWidth: 48, realWidth: 48, order: "" }, expand: { width: 48, minWidth: 48, realWidth: 48, order: "" }, index: { width: 48, minWidth: 48, realWidth: 48, order: "" } },
	TQ = {
		selection: {
			renderHeader: ({ store: e }) =>
				xs(qz, { disabled: e.states.data.value && 0 === e.states.data.value.length, size: e.states.tableSize.value, indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value, "onUpdate:modelValue": e.toggleAllSelection, modelValue: e.states.isAllSelected.value }),
			renderCell: ({ row: e, column: t, store: n, $index: r }) =>
				xs(qz, {
					disabled: !!t.selectable && !t.selectable.call(null, e, r),
					size: n.states.tableSize.value,
					onChange: () => {
						n.commit("rowSelectedChanged", e);
					},
					onClick: (e) => e.stopPropagation(),
					modelValue: n.isSelected(e)
				}),
			sortable: !1,
			resizable: !1
		},
		index: {
			renderHeader: ({ column: e }) => e.label || "#",
			renderCell({ column: e, $index: t }) {
				let n = t + 1;
				const r = e.index;
				return "number" == typeof r ? (n = t + r) : "function" == typeof r && (n = r(t)), xs("div", {}, [n]);
			},
			sortable: !1
		},
		expand: {
			renderHeader: ({ column: e }) => e.label || "",
			renderCell({ row: e, store: t, expanded: n }) {
				const { ns: r } = t,
					i = [r.e("expand-icon")];
				n && i.push(r.em("expand-icon", "expanded"));
				return xs(
					"div",
					{
						class: i,
						onClick: function (n) {
							n.stopPropagation(), t.toggleRowExpansion(e);
						}
					},
					{ default: () => [xs(OB, null, { default: () => [xs(pL)] })] }
				);
			},
			sortable: !1,
			resizable: !1
		}
	};
function kQ({ row: e, column: t, $index: n }) {
	var r;
	const i = t.property,
		s = i && UR(e, i).value;
	return t && t.formatter ? t.formatter(e, t, s, n) : (null == (r = null == s ? void 0 : s.toString) ? void 0 : r.call(s)) || "";
}
function AQ(e, t) {
	return e.reduce((e, t) => ((e[t] = t), e), t);
}
function MQ(e, t, n) {
	const r = Si(),
		i = Qe(""),
		s = Qe(!1),
		o = Qe(),
		a = Qe(),
		l = BD("table");
	cs(() => {
		(o.value = e.align ? `is-${e.align}` : null), o.value;
	}),
		cs(() => {
			(a.value = e.headerAlign ? `is-${e.headerAlign}` : o.value), a.value;
		});
	const u = ht(() => {
			let e = r.vnode.vParent || r.parent;
			for (; e && !e.tableId && !e.columnId; ) e = e.vnode.vParent || e.parent;
			return e;
		}),
		c = ht(() => {
			const { store: e } = r.parent;
			if (!e) return !1;
			const { treeData: t } = e.states,
				n = t.value;
			return n && Object.keys(n).length > 0;
		}),
		h = Qe(OJ(e.width)),
		d = Qe(PJ(e.minWidth));
	return {
		columnId: i,
		realAlign: o,
		isSubColumn: s,
		realHeaderAlign: a,
		columnOrTableParent: u,
		setColumnWidth: (e) => (h.value && (e.width = h.value), d.value && (e.minWidth = d.value), e.minWidth || (e.minWidth = 80), (e.realWidth = Number(void 0 === e.width ? e.minWidth : e.width)), e),
		setColumnForcedProps: (e) => {
			const t = e.type,
				n = TQ[t] || {};
			Object.keys(n).forEach((t) => {
				const r = n[t];
				"className" !== t && void 0 !== r && (e[t] = r);
			});
			const r = ((e) => SQ[e] || "")(t);
			if (r) {
				const t = `${it(l.namespace)}-${r}`;
				e.className = e.className ? `${e.className} ${t}` : t;
			}
			return e;
		},
		setColumnRenders: (i) => {
			e.renderHeader ||
				("selection" !== i.type &&
					(i.renderHeader = (e) => {
						r.columnConfig.value.label;
						const n = t.header;
						return n ? n(e) : i.label;
					}));
			let s = i.renderCell;
			const o = c.value;
			return (
				"expand" === i.type
					? ((i.renderCell = (e) => xs("div", { class: "cell" }, [s(e)])), (n.value.renderExpanded = (e) => (t.default ? t.default(e) : t.default)))
					: ((s = s || kQ),
					  (i.renderCell = (e) => {
							let n = null;
							if (t.default) {
								const r = t.default(e);
								n = r.some((e) => e.type !== Ur) ? r : s(e);
							} else n = s(e);
							const a = (function ({ row: e, treeNode: t, store: n }, r = !1) {
									const { ns: i } = n;
									if (!t) return r ? [xs("span", { class: i.e("placeholder") })] : null;
									const s = [],
										o = function (t) {
											t.stopPropagation(), n.loadOrToggle(e);
										};
									if ((t.indent && s.push(xs("span", { class: i.e("indent"), style: { "padding-left": `${t.indent}px` } })), "boolean" != typeof t.expanded || t.noLazyChildren)) s.push(xs("span", { class: i.e("placeholder") }));
									else {
										const e = [i.e("expand-icon"), t.expanded ? i.em("expand-icon", "expanded") : ""];
										let n = pL;
										t.loading && (n = HO), s.push(xs("div", { class: e, onClick: o }, { default: () => [xs(OB, { class: { [i.is("loading")]: t.loading } }, { default: () => [xs(n)] })] }));
									}
									return s;
								})(e, o && 0 === e.cellIndex),
								u = { class: "cell", style: {} };
							return (
								i.showOverflowTooltip && ((u.class = `${u.class} ${it(l.namespace)}-tooltip`), (u.style = { width: (e.column.realWidth || Number(e.column.width)) - 1 + "px" })),
								((e) => {
									function t(e) {
										var t;
										"ElTableColumn" === (null == (t = null == e ? void 0 : e.type) ? void 0 : t.name) && (e.vParent = r);
									}
									Array.isArray(e) ? e.forEach((e) => t(e)) : t(e);
								})(n),
								xs("div", u, [a, n])
							);
					  })),
				i
			);
		},
		getPropsData: (...t) =>
			t.reduce(
				(t, n) => (
					Array.isArray(n) &&
						n.forEach((n) => {
							t[n] = e[n];
						}),
					t
				),
				{}
			),
		getColumnElIndex: (e, t) => Array.prototype.indexOf.call(e, t)
	};
}
var IQ = {
	type: { type: String, default: "default" },
	label: String,
	className: String,
	labelClassName: String,
	property: String,
	prop: String,
	width: { type: [String, Number], default: "" },
	minWidth: { type: [String, Number], default: "" },
	renderHeader: Function,
	sortable: { type: [Boolean, String], default: !1 },
	sortMethod: Function,
	sortBy: [String, Function, Array],
	resizable: { type: Boolean, default: !0 },
	columnKey: String,
	align: String,
	headerAlign: String,
	showTooltipWhenOverflow: Boolean,
	showOverflowTooltip: Boolean,
	fixed: [Boolean, String],
	formatter: Function,
	selectable: Function,
	reserveSelection: Boolean,
	filterMethod: Function,
	filteredValue: Array,
	filters: Array,
	filterPlacement: String,
	filterMultiple: { type: Boolean, default: !0 },
	index: [Number, Function],
	sortOrders: { type: Array, default: () => ["ascending", "descending", null], validator: (e) => e.every((e) => ["ascending", "descending", null].includes(e)) }
};
let RQ = 1;
var LQ = Tn({
	name: "ElTableColumn",
	components: { ElCheckbox: qz },
	props: IQ,
	setup(e, { slots: t }) {
		const n = Si(),
			r = Qe({}),
			i = ht(() => {
				let e = n.parent;
				for (; e && !e.tableId; ) e = e.parent;
				return e;
			}),
			{ registerNormalWatchers: s, registerComplexWatchers: o } = (function (e, t) {
				const n = Si();
				return {
					registerComplexWatchers: () => {
						const r = { realWidth: "width", realMinWidth: "minWidth" },
							i = AQ(["fixed"], r);
						Object.keys(i).forEach((i) => {
							const s = r[i];
							xR(t, s) &&
								ds(
									() => t[s],
									(t) => {
										let r = t;
										"width" === s && "realWidth" === i && (r = OJ(t)), "minWidth" === s && "realMinWidth" === i && (r = PJ(t)), (n.columnConfig.value[s] = r), (n.columnConfig.value[i] = r);
										const o = "fixed" === s;
										e.value.store.scheduleLayout(o);
									}
								);
						});
					},
					registerNormalWatchers: () => {
						const e = { property: "prop", align: "realAlign", headerAlign: "realHeaderAlign" },
							r = AQ(["label", "filters", "filterMultiple", "sortable", "index", "formatter", "className", "labelClassName", "showOverflowTooltip"], e);
						Object.keys(r).forEach((r) => {
							const i = e[r];
							xR(t, i) &&
								ds(
									() => t[i],
									(e) => {
										n.columnConfig.value[r] = e;
									}
								);
						});
					}
				};
			})(i, e),
			{ columnId: a, isSubColumn: l, realHeaderAlign: h, columnOrTableParent: d, setColumnWidth: p, setColumnForcedProps: f, setColumnRenders: m, getPropsData: v, getColumnElIndex: g, realAlign: y } = MQ(e, t, i),
			b = d.value;
		(a.value = `${b.tableId || b.columnId}_column_${RQ++}`),
			Hn(() => {
				l.value = i.value !== b;
				const t = e.type || "default",
					d = "" === e.sortable || e.sortable,
					g = c(u({}, EQ[t]), {
						id: a.value,
						type: t,
						property: e.prop || e.property,
						align: y,
						headerAlign: h,
						showOverflowTooltip: e.showOverflowTooltip || e.showTooltipWhenOverflow,
						filterable: e.filters || e.filterMethod,
						filteredValue: [],
						filterPlacement: "",
						isColumnGroup: !1,
						isSubColumn: !1,
						filterOpened: !1,
						sortable: d,
						index: e.index,
						rawColumnKey: n.vnode.key
					});
				let x = v(
					["columnKey", "label", "className", "labelClassName", "type", "renderHeader", "formatter", "fixed", "resizable"],
					["sortMethod", "sortBy", "sortOrders"],
					["selectable", "reserveSelection"],
					["filterMethod", "filters", "filterMultiple", "filterOpened", "filteredValue", "filterPlacement"]
				);
				x = (function (e, t) {
					const n = {};
					let r;
					for (r in e) n[r] = e[r];
					for (r in t)
						if (xR(t, r)) {
							const e = t[r];
							void 0 !== e && (n[r] = e);
						}
					return n;
				})(g, x);
				(x = (function (...e) {
					return 0 === e.length
						? (e) => e
						: 1 === e.length
						? e[0]
						: e.reduce(
								(e, t) =>
									(...n) =>
										e(t(...n))
						  );
				})(
					m,
					p,
					f
				)(x)),
					(r.value = x),
					s(),
					o();
			}),
			Vn(() => {
				var e;
				const t = d.value,
					s = l.value ? t.vnode.el.children : null == (e = t.refs.hiddenColumns) ? void 0 : e.children,
					o = () => g(s || [], n.vnode.el);
				r.value.getColumnIndex = o;
				o() > -1 && i.value.store.commit("insertColumn", r.value, l.value ? t.columnConfig.value : null);
			}),
			$n(() => {
				i.value.store.commit("removeColumn", r.value, l.value ? b.columnConfig.value : null);
			}),
			(n.columnId = a.value),
			(n.columnConfig = r);
	},
	render() {
		var e, t, n;
		try {
			const r = null == (t = (e = this.$slots).default) ? void 0 : t.call(e, { row: {}, column: {}, $index: -1 }),
				i = [];
			if (Array.isArray(r))
				for (const e of r)
					"ElTableColumn" === (null == (n = e.type) ? void 0 : n.name) || 2 & e.shapeFlag
						? i.push(e)
						: e.type === Hr &&
						  Array.isArray(e.children) &&
						  e.children.forEach((e) => {
								1024 === (null == e ? void 0 : e.patchFlag) || SR(null == e ? void 0 : e.children) || i.push(e);
						  });
			return xs("div", i);
		} catch (Kj) {
			return xs("div", []);
		}
	}
});
const OQ = mN(CQ, { TableColumn: LQ }),
	PQ = gN(LQ);
var NQ = ((e) => ((e.ASC = "asc"), (e.DESC = "desc"), e))(NQ || {}),
	DQ = ((e) => ((e.CENTER = "center"), (e.RIGHT = "right"), e))(DQ || {}),
	BQ = ((e) => ((e.LEFT = "left"), (e.RIGHT = "right"), e))(BQ || {});
const FQ = { asc: "desc", desc: "asc" },
	HQ = Symbol("placeholder");
function VQ(e, t, n) {
	const r = ht(() => it(t).filter((e) => !e.hidden)),
		i = ht(() => it(r).filter((e) => "left" === e.fixed || !0 === e.fixed)),
		s = ht(() => it(r).filter((e) => "right" === e.fixed)),
		o = ht(() => it(r).filter((e) => !e.fixed)),
		a = ht(() => {
			const e = [];
			return (
				it(i).forEach((t) => {
					e.push(c(u({}, t), { placeholderSign: HQ }));
				}),
				it(o).forEach((t) => {
					e.push(t);
				}),
				it(s).forEach((t) => {
					e.push(c(u({}, t), { placeholderSign: HQ }));
				}),
				e
			);
		}),
		l = ht(() => it(i).length || it(s).length),
		h = ht(() =>
			it(t).reduce(
				(t, r) => (
					(t[r.key] = ((e, t, n) => {
						var r;
						const i = u({ flexGrow: 0, flexShrink: 0 }, n ? {} : { flexGrow: e.flexGrow || 0, flexShrink: e.flexShrink || 1 });
						n || (i.flexShrink = 1);
						const s = c(u(u({}, null != (r = e.style) ? r : {}), i), { flexBasis: "auto", width: e.width });
						return t || (e.maxWidth && (s.maxWidth = e.maxWidth), e.minWidth && (s.maxWidth = e.minWidth)), s;
					})(r, it(n), e.fixed)),
					t
				),
				{}
			)
		),
		d = ht(() => it(r).reduce((e, t) => e + t.width, 0)),
		p = (e) => it(t).find((t) => t.key === e);
	return {
		columns: t,
		columnsStyles: h,
		columnsTotalWidth: d,
		fixedColumnsOnLeft: i,
		fixedColumnsOnRight: s,
		hasFixedColumns: l,
		mainColumns: a,
		normalColumns: o,
		visibleColumns: r,
		getColumn: p,
		getColumnStyle: (e) => it(h)[e],
		updateColumnWidth: (e, t) => {
			e.width = t;
		},
		onColumnSorted: function (t) {
			var n;
			const { key: r } = t.currentTarget.dataset;
			if (!r) return;
			const { sortState: i, sortBy: s } = e;
			let o = NQ.ASC;
			(o = ER(i) ? FQ[i[r]] : FQ[s.order]), null == (n = e.onColumnSort) || n.call(e, { column: p(r), key: r, order: o });
		}
	};
}
const UQ = (e, { mainTableRef: t, leftTableRef: n, rightTableRef: r, onMaybeEndReached: i }) => {
		const s = Si(),
			{ emit: o } = s,
			a = et(!1),
			l = et(null),
			c = Qe(e.defaultExpandedRowKeys || []),
			h = Qe(-1),
			d = et(null),
			p = Qe({}),
			f = Qe({}),
			m = et({}),
			v = et({}),
			g = et({}),
			y = ht(() => XI(e.estimatedRowHeight));
		const b = QT(() => {
			var e, i, o, l;
			(a.value = !0), (p.value = u(u({}, it(p)), it(f))), x(it(d), !1), (f.value = {}), (d.value = null), null == (e = t.value) || e.forceUpdate(), null == (i = n.value) || i.forceUpdate(), null == (o = r.value) || o.forceUpdate(), null == (l = s.proxy) || l.$forceUpdate(), (a.value = !1);
		}, 0);
		function x(e, i = !1) {
			it(y) &&
				[t, n, r].forEach((t) => {
					const n = it(t);
					n && n.resetAfterRowIndex(e, i);
				});
		}
		return (
			ds(h, () => i()),
			{
				hoveringRowKey: l,
				expandedRowKeys: c,
				lastRenderedRowIndex: h,
				isDynamic: y,
				isResetting: a,
				rowHeights: p,
				resetAfterIndex: x,
				onRowExpanded: function ({ expanded: t, rowData: n, rowIndex: r, rowKey: i }) {
					var s, a;
					const l = [...it(c)],
						u = l.indexOf(i);
					t ? -1 === u && l.push(i) : u > -1 && l.splice(u, 1), (c.value = l), o("update:expandedRowKeys", l), null == (s = e.onRowExpand) || s.call(e, { expanded: t, rowData: n, rowIndex: r, rowKey: i }), null == (a = e.onExpandedRowsChange) || a.call(e, l);
				},
				onRowHovered: function ({ hovered: e, rowKey: t }) {
					l.value = e ? t : null;
				},
				onRowsRendered: function (t) {
					var n;
					null == (n = e.onRowsRendered) || n.call(e, t), t.rowCacheEnd > it(h) && (h.value = t.rowCacheEnd);
				},
				onRowHeightChange: function ({ rowKey: e, height: t, rowIndex: n }, r) {
					r ? (r === BQ.RIGHT ? (g.value[e] = t) : (m.value[e] = t)) : (v.value[e] = t);
					const i = Math.max(...[m, g, v].map((t) => t.value[e] || 0));
					it(p)[e] !== i &&
						(!(function (e, t, n) {
							const r = it(d);
							(null === r || r > n) && (d.value = n), (f.value[e] = t);
						})(e, i, n),
						b());
				}
			}
		);
	},
	zQ = (e, t) => e + t,
	$Q = (e) => (_R(e) ? e.reduce(zQ, 0) : e),
	jQ = (e, t, n = {}) => (CR(e) ? e(t) : null != e ? e : n),
	WQ = (e) => (
		["width", "maxWidth", "minWidth", "height"].forEach((t) => {
			e[t] = KR(e[t]);
		}),
		e
	),
	GQ = (e) => (Zr(e) ? (t) => xs(e, t) : e);
function YQ(e) {
	const t = Qe(),
		n = Qe(),
		r = Qe(),
		{ columns: i, columnsStyles: s, columnsTotalWidth: o, fixedColumnsOnLeft: a, fixedColumnsOnRight: l, hasFixedColumns: h, mainColumns: d, onColumnSorted: p } = VQ(e, ut(e, "columns"), ut(e, "fixed")),
		{
			scrollTo: f,
			scrollToLeft: m,
			scrollToTop: v,
			scrollToRow: g,
			onScroll: y,
			onVerticalScroll: b,
			scrollPos: x
		} = ((e, { mainTableRef: t, leftTableRef: n, rightTableRef: r, onMaybeEndReached: i }) => {
			const s = Qe({ scrollLeft: 0, scrollTop: 0 });
			function o(e) {
				var i, s, o;
				const { scrollTop: a } = e;
				null == (i = t.value) || i.scrollTo(e), null == (s = n.value) || s.scrollToTop(a), null == (o = r.value) || o.scrollToTop(a);
			}
			function a(e) {
				(s.value = e), o(e);
			}
			function l(e) {
				(s.value.scrollTop = e), o(it(s));
			}
			return (
				ds(
					() => it(s).scrollTop,
					(e, t) => {
						e > t && i();
					}
				),
				{
					scrollPos: s,
					scrollTo: a,
					scrollToLeft: function (e) {
						var n, r;
						(s.value.scrollLeft = e), null == (r = null == (n = t.value) ? void 0 : n.scrollTo) || r.call(n, it(s));
					},
					scrollToTop: l,
					scrollToRow: function (e, n = "auto") {
						var r;
						null == (r = t.value) || r.scrollToRow(e, n);
					},
					onScroll: function (t) {
						var n;
						a(t), null == (n = e.onScroll) || n.call(e, t);
					},
					onVerticalScroll: function ({ scrollTop: e }) {
						const { scrollTop: t } = it(s);
						e !== t && l(e);
					}
				}
			);
		})(e, { mainTableRef: t, leftTableRef: n, rightTableRef: r, onMaybeEndReached: X }),
		{
			expandedRowKeys: _,
			hoveringRowKey: w,
			lastRenderedRowIndex: C,
			isDynamic: S,
			isResetting: E,
			rowHeights: T,
			resetAfterIndex: k,
			onRowExpanded: A,
			onRowHeightChange: M,
			onRowHovered: I,
			onRowsRendered: R
		} = UQ(e, { mainTableRef: t, leftTableRef: n, rightTableRef: r, onMaybeEndReached: X }),
		{ data: L, depthMap: O } = ((e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: r }) => {
			const i = Qe({}),
				s = ht(() => {
					const n = {},
						{ data: r, rowKey: s } = e,
						o = it(t);
					if (!o || !o.length) return r;
					const a = [],
						l = new Set();
					o.forEach((e) => l.add(e));
					let u = r.slice();
					for (u.forEach((e) => (n[e[s]] = 0)); u.length > 0; ) {
						const e = u.shift();
						a.push(e), l.has(e[s]) && Array.isArray(e.children) && e.children.length > 0 && ((u = [...e.children, ...u]), e.children.forEach((t) => (n[t[s]] = n[e[s]] + 1)));
					}
					return (i.value = n), a;
				}),
				o = ht(() => {
					const { data: t, expandColumnKey: n } = e;
					return n ? it(s) : t;
				});
			return (
				ds(o, (e, t) => {
					e !== t && ((n.value = -1), r(0, !0));
				}),
				{ data: o, depthMap: i }
			);
		})(e, { expandedRowKeys: _, lastRenderedRowIndex: C, resetAfterIndex: k }),
		{
			bodyWidth: P,
			fixedTableHeight: N,
			mainTableHeight: D,
			leftTableWidth: B,
			rightTableWidth: F,
			headerWidth: H,
			rowsHeight: V,
			windowHeight: U,
			footerHeight: z,
			emptyStyle: $,
			rootStyle: j
		} = ((e, { columnsTotalWidth: t, data: n, fixedColumnsOnLeft: r, fixedColumnsOnRight: i }) => {
			const s = ht(() => {
					const { fixed: n, width: r, vScrollbarSize: i } = e,
						s = r - i;
					return n ? Math.max(Math.round(it(t)), s) : s;
				}),
				o = ht(() => it(s) + (e.fixed ? e.vScrollbarSize : 0)),
				a = ht(() => {
					const { height: t = 0, maxHeight: n = 0, footerHeight: r, hScrollbarSize: i } = e;
					if (n > 0) {
						const e = it(v),
							t = it(l),
							s = it(m) + e + t + i;
						return Math.min(s, n - r);
					}
					return t - r;
				}),
				l = ht(() => {
					const { rowHeight: t, estimatedRowHeight: r } = e,
						i = it(n);
					return XI(r) ? i.length * r : i.length * t;
				}),
				h = ht(() => {
					const { maxHeight: t } = e,
						n = it(a);
					if (XI(t) && t > 0) return n;
					const r = it(l) + it(m) + it(v);
					return Math.min(n, r);
				}),
				d = (e) => e.width,
				p = ht(() => $Q(it(r).map(d))),
				f = ht(() => $Q(it(i).map(d))),
				m = ht(() => $Q(e.headerHeight)),
				v = ht(() => {
					var t;
					return ((null == (t = e.fixedData) ? void 0 : t.length) || 0) * e.rowHeight;
				}),
				g = ht(() => it(a) - it(m) - it(v)),
				y = ht(() => {
					const { style: t = {}, height: n, width: r } = e;
					return WQ(c(u({}, t), { height: n, width: r }));
				}),
				b = ht(() => WQ({ height: e.footerHeight })),
				x = ht(() => ({ top: KR(it(m)), bottom: KR(e.footerHeight), width: KR(e.width) }));
			return { bodyWidth: s, fixedTableHeight: h, mainTableHeight: a, leftTableWidth: p, rightTableWidth: f, headerWidth: o, rowsHeight: l, windowHeight: g, footerHeight: b, emptyStyle: x, rootStyle: y };
		})(e, { columnsTotalWidth: o, data: L, fixedColumnsOnLeft: a, fixedColumnsOnRight: l }),
		W = et(!1),
		G = Qe(),
		Y = ht(() => {
			const t = 0 === it(L).length;
			return _R(e.fixedData) ? 0 === e.fixedData.length && t : t;
		});
	function X() {
		const { onEndReached: t } = e;
		if (!t) return;
		const { scrollTop: n } = it(x),
			r = it(V),
			i = r - (n + it(U)) + e.hScrollbarSize;
		it(C) >= 0 && r !== it(V) && t(i);
	}
	return (
		ds(
			() => e.expandedRowKeys,
			(e) => (_.value = e),
			{ deep: !0 }
		),
		{
			columns: i,
			containerRef: G,
			mainTableRef: t,
			leftTableRef: n,
			rightTableRef: r,
			isDynamic: S,
			isResetting: E,
			isScrolling: W,
			hoveringRowKey: w,
			hasFixedColumns: h,
			columnsStyles: s,
			columnsTotalWidth: o,
			data: L,
			expandedRowKeys: _,
			depthMap: O,
			fixedColumnsOnLeft: a,
			fixedColumnsOnRight: l,
			mainColumns: d,
			bodyWidth: P,
			emptyStyle: $,
			rootStyle: j,
			headerWidth: H,
			footerHeight: z,
			mainTableHeight: D,
			fixedTableHeight: N,
			leftTableWidth: B,
			rightTableWidth: F,
			showEmpty: Y,
			getRowHeight: function (t) {
				const { estimatedRowHeight: n, rowHeight: r, rowKey: i } = e;
				return n ? it(T)[it(L)[t][i]] || n : r;
			},
			onColumnSorted: p,
			onRowHovered: I,
			onRowExpanded: A,
			onRowsRendered: R,
			onRowHeightChange: M,
			scrollTo: f,
			scrollToLeft: m,
			scrollToTop: v,
			scrollToRow: g,
			onScroll: y,
			onVerticalScroll: b
		}
	);
}
const XQ = Symbol("tableV2"),
	KQ = String,
	qQ = { type: Array, required: !0 },
	ZQ = { type: Array },
	JQ = c(u({}, ZQ), { required: !0 }),
	QQ = { type: Array, default: () => [] },
	e0 = { type: Number, required: !0 },
	t0 = { type: [String, Number, Symbol], default: "id" },
	n0 = { type: Object },
	r0 = uN({
		class: String,
		columns: qQ,
		columnsStyles: { type: Object, required: !0 },
		depth: Number,
		expandColumnKey: String,
		estimatedRowHeight: c(u({}, $q.estimatedRowHeight), { default: void 0 }),
		isScrolling: Boolean,
		onRowExpand: { type: Function },
		onRowHover: { type: Function },
		onRowHeightChange: { type: Function },
		rowData: { type: Object, required: !0 },
		rowEventHandlers: { type: Object },
		rowIndex: { type: Number, required: !0 },
		rowKey: t0,
		style: { type: Object }
	}),
	i0 = { type: Number, required: !0 },
	s0 = uN({ class: String, columns: qQ, fixedHeaderData: { type: Array }, headerData: { type: Array, required: !0 }, headerHeight: { type: [Number, Array], default: 50 }, rowWidth: i0, rowHeight: { type: Number, default: 50 }, height: i0, width: i0 }),
	o0 = uN({
		columns: qQ,
		data: JQ,
		fixedData: ZQ,
		estimatedRowHeight: r0.estimatedRowHeight,
		width: e0,
		height: e0,
		headerWidth: e0,
		headerHeight: s0.headerHeight,
		bodyWidth: e0,
		rowHeight: e0,
		cache: Hq.cache,
		useIsScrolling: Boolean,
		scrollbarAlwaysOn: $q.scrollbarAlwaysOn,
		scrollbarStartGap: $q.scrollbarStartGap,
		scrollbarEndGap: $q.scrollbarEndGap,
		class: KQ,
		style: n0,
		containerStyle: n0,
		getRowHeight: { type: Function, required: !0 },
		rowKey: r0.rowKey,
		onRowsRendered: { type: Function },
		onScroll: { type: Function }
	}),
	a0 = uN({
		cache: o0.cache,
		estimatedRowHeight: r0.estimatedRowHeight,
		rowKey: t0,
		headerClass: { type: [String, Function] },
		headerProps: { type: [Object, Function] },
		headerCellProps: { type: [Object, Function] },
		headerHeight: s0.headerHeight,
		footerHeight: { type: Number, default: 0 },
		rowClass: { type: [String, Function] },
		rowProps: { type: [Object, Function] },
		rowHeight: { type: Number, default: 50 },
		cellProps: { type: [Object, Function] },
		columns: qQ,
		data: JQ,
		dataGetter: { type: Function },
		fixedData: ZQ,
		expandColumnKey: r0.expandColumnKey,
		expandedRowKeys: QQ,
		defaultExpandedRowKeys: QQ,
		class: KQ,
		fixed: Boolean,
		style: { type: Object },
		width: e0,
		height: e0,
		maxHeight: Number,
		useIsScrolling: Boolean,
		indentSize: { type: Number, default: 12 },
		iconSize: { type: Number, default: 12 },
		hScrollbarSize: $q.hScrollbarSize,
		vScrollbarSize: $q.vScrollbarSize,
		scrollbarAlwaysOn: jq.alwaysOn,
		sortBy: { type: Object, default: () => ({}) },
		sortState: { type: Object, default: void 0 },
		onColumnSort: { type: Function },
		onExpandedRowsChange: { type: Function },
		onEndReached: { type: Function },
		onRowExpand: r0.onRowExpand,
		onScroll: o0.onScroll,
		onRowsRendered: o0.onRowsRendered,
		rowEventHandlers: r0.rowEventHandlers
	}),
	l0 = (e, { slots: t }) => {
		var n;
		const { cellData: r, style: i } = e,
			s = (null == (n = null == r ? void 0 : r.toString) ? void 0 : n.call(r)) || "";
		return ri("div", { class: e.class, title: s, style: i }, [t.default ? t.default(e) : s]);
	};
(l0.displayName = "ElTableV2Cell"), (l0.inheritAttrs = !1);
const u0 = (e, { slots: t }) => {
	var n, r;
	return t.default ? t.default(e) : ri("div", { class: e.class, title: null == (n = e.column) ? void 0 : n.title }, [null == (r = e.column) ? void 0 : r.title]);
};
(u0.displayName = "ElTableV2HeaderCell"), (u0.inheritAttrs = !1);
const c0 = Tn({
		name: "ElTableV2HeaderRow",
		props: uN({ class: String, columns: qQ, columnsStyles: { type: Object, required: !0 }, headerIndex: Number, style: { type: Object } }),
		setup:
			(e, { slots: t }) =>
			() => {
				const { columns: n, columnsStyles: r, headerIndex: i, style: s } = e;
				let o = n.map((e, s) => t.cell({ columns: n, column: e, columnIndex: s, headerIndex: i, style: r[e.key] }));
				return t.header && (o = t.header({ cells: o.map((e) => (_R(e) && 1 === e.length ? e[0] : e)), columns: n, headerIndex: i })), ri("div", { class: e.class, style: s }, [o]);
			}
	}),
	h0 = Tn({
		name: "ElTableV2Header",
		props: s0,
		setup(e, { slots: t, expose: n }) {
			const r = BD("table-v2"),
				i = Qe(),
				s = ht(() => WQ({ width: e.width, height: e.height })),
				o = ht(() => WQ({ width: e.rowWidth, height: e.height })),
				a = ht(() => zE(it(e.headerHeight))),
				l = () => {
					const n = r.e("fixed-header-row"),
						{ columns: i, fixedHeaderData: s, rowHeight: o } = e;
					return null == s
						? void 0
						: s.map((e, r) => {
								var s;
								const a = WQ({ height: o, width: "100%" });
								return null == (s = t.fixed) ? void 0 : s.call(t, { class: n, columns: i, rowData: e, rowIndex: -(r + 1), style: a });
						  });
				},
				u = () => {
					const n = r.e("dynamic-header-row"),
						{ columns: i } = e;
					return it(a).map((e, r) => {
						var s;
						const o = WQ({ width: "100%", height: e });
						return null == (s = t.dynamic) ? void 0 : s.call(t, { class: n, columns: i, headerIndex: r, style: o });
					});
				};
			return (
				n({
					scrollToLeft: (e) => {
						const t = it(i);
						ns(() => {
							null == t || t.scroll({ left: e });
						});
					}
				}),
				() => {
					if (!(e.height <= 0)) return ri("div", { ref: i, class: e.class, style: it(s) }, [ri("div", { style: it(o), class: r.e("header") }, [u(), l()])]);
				}
			);
		}
	}),
	d0 = (e) => {
		const { isScrolling: t } = vn(XQ),
			n = Qe(!1),
			r = Qe(),
			i = ht(() => XI(e.estimatedRowHeight) && e.rowIndex >= 0),
			s = ht(() => {
				const { rowData: t, rowIndex: n, rowKey: r, onRowHover: i } = e,
					s = e.rowEventHandlers || {},
					o = {};
				return (
					Object.entries(s).forEach(([e, i]) => {
						CR(i) &&
							(o[e] = (e) => {
								i({ event: e, rowData: t, rowIndex: n, rowKey: r });
							});
					}),
					i &&
						[
							{ name: "onMouseleave", hovered: !1 },
							{ name: "onMouseenter", hovered: !0 }
						].forEach(({ name: e, hovered: s }) => {
							const a = o[e];
							o[e] = (e) => {
								i({ event: e, hovered: s, rowData: t, rowIndex: n, rowKey: r }), null == a || a(e);
							};
						}),
					o
				);
			});
		return (
			Vn(() => {
				it(i) &&
					((t = !1) => {
						const i = it(r);
						if (!i) return;
						const { columns: s, onRowHeightChange: o, rowKey: a, rowIndex: l, style: u } = e,
							{ height: c } = i.getBoundingClientRect();
						(n.value = !0),
							ns(() => {
								if (t || c !== Number.parseInt(u.height)) {
									const e = s[0],
										t = (null == e ? void 0 : e.placeholderSign) === HQ;
									null == o || o({ rowKey: a, height: c, rowIndex: l }, e && !t && e.fixed);
								}
							});
					})(!0);
			}),
			{
				isScrolling: t,
				measurable: i,
				measured: n,
				rowRef: r,
				eventHandlers: s,
				onExpand: (t) => {
					const { onRowExpand: n, rowData: r, rowIndex: i, rowKey: s } = e;
					null == n || n({ expanded: t, rowData: r, rowIndex: i, rowKey: s });
				}
			}
		);
	},
	p0 = Tn({
		name: "ElTableV2TableRow",
		props: r0,
		setup(e, { expose: t, slots: n, attrs: r }) {
			const { eventHandlers: i, isScrolling: s, measurable: o, measured: a, rowRef: l, onExpand: u } = d0(e);
			return (
				t({ onExpand: u }),
				() => {
					const { columns: t, columnsStyles: c, expandColumnKey: d, depth: p, rowData: f, rowIndex: m, style: v } = e;
					let g = t.map((e, r) => {
						const i = _R(f.children) && f.children.length > 0 && e.key === d;
						return n.cell({ column: e, columns: t, columnIndex: r, depth: p, style: c[e.key], rowData: f, rowIndex: m, isScrolling: it(s), expandIconProps: i ? { rowData: f, rowIndex: m, onExpand: u } : void 0 });
					});
					if ((n.row && (g = n.row({ cells: g.map((e) => (_R(e) && 1 === e.length ? e[0] : e)), style: v, columns: t, depth: p, rowData: f, rowIndex: m, isScrolling: it(s) })), it(o))) {
						const t = v || {},
							{ height: n } = t,
							s = h(t, ["height"]),
							o = it(a);
						return ri("div", hi({ ref: l, class: e.class, style: o ? v : s }, r, it(i)), [g]);
					}
					return ri("div", hi(r, { ref: l, class: e.class, style: v }, it(i)), [g]);
				}
			);
		}
	}),
	f0 = (e) => {
		const { sortOrder: t } = e;
		return ri(OB, { size: 14, class: e.class }, { default: () => [t === NQ.ASC ? ri(OP, null, null) : ri(MP, null, null)] });
	},
	m0 = (e) => {
		const { expanded: t, expandable: n, onExpand: r, style: i, size: s } = e,
			o = { onClick: n ? () => r(!t) : void 0, class: e.class };
		return ri(OB, hi(o, { size: s, style: i }), { default: () => [ri(pL, null, null)] });
	},
	v0 = Tn({
		name: "ElTableV2Grid",
		props: o0,
		setup(e, { slots: t, expose: n }) {
			const { ns: r } = vn(XQ),
				{
					bodyRef: i,
					fixedRowHeight: s,
					gridHeight: o,
					hasHeader: a,
					headerRef: l,
					headerHeight: h,
					totalHeight: d,
					forceUpdate: p,
					itemKey: f,
					onItemRendered: m,
					resetAfterRowIndex: v,
					scrollTo: g,
					scrollToTop: y,
					scrollToRow: b
				} = ((e) => {
					const t = Qe(),
						n = Qe(),
						r = ht(() => {
							const { data: t, rowHeight: n, estimatedRowHeight: r } = e;
							if (!r) return t.length * n;
						}),
						i = ht(() => {
							const { fixedData: t, rowHeight: n } = e;
							return ((null == t ? void 0 : t.length) || 0) * n;
						}),
						s = ht(() => $Q(e.headerHeight)),
						o = ht(() => {
							const { height: t } = e;
							return Math.max(0, t - it(s) - it(i));
						}),
						a = ht(() => it(s) + it(i) > 0);
					return {
						bodyRef: n,
						forceUpdate: function () {
							var e, r;
							null == (e = it(n)) || e.$forceUpdate(), null == (r = it(t)) || r.$forceUpdate();
						},
						fixedRowHeight: i,
						gridHeight: o,
						hasHeader: a,
						headerHeight: s,
						headerRef: t,
						totalHeight: r,
						itemKey: ({ data: t, rowIndex: n }) => t[n][e.rowKey],
						onItemRendered: function ({ rowCacheStart: t, rowCacheEnd: n, rowVisibleStart: r, rowVisibleEnd: i }) {
							var s;
							null == (s = e.onRowsRendered) || s.call(e, { rowCacheStart: t, rowCacheEnd: n, rowVisibleStart: r, rowVisibleEnd: i });
						},
						resetAfterRowIndex: function (e, t) {
							var r;
							null == (r = n.value) || r.resetAfterRowIndex(e, t);
						},
						scrollTo: function (e, r) {
							const i = it(t),
								s = it(n);
							i && s && (ER(e) ? (i.scrollToLeft(e.scrollLeft), s.scrollTo(e)) : (i.scrollToLeft(e), s.scrollTo({ scrollLeft: e, scrollTop: r })));
						},
						scrollToTop: function (e) {
							var t;
							null == (t = it(n)) || t.scrollTo({ scrollTop: e });
						},
						scrollToRow: function (e, t) {
							var r;
							null == (r = it(n)) || r.scrollToItem(e, 1, t);
						}
					};
				})(e);
			n({ forceUpdate: p, totalHeight: d, scrollTo: g, scrollToTop: y, scrollToRow: b, resetAfterRowIndex: v });
			const x = () => e.bodyWidth;
			return () => {
				const { cache: n, columns: d, data: p, fixedData: v, useIsScrolling: g, scrollbarAlwaysOn: y, scrollbarEndGap: b, scrollbarStartGap: _, style: w, rowHeight: C, bodyWidth: S, estimatedRowHeight: E, headerWidth: T, height: k, width: A, getRowHeight: M, onScroll: I } = e,
					R = XI(E),
					L = R ? yZ : sZ,
					O = it(h);
				return ri("div", { role: "table", class: [r.e("table"), e.class], style: w }, [
					ri(
						L,
						{
							ref: i,
							data: p,
							useIsScrolling: g,
							itemKey: f,
							columnCache: 0,
							columnWidth: R ? x : S,
							totalColumn: 1,
							totalRow: p.length,
							rowCache: n,
							rowHeight: R ? M : C,
							width: A,
							height: it(o),
							class: r.e("body"),
							scrollbarStartGap: _,
							scrollbarEndGap: b,
							scrollbarAlwaysOn: y,
							onScroll: I,
							onItemRendered: m,
							perfMode: !1
						},
						{
							default: (e) => {
								var n;
								const r = p[e.rowIndex];
								return null == (n = t.row) ? void 0 : n.call(t, c(u({}, e), { columns: d, rowData: r }));
							}
						}
					),
					it(a) && ri(h0, { ref: l, class: r.e("header-wrapper"), columns: d, headerData: p, headerHeight: e.headerHeight, fixedHeaderData: v, rowWidth: T, rowHeight: C, width: A, height: Math.min(O + it(s), k) }, { dynamic: t.header, fixed: t.row })
				]);
			};
		}
	});
const g0 = (e, { slots: t }) => {
	const n = e,
		{ mainTableRef: r } = n,
		i = h(n, ["mainTableRef"]);
	return ri(v0, hi({ ref: r }, i), "function" == typeof (s = t) || ("[object Object]" === Object.prototype.toString.call(s) && !Zr(s)) ? t : { default: () => [t] });
	var s;
};
const y0 = (e, { slots: t }) => {
	if (!e.columns.length) return;
	const n = e,
		{ leftTableRef: r } = n,
		i = h(n, ["leftTableRef"]);
	return ri(v0, hi({ ref: r }, i), "function" == typeof (s = t) || ("[object Object]" === Object.prototype.toString.call(s) && !Zr(s)) ? t : { default: () => [t] });
	var s;
};
const b0 = (e, { slots: t }) => {
	if (!e.columns.length) return;
	const n = e,
		{ rightTableRef: r } = n,
		i = h(n, ["rightTableRef"]);
	return ri(v0, hi({ ref: r }, i), "function" == typeof (s = t) || ("[object Object]" === Object.prototype.toString.call(s) && !Zr(s)) ? t : { default: () => [t] });
	var s;
};
const x0 = (e, { slots: t }) => {
		const {
				columns: n,
				columnsStyles: r,
				depthMap: i,
				expandColumnKey: s,
				expandedRowKeys: o,
				estimatedRowHeight: a,
				hasFixedColumns: l,
				hoveringRowKey: h,
				rowData: d,
				rowIndex: p,
				style: f,
				isScrolling: m,
				rowProps: v,
				rowClass: g,
				rowKey: y,
				rowEventHandlers: b,
				ns: x,
				onRowHovered: _,
				onRowExpanded: w
			} = e,
			C = jQ(g, { columns: n, rowData: d, rowIndex: p }, ""),
			S = jQ(v, { columns: n, rowData: d, rowIndex: p }),
			E = d[y],
			T = i[E] || 0,
			k = Boolean(s),
			A = p < 0,
			M = [x.e("row"), C, { [x.e(`row-depth-${T}`)]: k && p >= 0, [x.is("expanded")]: k && o.includes(E), [x.is("hovered")]: !m && E === h, [x.is("fixed")]: !T && A, [x.is("customized")]: Boolean(t.row) }],
			I = l ? _ : void 0,
			R = c(u({}, S), { columns: n, columnsStyles: r, class: M, depth: T, expandColumnKey: s, estimatedRowHeight: A ? void 0 : a, isScrolling: m, rowIndex: p, rowData: d, rowKey: E, rowEventHandlers: b, style: f });
		return ri(p0, hi(R, { onRowHover: I, onRowExpand: w }), "function" == typeof (L = t) || ("[object Object]" === Object.prototype.toString.call(L) && !Zr(L)) ? t : { default: () => [t] });
		var L;
	},
	_0 = ({ columns: e, column: t, columnIndex: n, depth: r, expandIconProps: i, isScrolling: s, rowData: o, rowIndex: a, style: l, expandedRowKeys: u, ns: c, cellProps: h, expandColumnKey: d, indentSize: p, iconSize: f, rowKey: m }, { slots: v }) => {
		const g = WQ(l);
		if (t.placeholderSign === HQ) return ri("div", { class: c.em("row-cell", "placeholder"), style: g }, null);
		const { cellRenderer: y, dataKey: b, dataGetter: x } = t,
			_ = GQ(y) || v.default || ((e) => ri(l0, e, null)),
			w = CR(x) ? x({ columns: e, column: t, columnIndex: n, rowData: o, rowIndex: a }) : XS(o, null != b ? b : ""),
			C = jQ(h, { cellData: w, columns: e, column: t, columnIndex: n, rowIndex: a, rowData: o }),
			S = _({ class: c.e("cell-text"), columns: e, column: t, columnIndex: n, cellData: w, isScrolling: s, rowData: o, rowIndex: a }),
			E = [c.e("row-cell"), t.align === DQ.CENTER && c.is("align-center"), t.align === DQ.RIGHT && c.is("align-right")],
			T = a >= 0 && t.key === d,
			k = a >= 0 && u.includes(o[m]);
		let A;
		const M = `margin-inline-start: ${r * p}px;`;
		return T && (A = ER(i) ? ri(m0, hi(i, { class: [c.e("expand-icon"), c.is("expanded", k)], size: f, expanded: k, style: M, expandable: !0 }), null) : ri("div", { style: [M, `width: ${f}px; height: ${f}px;`].join(" ") }, null)), ri("div", hi({ class: E, style: g }, C), [A, S]);
	};
_0.inheritAttrs = !1;
const w0 = ({ columns: e, columnsStyles: t, headerIndex: n, style: r, headerClass: i, headerProps: s, ns: o }, { slots: a }) => {
		const l = { columns: e, headerIndex: n },
			h = [o.e("header-row"), jQ(i, l, ""), { [o.is("customized")]: Boolean(a.header) }],
			d = c(u({}, jQ(s, l)), { columnsStyles: t, class: h, columns: e, headerIndex: n, style: r });
		return ri(c0, d, "function" == typeof (p = a) || ("[object Object]" === Object.prototype.toString.call(p) && !Zr(p)) ? a : { default: () => [a] });
		var p;
	},
	C0 = (e, { slots: t }) => {
		const { column: n, ns: r, style: i, onColumnSorted: s } = e,
			o = WQ(i);
		if (n.placeholderSign === HQ) return ri("div", { class: r.em("header-row-cell", "placeholder"), style: o }, null);
		const { headerCellRenderer: a, headerClass: l, sortable: h } = n,
			d = c(u({}, e), { class: r.e("header-cell-text") }),
			p = (GQ(a) || t.default || ((e) => ri(u0, e, null)))(d),
			{ sortBy: f, sortState: m, headerCellProps: v } = e;
		let g, y;
		if (m) {
			const e = m[n.key];
			(g = Boolean(FQ[e])), (y = g ? e : NQ.ASC);
		} else (g = n.key === f.key), (y = g ? f.order : NQ.ASC);
		const b = [r.e("header-cell"), jQ(l, e, ""), n.align === DQ.CENTER && r.is("align-center"), n.align === DQ.RIGHT && r.is("align-right"), h && r.is("sortable")],
			x = c(u({}, jQ(v, e)), { onClick: n.sortable ? s : void 0, class: b, style: o, "data-key": n.key });
		return ri("div", x, [p, h && ri(f0, { class: [r.e("sort-icon"), g && r.is("sorting")], sortOrder: y }, null)]);
	},
	S0 = (e, { slots: t }) => {
		var n;
		return ri("div", { class: e.class, style: e.style }, [null == (n = t.default) ? void 0 : n.call(t)]);
	};
S0.displayName = "ElTableV2Footer";
const E0 = (e, { slots: t }) => ri("div", { class: e.class, style: e.style }, [t.default ? t.default() : ri(XY, null, null)]);
E0.displayName = "ElTableV2Empty";
const T0 = (e, { slots: t }) => {
	var n;
	return ri("div", { class: e.class, style: e.style }, [null == (n = t.default) ? void 0 : n.call(t)]);
};
function k0(e) {
	return "function" == typeof e || ("[object Object]" === Object.prototype.toString.call(e) && !Zr(e));
}
T0.displayName = "ElTableV2Overlay";
const A0 = Tn({
		name: "ElTableV2",
		props: a0,
		setup(e, { slots: t, expose: n }) {
			const r = BD("table-v2"),
				{
					columnsStyles: i,
					fixedColumnsOnLeft: s,
					fixedColumnsOnRight: o,
					mainColumns: a,
					mainTableHeight: l,
					fixedTableHeight: u,
					leftTableWidth: c,
					rightTableWidth: h,
					data: d,
					depthMap: p,
					expandedRowKeys: f,
					hasFixedColumns: m,
					hoveringRowKey: v,
					mainTableRef: g,
					leftTableRef: y,
					rightTableRef: b,
					isDynamic: x,
					isResetting: _,
					isScrolling: w,
					bodyWidth: C,
					emptyStyle: S,
					rootStyle: E,
					headerWidth: T,
					footerHeight: k,
					showEmpty: A,
					scrollTo: M,
					scrollToLeft: I,
					scrollToTop: R,
					scrollToRow: L,
					getRowHeight: O,
					onColumnSorted: P,
					onRowHeightChange: N,
					onRowHovered: D,
					onRowExpanded: B,
					onRowsRendered: F,
					onScroll: H,
					onVerticalScroll: V
				} = YQ(e);
			return (
				n({ scrollTo: M, scrollToLeft: I, scrollToTop: R, scrollToRow: L }),
				mn(XQ, { ns: r, isResetting: _, hoveringRowKey: v, isScrolling: w }),
				() => {
					const {
							cache: n,
							cellProps: _,
							estimatedRowHeight: w,
							expandColumnKey: M,
							fixedData: I,
							headerHeight: R,
							headerClass: L,
							headerProps: U,
							headerCellProps: z,
							sortBy: $,
							sortState: j,
							rowHeight: W,
							rowClass: G,
							rowEventHandlers: Y,
							rowKey: X,
							rowProps: K,
							scrollbarAlwaysOn: q,
							indentSize: Z,
							iconSize: J,
							useIsScrolling: Q,
							vScrollbarSize: ee,
							width: te
						} = e,
						ne = it(d),
						re = {
							cache: n,
							class: r.e("main"),
							columns: it(a),
							data: ne,
							fixedData: I,
							estimatedRowHeight: w,
							bodyWidth: it(C),
							headerHeight: R,
							headerWidth: it(T),
							height: it(l),
							mainTableRef: g,
							rowKey: X,
							rowHeight: W,
							scrollbarAlwaysOn: q,
							scrollbarStartGap: 2,
							scrollbarEndGap: ee,
							useIsScrolling: Q,
							width: te,
							getRowHeight: O,
							onRowsRendered: F,
							onScroll: H
						},
						ie = it(c),
						se = it(u),
						oe = {
							cache: n,
							class: r.e("left"),
							columns: it(s),
							data: ne,
							estimatedRowHeight: w,
							leftTableRef: y,
							rowHeight: W,
							bodyWidth: ie,
							headerWidth: ie,
							headerHeight: R,
							height: se,
							rowKey: X,
							scrollbarAlwaysOn: q,
							scrollbarStartGap: 2,
							scrollbarEndGap: ee,
							useIsScrolling: Q,
							width: ie,
							getRowHeight: O,
							onScroll: V
						},
						ae = it(h) + ee,
						le = {
							cache: n,
							class: r.e("right"),
							columns: it(o),
							data: ne,
							estimatedRowHeight: w,
							rightTableRef: b,
							rowHeight: W,
							bodyWidth: ae,
							headerWidth: ae,
							headerHeight: R,
							height: se,
							rowKey: X,
							scrollbarAlwaysOn: q,
							scrollbarStartGap: 2,
							scrollbarEndGap: ee,
							width: ae,
							style: `--${it(r.namespace)}-table-scrollbar-size: ${ee}px`,
							useIsScrolling: Q,
							getRowHeight: O,
							onScroll: V
						},
						ue = it(i),
						ce = {
							ns: r,
							depthMap: it(p),
							columnsStyles: ue,
							expandColumnKey: M,
							expandedRowKeys: it(f),
							estimatedRowHeight: w,
							hasFixedColumns: it(m),
							hoveringRowKey: it(v),
							rowProps: K,
							rowClass: G,
							rowKey: X,
							rowEventHandlers: Y,
							onRowHovered: D,
							onRowExpanded: B,
							onRowHeightChange: N
						},
						he = { cellProps: _, expandColumnKey: M, indentSize: Z, iconSize: J, rowKey: X, expandedRowKeys: it(f), ns: r },
						de = { ns: r, headerClass: L, headerProps: U, columnsStyles: ue },
						pe = { ns: r, sortBy: $, sortState: j, headerCellProps: z, onColumnSorted: P },
						fe = {
							row: (e) => ri(x0, hi(e, ce), { row: t.row, cell: (e) => (t.cell ? ri(_0, hi(e, he, { style: ue[e.column.key] }), { default: () => [t.cell] }) : ri(_0, hi(e, he, { style: ue[e.column.key] }), null)) }),
							header: (e) => ri(w0, hi(e, de), { header: t.header, cell: (e) => (t["header-cell"] ? ri(C0, hi(e, pe, { style: ue[e.column.key] }), { default: () => [t["header-cell"]] }) : ri(C0, hi(e, pe, { style: ue[e.column.key] }), null)) })
						},
						me = [e.class, r.b(), r.e("root"), { [r.is("dynamic")]: it(x) }],
						ve = { class: r.e("footer"), style: it(k) };
					return ri("div", { class: me, style: it(E) }, [
						ri(g0, re, k0(fe) ? fe : { default: () => [fe] }),
						ri(y0, oe, k0(fe) ? fe : { default: () => [fe] }),
						ri(b0, le, k0(fe) ? fe : { default: () => [fe] }),
						t.footer && ri(S0, ve, { default: t.footer }),
						it(A) && ri(E0, { class: r.e("empty"), style: it(S) }, { default: t.empty }),
						t.overlay && ri(T0, { class: r.e("overlay") }, { default: t.overlay })
					]);
				}
			);
		}
	}),
	M0 = Tn({
		name: "ElAutoResizer",
		props: uN({ disableWidth: Boolean, disableHeight: Boolean, onResize: { type: Function } }),
		setup(e, { slots: t }) {
			const n = BD("auto-resizer"),
				{
					height: r,
					width: i,
					sizer: s
				} = ((e) => {
					const t = Qe(),
						n = Qe(0),
						r = Qe(0);
					let i;
					return (
						Vn(() => {
							i = pR(t, ([e]) => {
								const { width: t, height: i } = e.contentRect,
									{ paddingLeft: s, paddingRight: o, paddingTop: a, paddingBottom: l } = getComputedStyle(e.target),
									u = Number.parseInt(s) || 0,
									c = Number.parseInt(o) || 0,
									h = Number.parseInt(a) || 0,
									d = Number.parseInt(l) || 0;
								(n.value = t - u - c), (r.value = i - h - d);
							}).stop;
						}),
						$n(() => {
							null == i || i();
						}),
						ds([n, r], ([t, n]) => {
							var r;
							null == (r = e.onResize) || r.call(e, { width: t, height: n });
						}),
						{ sizer: t, width: n, height: r }
					);
				})(e),
				o = { width: "100%", height: "100%" };
			return () => {
				var e;
				return ri("div", { ref: s, class: n.b(), style: o }, [null == (e = t.default) ? void 0 : e.call(t, { height: r.value, width: i.value })]);
			};
		}
	}),
	I0 = mN(A0),
	R0 = mN(M0),
	L0 = uN({ tabs: { type: Array, default: () => [] } });
var O0 = IB(
	Tn(
		c(u({}, { name: "ElTabBar" }), {
			props: L0,
			setup(e, { expose: t }) {
				const n = e,
					r = Si(),
					i = vn(JN);
				i || $R("ElTabBar", "<el-tabs><el-tab-bar /></el-tabs>");
				const s = BD("tabs"),
					o = Qe(),
					a = Qe(),
					l = () =>
						(a.value = (() => {
							let e = 0,
								t = 0;
							const s = ["top", "bottom"].includes(i.props.tabPosition) ? "width" : "height",
								o = "width" === s ? "x" : "y";
							return (
								n.tabs.every((i) => {
									var a, l, u, c;
									const h = null == (l = null == (a = r.parent) ? void 0 : a.refs) ? void 0 : l[`tab-${i.paneName}`];
									if (!h) return !1;
									if (!i.active) return !0;
									t = h[`client${DR(s)}`];
									const d = "x" === o ? "left" : "top";
									e = h.getBoundingClientRect()[d] - (null != (c = null == (u = h.parentElement) ? void 0 : u.getBoundingClientRect()[d]) ? c : 0);
									const p = window.getComputedStyle(h);
									return "width" === s && (n.tabs.length > 1 && (t -= Number.parseFloat(p.paddingLeft) + Number.parseFloat(p.paddingRight)), (e += Number.parseFloat(p.paddingLeft))), !1;
								}),
								{ [s]: `${t}px`, transform: `translate${DR(o)}(${e}px)` }
							);
						})());
				return (
					ds(
						() => n.tabs,
						async () => {
							await ns(), l();
						},
						{ immediate: !0 }
					),
					pR(o, () => l()),
					t({ ref: o, update: l }),
					(e, t) => (Wr(), Kr("div", { ref_key: "barRef", ref: o, class: gt([it(s).e("active-bar"), it(s).is(it(i).props.tabPosition)]), style: pt(a.value) }, null, 6))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]
);
const P0 = uN({
		panes: { type: Array, default: () => [] },
		currentName: { type: [String, Number], default: "" },
		editable: Boolean,
		onTabClick: { type: Function, default: yR },
		onTabRemove: { type: Function, default: yR },
		type: { type: String, values: ["card", "border-card", ""], default: "" },
		stretch: Boolean
	}),
	N0 = Tn({
		name: "ElTabNav",
		props: P0,
		setup(e, { expose: t }) {
			const n = Si(),
				r = vn(JN);
			r || $R("ElTabNav", "<el-tabs><tab-nav /></el-tabs>");
			const i = BD("tabs"),
				s = (function ({ document: e = rR } = {}) {
					if (!e) return Qe("visible");
					const t = Qe(e.visibilityState);
					return (
						iR(e, "visibilitychange", () => {
							t.value = e.visibilityState;
						}),
						t
					);
				})(),
				o = (function ({ window: e = nR } = {}) {
					if (!e) return Qe(!1);
					const t = Qe(e.document.hasFocus());
					return (
						iR(e, "blur", () => {
							t.value = !1;
						}),
						iR(e, "focus", () => {
							t.value = !0;
						}),
						t
					);
				})(),
				a = Qe(),
				l = Qe(),
				u = Qe(),
				c = Qe(!1),
				h = Qe(0),
				d = Qe(!1),
				p = Qe(!0),
				f = ht(() => (["top", "bottom"].includes(r.props.tabPosition) ? "width" : "height")),
				m = ht(() => ({ transform: `translate${"width" === f.value ? "X" : "Y"}(-${h.value}px)` })),
				v = () => {
					if (!a.value) return;
					const e = a.value[`offset${DR(f.value)}`],
						t = h.value;
					if (!t) return;
					const n = t > e ? t - e : 0;
					h.value = n;
				},
				g = () => {
					if (!a.value || !l.value) return;
					const e = l.value[`offset${DR(f.value)}`],
						t = a.value[`offset${DR(f.value)}`],
						n = h.value;
					if (e - n <= t) return;
					const r = e - n > 2 * t ? n + t : e - t;
					h.value = r;
				},
				y = () => {
					const e = l.value;
					if (!(c.value && u.value && a.value && e)) return;
					const t = u.value.querySelector(".is-active");
					if (!t) return;
					const n = a.value,
						i = ["top", "bottom"].includes(r.props.tabPosition),
						s = t.getBoundingClientRect(),
						o = n.getBoundingClientRect(),
						d = i ? e.offsetWidth - o.width : e.offsetHeight - o.height,
						p = h.value;
					let f = p;
					i ? (s.left < o.left && (f = p - (o.left - s.left)), s.right > o.right && (f = p + s.right - o.right)) : (s.top < o.top && (f = p - (o.top - s.top)), s.bottom > o.bottom && (f = p + (s.bottom - o.bottom))), (f = Math.max(f, 0)), (h.value = Math.min(f, d));
				},
				b = () => {
					if (!l.value || !a.value) return;
					const e = l.value[`offset${DR(f.value)}`],
						t = a.value[`offset${DR(f.value)}`],
						n = h.value;
					if (t < e) {
						const n = h.value;
						(c.value = c.value || {}), (c.value.prev = n), (c.value.next = n + t < e), e - n < t && (h.value = e - t);
					} else (c.value = !1), n > 0 && (h.value = 0);
				},
				x = (e) => {
					const t = e.code,
						{ up: n, down: r, left: i, right: s } = bN;
					if (![n, r, i, s].includes(t)) return;
					const o = Array.from(e.currentTarget.querySelectorAll("[role=tab]")),
						a = o.indexOf(e.target);
					let l;
					(l = t === i || t === n ? (0 === a ? o.length - 1 : a - 1) : a < o.length - 1 ? a + 1 : 0), o[l].focus(), o[l].click(), _();
				},
				_ = () => {
					p.value && (d.value = !0);
				},
				w = () => (d.value = !1);
			return (
				ds(s, (e) => {
					"hidden" === e ? (p.value = !1) : "visible" === e && setTimeout(() => (p.value = !0), 50);
				}),
				ds(o, (e) => {
					e ? setTimeout(() => (p.value = !0), 50) : (p.value = !1);
				}),
				pR(u, b),
				Vn(() => setTimeout(() => y(), 0)),
				zn(() => b()),
				t({ scrollToActiveTab: y, removeFocus: w }),
				ds(
					() => e.panes,
					() => n.update(),
					{ flush: "post" }
				),
				() => {
					const t = c.value
							? [
									ri("span", { class: [i.e("nav-prev"), i.is("disabled", !c.value.prev)], onClick: v }, [ri(OB, null, { default: () => [ri(uL, null, null)] })]),
									ri("span", { class: [i.e("nav-next"), i.is("disabled", !c.value.next)], onClick: g }, [ri(OB, null, { default: () => [ri(pL, null, null)] })])
							  ]
							: null,
						n = e.panes.map((t, n) => {
							var s, o;
							const a = t.props.name || t.index || `${n}`,
								l = t.isClosable || e.editable;
							t.index = `${n}`;
							const u = l ? ri(OB, { class: "is-icon-close", onClick: (n) => e.onTabRemove(t, n) }, { default: () => [ri(aO, null, null)] }) : null,
								c = (null == (o = (s = t.slots).label) ? void 0 : o.call(s)) || t.props.label,
								h = t.active ? 0 : -1;
							return ri(
								"div",
								{
									ref: `tab-${a}`,
									class: [i.e("item"), i.is(r.props.tabPosition), i.is("active", t.active), i.is("disabled", t.props.disabled), i.is("closable", l), i.is("focus", d.value)],
									id: `tab-${a}`,
									key: `tab-${a}`,
									"aria-controls": `pane-${a}`,
									role: "tab",
									"aria-selected": t.active,
									tabindex: h,
									onFocus: () => _(),
									onBlur: () => w(),
									onClick: (n) => {
										w(), e.onTabClick(t, a, n);
									},
									onKeydown: (n) => {
										!l || (n.code !== bN.delete && n.code !== bN.backspace) || e.onTabRemove(t, n);
									}
								},
								[c, u]
							);
						});
					return ri("div", { ref: u, class: [i.e("nav-wrap"), i.is("scrollable", !!c.value), i.is(r.props.tabPosition)] }, [
						t,
						ri("div", { class: i.e("nav-scroll"), ref: a }, [
							ri("div", { class: [i.e("nav"), i.is(r.props.tabPosition), i.is("stretch", e.stretch && ["top", "bottom"].includes(r.props.tabPosition))], ref: l, style: m.value, role: "tablist", onKeydown: x }, [e.type ? null : ri(O0, { tabs: [...e.panes] }, null), n])
						])
					]);
				}
			);
		}
	}),
	D0 = uN({
		type: { type: String, values: ["card", "border-card", ""], default: "" },
		activeName: { type: [String, Number], default: "" },
		closable: Boolean,
		addable: Boolean,
		modelValue: { type: [String, Number], default: "" },
		editable: Boolean,
		tabPosition: { type: String, values: ["top", "right", "bottom", "left"], default: "top" },
		beforeLeave: { type: Function, default: () => !0 },
		stretch: Boolean
	}),
	B0 = (e) => SR(e) || XI(e);
var F0 = Tn({
	name: "ElTabs",
	props: D0,
	emits: { [_N]: (e) => B0(e), "tab-click": (e, t) => t instanceof Event, "tab-change": (e) => B0(e), edit: (e, t) => ["remove", "add"].includes(t), "tab-remove": (e) => B0(e), "tab-add": () => !0 },
	setup(e, { emit: t, slots: n, expose: r }) {
		const i = BD("tabs"),
			s = Qe(),
			o = Fe({}),
			a = Qe(e.modelValue || e.activeName || "0"),
			l = async (n) => {
				var r, i, o;
				if (a.value !== n)
					try {
						!1 !== (await (null == (r = e.beforeLeave) ? void 0 : r.call(e, n, a.value))) &&
							(((e) => {
								(a.value = e), t(_N, e), t("tab-change", e);
							})(n),
							null == (o = null == (i = s.value) ? void 0 : i.removeFocus) || o.call(i));
					} catch (Kj) {}
			},
			u = (e, n, r) => {
				e.props.disabled || (l(n), t("tab-click", e, r));
			},
			c = (e, n) => {
				e.props.disabled || (n.stopPropagation(), t("edit", e.props.name, "remove"), t("tab-remove", e.props.name));
			},
			h = () => {
				t("edit", void 0, "add"), t("tab-add");
			};
		ds(
			() => e.activeName,
			(e) => l(e)
		),
			ds(
				() => e.modelValue,
				(e) => l(e)
			),
			ds(a, async () => {
				var e;
				null == (e = s.value) || e.scrollToActiveTab();
			});
		mn(JN, { props: e, currentName: a, registerPane: (e) => (o[e.uid] = e), unregisterPane: (e) => delete o[e] });
		return (
			r({ currentName: a }),
			() => {
				const t =
						e.editable || e.addable
							? ri(
									"span",
									{
										class: i.e("new-tab"),
										tabindex: "0",
										onClick: h,
										onKeydown: (e) => {
											e.code === bN.enter && h();
										}
									},
									[ri(OB, { class: i.is("icon-plus") }, { default: () => [ri(sP, null, null)] })]
							  )
							: null,
					r = ri("div", { class: [i.e("header"), i.is(e.tabPosition)] }, [t, ri(N0, { ref: s, currentName: a.value, editable: e.editable, type: e.type, panes: Object.values(o), stretch: e.stretch, onTabClick: u, onTabRemove: c }, null)]),
					l = ri("div", { class: i.e("content") }, [mi(n, "default")]);
				return ri("div", { class: [i.b(), i.m(e.tabPosition), { [i.m("card")]: "card" === e.type, [i.m("border-card")]: "border-card" === e.type }] }, [...("bottom" !== e.tabPosition ? [r, l] : [l, r])]);
			}
		);
	}
});
const H0 = uN({ label: { type: String, default: "" }, name: { type: [String, Number], default: "" }, closable: Boolean, disabled: Boolean, lazy: Boolean }),
	V0 = ["id", "aria-hidden", "aria-labelledby"];
var U0 = IB(
	Tn(
		c(u({}, { name: "ElTabPane" }), {
			props: H0,
			setup(e) {
				const t = e,
					n = Si(),
					r = gs(),
					i = vn(JN);
				i || $R("ElTabPane", "usage: <el-tabs><el-tab-pane /></el-tabs/>");
				const s = BD("tab-pane"),
					o = Qe(),
					a = ht(() => t.closable || i.props.closable),
					l = jI(() => i.currentName.value === (t.name || o.value)),
					u = Qe(l.value),
					c = ht(() => t.name || o.value),
					h = jI(() => !t.lazy || u.value || l.value);
				ds(l, (e) => {
					e && (u.value = !0);
				});
				const d = Fe({ uid: n.uid, slots: r, props: t, paneName: c, active: l, index: o, isClosable: a });
				return (
					Vn(() => {
						i.registerPane(d);
					}),
					jn(() => {
						i.unregisterPane(d.uid);
					}),
					(e, t) => (it(h) ? yr((Wr(), Kr("div", { key: 0, id: `pane-${it(c)}`, class: gt(it(s).b()), role: "tabpanel", "aria-hidden": !it(l), "aria-labelledby": `tab-${it(c)}` }, [mi(e.$slots, "default")], 10, V0)), [[Wo, it(l)]]) : ai("v-if", !0))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]
);
const z0 = mN(F0, { TabPane: U0 }),
	$0 = gN(U0),
	j0 = uN({
		format: { type: String, default: "HH:mm" },
		modelValue: String,
		disabled: Boolean,
		editable: { type: Boolean, default: !0 },
		effect: { type: String, default: "light" },
		clearable: { type: Boolean, default: !0 },
		size: cD,
		placeholder: String,
		start: { type: String, default: "09:00" },
		end: { type: String, default: "18:00" },
		step: { type: String, default: "00:30" },
		minTime: String,
		maxTime: String,
		name: String,
		prefixIcon: { type: [String, Object], default: () => rO },
		clearIcon: { type: [String, Object], default: () => QL }
	}),
	W0 = (e) => {
		const t = (e || "").split(":");
		if (t.length >= 2) {
			let n = Number.parseInt(t[0], 10);
			const r = Number.parseInt(t[1], 10),
				i = e.toUpperCase();
			return i.includes("AM") && 12 === n ? (n = 0) : i.includes("PM") && 12 !== n && (n += 12), { hours: n, minutes: r };
		}
		return null;
	},
	G0 = (e, t) => {
		const n = W0(e);
		if (!n) return -1;
		const r = W0(t);
		if (!r) return -1;
		const i = n.minutes + 60 * n.hours,
			s = r.minutes + 60 * r.hours;
		return i === s ? 0 : i > s ? 1 : -1;
	},
	Y0 = (e) => `${e}`.padStart(2, "0"),
	X0 = (e) => `${Y0(e.hours)}:${Y0(e.minutes)}`,
	K0 = (e, t) => {
		const n = W0(e);
		if (!n) return "";
		const r = W0(t);
		if (!r) return "";
		const i = { hours: n.hours, minutes: n.minutes };
		return (i.minutes += r.minutes), (i.hours += r.hours), (i.hours += Math.floor(i.minutes / 60)), (i.minutes = i.minutes % 60), X0(i);
	};
var q0 = IB(
	Tn(
		c(u({}, { name: "ElTimeSelect" }), {
			props: j0,
			emits: ["change", "blur", "focus", "update:modelValue"],
			setup(e, { expose: t }) {
				const n = e;
				QV.extend(rU);
				const { Option: r } = RK,
					i = BD("input"),
					s = Qe(),
					o = ht(() => n.modelValue),
					a = ht(() => {
						const e = W0(n.start);
						return e ? X0(e) : null;
					}),
					l = ht(() => {
						const e = W0(n.end);
						return e ? X0(e) : null;
					}),
					u = ht(() => {
						const e = W0(n.step);
						return e ? X0(e) : null;
					}),
					c = ht(() => {
						const e = W0(n.minTime || "");
						return e ? X0(e) : null;
					}),
					h = ht(() => {
						const e = W0(n.maxTime || "");
						return e ? X0(e) : null;
					}),
					d = ht(() => {
						const e = [];
						if (n.start && n.end && n.step) {
							let t,
								r = a.value;
							for (; r && l.value && G0(r, l.value) <= 0; ) (t = QV(r, "HH:mm").format(n.format)), e.push({ value: t, disabled: G0(r, c.value || "-1:-1") <= 0 || G0(r, h.value || "100:100") >= 0 }), (r = K0(r, u.value));
						}
						return e;
					});
				return (
					t({
						blur: () => {
							var e, t;
							null == (t = null == (e = s.value) ? void 0 : e.blur) || t.call(e);
						},
						focus: () => {
							var e, t;
							null == (t = null == (e = s.value) ? void 0 : e.focus) || t.call(e);
						}
					}),
					(e, t) => (
						Wr(),
						qr(
							it(RK),
							{
								ref_key: "select",
								ref: s,
								"model-value": it(o),
								disabled: e.disabled,
								clearable: e.clearable,
								"clear-icon": e.clearIcon,
								size: e.size,
								effect: e.effect,
								placeholder: e.placeholder,
								"default-first-option": "",
								filterable: e.editable,
								"onUpdate:modelValue": t[0] || (t[0] = (t) => e.$emit("update:modelValue", t)),
								onChange: t[1] || (t[1] = (t) => e.$emit("change", t)),
								onBlur: t[2] || (t[2] = (t) => e.$emit("blur", t)),
								onFocus: t[3] || (t[3] = (t) => e.$emit("focus", t))
							},
							{
								prefix: cn(() => [e.prefixIcon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(i).e("prefix-icon")) }, { default: cn(() => [(Wr(), qr(Nr(e.prefixIcon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)]),
								default: cn(() => [
									(Wr(!0),
									Kr(
										Hr,
										null,
										pi(it(d), (e) => (Wr(), qr(it(r), { key: e.value, label: e.value, value: e.value, disabled: e.disabled }, null, 8, ["label", "value", "disabled"]))),
										128
									))
								]),
								_: 1
							},
							8,
							["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]
);
q0.install = (e) => {
	e.component(q0.name, q0);
};
const Z0 = q0,
	J0 = Tn({
		name: "ElTimeline",
		setup(e, { slots: t }) {
			const n = BD("timeline");
			return mn("timeline", t), () => xs("ul", { class: [n.b()] }, [mi(t, "default")]);
		}
	}),
	Q0 = uN({
		timestamp: { type: String, default: "" },
		hideTimestamp: { type: Boolean, default: !1 },
		center: { type: Boolean, default: !1 },
		placement: { type: String, values: ["top", "bottom"], default: "bottom" },
		type: { type: String, values: ["primary", "success", "warning", "danger", "info"], default: "" },
		color: { type: String, default: "" },
		size: { type: String, values: ["normal", "large"], default: "normal" },
		icon: { type: cN, default: "" },
		hollow: { type: Boolean, default: !1 }
	});
var e1 = IB(
	Tn(
		c(u({}, { name: "ElTimelineItem" }), {
			props: Q0,
			setup(e) {
				const t = BD("timeline-item");
				return (e, n) => (
					Wr(),
					Kr(
						"li",
						{ class: gt([it(t).b(), { [it(t).e("center")]: e.center }]) },
						[
							ni("div", { class: gt(it(t).e("tail")) }, null, 2),
							e.$slots.dot
								? ai("v-if", !0)
								: (Wr(),
								  Kr(
										"div",
										{ key: 0, class: gt([it(t).e("node"), it(t).em("node", e.size || ""), it(t).em("node", e.type || ""), it(t).is("hollow", e.hollow)]), style: pt({ backgroundColor: e.color }) },
										[e.icon ? (Wr(), qr(it(OB), { key: 0, class: gt(it(t).e("icon")) }, { default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0)],
										6
								  )),
							e.$slots.dot ? (Wr(), Kr("div", { key: 1, class: gt(it(t).e("dot")) }, [mi(e.$slots, "dot")], 2)) : ai("v-if", !0),
							ni(
								"div",
								{ class: gt(it(t).e("wrapper")) },
								[
									e.hideTimestamp || "top" !== e.placement ? ai("v-if", !0) : (Wr(), Kr("div", { key: 0, class: gt([it(t).e("timestamp"), it(t).is("top")]) }, bt(e.timestamp), 3)),
									ni("div", { class: gt(it(t).e("content")) }, [mi(e.$slots, "default")], 2),
									e.hideTimestamp || "bottom" !== e.placement ? ai("v-if", !0) : (Wr(), Kr("div", { key: 1, class: gt([it(t).e("timestamp"), it(t).is("bottom")]) }, bt(e.timestamp), 3))
								],
								2
							)
						],
						2
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]
);
const t1 = mN(J0, { TimelineItem: e1 }),
	n1 = gN(e1),
	r1 = uN({ nowrap: Boolean });
var i1 = ((e) => ((e.top = "top"), (e.bottom = "bottom"), (e.left = "left"), (e.right = "right"), e))(i1 || {});
const s1 = Object.values(i1),
	o1 = uN({ width: { type: Number, default: 10 }, height: { type: Number, default: 10 }, style: { type: Object, default: null } }),
	a1 = uN({ side: { type: String, values: s1, required: !0 } }),
	l1 = uN({
		ariaLabel: String,
		arrowPadding: { type: Number, default: 5 },
		effect: { type: String, default: "" },
		contentClass: String,
		placement: { type: String, values: ["top-start", "top-end", "top", "bottom-start", "bottom-end", "bottom", "left-start", "left-end", "left", "right-start", "right-end", "right"], default: "bottom" },
		reference: { type: Object, default: null },
		offset: { type: Number, default: 8 },
		strategy: { type: String, values: ["absolute", "fixed"], default: "absolute" },
		showArrow: { type: Boolean, default: !1 }
	}),
	u1 = uN({ delayDuration: { type: Number, default: 300 }, defaultOpen: Boolean, open: { type: Boolean, default: void 0 }, onOpenChange: { type: Function }, "onUpdate:open": { type: Function } }),
	c1 = { type: Function },
	h1 = uN({ onBlur: c1, onClick: c1, onFocus: c1, onMouseDown: c1, onMouseEnter: c1, onMouseLeave: c1 }),
	d1 = uN(c(u(u(u(u({}, u1), o1), h1), l1), { alwaysOn: Boolean, fullTransition: Boolean, transitionProps: { type: Object, default: null }, teleported: Boolean, to: { type: String, default: "body" } }));
var p1 = IB(
	Tn(
		c(u({}, { name: "ElTooltipV2Root" }), {
			props: u1,
			setup(e, { expose: t }) {
				const n = e,
					r = Qe(n.defaultOpen),
					i = Qe(null),
					s = ht({
						get: () => (ik(n.open) ? r.value : n.open),
						set: (e) => {
							var t;
							(r.value = e), null == (t = n["onUpdate:open"]) || t.call(n, e);
						}
					}),
					o = ht(() => XI(n.delayDuration) && n.delayDuration > 0),
					{ start: a, stop: l } = eR(
						() => {
							s.value = !0;
						},
						ht(() => n.delayDuration),
						{ immediate: !1 }
					),
					u = BD("tooltip-v2"),
					c = gD(),
					h = () => {
						l(), (s.value = !0);
					},
					d = h,
					p = () => {
						l(), (s.value = !1);
					};
				return (
					ds(s, (e) => {
						var t;
						e && (document.dispatchEvent(new CustomEvent("tooltip_v2.open")), d()), null == (t = n.onOpenChange) || t.call(n, e);
					}),
					Vn(() => {
						document.addEventListener("tooltip_v2.open", p);
					}),
					$n(() => {
						l(), document.removeEventListener("tooltip_v2.open", p);
					}),
					mn(nD, {
						contentId: c,
						triggerRef: i,
						ns: u,
						onClose: p,
						onDelayOpen: () => {
							it(o) ? a() : h();
						},
						onOpen: d
					}),
					t({ onOpen: d, onClose: p }),
					(e, t) => mi(e.$slots, "default", { open: it(s) })
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]
);
var f1 = IB(
	Tn(
		c(u({}, { name: "ElTooltipV2Arrow" }), {
			props: u(u({}, o1), a1),
			setup(e) {
				const t = e,
					{ ns: n } = vn(nD),
					{ arrowRef: r } = vn(rD),
					i = ht(() => {
						const { style: e, width: r, height: i } = t,
							s = n.namespace.value;
						return u({ [`--${s}-tooltip-v2-arrow-width`]: `${r}px`, [`--${s}-tooltip-v2-arrow-height`]: `${i}px`, [`--${s}-tooltip-v2-arrow-border-width`]: r / 2 + "px", [`--${s}-tooltip-v2-arrow-cover-width`]: r / 2 - 1 }, e || {});
					});
				return (e, t) => (Wr(), Kr("span", { ref_key: "arrowRef", ref: r, style: pt(it(i)), class: gt(it(n).e("arrow")) }, null, 6));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]
);
var m1 = IB(
	Tn({
		name: "ElVisuallyHidden",
		props: { style: { type: [String, Object, Array] } },
		setup: (e) => ({ computedStyle: ht(() => [e.style, { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }]) })
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				return Wr(), Kr("span", hi(e.$attrs, { style: e.computedStyle }), [mi(e.$slots, "default")], 16);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]
	]
);
const v1 = ["data-side"];
var g1 = IB(
	Tn(
		c(u({}, { name: "ElTooltipV2Content" }), {
			props: u(u({}, l1), r1),
			setup(e) {
				const t = e,
					{ triggerRef: n, contentId: r } = vn(nD),
					i = Qe(t.placement),
					s = Qe(t.strategy),
					o = Qe(null),
					{
						referenceRef: a,
						contentRef: l,
						middlewareData: u,
						x: c,
						y: h,
						update: d
					} = kB({
						placement: i,
						strategy: s,
						middleware: ht(() => {
							const e = [qD(t.offset)];
							return (
								t.showArrow &&
									e.push(
										(({ arrowRef: e, padding: t }) => ({
											name: "arrow",
											options: { element: e, padding: t },
											fn(n) {
												const r = it(e);
												return r ? KD({ element: r, padding: t }).fn(n) : {};
											}
										}))({ arrowRef: o })
									),
								e
							);
						})
					}),
					p = HD().nextZIndex(),
					f = BD("tooltip-v2"),
					m = ht(() => i.value.split("-")[0]),
					v = ht(() => ({ position: it(s), top: `${it(h) || 0}px`, left: `${it(c) || 0}px`, zIndex: p })),
					g = ht(() => {
						if (!t.showArrow) return {};
						const { arrow: e } = it(u);
						return { [`--${f.namespace.value}-tooltip-v2-arrow-x`]: `${null == e ? void 0 : e.x}px` || "", [`--${f.namespace.value}-tooltip-v2-arrow-y`]: `${null == e ? void 0 : e.y}px` || "" };
					}),
					y = ht(() => [f.e("content"), f.is("dark", "dark" === t.effect), f.is(it(s)), t.contentClass]);
				return (
					ds(o, () => d()),
					ds(
						() => t.placement,
						(e) => (i.value = e)
					),
					Vn(() => {
						ds(
							() => t.reference || n.value,
							(e) => {
								a.value = e || void 0;
							},
							{ immediate: !0 }
						);
					}),
					mn(rD, { arrowRef: o }),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ ref_key: "contentRef", ref: l, style: pt(it(v)), "data-tooltip-v2-root": "" },
							[
								e.nowrap
									? ai("v-if", !0)
									: (Wr(),
									  Kr(
											"div",
											{ key: 0, "data-side": it(m), class: gt(it(y)) },
											[
												mi(e.$slots, "default", { contentStyle: it(v), contentClass: it(y) }),
												ri(it(m1), { id: it(r), role: "tooltip" }, { default: cn(() => [e.ariaLabel ? (Wr(), Kr(Hr, { key: 0 }, [oi(bt(e.ariaLabel), 1)], 64)) : mi(e.$slots, "default", { key: 1 })]), _: 3 }, 8, ["id"]),
												mi(e.$slots, "arrow", { style: pt(it(g)), side: it(m) })
											],
											10,
											v1
									  ))
							],
							4
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]
);
var y1 = Tn({
	props: uN({ setRef: { type: Function, required: !0 }, onlyChild: Boolean }),
	setup(e, { slots: t }) {
		const n = Qe(),
			r = yN(n, (t) => {
				t ? e.setRef(t.nextElementSibling) : e.setRef(null);
			});
		return () => {
			var n;
			const [i] = (null == (n = t.default) ? void 0 : n.call(t)) || [],
				s = e.onlyChild
					? ((e) => {
							if (!_R(e) || e.length > 1) throw new Error("expect to receive a single Vue element child");
							return e[0];
					  })(i.children)
					: i.children;
			return ri(Hr, { ref: r }, [s]);
		};
	}
});
var b1 = IB(
	Tn(
		c(u({}, { name: "ElTooltipV2Trigger" }), {
			props: u(u({}, r1), h1),
			setup(e) {
				const t = e,
					{ onClose: n, onOpen: r, onDelayOpen: i, triggerRef: s, contentId: o } = vn(nD);
				let a = !1;
				const l = (e) => {
						s.value = e;
					},
					u = () => {
						a = !1;
					},
					c = PI(t.onMouseEnter, i),
					h = PI(t.onMouseLeave, n),
					d = PI(t.onMouseDown, () => {
						n(), (a = !0), document.addEventListener("mouseup", u, { once: !0 });
					}),
					p = PI(t.onFocus, () => {
						a || r();
					}),
					f = {
						blur: PI(t.onBlur, n),
						click: PI(t.onClick, (e) => {
							0 === e.detail && n();
						}),
						focus: p,
						mousedown: d,
						mouseenter: c,
						mouseleave: h
					},
					m = (e, t, n) => {
						e &&
							Object.entries(t).forEach(([t, r]) => {
								e[n](t, r);
							});
					};
				return (
					ds(s, (e, t) => {
						m(e, f, "addEventListener"), m(t, f, "removeEventListener"), e && e.setAttribute("aria-describedby", o.value);
					}),
					$n(() => {
						m(s.value, f, "removeEventListener"), document.removeEventListener("mouseup", u);
					}),
					(e, t) => (e.nowrap ? (Wr(), qr(it(y1), { key: 0, "set-ref": l, "only-child": "" }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 })) : (Wr(), Kr("button", hi({ key: 1, ref_key: "triggerRef", ref: s }, e.$attrs), [mi(e.$slots, "default")], 16)))
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]
);
const x1 = mN(
		IB(
			Tn(
				c(u({}, { name: "ElTooltipV2" }), {
					props: d1,
					setup(e) {
						const t = at(e),
							n = Fe(ck(t, Object.keys(o1))),
							r = Fe(ck(t, Object.keys(l1))),
							i = Fe(ck(t, Object.keys(u1))),
							s = Fe(ck(t, Object.keys(h1)));
						return (e, t) => (
							Wr(),
							qr(
								p1,
								yt(ii(i)),
								{
									default: cn(({ open: t }) => [
										ri(b1, hi(s, { nowrap: "" }), { default: cn(() => [mi(e.$slots, "trigger")]), _: 3 }, 16),
										(Wr(),
										qr(
											Lr,
											{ to: e.to, disabled: !e.teleported },
											[
												e.fullTransition
													? (Wr(),
													  qr(
															lo,
															yt(hi({ key: 0 }, e.transitionProps)),
															{
																default: cn(() => [
																	e.alwaysOn || t
																		? (Wr(),
																		  qr(
																				g1,
																				yt(hi({ key: 0 }, r)),
																				{ arrow: cn(({ style: t, side: r }) => [e.showArrow ? (Wr(), qr(f1, hi({ key: 0 }, n, { style: t, side: r }), null, 16, ["style", "side"])) : ai("v-if", !0)]), default: cn(() => [mi(e.$slots, "default")]), _: 3 },
																				16
																		  ))
																		: ai("v-if", !0)
																]),
																_: 2
															},
															1040
													  ))
													: (Wr(),
													  Kr(
															Hr,
															{ key: 1 },
															[
																e.alwaysOn || t
																	? (Wr(),
																	  qr(
																			g1,
																			yt(hi({ key: 0 }, r)),
																			{ arrow: cn(({ style: t, side: r }) => [e.showArrow ? (Wr(), qr(f1, hi({ key: 0 }, n, { style: t, side: r }), null, 16, ["style", "side"])) : ai("v-if", !0)]), default: cn(() => [mi(e.$slots, "default")]), _: 3 },
																			16
																	  ))
																	: ai("v-if", !0)
															],
															64
													  ))
											],
											8,
											["to", "disabled"]
										))
									]),
									_: 3
								},
								16
							)
						);
					}
				})
			),
			[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]
		)
	),
	_1 = { data: { type: Array, default: () => [] }, optionRender: Function, placeholder: String, title: String, filterable: Boolean, format: Object, filterMethod: Function, defaultChecked: Array, props: Object },
	w1 = Tn({
		name: "ElTransferPanel",
		components: { ElCheckboxGroup: Jz, ElCheckbox: qz, ElInput: WB, OptionContent: ({ option: e }) => e },
		props: _1,
		emits: ["checked-change"],
		setup(e, { slots: t }) {
			const { t: n } = CD(),
				r = BD("transfer"),
				i = Fe({ checked: [], allChecked: !1, query: "", inputHover: !1, checkChangeByUser: !0 }),
				{
					labelProp: s,
					keyProp: o,
					disabledProp: a,
					filteredData: l,
					checkedSummary: u,
					isIndeterminate: c,
					handleAllCheckedChange: h
				} = ((e, t) => {
					const { emit: n } = Si(),
						r = ht(() => e.props.label || "label"),
						i = ht(() => e.props.key || "key"),
						s = ht(() => e.props.disabled || "disabled"),
						o = ht(() => e.data.filter((n) => ("function" == typeof e.filterMethod ? e.filterMethod(t.query, n) : (n[r.value] || n[i.value].toString()).toLowerCase().includes(t.query.toLowerCase())))),
						a = ht(() => o.value.filter((e) => !e[s.value])),
						l = ht(() => {
							const n = t.checked.length,
								r = e.data.length,
								{ noChecked: i, hasChecked: s } = e.format;
							return i && s ? (n > 0 ? s.replace(/\${checked}/g, n.toString()).replace(/\${total}/g, r.toString()) : i.replace(/\${total}/g, r.toString())) : `${n}/${r}`;
						}),
						u = ht(() => {
							const e = t.checked.length;
							return e > 0 && e < a.value.length;
						}),
						c = () => {
							const e = a.value.map((e) => e[i.value]);
							t.allChecked = e.length > 0 && e.every((e) => t.checked.includes(e));
						};
					return (
						ds(
							() => t.checked,
							(e, r) => {
								if ((c(), t.checkChangeByUser)) {
									const t = e.concat(r).filter((t) => !e.includes(t) || !r.includes(t));
									n("checked-change", e, t);
								} else n("checked-change", e), (t.checkChangeByUser = !0);
							}
						),
						ds(a, () => {
							c();
						}),
						ds(
							() => e.data,
							() => {
								const e = [],
									n = o.value.map((e) => e[i.value]);
								t.checked.forEach((t) => {
									n.includes(t) && e.push(t);
								}),
									(t.checkChangeByUser = !1),
									(t.checked = e);
							}
						),
						ds(
							() => e.defaultChecked,
							(e, n) => {
								if (n && e.length === n.length && e.every((e) => n.includes(e))) return;
								const r = [],
									s = a.value.map((e) => e[i.value]);
								e.forEach((e) => {
									s.includes(e) && r.push(e);
								}),
									(t.checkChangeByUser = !1),
									(t.checked = r);
							},
							{ immediate: !0 }
						),
						{
							labelProp: r,
							keyProp: i,
							disabledProp: s,
							filteredData: o,
							checkableData: a,
							checkedSummary: l,
							isIndeterminate: u,
							updateAllChecked: c,
							handleAllCheckedChange: (e) => {
								t.checked = e ? a.value.map((e) => e[i.value]) : [];
							}
						}
					);
				})(e, i),
				d = ht(() => i.query.length > 0 && 0 === l.value.length),
				p = ht(() => !!t.default()[0].children.length),
				{ checked: f, allChecked: m, query: v, inputHover: g, checkChangeByUser: y } = at(i);
			return { ns: r, labelProp: s, keyProp: o, disabledProp: a, filteredData: l, checkedSummary: u, isIndeterminate: c, handleAllCheckedChange: h, checked: f, allChecked: m, query: v, inputHover: g, checkChangeByUser: y, hasNoMatch: d, SearchIcon: EP, hasFooter: p, t: n };
		}
	});
const C1 = Tn({
		name: "ElTransfer",
		components: {
			TransferPanel: IB(w1, [
				[
					"render",
					function (e, t, n, r, i, s) {
						const o = Or("el-checkbox"),
							a = Or("el-input"),
							l = Or("option-content"),
							u = Or("el-checkbox-group");
						return (
							Wr(),
							Kr(
								"div",
								{ class: gt(e.ns.b("panel")) },
								[
									ni(
										"p",
										{ class: gt(e.ns.be("panel", "header")) },
										[
											ri(
												o,
												{ modelValue: e.allChecked, "onUpdate:modelValue": t[0] || (t[0] = (t) => (e.allChecked = t)), indeterminate: e.isIndeterminate, onChange: e.handleAllCheckedChange },
												{ default: cn(() => [oi(bt(e.title) + " ", 1), ni("span", null, bt(e.checkedSummary), 1)]), _: 1 },
												8,
												["modelValue", "indeterminate", "onChange"]
											)
										],
										2
									),
									ni(
										"div",
										{ class: gt([e.ns.be("panel", "body"), e.ns.is("with-footer", e.hasFooter)]) },
										[
											e.filterable
												? (Wr(),
												  qr(
														a,
														{
															key: 0,
															modelValue: e.query,
															"onUpdate:modelValue": t[1] || (t[1] = (t) => (e.query = t)),
															class: gt(e.ns.be("panel", "filter")),
															size: "default",
															placeholder: e.placeholder,
															"prefix-icon": e.SearchIcon,
															clearable: "",
															onMouseenter: t[2] || (t[2] = (t) => (e.inputHover = !0)),
															onMouseleave: t[3] || (t[3] = (t) => (e.inputHover = !1))
														},
														null,
														8,
														["modelValue", "class", "placeholder", "prefix-icon"]
												  ))
												: ai("v-if", !0),
											yr(
												ri(
													u,
													{ modelValue: e.checked, "onUpdate:modelValue": t[4] || (t[4] = (t) => (e.checked = t)), class: gt([e.ns.is("filterable", e.filterable), e.ns.be("panel", "list")]) },
													{
														default: cn(() => [
															(Wr(!0),
															Kr(
																Hr,
																null,
																pi(
																	e.filteredData,
																	(t) => (
																		Wr(),
																		qr(o, { key: t[e.keyProp], class: gt(e.ns.be("panel", "item")), label: t[e.keyProp], disabled: t[e.disabledProp] }, { default: cn(() => [ri(l, { option: e.optionRender(t) }, null, 8, ["option"])]), _: 2 }, 1032, [
																			"class",
																			"label",
																			"disabled"
																		])
																	)
																),
																128
															))
														]),
														_: 1
													},
													8,
													["modelValue", "class"]
												),
												[[Wo, !e.hasNoMatch && e.data.length > 0]]
											),
											yr(ni("p", { class: gt(e.ns.be("panel", "empty")) }, bt(e.hasNoMatch ? e.t("el.transfer.noMatch") : e.t("el.transfer.noData")), 3), [[Wo, e.hasNoMatch || 0 === e.data.length]])
										],
										2
									),
									e.hasFooter ? (Wr(), Kr("p", { key: 0, class: gt(e.ns.be("panel", "footer")) }, [mi(e.$slots, "default")], 2)) : ai("v-if", !0)
								],
								2
							)
						);
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]
			]),
			ElButton: qV,
			ElIcon: OB,
			ArrowLeft: uL,
			ArrowRight: pL
		},
		props: {
			data: { type: Array, default: () => [] },
			titles: { type: Array, default: () => [] },
			buttonTexts: { type: Array, default: () => [] },
			filterPlaceholder: { type: String, default: "" },
			filterMethod: Function,
			leftDefaultChecked: { type: Array, default: () => [] },
			rightDefaultChecked: { type: Array, default: () => [] },
			renderContent: Function,
			modelValue: { type: Array, default: () => [] },
			format: { type: Object, default: () => ({}) },
			filterable: { type: Boolean, default: !1 },
			props: { type: Object, default: () => ({ label: "label", key: "key", disabled: "disabled" }) },
			targetOrder: { type: String, default: "original", validator: (e) => ["original", "push", "unshift"].includes(e) }
		},
		emits: [_N, "change", "left-check-change", "right-check-change"],
		setup(e, { emit: t, slots: n }) {
			const { t: r } = CD(),
				i = BD("transfer"),
				s = vn(YN, {}),
				o = Fe({ leftChecked: [], rightChecked: [] }),
				{
					propsKey: a,
					sourceData: l,
					targetData: h
				} = ((e) => {
					const t = ht(() => e.props.key),
						n = ht(() => e.data.reduce((e, n) => (e[n[t.value]] = n) && e, {})),
						r = ht(() => e.data.filter((n) => !e.modelValue.includes(n[t.value]))),
						i = ht(() =>
							"original" === e.targetOrder
								? e.data.filter((n) => e.modelValue.includes(n[t.value]))
								: e.modelValue.reduce((e, t) => {
										const r = n.value[t];
										return r && e.push(r), e;
								  }, [])
						);
					return { propsKey: t, sourceData: r, targetData: i };
				})(e),
				{ onSourceCheckedChange: d, onTargetCheckedChange: p } = ((e, t) => ({
					onSourceCheckedChange: (n, r) => {
						(e.leftChecked = n), void 0 !== r && t("left-check-change", n, r);
					},
					onTargetCheckedChange: (n, r) => {
						(e.rightChecked = n), void 0 !== r && t("right-check-change", n, r);
					}
				}))(o, t),
				{ addToLeft: f, addToRight: m } = ((e, t, n, r) => {
					const i = (e, t, n) => {
						r(_N, e), r("change", e, t, n);
					};
					return {
						addToLeft: () => {
							const n = e.modelValue.slice();
							t.rightChecked.forEach((e) => {
								const t = n.indexOf(e);
								t > -1 && n.splice(t, 1);
							}),
								i(n, "left", t.rightChecked);
						},
						addToRight: () => {
							let r = e.modelValue.slice();
							const s = e.data
								.filter((r) => {
									const i = r[n.value];
									return t.leftChecked.includes(i) && !e.modelValue.includes(i);
								})
								.map((e) => e[n.value]);
							(r = "unshift" === e.targetOrder ? s.concat(r) : r.concat(s)), "original" === e.targetOrder && (r = e.data.filter((e) => r.includes(e[n.value])).map((e) => e[n.value])), i(r, "right", t.leftChecked);
						}
					};
				})(e, o, a, t),
				v = Qe(),
				g = Qe(),
				y = ht(() => 2 === e.buttonTexts.length),
				b = ht(() => e.titles[0] || r("el.transfer.titles.0")),
				x = ht(() => e.titles[1] || r("el.transfer.titles.1")),
				_ = ht(() => e.filterPlaceholder || r("el.transfer.filterPlaceholder"));
			ds(
				() => e.modelValue,
				() => {
					var e;
					null == (e = s.validate) || e.call(s, "change").catch((e) => {});
				}
			);
			const w = ht(() => (t) => e.renderContent ? e.renderContent(xs, t) : n.default ? n.default({ option: t }) : xs("span", t[e.props.label] || t[e.props.key]));
			return c(u({ ns: i, sourceData: l, targetData: h, onSourceCheckedChange: d, onTargetCheckedChange: p, addToLeft: f, addToRight: m }, at(o)), {
				hasButtonTexts: y,
				leftPanelTitle: b,
				rightPanelTitle: x,
				panelFilterPlaceholder: _,
				clearQuery: (e) => {
					switch (e) {
						case "left":
							v.value.query = "";
							break;
						case "right":
							g.value.query = "";
					}
				},
				leftPanel: v,
				rightPanel: g,
				optionRender: w
			});
		}
	}),
	S1 = { key: 0 },
	E1 = { key: 0 };
var T1 = IB(C1, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("transfer-panel"),
				a = Or("arrow-left"),
				l = Or("el-icon"),
				u = Or("el-button"),
				c = Or("arrow-right");
			return (
				Wr(),
				Kr(
					"div",
					{ class: gt(e.ns.b()) },
					[
						ri(
							o,
							{
								ref: "leftPanel",
								data: e.sourceData,
								"option-render": e.optionRender,
								placeholder: e.panelFilterPlaceholder,
								title: e.leftPanelTitle,
								filterable: e.filterable,
								format: e.format,
								"filter-method": e.filterMethod,
								"default-checked": e.leftDefaultChecked,
								props: e.props,
								onCheckedChange: e.onSourceCheckedChange
							},
							{ default: cn(() => [mi(e.$slots, "left-footer")]), _: 3 },
							8,
							["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]
						),
						ni(
							"div",
							{ class: gt(e.ns.e("buttons")) },
							[
								ri(
									u,
									{ type: "primary", class: gt([e.ns.e("button"), e.ns.is("with-texts", e.hasButtonTexts)]), disabled: 0 === e.rightChecked.length, onClick: e.addToLeft },
									{ default: cn(() => [ri(l, null, { default: cn(() => [ri(a)]), _: 1 }), void 0 !== e.buttonTexts[0] ? (Wr(), Kr("span", S1, bt(e.buttonTexts[0]), 1)) : ai("v-if", !0)]), _: 1 },
									8,
									["class", "disabled", "onClick"]
								),
								ri(
									u,
									{ type: "primary", class: gt([e.ns.e("button"), e.ns.is("with-texts", e.hasButtonTexts)]), disabled: 0 === e.leftChecked.length, onClick: e.addToRight },
									{ default: cn(() => [void 0 !== e.buttonTexts[1] ? (Wr(), Kr("span", E1, bt(e.buttonTexts[1]), 1)) : ai("v-if", !0), ri(l, null, { default: cn(() => [ri(c)]), _: 1 })]), _: 1 },
									8,
									["class", "disabled", "onClick"]
								)
							],
							2
						),
						ri(
							o,
							{
								ref: "rightPanel",
								data: e.targetData,
								"option-render": e.optionRender,
								placeholder: e.panelFilterPlaceholder,
								filterable: e.filterable,
								format: e.format,
								"filter-method": e.filterMethod,
								title: e.rightPanelTitle,
								"default-checked": e.rightDefaultChecked,
								props: e.props,
								onCheckedChange: e.onTargetCheckedChange
							},
							{ default: cn(() => [mi(e.$slots, "right-footer")]), _: 3 },
							8,
							["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"]
						)
					],
					2
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/index.vue"]
]);
T1.install = (e) => {
	e.component(T1.name, T1);
};
const k1 = T1,
	A1 = "$treeNodeId",
	M1 = function (e, t) {
		t && !t[A1] && Object.defineProperty(t, A1, { value: e.id, enumerable: !1, configurable: !1, writable: !1 });
	},
	I1 = function (e, t) {
		return e ? t[e] : t[A1];
	},
	R1 = (e) => {
		let t = !0,
			n = !0,
			r = !0;
		for (let i = 0, s = e.length; i < s; i++) {
			const s = e[i];
			(!0 !== s.checked || s.indeterminate) && ((t = !1), s.disabled || (r = !1)), (!1 !== s.checked || s.indeterminate) && (n = !1);
		}
		return { all: t, none: n, allWithoutDisable: r, half: !t && !n };
	},
	L1 = function (e) {
		if (0 === e.childNodes.length) return;
		const { all: t, none: n, half: r } = R1(e.childNodes);
		t ? ((e.checked = !0), (e.indeterminate = !1)) : r ? ((e.checked = !1), (e.indeterminate = !0)) : n && ((e.checked = !1), (e.indeterminate = !1));
		const i = e.parent;
		i && 0 !== i.level && (e.store.checkStrictly || L1(i));
	},
	O1 = function (e, t) {
		const n = e.store.props,
			r = e.data || {},
			i = n[t];
		if ("function" == typeof i) return i(r, e);
		if ("string" == typeof i) return r[i];
		if (void 0 === i) {
			const e = r[t];
			return void 0 === e ? "" : e;
		}
	};
let P1 = 0;
class N1 {
	constructor(e) {
		(this.id = P1++), (this.text = null), (this.checked = !1), (this.indeterminate = !1), (this.data = null), (this.expanded = !1), (this.parent = null), (this.visible = !0), (this.isCurrent = !1), (this.canFocus = !1);
		for (const t in e) xR(e, t) && (this[t] = e[t]);
		(this.level = 0), (this.loaded = !1), (this.childNodes = []), (this.loading = !1), this.parent && (this.level = this.parent.level + 1);
	}
	initialize() {
		const e = this.store;
		if (!e) throw new Error("[Node]store is required!");
		e.registerNode(this);
		const t = e.props;
		if (t && void 0 !== t.isLeaf) {
			const e = O1(this, "isLeaf");
			"boolean" == typeof e && (this.isLeafByUser = e);
		}
		if ((!0 !== e.lazy && this.data ? (this.setData(this.data), e.defaultExpandAll && ((this.expanded = !0), (this.canFocus = !0))) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || M1(this, this.data), !this.data)) return;
		const n = e.defaultExpandedKeys,
			r = e.key;
		r && n && n.includes(this.key) && this.expand(null, e.autoExpandParent),
			r && void 0 !== e.currentNodeKey && this.key === e.currentNodeKey && ((e.currentNode = this), (e.currentNode.isCurrent = !0)),
			e.lazy && e._initDefaultCheckedNode(this),
			this.updateLeafState(),
			!this.parent || (1 !== this.level && !0 !== this.parent.expanded) || (this.canFocus = !0);
	}
	setData(e) {
		let t;
		Array.isArray(e) || M1(this, e), (this.data = e), (this.childNodes = []), (t = 0 === this.level && Array.isArray(this.data) ? this.data : O1(this, "children") || []);
		for (let n = 0, r = t.length; n < r; n++) this.insertChild({ data: t[n] });
	}
	get label() {
		return O1(this, "label");
	}
	get key() {
		const e = this.store.key;
		return this.data ? this.data[e] : null;
	}
	get disabled() {
		return O1(this, "disabled");
	}
	get nextSibling() {
		const e = this.parent;
		if (e) {
			const t = e.childNodes.indexOf(this);
			if (t > -1) return e.childNodes[t + 1];
		}
		return null;
	}
	get previousSibling() {
		const e = this.parent;
		if (e) {
			const t = e.childNodes.indexOf(this);
			if (t > -1) return t > 0 ? e.childNodes[t - 1] : null;
		}
		return null;
	}
	contains(e, t = !0) {
		return (this.childNodes || []).some((n) => n === e || (t && n.contains(e)));
	}
	remove() {
		const e = this.parent;
		e && e.removeChild(this);
	}
	insertChild(e, t, n) {
		if (!e) throw new Error("InsertChild error: child is required.");
		if (!(e instanceof N1)) {
			if (!n) {
				const n = this.getChildren(!0);
				n.includes(e.data) || (void 0 === t || t < 0 ? n.push(e.data) : n.splice(t, 0, e.data));
			}
			Object.assign(e, { parent: this, store: this.store }), (e = Fe(new N1(e))) instanceof N1 && e.initialize();
		}
		(e.level = this.level + 1), void 0 === t || t < 0 ? this.childNodes.push(e) : this.childNodes.splice(t, 0, e), this.updateLeafState();
	}
	insertBefore(e, t) {
		let n;
		t && (n = this.childNodes.indexOf(t)), this.insertChild(e, n);
	}
	insertAfter(e, t) {
		let n;
		t && ((n = this.childNodes.indexOf(t)), -1 !== n && (n += 1)), this.insertChild(e, n);
	}
	removeChild(e) {
		const t = this.getChildren() || [],
			n = t.indexOf(e.data);
		n > -1 && t.splice(n, 1);
		const r = this.childNodes.indexOf(e);
		r > -1 && (this.store && this.store.deregisterNode(e), (e.parent = null), this.childNodes.splice(r, 1)), this.updateLeafState();
	}
	removeChildByData(e) {
		let t = null;
		for (let n = 0; n < this.childNodes.length; n++)
			if (this.childNodes[n].data === e) {
				t = this.childNodes[n];
				break;
			}
		t && this.removeChild(t);
	}
	expand(e, t) {
		const n = () => {
			if (t) {
				let e = this.parent;
				for (; e.level > 0; ) (e.expanded = !0), (e = e.parent);
			}
			(this.expanded = !0),
				e && e(),
				this.childNodes.forEach((e) => {
					e.canFocus = !0;
				});
		};
		this.shouldLoadData()
			? this.loadData((e) => {
					Array.isArray(e) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || L1(this), n());
			  })
			: n();
	}
	doCreateChildren(e, t = {}) {
		e.forEach((e) => {
			this.insertChild(Object.assign({ data: e }, t), void 0, !0);
		});
	}
	collapse() {
		(this.expanded = !1),
			this.childNodes.forEach((e) => {
				e.canFocus = !1;
			});
	}
	shouldLoadData() {
		return !0 === this.store.lazy && this.store.load && !this.loaded;
	}
	updateLeafState() {
		if (!0 === this.store.lazy && !0 !== this.loaded && void 0 !== this.isLeafByUser) return void (this.isLeaf = this.isLeafByUser);
		const e = this.childNodes;
		!this.store.lazy || (!0 === this.store.lazy && !0 === this.loaded) ? (this.isLeaf = !e || 0 === e.length) : (this.isLeaf = !1);
	}
	setChecked(e, t, n, r) {
		if (((this.indeterminate = "half" === e), (this.checked = !0 === e), this.store.checkStrictly)) return;
		if (!this.shouldLoadData() || this.store.checkDescendants) {
			const { all: n, allWithoutDisable: i } = R1(this.childNodes);
			this.isLeaf || n || !i || ((this.checked = !1), (e = !1));
			const s = () => {
				if (t) {
					const n = this.childNodes;
					for (let o = 0, a = n.length; o < a; o++) {
						const i = n[o];
						r = r || !1 !== e;
						const s = i.disabled ? i.checked : r;
						i.setChecked(s, t, !0, r);
					}
					const { half: i, all: s } = R1(n);
					s || ((this.checked = s), (this.indeterminate = i));
				}
			};
			if (this.shouldLoadData())
				return void this.loadData(
					() => {
						s(), L1(this);
					},
					{ checked: !1 !== e }
				);
			s();
		}
		const i = this.parent;
		i && 0 !== i.level && (n || L1(i));
	}
	getChildren(e = !1) {
		if (0 === this.level) return this.data;
		const t = this.data;
		if (!t) return null;
		const n = this.store.props;
		let r = "children";
		return n && (r = n.children || "children"), void 0 === t[r] && (t[r] = null), e && !t[r] && (t[r] = []), t[r];
	}
	updateChildren() {
		const e = this.getChildren() || [],
			t = this.childNodes.map((e) => e.data),
			n = {},
			r = [];
		e.forEach((e, i) => {
			const s = e[A1];
			!!s && t.findIndex((e) => e[A1] === s) >= 0 ? (n[s] = { index: i, data: e }) : r.push({ index: i, data: e });
		}),
			this.store.lazy ||
				t.forEach((e) => {
					n[e[A1]] || this.removeChildByData(e);
				}),
			r.forEach(({ index: e, data: t }) => {
				this.insertChild({ data: t }, e);
			}),
			this.updateLeafState();
	}
	loadData(e, t = {}) {
		if (!0 !== this.store.lazy || !this.store.load || this.loaded || (this.loading && !Object.keys(t).length)) e && e.call(this);
		else {
			this.loading = !0;
			const n = (n) => {
				(this.loaded = !0), (this.loading = !1), (this.childNodes = []), this.doCreateChildren(n, t), this.updateLeafState(), e && e.call(this, n);
			};
			this.store.load(this, n);
		}
	}
}
class D1 {
	constructor(e) {
		(this.currentNode = null), (this.currentNodeKey = null);
		for (const t in e) xR(e, t) && (this[t] = e[t]);
		this.nodesMap = {};
	}
	initialize() {
		if (((this.root = new N1({ data: this.data, store: this })), this.root.initialize(), this.lazy && this.load)) {
			(0, this.load)(this.root, (e) => {
				this.root.doCreateChildren(e), this._initDefaultCheckedNodes();
			});
		} else this._initDefaultCheckedNodes();
	}
	filter(e) {
		const t = this.filterNodeMethod,
			n = this.lazy,
			r = function (i) {
				const s = i.root ? i.root.childNodes : i.childNodes;
				if (
					(s.forEach((n) => {
						(n.visible = t.call(n, e, n.data, n)), r(n);
					}),
					!i.visible && s.length)
				) {
					let e = !0;
					(e = !s.some((e) => e.visible)), i.root ? (i.root.visible = !1 === e) : (i.visible = !1 === e);
				}
				e && (!i.visible || i.isLeaf || n || i.expand());
			};
		r(this);
	}
	setData(e) {
		e !== this.root.data ? (this.root.setData(e), this._initDefaultCheckedNodes()) : this.root.updateChildren();
	}
	getNode(e) {
		if (e instanceof N1) return e;
		const t = "object" != typeof e ? e : I1(this.key, e);
		return this.nodesMap[t] || null;
	}
	insertBefore(e, t) {
		const n = this.getNode(t);
		n.parent.insertBefore({ data: e }, n);
	}
	insertAfter(e, t) {
		const n = this.getNode(t);
		n.parent.insertAfter({ data: e }, n);
	}
	remove(e) {
		const t = this.getNode(e);
		t && t.parent && (t === this.currentNode && (this.currentNode = null), t.parent.removeChild(t));
	}
	append(e, t) {
		const n = t ? this.getNode(t) : this.root;
		n && n.insertChild({ data: e });
	}
	_initDefaultCheckedNodes() {
		const e = this.defaultCheckedKeys || [],
			t = this.nodesMap;
		e.forEach((e) => {
			const n = t[e];
			n && n.setChecked(!0, !this.checkStrictly);
		});
	}
	_initDefaultCheckedNode(e) {
		(this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly);
	}
	setDefaultCheckedKey(e) {
		e !== this.defaultCheckedKeys && ((this.defaultCheckedKeys = e), this._initDefaultCheckedNodes());
	}
	registerNode(e) {
		const t = this.key;
		if (e && e.data)
			if (t) {
				void 0 !== e.key && (this.nodesMap[e.key] = e);
			} else this.nodesMap[e.id] = e;
	}
	deregisterNode(e) {
		this.key &&
			e &&
			e.data &&
			(e.childNodes.forEach((e) => {
				this.deregisterNode(e);
			}),
			delete this.nodesMap[e.key]);
	}
	getCheckedNodes(e = !1, t = !1) {
		const n = [],
			r = function (i) {
				(i.root ? i.root.childNodes : i.childNodes).forEach((i) => {
					(i.checked || (t && i.indeterminate)) && (!e || (e && i.isLeaf)) && n.push(i.data), r(i);
				});
			};
		return r(this), n;
	}
	getCheckedKeys(e = !1) {
		return this.getCheckedNodes(e).map((e) => (e || {})[this.key]);
	}
	getHalfCheckedNodes() {
		const e = [],
			t = function (n) {
				(n.root ? n.root.childNodes : n.childNodes).forEach((n) => {
					n.indeterminate && e.push(n.data), t(n);
				});
			};
		return t(this), e;
	}
	getHalfCheckedKeys() {
		return this.getHalfCheckedNodes().map((e) => (e || {})[this.key]);
	}
	_getAllNodes() {
		const e = [],
			t = this.nodesMap;
		for (const n in t) xR(t, n) && e.push(t[n]);
		return e;
	}
	updateChildren(e, t) {
		const n = this.nodesMap[e];
		if (!n) return;
		const r = n.childNodes;
		for (let i = r.length - 1; i >= 0; i--) {
			const e = r[i];
			this.remove(e.data);
		}
		for (let i = 0, s = t.length; i < s; i++) {
			const e = t[i];
			this.append(e, n.data);
		}
	}
	_setCheckedKeys(e, t = !1, n) {
		const r = this._getAllNodes().sort((e, t) => t.level - e.level),
			i = Object.create(null),
			s = Object.keys(n);
		r.forEach((e) => e.setChecked(!1, !1));
		for (let o = 0, a = r.length; o < a; o++) {
			const n = r[o],
				a = n.data[e].toString();
			if (!s.includes(a)) {
				n.checked && !i[a] && n.setChecked(!1, !1);
				continue;
			}
			let l = n.parent;
			for (; l && l.level > 0; ) (i[l.data[e]] = !0), (l = l.parent);
			if (n.isLeaf || this.checkStrictly) n.setChecked(!0, !1);
			else if ((n.setChecked(!0, !0), t)) {
				n.setChecked(!1, !1);
				const e = function (t) {
					t.childNodes.forEach((t) => {
						t.isLeaf || t.setChecked(!1, !1), e(t);
					});
				};
				e(n);
			}
		}
	}
	setCheckedNodes(e, t = !1) {
		const n = this.key,
			r = {};
		e.forEach((e) => {
			r[(e || {})[n]] = !0;
		}),
			this._setCheckedKeys(n, t, r);
	}
	setCheckedKeys(e, t = !1) {
		this.defaultCheckedKeys = e;
		const n = this.key,
			r = {};
		e.forEach((e) => {
			r[e] = !0;
		}),
			this._setCheckedKeys(n, t, r);
	}
	setDefaultExpandedKeys(e) {
		(e = e || []),
			(this.defaultExpandedKeys = e),
			e.forEach((e) => {
				const t = this.getNode(e);
				t && t.expand(null, this.autoExpandParent);
			});
	}
	setChecked(e, t, n) {
		const r = this.getNode(e);
		r && r.setChecked(!!t, n);
	}
	getCurrentNode() {
		return this.currentNode;
	}
	setCurrentNode(e) {
		const t = this.currentNode;
		t && (t.isCurrent = !1), (this.currentNode = e), (this.currentNode.isCurrent = !0);
	}
	setUserCurrentNode(e, t = !0) {
		const n = e[this.key],
			r = this.nodesMap[n];
		this.setCurrentNode(r), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0);
	}
	setCurrentNodeKey(e, t = !0) {
		if (null == e) return this.currentNode && (this.currentNode.isCurrent = !1), void (this.currentNode = null);
		const n = this.getNode(e);
		n && (this.setCurrentNode(n), t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0));
	}
}
var B1 = IB(
	Tn({
		name: "ElTreeNodeContent",
		props: { node: { type: Object, required: !0 }, renderContent: Function },
		setup(e) {
			const t = BD("tree"),
				n = vn("NodeInstance"),
				r = vn("RootTree");
			return () => {
				const i = e.node,
					{ data: s, store: o } = i;
				return e.renderContent ? e.renderContent(xs, { _self: n, node: i, data: s, store: o }) : r.ctx.slots.default ? r.ctx.slots.default({ node: i, data: s }) : xs("span", { class: t.be("node", "label") }, [i.label]);
			};
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]
);
function F1(e) {
	const t = vn("TreeNodeMap", null),
		n = {
			treeNodeExpand: (t) => {
				e.node !== t && e.node.collapse();
			},
			children: []
		};
	return (
		t && t.children.push(n),
		mn("TreeNodeMap", n),
		{
			broadcastExpanded: (t) => {
				if (e.accordion) for (const e of n.children) e.treeNodeExpand(t);
			}
		}
	);
}
const H1 = Symbol("dragEvents");
const V1 = Tn({
		name: "ElTreeNode",
		components: { ElCollapseTransition: ej, ElCheckbox: qz, NodeContent: B1, ElIcon: OB, Loading: HO },
		props: { node: { type: N1, default: () => ({}) }, props: { type: Object, default: () => ({}) }, accordion: Boolean, renderContent: Function, renderAfterExpand: Boolean, showCheckbox: { type: Boolean, default: !1 } },
		emits: ["node-expand"],
		setup(e, t) {
			const n = BD("tree"),
				{ broadcastExpanded: r } = F1(e),
				i = vn("RootTree"),
				s = Qe(!1),
				o = Qe(!1),
				a = Qe(null),
				l = Qe(null),
				u = Qe(null),
				c = vn(H1),
				h = Si();
			mn("NodeInstance", h), e.node.expanded && ((s.value = !0), (o.value = !0));
			const d = i.props.children || "children";
			ds(
				() => {
					const t = e.node.data[d];
					return t && [...t];
				},
				() => {
					e.node.updateChildren();
				}
			),
				ds(
					() => e.node.indeterminate,
					(t) => {
						p(e.node.checked, t);
					}
				),
				ds(
					() => e.node.checked,
					(t) => {
						p(t, e.node.indeterminate);
					}
				),
				ds(
					() => e.node.expanded,
					(e) => {
						ns(() => (s.value = e)), e && (o.value = !0);
					}
				);
			const p = (t, n) => {
					(a.value === t && l.value === n) || i.ctx.emit("check-change", e.node.data, t, n), (a.value = t), (l.value = n);
				},
				f = () => {
					e.node.isLeaf || (s.value ? (i.ctx.emit("node-collapse", e.node.data, e.node, h), e.node.collapse()) : (e.node.expand(), t.emit("node-expand", e.node.data, e.node, h)));
				},
				m = (t, n) => {
					e.node.setChecked(n.target.checked, !i.props.checkStrictly),
						ns(() => {
							const t = i.store.value;
							i.ctx.emit("check", e.node.data, { checkedNodes: t.getCheckedNodes(), checkedKeys: t.getCheckedKeys(), halfCheckedNodes: t.getHalfCheckedNodes(), halfCheckedKeys: t.getHalfCheckedKeys() });
						});
				};
			return {
				ns: n,
				node$: u,
				tree: i,
				expanded: s,
				childNodeRendered: o,
				oldChecked: a,
				oldIndeterminate: l,
				getNodeKey: (e) => I1(i.props.nodeKey, e.data),
				getNodeClass: (t) => {
					const n = e.props.class;
					if (!n) return {};
					let r;
					if (CR(n)) {
						const { data: e } = t;
						r = n(e, t);
					} else r = n;
					return SR(r) ? { [r]: !0 } : r;
				},
				handleSelectChange: p,
				handleClick: (t) => {
					const n = i.store.value;
					n.setCurrentNode(e.node),
						i.ctx.emit("current-change", n.currentNode ? n.currentNode.data : null, n.currentNode),
						(i.currentNode.value = e.node),
						i.props.expandOnClickNode && f(),
						i.props.checkOnClickNode && !e.node.disabled && m(null, { target: { checked: !e.node.checked } }),
						i.ctx.emit("node-click", e.node.data, e.node, h, t);
				},
				handleContextMenu: (t) => {
					i.instance.vnode.props.onNodeContextmenu && (t.stopPropagation(), t.preventDefault()), i.ctx.emit("node-contextmenu", t, e.node.data, e.node, h);
				},
				handleExpandIconClick: f,
				handleCheckChange: m,
				handleChildNodeExpand: (e, t, n) => {
					r(t), i.ctx.emit("node-expand", e, t, n);
				},
				handleDragStart: (t) => {
					i.props.draggable && c.treeNodeDragStart({ event: t, treeNode: e });
				},
				handleDragOver: (t) => {
					t.preventDefault(), i.props.draggable && c.treeNodeDragOver({ event: t, treeNode: { $el: u.value, node: e.node } });
				},
				handleDrop: (e) => {
					e.preventDefault();
				},
				handleDragEnd: (e) => {
					i.props.draggable && c.treeNodeDragEnd(e);
				},
				CaretRight: ML
			};
		}
	}),
	U1 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"],
	z1 = ["aria-expanded"];
var $1 = IB(
	Tn({
		name: "ElTree",
		components: {
			ElTreeNode: IB(V1, [
				[
					"render",
					function (e, t, n, r, i, s) {
						const o = Or("el-icon"),
							a = Or("el-checkbox"),
							l = Or("loading"),
							u = Or("node-content"),
							c = Or("el-tree-node"),
							h = Or("el-collapse-transition");
						return yr(
							(Wr(),
							Kr(
								"div",
								{
									ref: "node$",
									class: gt([e.ns.b("node"), e.ns.is("expanded", e.expanded), e.ns.is("current", e.node.isCurrent), e.ns.is("hidden", !e.node.visible), e.ns.is("focusable", !e.node.disabled), e.ns.is("checked", !e.node.disabled && e.node.checked), e.getNodeClass(e.node)]),
									role: "treeitem",
									tabindex: "-1",
									"aria-expanded": e.expanded,
									"aria-disabled": e.node.disabled,
									"aria-checked": e.node.checked,
									draggable: e.tree.props.draggable,
									"data-key": e.getNodeKey(e.node),
									onClick: t[1] || (t[1] = zo((...t) => e.handleClick && e.handleClick(...t), ["stop"])),
									onContextmenu: t[2] || (t[2] = (...t) => e.handleContextMenu && e.handleContextMenu(...t)),
									onDragstart: t[3] || (t[3] = zo((...t) => e.handleDragStart && e.handleDragStart(...t), ["stop"])),
									onDragover: t[4] || (t[4] = zo((...t) => e.handleDragOver && e.handleDragOver(...t), ["stop"])),
									onDragend: t[5] || (t[5] = zo((...t) => e.handleDragEnd && e.handleDragEnd(...t), ["stop"])),
									onDrop: t[6] || (t[6] = zo((...t) => e.handleDrop && e.handleDrop(...t), ["stop"]))
								},
								[
									ni(
										"div",
										{ class: gt(e.ns.be("node", "content")), style: pt({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" }) },
										[
											e.tree.props.icon || e.CaretRight
												? (Wr(),
												  qr(
														o,
														{ key: 0, class: gt([e.ns.be("node", "expand-icon"), e.ns.is("leaf", e.node.isLeaf), { expanded: !e.node.isLeaf && e.expanded }]), onClick: zo(e.handleExpandIconClick, ["stop"]) },
														{ default: cn(() => [(Wr(), qr(Nr(e.tree.props.icon || e.CaretRight)))]), _: 1 },
														8,
														["class", "onClick"]
												  ))
												: ai("v-if", !0),
											e.showCheckbox
												? (Wr(),
												  qr(a, { key: 1, "model-value": e.node.checked, indeterminate: e.node.indeterminate, disabled: !!e.node.disabled, onClick: t[0] || (t[0] = zo(() => {}, ["stop"])), onChange: e.handleCheckChange }, null, 8, [
														"model-value",
														"indeterminate",
														"disabled",
														"onChange"
												  ]))
												: ai("v-if", !0),
											e.node.loading ? (Wr(), qr(o, { key: 2, class: gt([e.ns.be("node", "loading-icon"), e.ns.is("loading")]) }, { default: cn(() => [ri(l)]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
											ri(u, { node: e.node, "render-content": e.renderContent }, null, 8, ["node", "render-content"])
										],
										6
									),
									ri(h, null, {
										default: cn(() => [
											!e.renderAfterExpand || e.childNodeRendered
												? yr(
														(Wr(),
														Kr(
															"div",
															{ key: 0, class: gt(e.ns.be("node", "children")), role: "group", "aria-expanded": e.expanded },
															[
																(Wr(!0),
																Kr(
																	Hr,
																	null,
																	pi(
																		e.node.childNodes,
																		(t) => (
																			Wr(),
																			qr(
																				c,
																				{
																					key: e.getNodeKey(t),
																					"render-content": e.renderContent,
																					"render-after-expand": e.renderAfterExpand,
																					"show-checkbox": e.showCheckbox,
																					node: t,
																					accordion: e.accordion,
																					props: e.props,
																					onNodeExpand: e.handleChildNodeExpand
																				},
																				null,
																				8,
																				["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]
																			)
																		)
																	),
																	128
																))
															],
															10,
															z1
														)),
														[[Wo, e.expanded]]
												  )
												: ai("v-if", !0)
										]),
										_: 1
									})
								],
								42,
								U1
							)),
							[[Wo, e.node.visible]]
						);
					}
				],
				["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]
			])
		},
		props: {
			data: { type: Array, default: () => [] },
			emptyText: { type: String },
			renderAfterExpand: { type: Boolean, default: !0 },
			nodeKey: String,
			checkStrictly: Boolean,
			defaultExpandAll: Boolean,
			expandOnClickNode: { type: Boolean, default: !0 },
			checkOnClickNode: Boolean,
			checkDescendants: { type: Boolean, default: !1 },
			autoExpandParent: { type: Boolean, default: !0 },
			defaultCheckedKeys: Array,
			defaultExpandedKeys: Array,
			currentNodeKey: [String, Number],
			renderContent: Function,
			showCheckbox: { type: Boolean, default: !1 },
			draggable: { type: Boolean, default: !1 },
			allowDrag: Function,
			allowDrop: Function,
			props: { type: Object, default: () => ({ children: "children", label: "label", disabled: "disabled" }) },
			lazy: { type: Boolean, default: !1 },
			highlightCurrent: Boolean,
			load: Function,
			filterNodeMethod: Function,
			accordion: Boolean,
			indent: { type: Number, default: 18 },
			icon: [String, Object]
		},
		emits: ["check-change", "current-change", "node-click", "node-contextmenu", "node-collapse", "node-expand", "check", "node-drag-start", "node-drag-end", "node-drop", "node-drag-leave", "node-drag-enter", "node-drag-over"],
		setup(e, t) {
			const { t: n } = CD(),
				r = BD("tree"),
				i = Qe(
					new D1({
						key: e.nodeKey,
						data: e.data,
						lazy: e.lazy,
						props: e.props,
						load: e.load,
						currentNodeKey: e.currentNodeKey,
						checkStrictly: e.checkStrictly,
						checkDescendants: e.checkDescendants,
						defaultCheckedKeys: e.defaultCheckedKeys,
						defaultExpandedKeys: e.defaultExpandedKeys,
						autoExpandParent: e.autoExpandParent,
						defaultExpandAll: e.defaultExpandAll,
						filterNodeMethod: e.filterNodeMethod
					})
				);
			i.value.initialize();
			const s = Qe(i.value.root),
				o = Qe(null),
				a = Qe(null),
				l = Qe(null),
				{ broadcastExpanded: u } = F1(e),
				{ dragState: c } = (function ({ props: e, ctx: t, el$: n, dropIndicator$: r, store: i }) {
					const s = BD("tree"),
						o = Qe({ showDropIndicator: !1, draggingNode: null, dropNode: null, allowDrop: !0, dropType: null });
					return (
						mn(H1, {
							treeNodeDragStart: ({ event: n, treeNode: r }) => {
								if ("function" == typeof e.allowDrag && !e.allowDrag(r.node)) return n.preventDefault(), !1;
								n.dataTransfer.effectAllowed = "move";
								try {
									n.dataTransfer.setData("text/plain", "");
								} catch (Kj) {}
								(o.value.draggingNode = r), t.emit("node-drag-start", r.node, n);
							},
							treeNodeDragOver: ({ event: i, treeNode: a }) => {
								const l = a,
									u = o.value.dropNode;
								u && u !== l && YR(u.$el, s.is("drop-inner"));
								const c = o.value.draggingNode;
								if (!c || !l) return;
								let h = !0,
									d = !0,
									p = !0,
									f = !0;
								"function" == typeof e.allowDrop && ((h = e.allowDrop(c.node, l.node, "prev")), (f = d = e.allowDrop(c.node, l.node, "inner")), (p = e.allowDrop(c.node, l.node, "next"))),
									(i.dataTransfer.dropEffect = d || h || p ? "move" : "none"),
									(h || d || p) && u !== l && (u && t.emit("node-drag-leave", c.node, u.node, i), t.emit("node-drag-enter", c.node, l.node, i)),
									(h || d || p) && (o.value.dropNode = l),
									l.node.nextSibling === c.node && (p = !1),
									l.node.previousSibling === c.node && (h = !1),
									l.node.contains(c.node, !1) && (d = !1),
									(c.node === l.node || c.node.contains(l.node)) && ((h = !1), (d = !1), (p = !1));
								const m = l.$el.getBoundingClientRect(),
									v = n.value.getBoundingClientRect();
								let g;
								const y = h ? (d ? 0.25 : p ? 0.45 : 1) : -1,
									b = p ? (d ? 0.75 : h ? 0.55 : 0) : 1;
								let x = -9999;
								const _ = i.clientY - m.top;
								g = _ < m.height * y ? "before" : _ > m.height * b ? "after" : d ? "inner" : "none";
								const w = l.$el.querySelector(`.${s.be("node", "expand-icon")}`).getBoundingClientRect(),
									C = r.value;
								"before" === g ? (x = w.top - v.top) : "after" === g && (x = w.bottom - v.top),
									(C.style.top = `${x}px`),
									(C.style.left = w.right - v.left + "px"),
									"inner" === g ? GR(l.$el, s.is("drop-inner")) : YR(l.$el, s.is("drop-inner")),
									(o.value.showDropIndicator = "before" === g || "after" === g),
									(o.value.allowDrop = o.value.showDropIndicator || f),
									(o.value.dropType = g),
									t.emit("node-drag-over", c.node, l.node, i);
							},
							treeNodeDragEnd: (e) => {
								const { draggingNode: n, dropType: r, dropNode: a } = o.value;
								if ((e.preventDefault(), (e.dataTransfer.dropEffect = "move"), n && a)) {
									const o = { data: n.node.data };
									"none" !== r && n.node.remove(),
										"before" === r ? a.node.parent.insertBefore(o, a.node) : "after" === r ? a.node.parent.insertAfter(o, a.node) : "inner" === r && a.node.insertChild(o),
										"none" !== r && i.value.registerNode(o),
										YR(a.$el, s.is("drop-inner")),
										t.emit("node-drag-end", n.node, a.node, r, e),
										"none" !== r && t.emit("node-drop", n.node, a.node, r, e);
								}
								n && !a && t.emit("node-drag-end", n.node, null, r, e), (o.value.showDropIndicator = !1), (o.value.draggingNode = null), (o.value.dropNode = null), (o.value.allowDrop = !0);
							}
						}),
						{ dragState: o }
					);
				})({ props: e, ctx: t, el$: a, dropIndicator$: l, store: i });
			!(function ({ el$: e }, t) {
				const n = BD("tree"),
					r = et([]),
					i = et([]);
				Vn(() => {
					o(), RI(e.value, "keydown", s);
				}),
					$n(() => {
						LI(e.value, "keydown", s);
					}),
					zn(() => {
						(r.value = Array.from(e.value.querySelectorAll("[role=treeitem]"))), (i.value = Array.from(e.value.querySelectorAll("input[type=checkbox]")));
					}),
					ds(i, (e) => {
						e.forEach((e) => {
							e.setAttribute("tabindex", "-1");
						});
					});
				const s = (i) => {
						const s = i.target;
						if (!s.className.includes(n.b("node"))) return;
						const o = i.code;
						r.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
						const a = r.value.indexOf(s);
						let l;
						if ([bN.up, bN.down].includes(o)) {
							if ((i.preventDefault(), o === bN.up)) {
								l = -1 === a ? 0 : 0 !== a ? a - 1 : r.value.length - 1;
								const e = l;
								for (; !t.value.getNode(r.value[l].dataset.key).canFocus; ) {
									if ((l--, l === e)) {
										l = -1;
										break;
									}
									l < 0 && (l = r.value.length - 1);
								}
							} else {
								l = -1 === a ? 0 : a < r.value.length - 1 ? a + 1 : 0;
								const e = l;
								for (; !t.value.getNode(r.value[l].dataset.key).canFocus; ) {
									if ((l++, l === e)) {
										l = -1;
										break;
									}
									l >= r.value.length && (l = 0);
								}
							}
							-1 !== l && r.value[l].focus();
						}
						[bN.left, bN.right].includes(o) && (i.preventDefault(), s.click());
						const u = s.querySelector('[type="checkbox"]');
						[bN.enter, bN.space].includes(o) && u && (i.preventDefault(), u.click());
					},
					o = () => {
						var t;
						(r.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`))), (i.value = Array.from(e.value.querySelectorAll("input[type=checkbox]")));
						const s = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
						s.length ? s[0].setAttribute("tabindex", "0") : null == (t = r.value[0]) || t.setAttribute("tabindex", "0");
					};
			})({ el$: a }, i);
			const h = ht(() => {
				const { childNodes: e } = s.value;
				return !e || 0 === e.length || e.every(({ visible: e }) => !e);
			});
			ds(
				() => e.defaultCheckedKeys,
				(e) => {
					i.value.setDefaultCheckedKey(e);
				}
			),
				ds(
					() => e.defaultExpandedKeys,
					(e) => {
						i.value.setDefaultExpandedKeys(e);
					}
				),
				ds(
					() => e.data,
					(e) => {
						i.value.setData(e);
					},
					{ deep: !0 }
				),
				ds(
					() => e.checkStrictly,
					(e) => {
						i.value.checkStrictly = e;
					}
				);
			const d = () => {
				const e = i.value.getCurrentNode();
				return e ? e.data : null;
			};
			return (
				mn("RootTree", { ctx: t, props: e, store: i, root: s, currentNode: o, instance: Si() }),
				mn(YN, void 0),
				{
					ns: r,
					store: i,
					root: s,
					currentNode: o,
					dragState: c,
					el$: a,
					dropIndicator$: l,
					isEmpty: h,
					filter: (t) => {
						if (!e.filterNodeMethod) throw new Error("[Tree] filterNodeMethod is required when filter");
						i.value.filter(t);
					},
					getNodeKey: (t) => I1(e.nodeKey, t.data),
					getNodePath: (t) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in getNodePath");
						const n = i.value.getNode(t);
						if (!n) return [];
						const r = [n.data];
						let o = n.parent;
						for (; o && o !== s.value; ) r.push(o.data), (o = o.parent);
						return r.reverse();
					},
					getCheckedNodes: (e, t) => i.value.getCheckedNodes(e, t),
					getCheckedKeys: (e) => i.value.getCheckedKeys(e),
					getCurrentNode: d,
					getCurrentKey: () => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in getCurrentKey");
						const t = d();
						return t ? t[e.nodeKey] : null;
					},
					setCheckedNodes: (t, n) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in setCheckedNodes");
						i.value.setCheckedNodes(t, n);
					},
					setCheckedKeys: (t, n) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in setCheckedKeys");
						i.value.setCheckedKeys(t, n);
					},
					setChecked: (e, t, n) => {
						i.value.setChecked(e, t, n);
					},
					getHalfCheckedNodes: () => i.value.getHalfCheckedNodes(),
					getHalfCheckedKeys: () => i.value.getHalfCheckedKeys(),
					setCurrentNode: (t, n = !0) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in setCurrentNode");
						i.value.setUserCurrentNode(t, n);
					},
					setCurrentKey: (t, n = !0) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in setCurrentKey");
						i.value.setCurrentNodeKey(t, n);
					},
					t: n,
					getNode: (e) => i.value.getNode(e),
					remove: (e) => {
						i.value.remove(e);
					},
					append: (e, t) => {
						i.value.append(e, t);
					},
					insertBefore: (e, t) => {
						i.value.insertBefore(e, t);
					},
					insertAfter: (e, t) => {
						i.value.insertAfter(e, t);
					},
					handleNodeExpand: (e, n, r) => {
						u(n), t.emit("node-expand", e, n, r);
					},
					updateKeyChildren: (t, n) => {
						if (!e.nodeKey) throw new Error("[Tree] nodeKey is required in updateKeyChild");
						i.value.updateChildren(t, n);
					}
				}
			);
		}
	}),
	[
		[
			"render",
			function (e, t, n, r, i, s) {
				var o;
				const a = Or("el-tree-node");
				return (
					Wr(),
					Kr(
						"div",
						{ ref: "el$", class: gt([e.ns.b(), e.ns.is("dragging", !!e.dragState.draggingNode), e.ns.is("drop-not-allow", !e.dragState.allowDrop), e.ns.is("drop-inner", "inner" === e.dragState.dropType), { [e.ns.m("highlight-current")]: e.highlightCurrent }]), role: "tree" },
						[
							(Wr(!0),
							Kr(
								Hr,
								null,
								pi(
									e.root.childNodes,
									(t) => (
										Wr(),
										qr(a, { key: e.getNodeKey(t), node: t, props: e.props, accordion: e.accordion, "render-after-expand": e.renderAfterExpand, "show-checkbox": e.showCheckbox, "render-content": e.renderContent, onNodeExpand: e.handleNodeExpand }, null, 8, [
											"node",
											"props",
											"accordion",
											"render-after-expand",
											"show-checkbox",
											"render-content",
											"onNodeExpand"
										])
									)
								),
								128
							)),
							e.isEmpty ? (Wr(), Kr("div", { key: 0, class: gt(e.ns.e("empty-block")) }, [ni("span", { class: gt(e.ns.e("empty-text")) }, bt(null != (o = e.emptyText) ? o : e.t("el.tree.emptyText")), 3)], 2)) : ai("v-if", !0),
							yr(ni("div", { ref: "dropIndicator$", class: gt(e.ns.e("drop-indicator")) }, null, 2), [[Wo, e.dragState.showDropIndicator]])
						],
						2
					)
				);
			}
		],
		["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]
	]
);
$1.install = (e) => {
	e.component($1.name, $1);
};
const j1 = $1,
	W1 = j1,
	G1 = Tn({
		extends: LK,
		setup(e, t) {
			const n = LK.setup(e, t);
			return delete n.selectOptionClick, n;
		},
		methods: {
			selectOptionClick() {
				this.$el.parentElement.click();
			}
		}
	});
function Y1(e) {
	return e || 0 === e;
}
function X1(e) {
	return Array.isArray(e) ? e : Y1(e) ? [e] : [];
}
var K1 = IB(
	Tn({
		name: "ElTreeSelect",
		inheritAttrs: !1,
		props: u(u({}, RK.props), j1.props),
		setup(e, t) {
			const { slots: n, expose: r } = t,
				i = Qe(),
				s = Qe(),
				o = ht(() => e.nodeKey || e.valueKey || "value"),
				a = ((e, { attrs: t }, { tree: n, key: r }) => {
					const i = BD("tree-select"),
						s = c(u(u({}, ck(at(e), Object.keys(RK.props))), t), {
							valueKey: r,
							popperClass: ht(() => {
								const t = [i.e("popper")];
								return e.popperClass && t.push(e.popperClass), t.join(" ");
							}),
							filterMethod: (t = "") => {
								e.filterMethod && e.filterMethod(t),
									ns(() => {
										var e;
										null == (e = n.value) || e.filter(t);
									});
							},
							onVisibleChange: (n) => {
								var r;
								null == (r = t.onVisibleChange) || r.call(t, n), e.filterable && n && s.filterMethod();
							}
						});
					return s;
				})(e, t, { select: i, tree: s, key: o }),
				l = ((e, { attrs: t, slots: n, emit: r }, { select: i, tree: s, key: o }) => {
					ds(
						() => e.modelValue,
						() => {
							e.showCheckbox &&
								ns(() => {
									const t = s.value;
									t && !rk(t.getCheckedKeys(), X1(e.modelValue)) && t.setCheckedKeys(X1(e.modelValue));
								});
						},
						{ immediate: !0, deep: !0 }
					);
					const a = ht(() => u({ value: o.value }, e.props)),
						l = (e, t) => {
							var n;
							const r = a.value[e];
							return CR(r) ? r(t, null == (n = s.value) ? void 0 : n.getNode(l("value", t))) : t[r];
						};
					return c(u(u({}, ck(at(e), Object.keys(j1.props))), t), {
						nodeKey: o,
						expandOnClickNode: ht(() => !e.checkStrictly),
						defaultExpandedKeys: ht(() => {
							const t = X1(e.modelValue),
								n = s.value
									? t
											.map((e) => {
												var t, n, r;
												return null == (r = null == (n = null == (t = s.value) ? void 0 : t.getNode(e)) ? void 0 : n.parent) ? void 0 : r.key;
											})
											.filter((e) => Y1(e))
									: t;
							return e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(n) : n;
						}),
						renderContent: (t, { node: r, data: i, store: s }) =>
							t(G1, { value: l("value", i), label: l("label", i), disabled: l("disabled", i) }, e.renderContent ? () => e.renderContent(t, { node: r, data: i, store: s }) : n.default ? () => n.default({ node: r, data: i, store: s }) : void 0),
						filterNodeMethod: (t, n, r) => {
							var i;
							return e.filterNodeMethod ? e.filterNodeMethod(t, n, r) : !t || (null == (i = l("label", n)) ? void 0 : i.includes(t));
						},
						onNodeClick: (n, r, s) => {
							var o, a, u;
							if ((null == (o = t.onNodeClick) || o.call(t, n, r, s), (e.checkStrictly && e.showCheckbox ? e.checkOnClickNode : e.checkStrictly) || r.isLeaf)) {
								if (!l("disabled", n)) {
									const e = null == (a = i.value) ? void 0 : a.options.get(l("value", n));
									null == (u = i.value) || u.handleOptionSelect(e, !0);
								}
							} else s.proxy.handleExpandIconClick();
						},
						onCheck: (n, i) => {
							var o, a;
							null == (o = t.onCheck) || o.call(t, n, i);
							const u = e.checkStrictly ? i.checkedKeys : null == (a = s.value) ? void 0 : a.getCheckedKeys(!0),
								c = l("value", n);
							r(_N, e.multiple ? u : u.includes(c) ? c : void 0);
						}
					});
				})(e, t, { select: i, tree: s, key: o }),
				h = Fe({});
			return (
				r(h),
				Vn(() => {
					Object.assign(
						h,
						u(
							u(
								{},
								ck(s.value, [
									"filter",
									"updateKeyChildren",
									"getCheckedNodes",
									"setCheckedNodes",
									"getCheckedKeys",
									"setCheckedKeys",
									"setChecked",
									"getHalfCheckedNodes",
									"getHalfCheckedKeys",
									"getCurrentKey",
									"getCurrentNode",
									"setCurrentKey",
									"setCurrentNode",
									"getNode",
									"remove",
									"append",
									"insertBefore",
									"insertAfter"
								])
							),
							ck(i.value, ["focus", "blur"])
						)
					);
				}),
				() => xs(RK, Fe(c(u({}, a), { ref: (e) => (i.value = e) })), c(u({}, n), { default: () => xs(j1, Fe(c(u({}, l), { ref: (e) => (s.value = e) }))) }))
			);
		}
	}),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]
);
K1.install = (e) => {
	e.component(K1.name, K1);
};
const q1 = K1,
	Z1 = Symbol(),
	J1 = { key: -1, level: -1, data: {} };
var Q1 = ((e) => ((e.KEY = "id"), (e.LABEL = "label"), (e.CHILDREN = "children"), (e.DISABLED = "disabled"), e))(Q1 || {}),
	e2 = ((e) => ((e.ADD = "add"), (e.DELETE = "delete"), e))(e2 || {});
const t2 = uN({
		data: { type: Array, default: () => [] },
		emptyText: { type: String },
		height: { type: Number, default: 200 },
		props: { type: Object, default: () => ({ children: "children", label: "label", disabled: "disabled", value: "id" }) },
		highlightCurrent: { type: Boolean, default: !1 },
		showCheckbox: { type: Boolean, default: !1 },
		defaultCheckedKeys: { type: Array, default: () => [] },
		checkStrictly: { type: Boolean, default: !1 },
		defaultExpandedKeys: { type: Array, default: () => [] },
		indent: { type: Number, default: 16 },
		icon: { type: cN },
		expandOnClickNode: { type: Boolean, default: !0 },
		checkOnClickNode: { type: Boolean, default: !1 },
		currentNodeKey: { type: [String, Number] },
		accordion: { type: Boolean, default: !1 },
		filterMethod: { type: Function },
		perfMode: { type: Boolean, default: !0 }
	}),
	n2 = uN({
		node: { type: Object, default: () => J1 },
		expanded: { type: Boolean, default: !1 },
		checked: { type: Boolean, default: !1 },
		indeterminate: { type: Boolean, default: !1 },
		showCheckbox: { type: Boolean, default: !1 },
		disabled: { type: Boolean, default: !1 },
		current: { type: Boolean, default: !1 },
		hiddenExpandIcon: { type: Boolean, default: !1 }
	}),
	r2 = uN({ node: { type: Object, required: !0 } }),
	i2 = { "node-click": (e, t, n) => e && t && n, "node-expand": (e, t) => e && t, "node-collapse": (e, t) => e && t, "current-change": (e, t) => e && t, check: (e, t) => e && t, "check-change": (e, t) => e && "boolean" == typeof t, "node-contextmenu": (e, t, n) => e && t && n };
function s2(e, t) {
	const n = Qe(new Set(e.defaultExpandedKeys)),
		r = Qe(),
		i = et();
	ds(
		() => e.currentNodeKey,
		(e) => {
			r.value = e;
		},
		{ immediate: !0 }
	),
		ds(
			() => e.data,
			(e) => {
				M(e);
			},
			{ immediate: !0 }
		);
	const {
			isIndeterminate: s,
			isChecked: o,
			toggleCheckbox: a,
			getCheckedKeys: l,
			getCheckedNodes: u,
			getHalfCheckedKeys: c,
			getHalfCheckedNodes: h,
			setChecked: d,
			setCheckedKeys: p
		} = (function (e, t) {
			const n = Qe(new Set()),
				r = Qe(new Set()),
				{ emit: i } = Si();
			ds(
				() => t.value,
				() =>
					ns(() => {
						h(e.defaultCheckedKeys);
					}),
				{ immediate: !0 }
			);
			const s = () => {
					if (!t.value || !e.showCheckbox || e.checkStrictly) return;
					const { levelTreeNodeMap: i, maxLevel: s } = t.value,
						o = n.value,
						a = new Set();
					for (let e = s - 1; e >= 1; --e) {
						const t = i.get(e);
						t &&
							t.forEach((e) => {
								const t = e.children;
								if (t) {
									let n = !0,
										r = !1;
									for (const e of t) {
										const t = e.key;
										if (o.has(t)) r = !0;
										else {
											if (a.has(t)) {
												(n = !1), (r = !0);
												break;
											}
											n = !1;
										}
									}
									n ? o.add(e.key) : r ? (a.add(e.key), o.delete(e.key)) : (o.delete(e.key), a.delete(e.key));
								}
							});
					}
					r.value = a;
				},
				o = (e) => n.value.has(e.key),
				a = (t, r, i = !0) => {
					const o = n.value,
						a = (t, n) => {
							o[n ? e2.ADD : e2.DELETE](t.key);
							const r = t.children;
							!e.checkStrictly &&
								r &&
								r.forEach((e) => {
									e.disabled || a(e, n);
								});
						};
					a(t, r), s(), i && l(t, r);
				},
				l = (e, t) => {
					const { checkedNodes: n, checkedKeys: r } = u(),
						{ halfCheckedNodes: s, halfCheckedKeys: o } = c();
					i("check", e.data, { checkedKeys: r, checkedNodes: n, halfCheckedKeys: o, halfCheckedNodes: s }), i("check-change", e.data, t);
				};
			function u(r = !1) {
				const i = [],
					s = [];
				if ((null == t ? void 0 : t.value) && e.showCheckbox) {
					const { treeNodeMap: e } = t.value;
					n.value.forEach((t) => {
						const n = e.get(t);
						n && (!r || (r && n.isLeaf)) && (s.push(t), i.push(n.data));
					});
				}
				return { checkedKeys: s, checkedNodes: i };
			}
			function c() {
				const n = [],
					i = [];
				if ((null == t ? void 0 : t.value) && e.showCheckbox) {
					const { treeNodeMap: e } = t.value;
					r.value.forEach((t) => {
						const r = e.get(t);
						r && (i.push(t), n.push(r.data));
					});
				}
				return { halfCheckedNodes: n, halfCheckedKeys: i };
			}
			function h(n) {
				if (null == t ? void 0 : t.value) {
					const { treeNodeMap: r } = t.value;
					if (e.showCheckbox && r && n)
						for (const e of n) {
							const t = r.get(e);
							t && !o(t) && a(t, !0, !1);
						}
				}
			}
			return {
				updateCheckedKeys: s,
				toggleCheckbox: a,
				isChecked: o,
				isIndeterminate: (e) => r.value.has(e.key),
				getCheckedKeys: function (e = !1) {
					return u(e).checkedKeys;
				},
				getCheckedNodes: function (e = !1) {
					return u(e).checkedNodes;
				},
				getHalfCheckedKeys: function () {
					return c().halfCheckedKeys;
				},
				getHalfCheckedNodes: function () {
					return c().halfCheckedNodes;
				},
				setChecked: function (n, r) {
					if ((null == t ? void 0 : t.value) && e.showCheckbox) {
						const e = t.value.treeNodeMap.get(n);
						e && a(e, r, !1);
					}
				},
				setCheckedKeys: function (e) {
					n.value.clear(), r.value.clear(), h(e);
				}
			};
		})(e, i),
		{
			doFilter: f,
			hiddenNodeKeySet: m,
			isForceHiddenExpandIcon: v
		} = (function (e, t) {
			const n = Qe(new Set([])),
				r = Qe(new Set([])),
				i = ht(() => CR(e.filterMethod));
			return {
				hiddenExpandIconKeySet: r,
				hiddenNodeKeySet: n,
				doFilter: function (s) {
					var o;
					if (!i.value) return;
					const a = new Set(),
						l = r.value,
						u = n.value,
						c = [],
						h = (null == (o = t.value) ? void 0 : o.treeNodes) || [],
						d = e.filterMethod;
					return (
						u.clear(),
						(function e(t) {
							t.forEach((t) => {
								c.push(t),
									(null == d ? void 0 : d(s, t.data))
										? c.forEach((e) => {
												a.add(e.key);
										  })
										: t.isLeaf && u.add(t.key);
								const n = t.children;
								if ((n && e(n), !t.isLeaf))
									if (a.has(t.key)) {
										if (n) {
											let e = !0;
											for (const t of n)
												if (!u.has(t.key)) {
													e = !1;
													break;
												}
											e ? l.add(t.key) : l.delete(t.key);
										}
									} else u.add(t.key);
								c.pop();
							});
						})(h),
						a
					);
				},
				isForceHiddenExpandIcon: function (e) {
					return r.value.has(e.key);
				}
			};
		})(e, i),
		g = ht(() => {
			var t;
			return (null == (t = e.props) ? void 0 : t.value) || Q1.KEY;
		}),
		y = ht(() => {
			var t;
			return (null == (t = e.props) ? void 0 : t.children) || Q1.CHILDREN;
		}),
		b = ht(() => {
			var t;
			return (null == (t = e.props) ? void 0 : t.disabled) || Q1.DISABLED;
		}),
		x = ht(() => {
			var t;
			return (null == (t = e.props) ? void 0 : t.label) || Q1.LABEL;
		}),
		_ = ht(() => {
			const e = n.value,
				t = m.value,
				r = [],
				s = (i.value && i.value.treeNodes) || [];
			return (
				(function () {
					const n = [];
					for (let e = s.length - 1; e >= 0; --e) n.push(s[e]);
					for (; n.length; ) {
						const i = n.pop();
						if (i && (t.has(i.key) || r.push(i), e.has(i.key))) {
							const e = i.children;
							if (e) {
								for (let t = e.length - 1; t >= 0; --t) n.push(e[t]);
							}
						}
					}
				})(),
				r
			);
		}),
		w = ht(() => _.value.length > 0);
	function C(e) {
		return e[y.value];
	}
	function S(e) {
		return e ? e[g.value] : "";
	}
	function E(e) {
		return e[b.value];
	}
	function T(e) {
		return e[x.value];
	}
	function k(r) {
		n.value.has(r.key)
			? (function (e) {
					n.value.delete(e.key), t("node-collapse", e.data, e);
			  })(r)
			: (function (r) {
					const s = n.value;
					if ((null == i ? void 0 : i.value) && e.accordion) {
						const { treeNodeMap: e } = i.value;
						s.forEach((t) => {
							const n = e.get(t);
							n && n.level == n.level && s.delete(t);
						});
					}
					s.add(r.key), t("node-expand", r.data, r);
			  })(r);
	}
	function A(e) {
		const t = r.value;
		return !!t && t === e.key;
	}
	function M(e) {
		ns(
			() =>
				(i.value = (function (e) {
					const t = new Map(),
						n = new Map();
					let r = 1;
					const i = (function e(i, s = 1, o) {
						var a;
						const l = [];
						for (const r of i) {
							const i = S(r),
								u = { level: s, key: i, data: r };
							(u.label = T(r)), (u.parent = o);
							const c = C(r);
							(u.disabled = E(r)), (u.isLeaf = !c || 0 === c.length), c && c.length && (u.children = e(c, s + 1, u)), l.push(u), t.set(i, u), n.has(s) || n.set(s, []), null == (a = n.get(s)) || a.push(u);
						}
						return s > r && (r = s), l;
					})(e);
					return { treeNodeMap: t, levelTreeNodeMap: n, maxLevel: r, treeNodes: i };
				})(e))
		);
	}
	return {
		tree: i,
		flattenTree: _,
		isNotEmpty: w,
		getKey: S,
		getChildren: C,
		toggleExpand: k,
		toggleCheckbox: a,
		isExpanded: function (e) {
			return n.value.has(e.key);
		},
		isChecked: o,
		isIndeterminate: s,
		isDisabled: function (e) {
			return !!e.disabled;
		},
		isCurrent: A,
		isForceHiddenExpandIcon: v,
		handleNodeClick: function (n, i) {
			t("node-click", n.data, n, i),
				(function (e) {
					A(e) || ((r.value = e.key), t("current-change", e.data, e));
				})(n),
				e.expandOnClickNode && k(n),
				e.showCheckbox && e.checkOnClickNode && !n.disabled && a(n, !o(n), !0);
		},
		handleNodeCheck: function (e, t) {
			a(e, t);
		},
		getCurrentNode: function () {
			var e, t;
			if (r.value) return null == (t = null == (e = null == i ? void 0 : i.value) ? void 0 : e.treeNodeMap.get(r.value)) ? void 0 : t.data;
		},
		getCurrentKey: function () {
			return r.value;
		},
		setCurrentKey: function (e) {
			r.value = e;
		},
		getCheckedKeys: l,
		getCheckedNodes: u,
		getHalfCheckedKeys: c,
		getHalfCheckedNodes: h,
		setChecked: d,
		setCheckedKeys: p,
		filter: function (e) {
			const t = f(e);
			t && (n.value = t);
		},
		setData: M
	};
}
var o2 = Tn({
	name: "ElTreeNodeContent",
	props: r2,
	setup(e) {
		const t = vn(Z1),
			n = BD("tree");
		return () => {
			const r = e.node,
				{ data: i } = r;
			return (null == t ? void 0 : t.ctx.slots.default) ? t.ctx.slots.default({ node: r, data: i }) : xs("span", { class: n.be("node", "label") }, [null == r ? void 0 : r.label]);
		};
	}
});
const a2 = Tn({
		name: "ElTreeNode",
		components: { ElIcon: OB, CaretRight: ML, ElCheckbox: qz, ElNodeContent: o2 },
		props: n2,
		emits: { click: (e, t) => !(!e || !t), toggle: (e) => !!e, check: (e, t) => e && "boolean" == typeof t },
		setup(e, { emit: t }) {
			const n = vn(Z1);
			return {
				ns: BD("tree"),
				indent: ht(() => {
					var e;
					return null != (e = null == n ? void 0 : n.props.indent) ? e : 16;
				}),
				icon: ht(() => {
					var e;
					return null != (e = null == n ? void 0 : n.props.icon) ? e : "caret-right";
				}),
				handleClick: (n) => {
					t("click", e.node, n);
				},
				handleExpandIconClick: () => {
					t("toggle", e.node);
				},
				handleCheckChange: (n) => {
					t("check", e.node, n);
				},
				handleContextMenu: (t) => {
					var r, i, s, o;
					(null == (s = null == (i = null == (r = null == n ? void 0 : n.instance) ? void 0 : r.vnode) ? void 0 : i.props) ? void 0 : s.onNodeContextmenu) && (t.stopPropagation(), t.preventDefault()),
						null == n || n.ctx.emit("node-contextmenu", t, null == (o = e.node) ? void 0 : o.data, e.node);
				}
			};
		}
	}),
	l2 = ["aria-expanded", "aria-disabled", "aria-checked", "data-key"];
const u2 = mN(
	IB(
		Tn({
			name: "ElTreeV2",
			components: {
				ElTreeNode: IB(a2, [
					[
						"render",
						function (e, t, n, r, i, s) {
							var o, a, l;
							const u = Or("el-icon"),
								c = Or("el-checkbox"),
								h = Or("el-node-content");
							return (
								Wr(),
								Kr(
									"div",
									{
										ref: "node$",
										class: gt([e.ns.b("node"), e.ns.is("expanded", e.expanded), e.ns.is("current", e.current), e.ns.is("focusable", !e.disabled), e.ns.is("checked", !e.disabled && e.checked)]),
										role: "treeitem",
										tabindex: "-1",
										"aria-expanded": e.expanded,
										"aria-disabled": e.disabled,
										"aria-checked": e.checked,
										"data-key": null == (o = e.node) ? void 0 : o.key,
										onClick: t[1] || (t[1] = zo((...t) => e.handleClick && e.handleClick(...t), ["stop"])),
										onContextmenu: t[2] || (t[2] = (...t) => e.handleContextMenu && e.handleContextMenu(...t))
									},
									[
										ni(
											"div",
											{ class: gt(e.ns.be("node", "content")), style: pt({ paddingLeft: (e.node.level - 1) * e.indent + "px" }) },
											[
												e.icon
													? (Wr(),
													  qr(
															u,
															{
																key: 0,
																class: gt([e.ns.is("leaf", !!(null == (a = e.node) ? void 0 : a.isLeaf)), e.ns.is("hidden", e.hiddenExpandIcon), { expanded: !(null == (l = e.node) ? void 0 : l.isLeaf) && e.expanded }, e.ns.be("node", "expand-icon")]),
																onClick: zo(e.handleExpandIconClick, ["stop"])
															},
															{ default: cn(() => [(Wr(), qr(Nr(e.icon)))]), _: 1 },
															8,
															["class", "onClick"]
													  ))
													: ai("v-if", !0),
												e.showCheckbox
													? (Wr(),
													  qr(c, { key: 1, "model-value": e.checked, indeterminate: e.indeterminate, disabled: e.disabled, onChange: e.handleCheckChange, onClick: t[0] || (t[0] = zo(() => {}, ["stop"])) }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"]))
													: ai("v-if", !0),
												ri(h, { node: e.node }, null, 8, ["node"])
											],
											6
										)
									],
									42,
									l2
								)
							);
						}
					],
					["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]
				]),
				FixedSizeList: Jq
			},
			props: t2,
			emits: i2,
			setup(e, t) {
				mn(Z1, { ctx: t, props: e, instance: Si() }), mn(YN, void 0);
				const { t: n } = CD(),
					r = BD("tree"),
					{
						flattenTree: i,
						isNotEmpty: s,
						toggleExpand: o,
						isExpanded: a,
						isIndeterminate: l,
						isChecked: u,
						isDisabled: c,
						isCurrent: h,
						isForceHiddenExpandIcon: d,
						toggleCheckbox: p,
						handleNodeClick: f,
						handleNodeCheck: m,
						getCurrentNode: v,
						getCurrentKey: g,
						setCurrentKey: y,
						getCheckedKeys: b,
						getCheckedNodes: x,
						getHalfCheckedKeys: _,
						getHalfCheckedNodes: w,
						setChecked: C,
						setCheckedKeys: S,
						filter: E,
						setData: T
					} = s2(e, t.emit);
				return (
					t.expose({ getCurrentNode: v, getCurrentKey: g, setCurrentKey: y, getCheckedKeys: b, getCheckedNodes: x, getHalfCheckedKeys: _, getHalfCheckedNodes: w, setChecked: C, setCheckedKeys: S, filter: E, setData: T }),
					{ t: n, ns: r, flattenTree: i, itemSize: 26, isNotEmpty: s, toggleExpand: o, toggleCheckbox: p, isExpanded: a, isIndeterminate: l, isChecked: u, isDisabled: c, isCurrent: h, isForceHiddenExpandIcon: d, handleNodeClick: f, handleNodeCheck: m }
				);
			}
		}),
		[
			[
				"render",
				function (e, t, n, r, i, s) {
					var o;
					const a = Or("el-tree-node"),
						l = Or("fixed-size-list");
					return (
						Wr(),
						Kr(
							"div",
							{ class: gt([e.ns.b(), { [e.ns.m("highlight-current")]: e.highlightCurrent }]), role: "tree" },
							[
								e.isNotEmpty
									? (Wr(),
									  qr(
											l,
											{ key: 0, "class-name": e.ns.b("virtual-list"), data: e.flattenTree, total: e.flattenTree.length, height: e.height, "item-size": e.itemSize, "perf-mode": e.perfMode },
											{
												default: cn(({ data: t, index: n, style: r }) => [
													(Wr(),
													qr(
														a,
														{
															key: t[n].key,
															style: pt(r),
															node: t[n],
															expanded: e.isExpanded(t[n]),
															"show-checkbox": e.showCheckbox,
															checked: e.isChecked(t[n]),
															indeterminate: e.isIndeterminate(t[n]),
															disabled: e.isDisabled(t[n]),
															current: e.isCurrent(t[n]),
															"hidden-expand-icon": e.isForceHiddenExpandIcon(t[n]),
															onClick: e.handleNodeClick,
															onToggle: e.toggleExpand,
															onCheck: e.handleNodeCheck
														},
														null,
														8,
														["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]
													))
												]),
												_: 1
											},
											8,
											["class-name", "data", "total", "height", "item-size", "perf-mode"]
									  ))
									: (Wr(), Kr("div", { key: 1, class: gt(e.ns.e("empty-block")) }, [ni("span", { class: gt(e.ns.e("empty-text")) }, bt(null != (o = e.emptyText) ? o : e.t("el.tree.emptyText")), 3)], 2))
							],
							2
						)
					);
				}
			],
			["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]
		]
	)
);
class c2 extends Error {
	constructor(e, t, n, r) {
		super(e), (this.name = "UploadAjaxError"), (this.status = t), (this.method = n), (this.url = r);
	}
}
function h2(e, t, n) {
	let r;
	return (r = n.response ? `${n.response.error || n.response}` : n.responseText ? `${n.responseText}` : `fail to ${t.method} ${e} ${n.status}`), new c2(r, n.status, t.method, e);
}
const d2 = ["text", "picture", "picture-card"];
let p2 = 1;
const f2 = () => Date.now() + p2++,
	m2 = uN({
		action: { type: String, default: "#" },
		headers: { type: Object },
		method: { type: String, default: "post" },
		data: { type: Object, default: () => ({}) },
		multiple: { type: Boolean, default: !1 },
		name: { type: String, default: "file" },
		drag: { type: Boolean, default: !1 },
		withCredentials: Boolean,
		showFileList: { type: Boolean, default: !0 },
		accept: { type: String, default: "" },
		type: { type: String, default: "select" },
		fileList: { type: Array, default: () => [] },
		autoUpload: { type: Boolean, default: !0 },
		listType: { type: String, values: d2, default: "text" },
		httpRequest: {
			type: Function,
			default: (e) => {
				"undefined" == typeof XMLHttpRequest && $R("ElUpload", "XMLHttpRequest is undefined");
				const t = new XMLHttpRequest(),
					n = e.action;
				t.upload &&
					t.upload.addEventListener("progress", (t) => {
						const n = t;
						(n.percent = t.total > 0 ? (t.loaded / t.total) * 100 : 0), e.onProgress(n);
					});
				const r = new FormData();
				if (e.data) for (const [s, o] of Object.entries(e.data)) Array.isArray(o) ? r.append(s, ...o) : r.append(s, o);
				r.append(e.filename, e.file, e.file.name),
					t.addEventListener("error", () => {
						e.onError(h2(n, e, t));
					}),
					t.addEventListener("load", () => {
						if (t.status < 200 || t.status >= 300) return e.onError(h2(n, e, t));
						e.onSuccess(
							(function (e) {
								const t = e.responseText || e.response;
								if (!t) return t;
								try {
									return JSON.parse(t);
								} catch (Kj) {
									return t;
								}
							})(t)
						);
					}),
					t.open(e.method, n, !0),
					e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
				const i = e.headers || {};
				if (i instanceof Headers) i.forEach((e, n) => t.setRequestHeader(n, e));
				else for (const [s, o] of Object.entries(i)) ik(o) || t.setRequestHeader(s, String(o));
				return t.send(r), t;
			}
		},
		disabled: Boolean,
		limit: Number
	}),
	v2 = uN(
		c(u({}, m2), {
			beforeUpload: { type: Function, default: yR },
			beforeRemove: { type: Function },
			onRemove: { type: Function, default: yR },
			onChange: { type: Function, default: yR },
			onPreview: { type: Function, default: yR },
			onSuccess: { type: Function, default: yR },
			onProgress: { type: Function, default: yR },
			onError: { type: Function, default: yR },
			onExceed: { type: Function, default: yR }
		})
	),
	g2 = uN({ files: { type: Array, default: () => [] }, disabled: { type: Boolean, default: !1 }, handlePreview: { type: Function, default: yR }, listType: { type: String, values: d2, default: "text" } }),
	y2 = ["onKeydown"],
	b2 = ["src"],
	x2 = ["onClick"],
	_2 = ["onClick"],
	w2 = ["onClick"];
var C2 = IB(
	Tn(
		c(u({}, { name: "ElUploadList" }), {
			props: g2,
			emits: { remove: (e) => !!e },
			setup(e, { emit: t }) {
				const n = e,
					{ t: r } = CD(),
					i = BD("upload"),
					s = BD("icon"),
					o = BD("list"),
					a = Qe(!1),
					l = (e) => {
						t("remove", e);
					};
				return (e, t) => (
					Wr(),
					qr(
						ko,
						{ tag: "ul", class: gt([it(i).b("list"), it(i).bm("list", e.listType), it(i).is("disabled", e.disabled)]), name: it(o).b() },
						{
							default: cn(() => [
								(Wr(!0),
								Kr(
									Hr,
									null,
									pi(
										e.files,
										(o) => (
											Wr(),
											Kr(
												"li",
												{
													key: o.uid || o.name,
													class: gt([it(i).be("list", "item"), it(i).is(o.status), { focusing: a.value }]),
													tabindex: "0",
													onKeydown: jo((t) => !e.disabled && l(o), ["delete"]),
													onFocus: t[0] || (t[0] = (e) => (a.value = !0)),
													onBlur: t[1] || (t[1] = (e) => (a.value = !1)),
													onClick: t[2] || (t[2] = (e) => (a.value = !1))
												},
												[
													mi(e.$slots, "default", { file: o }, () => [
														"picture" === e.listType || ("uploading" !== o.status && "picture-card" === e.listType) ? (Wr(), Kr("img", { key: 0, class: gt(it(i).be("list", "item-thumbnail")), src: o.url, alt: "" }, null, 10, b2)) : ai("v-if", !0),
														"picture" === e.listType || ("uploading" !== o.status && "picture-card" === e.listType)
															? ai("v-if", !0)
															: (Wr(),
															  Kr(
																	"div",
																	{ key: 1, class: gt(it(i).be("list", "item-info")) },
																	[
																		ni(
																			"a",
																			{
																				class: gt(it(i).be("list", "item-name")),
																				onClick: zo(
																					(e) =>
																						((e) => {
																							n.handlePreview(e);
																						})(o),
																					["prevent"]
																				)
																			},
																			[ri(it(OB), { class: gt(it(s).m("document")) }, { default: cn(() => [ri(it(CO))]), _: 1 }, 8, ["class"]), ni("span", { class: gt(it(i).be("list", "item-file-name")) }, bt(o.name), 3)],
																			10,
																			x2
																		),
																		"uploading" === o.status
																			? (Wr(),
																			  qr(
																					it(pq),
																					{
																						key: 0,
																						type: "picture-card" === e.listType ? "circle" : "line",
																						"stroke-width": "picture-card" === e.listType ? 6 : 2,
																						percentage: Number(o.percentage),
																						style: pt("picture-card" === e.listType ? "" : "margin-top: 0.5rem")
																					},
																					null,
																					8,
																					["type", "stroke-width", "percentage", "style"]
																			  ))
																			: ai("v-if", !0)
																	],
																	2
															  )),
														ni(
															"label",
															{ class: gt(it(i).be("list", "item-status-label")) },
															[
																"text" === e.listType
																	? (Wr(), qr(it(OB), { key: 0, class: gt([it(s).m("upload-success"), it(s).m("circle-check")]) }, { default: cn(() => [ri(it(WL))]), _: 1 }, 8, ["class"]))
																	: ["picture-card", "picture"].includes(e.listType)
																	? (Wr(), qr(it(OB), { key: 1, class: gt([it(s).m("upload-success"), it(s).m("check")]) }, { default: cn(() => [ri(it(BL))]), _: 1 }, 8, ["class"]))
																	: ai("v-if", !0)
															],
															2
														),
														e.disabled ? ai("v-if", !0) : (Wr(), qr(it(OB), { key: 2, class: gt(it(s).m("close")), onClick: (e) => l(o) }, { default: cn(() => [ri(it(aO))]), _: 2 }, 1032, ["class", "onClick"])),
														ai(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
														ai(" This is a bug which needs to be fixed "),
														ai(" TODO: Fix the incorrect navigation interaction "),
														e.disabled ? ai("v-if", !0) : (Wr(), Kr("i", { key: 3, class: gt(it(s).m("close-tip")) }, bt(it(r)("el.upload.deleteTip")), 3)),
														"picture-card" === e.listType
															? (Wr(),
															  Kr(
																	"span",
																	{ key: 4, class: gt(it(i).be("list", "item-actions")) },
																	[
																		ni("span", { class: gt(it(i).be("list", "item-preview")), onClick: (t) => e.handlePreview(o) }, [ri(it(OB), { class: gt(it(s).m("zoom-in")) }, { default: cn(() => [ri(it(rN))]), _: 1 }, 8, ["class"])], 10, _2),
																		e.disabled
																			? ai("v-if", !0)
																			: (Wr(), Kr("span", { key: 0, class: gt(it(i).be("list", "item-delete")), onClick: (e) => l(o) }, [ri(it(OB), { class: gt(it(s).m("delete")) }, { default: cn(() => [ri(it(bO))]), _: 1 }, 8, ["class"])], 10, w2))
																	],
																	2
															  ))
															: ai("v-if", !0)
													])
												],
												42,
												y2
											)
										)
									),
									128
								)),
								mi(e.$slots, "append")
							]),
							_: 3
						},
						8,
						["class", "name"]
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]
);
const S2 = uN({ disabled: { type: Boolean, default: !1 } }),
	E2 = { file: (e) => _R(e) },
	T2 = ["onDrop", "onDragover"];
var k2 = IB(
	Tn(
		c(u({}, { name: "ElUploadDrag" }), {
			props: S2,
			emits: E2,
			setup(e, { emit: t }) {
				const n = e,
					r = vn(QN);
				r || $R("ElUploadDrag", "usage: <el-upload><el-upload-dragger /></el-upload>");
				const i = BD("upload"),
					s = Qe(!1),
					o = (e) => {
						if (n.disabled) return;
						s.value = !1;
						const i = Array.from(e.dataTransfer.files),
							o = r.accept.value;
						if (!o) return void t("file", i);
						const a = i.filter((e) => {
							const { type: t, name: n } = e,
								r = n.includes(".") ? `.${n.split(".").pop()}` : "",
								i = t.replace(/\/.*$/, "");
							return o
								.split(",")
								.map((e) => e.trim())
								.filter((e) => e)
								.some((e) => (e.startsWith(".") ? r === e : /\/\*$/.test(e) ? i === e.replace(/\/\*$/, "") : !!/^[^/]+\/[^/]+$/.test(e) && t === e));
						});
						t("file", a);
					},
					a = () => {
						n.disabled || (s.value = !0);
					};
				return (e, t) => (Wr(), Kr("div", { class: gt([it(i).b("dragger"), it(i).is("dragover", s.value)]), onDrop: zo(o, ["prevent"]), onDragover: zo(a, ["prevent"]), onDragleave: t[0] || (t[0] = zo((e) => (s.value = !1), ["prevent"])) }, [mi(e.$slots, "default")], 42, T2));
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]
);
const A2 = uN(
		c(u({}, m2), {
			fileList: { type: Array, default: () => [] },
			beforeUpload: { type: Function, default: yR },
			onRemove: { type: Function, default: yR },
			onStart: { type: Function, default: yR },
			onSuccess: { type: Function, default: yR },
			onProgress: { type: Function, default: yR },
			onError: { type: Function, default: yR },
			onExceed: { type: Function, default: yR }
		})
	),
	M2 = ["onKeydown"],
	I2 = ["name", "multiple", "accept"];
var R2 = IB(
	Tn(
		c(u({}, { name: "ElUploadContent", inheritAttrs: !1 }), {
			props: A2,
			setup(e, { expose: t }) {
				const n = e,
					r = BD("upload"),
					i = et({}),
					s = et(),
					o = (e) => {
						if (0 === e.length) return;
						const { autoUpload: t, limit: r, fileList: i, multiple: s, onStart: o, onExceed: l } = n;
						if (r && i.length + e.length > r) l(e, i);
						else {
							s || (e = e.slice(0, 1));
							for (const n of e) {
								const e = n;
								(e.uid = f2()), o(e), t && a(e);
							}
						}
					},
					a = async (e) => {
						if (((s.value.value = ""), !n.beforeUpload)) return l(e);
						let t;
						try {
							t = await n.beforeUpload(e);
						} catch (Kj) {
							t = !1;
						}
						if (!1 === t) return void n.onRemove(e);
						let r = e;
						t instanceof Blob && (r = t instanceof File ? t : new File([t], e.name, { type: e.type })), l(Object.assign(r, { uid: e.uid }));
					},
					l = (e) => {
						const { headers: t, data: r, method: s, withCredentials: o, name: a, action: l, onProgress: u, onSuccess: c, onError: h, httpRequest: d } = n,
							{ uid: p } = e,
							f = {
								headers: t || {},
								withCredentials: o,
								file: e,
								data: r,
								method: s,
								filename: a,
								action: l,
								onProgress: (t) => {
									u(t, e);
								},
								onSuccess: (t) => {
									c(t, e), delete i.value[p];
								},
								onError: (t) => {
									h(t, e), delete i.value[p];
								}
							},
							m = d(f);
						(i.value[p] = m), m instanceof Promise && m.then(f.onSuccess, f.onError);
					},
					u = (e) => {
						const t = e.target.files;
						t && o(Array.from(t));
					},
					c = () => {
						n.disabled || ((s.value.value = ""), s.value.click());
					},
					h = () => {
						c();
					};
				return (
					t({
						abort: (e) => {
							var t;
							((t = i.value), Object.entries(t)).filter(e ? ([t]) => String(e.uid) === t : () => !0).forEach(([e, t]) => {
								t instanceof XMLHttpRequest && t.abort(), delete i.value[e];
							});
						},
						upload: a
					}),
					(e, t) => (
						Wr(),
						Kr(
							"div",
							{ class: gt([it(r).b(), it(r).m(e.listType), it(r).is("drag", e.drag)]), tabindex: "0", onClick: c, onKeydown: jo(zo(h, ["self"]), ["enter", "space"]) },
							[
								e.drag ? (Wr(), qr(k2, { key: 0, disabled: e.disabled, onFile: o }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["disabled"])) : mi(e.$slots, "default", { key: 1 }),
								ni("input", { ref_key: "inputRef", ref: s, class: gt(it(r).e("input")), name: e.name, multiple: e.multiple, accept: e.accept, type: "file", onChange: u, onClick: t[0] || (t[0] = zo(() => {}, ["stop"])) }, null, 42, I2)
							],
							42,
							M2
						)
					)
				);
			}
		})
	),
	[["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]
);
const L2 = (e, t) => {
	const n = Qe([]),
		r = (e) => n.value.find((t) => t.uid === e.uid);
	function i(e) {
		var n;
		null == (n = t.value) || n.abort(e);
	}
	return (
		ds(
			() => e.listType,
			(t) => {
				("picture-card" !== t && "picture" !== t) ||
					(n.value = n.value.map((t) => {
						const { raw: r, url: i } = t;
						if (!i && r)
							try {
								t.url = URL.createObjectURL(r);
							} catch (s) {
								e.onError(s, t, n.value);
							}
						return t;
					}));
			}
		),
		ds(
			() => e.fileList,
			(e) => {
				for (const t of e) t.uid || (t.uid = f2()), t.status || (t.status = "success");
				n.value = e;
			},
			{ immediate: !0, deep: !0 }
		),
		{
			abort: i,
			clearFiles: function (e = ["ready", "uploading", "success", "fail"]) {
				n.value = n.value.filter((t) => !e.includes(t.status));
			},
			handleError: (t, i) => {
				const s = r(i);
				s && ((s.status = "fail"), n.value.splice(n.value.indexOf(s), 1), e.onError(t, s, n.value), e.onChange(s, n.value));
			},
			handleProgress: (t, i) => {
				const s = r(i);
				s && (e.onProgress(t, s, n.value), (s.status = "uploading"), (s.percentage = Math.round(t.percent)));
			},
			handleStart: (t) => {
				const r = { name: t.name, percentage: 0, status: "ready", size: t.size, raw: t, uid: t.uid };
				if ("picture-card" === e.listType || "picture" === e.listType)
					try {
						r.url = URL.createObjectURL(t);
					} catch (i) {
						i.message, e.onError(i, r, n.value);
					}
				n.value.push(r), e.onChange(r, n.value);
			},
			handleSuccess: (t, i) => {
				const s = r(i);
				s && ((s.status = "success"), (s.response = t), e.onSuccess(t, s, n.value), e.onChange(s, n.value));
			},
			handleRemove: async (t) => {
				const s = t instanceof File ? r(t) : t;
				s || $R("ElUpload", "file to be removed not found");
				const o = (t) => {
					i(t);
					const r = n.value;
					r.splice(r.indexOf(t), 1),
						e.onRemove(t, r),
						((e) => {
							var t;
							(null == (t = e.url) ? void 0 : t.startsWith("blob:")) && URL.revokeObjectURL(e.url);
						})(t);
				};
				if (e.beforeRemove) {
					!1 !== (await e.beforeRemove(s, n.value)) && o(s);
				} else o(s);
			},
			submit: function () {
				n.value
					.filter(({ status: e }) => "ready" === e)
					.forEach(({ raw: e }) => {
						var n;
						return e && (null == (n = t.value) ? void 0 : n.upload(e));
					});
			},
			uploadFiles: n
		}
	);
};
const O2 = mN(
	IB(
		Tn(
			c(u({}, { name: "ElUpload" }), {
				props: v2,
				setup(e, { expose: t }) {
					const n = e,
						r = gs(),
						i = dD(),
						s = et(),
						{ abort: o, submit: a, clearFiles: l, uploadFiles: h, handleStart: d, handleError: p, handleRemove: f, handleSuccess: m, handleProgress: v } = L2(n, s),
						g = ht(() => "picture-card" === n.listType),
						y = ht(() => c(u({}, n), { onStart: d, onProgress: v, onSuccess: m, onError: p, onRemove: f }));
					return (
						$n(() => {
							h.value.forEach(({ url: e }) => {
								(null == e ? void 0 : e.startsWith("blob:")) && URL.revokeObjectURL(e);
							});
						}),
						mn(QN, { accept: ut(n, "accept") }),
						t({ abort: o, submit: a, clearFiles: l, handleStart: d, handleRemove: f }),
						(e, t) => (
							Wr(),
							Kr("div", null, [
								it(g) && e.showFileList
									? (Wr(),
									  qr(
											C2,
											{ key: 0, disabled: it(i), "list-type": e.listType, files: it(h), "handle-preview": e.onPreview, onRemove: it(f) },
											fi(
												{
													append: cn(() => [
														"picture-card" === e.listType
															? (Wr(),
															  qr(
																	R2,
																	hi({ key: 0, ref_key: "uploadRef", ref: s }, it(y)),
																	{ default: cn(() => [it(r).trigger ? mi(e.$slots, "trigger", { key: 0 }) : ai("v-if", !0), !it(r).trigger && it(r).default ? mi(e.$slots, "default", { key: 1 }) : ai("v-if", !0)]), _: 3 },
																	16
															  ))
															: ai("v-if", !0)
													]),
													_: 2
												},
												[e.$slots.file ? { name: "default", fn: cn(({ file: t }) => [mi(e.$slots, "file", { file: t })]) } : void 0]
											),
											1032,
											["disabled", "list-type", "files", "handle-preview", "onRemove"]
									  ))
									: ai("v-if", !0),
								"picture-card" !== e.listType
									? (Wr(), qr(R2, hi({ key: 1, ref_key: "uploadRef", ref: s }, it(y)), { default: cn(() => [it(r).trigger ? mi(e.$slots, "trigger", { key: 0 }) : ai("v-if", !0), !it(r).trigger && it(r).default ? mi(e.$slots, "default", { key: 1 }) : ai("v-if", !0)]), _: 3 }, 16))
									: ai("v-if", !0),
								e.$slots.trigger ? mi(e.$slots, "default", { key: 2 }) : ai("v-if", !0),
								mi(e.$slots, "tip"),
								!it(g) && e.showFileList
									? (Wr(),
									  qr(C2, { key: 3, disabled: it(i), "list-type": e.listType, files: it(h), "handle-preview": e.onPreview, onRemove: it(f) }, fi({ _: 2 }, [e.$slots.file ? { name: "default", fn: cn(({ file: t }) => [mi(e.$slots, "file", { file: t })]) } : void 0]), 1032, [
											"disabled",
											"list-type",
											"files",
											"handle-preview",
											"onRemove"
									  ]))
									: ai("v-if", !0)
							])
						)
					);
				}
			})
		),
		[["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]
	)
);
var P2 = [
	RB,
	DB,
	sV,
	R0,
	uV,
	pV,
	vV,
	_V,
	wV,
	qV,
	ZV,
	Cz,
	Ez,
	Pz,
	Nz,
	$$,
	R$,
	G$,
	qz,
	Zz,
	Jz,
	X$,
	aj,
	lj,
	tj,
	Dj,
	Fj,
	jj,
	Wj,
	Gj,
	Yj,
	Xj,
	sG,
	dG,
	pG,
	CG,
	EG,
	LG,
	vY,
	gY,
	yY,
	XY,
	AX,
	MX,
	OB,
	BX,
	LX,
	WB,
	zX,
	GX,
	lK,
	uK,
	cK,
	dK,
	qK,
	QK,
	sq,
	FH,
	pq,
	d$,
	f$,
	p$,
	yq,
	wq,
	Sq,
	ZB,
	RK,
	LK,
	OK,
	NZ,
	HZ,
	VZ,
	sJ,
	lJ,
	fJ,
	mJ,
	CJ,
	OQ,
	PQ,
	I0,
	z0,
	$0,
	P$,
	mz,
	Z0,
	t1,
	n1,
	QH,
	x1,
	k1,
	W1,
	q1,
	u2,
	O2
];
const N2 = "ElInfiniteScroll",
	D2 = { delay: { type: Number, default: 200 }, distance: { type: Number, default: 0 }, disabled: { type: Boolean, default: !1 }, immediate: { type: Boolean, default: !0 } },
	B2 = (e, t) =>
		Object.entries(D2).reduce((n, [r, i]) => {
			var s, o;
			const { type: a, default: l } = i,
				u = e.getAttribute(`infinite-scroll-${r}`);
			let c = null != (o = null != (s = t[u]) ? s : u) ? o : l;
			return (c = "false" !== c && c), (c = a(c)), (n[r] = Number.isNaN(c) ? l : c), n;
		}, {}),
	F2 = (e) => {
		const { observer: t } = e[N2];
		t && (t.disconnect(), delete e[N2].observer);
	},
	H2 = (e, t) => {
		const { container: n, containerEl: r, instance: i, observer: s, lastScrollTop: o } = e[N2],
			{ disabled: a, distance: l } = B2(e, i),
			{ clientHeight: u, scrollHeight: c, scrollTop: h } = r,
			d = h - o;
		if (((e[N2].lastScrollTop = h), s || a || d < 0)) return;
		let p = !1;
		if (n === e) p = c - (u + h) <= l;
		else {
			const { clientTop: t, scrollHeight: n } = e;
			p = h + u >= ((e, t) => Math.abs(mR(e) - mR(t)))(e, r) + t + n - l;
		}
		p && t.call(i);
	};
function V2(e, t) {
	const { containerEl: n, instance: r } = e[N2],
		{ disabled: i } = B2(e, r);
	i || 0 === n.clientHeight || (n.scrollHeight <= n.clientHeight ? t.call(r) : F2(e));
}
const U2 = {
		async mounted(e, t) {
			const { instance: n, value: r } = t;
			CR(r) || $R(N2, "'v-infinite-scroll' binding value must be a function"), await ns();
			const { delay: i, immediate: s } = B2(e, n),
				o = ZR(e, !0),
				a = o === window ? document.documentElement : o,
				l = hk(H2.bind(null, e, r), i);
			if (o) {
				if (((e[N2] = { instance: n, container: o, containerEl: a, delay: i, cb: r, onScroll: l, lastScrollTop: a.scrollTop }), s)) {
					const t = new MutationObserver(hk(V2.bind(null, e, r), 50));
					(e[N2].observer = t), t.observe(e, { childList: !0, subtree: !0 }), V2(e, r);
				}
				o.addEventListener("scroll", l);
			}
		},
		unmounted(e) {
			const { container: t, onScroll: n } = e[N2];
			null == t || t.removeEventListener("scroll", n), F2(e);
		},
		async updated(e) {
			e[N2] || (await ns());
			const { containerEl: t, cb: n, observer: r } = e[N2];
			t.clientHeight && r && V2(e, n);
		},
		install: (e) => {
			e.directive("InfiniteScroll", U2);
		}
	},
	z2 = U2;
let $2;
const j2 = function (e = {}) {
		if (!GI) return;
		const t = W2(e);
		if (t.fullscreen && $2) return $2;
		const n = (function (e) {
			let t;
			const n = BD("loading"),
				r = Qe(!1),
				i = Fe(c(u({}, e), { originalPosition: "", originalOverflow: "", visible: !1 }));
			function s() {
				const e = i.parent;
				if (!e.vLoadingAddClassList) {
					let t = e.getAttribute("loading-number");
					(t = Number.parseInt(t) - 1), t ? e.setAttribute("loading-number", t.toString()) : (YR(e, n.bm("parent", "relative")), e.removeAttribute("loading-number")), YR(e, n.bm("parent", "hidden"));
				}
				o(), l.unmount();
			}
			function o() {
				var e, t;
				null == (t = null == (e = h.$el) ? void 0 : e.parentNode) || t.removeChild(h.$el);
			}
			function a() {
				r.value && ((r.value = !1), s());
			}
			const l = Zo({
					name: "ElLoading",
					setup: () => () => {
						const e = i.spinner || i.svg,
							t = xs("svg", u({ class: "circular", viewBox: i.svgViewBox ? i.svgViewBox : "25 25 50 50" }, e ? { innerHTML: e } : {}), [xs("circle", { class: "path", cx: "50", cy: "50", r: "20", fill: "none" })]),
							r = i.text ? xs("p", { class: n.b("text") }, [i.text]) : void 0;
						return xs(
							lo,
							{ name: n.b("fade"), onAfterLeave: a },
							{ default: cn(() => [yr(ri("div", { style: { backgroundColor: i.background || "" }, class: [n.b("mask"), i.customClass, i.fullscreen ? "is-fullscreen" : ""] }, [xs("div", { class: n.b("spinner") }, [t, r])]), [[Wo, i.visible]])]) }
						);
					}
				}),
				h = l.mount(document.createElement("div"));
			return c(u({}, at(i)), {
				setText: function (e) {
					i.text = e;
				},
				removeElLoadingChild: o,
				close: function () {
					var n;
					(e.beforeClose && !e.beforeClose()) ||
						((i.parent.vLoadingAddClassList = void 0),
						(r.value = !0),
						clearTimeout(t),
						(t = window.setTimeout(() => {
							r.value && ((r.value = !1), s());
						}, 400)),
						(i.visible = !1),
						null == (n = e.closed) || n.call(e));
				},
				handleAfterLeave: a,
				vm: h,
				get $el() {
					return h.$el;
				}
			});
		})(
			c(u({}, t), {
				closed: () => {
					var e;
					null == (e = t.closed) || e.call(t), t.fullscreen && ($2 = void 0);
				}
			})
		);
		G2(t, t.parent, n), Y2(t, t.parent, n), (t.parent.vLoadingAddClassList = () => Y2(t, t.parent, n));
		let r = t.parent.getAttribute("loading-number");
		return (r = r ? `${Number.parseInt(r) + 1}` : "1"), t.parent.setAttribute("loading-number", r), t.parent.appendChild(n.$el), ns(() => (n.visible.value = t.visible)), t.fullscreen && ($2 = n), n;
	},
	W2 = (e) => {
		var t, n, r, i;
		let s;
		return (
			(s = SR(e.target) ? (null != (t = document.querySelector(e.target)) ? t : document.body) : e.target || document.body),
			{
				parent: s === document.body || e.body ? document.body : s,
				background: e.background || "",
				svg: e.svg || "",
				svgViewBox: e.svgViewBox || "",
				spinner: e.spinner || !1,
				text: e.text || "",
				fullscreen: s === document.body && (null == (n = e.fullscreen) || n),
				lock: null != (r = e.lock) && r,
				customClass: e.customClass || "",
				visible: null == (i = e.visible) || i,
				target: s
			}
		);
	},
	G2 = async (e, t, n) => {
		const { nextZIndex: r } = HD(),
			i = {};
		if (e.fullscreen) (n.originalPosition.value = XR(document.body, "position")), (n.originalOverflow.value = XR(document.body, "overflow")), (i.zIndex = r());
		else if (e.parent === document.body) {
			(n.originalPosition.value = XR(document.body, "position")), await ns();
			for (const t of ["top", "left"]) {
				const n = "top" === t ? "scrollTop" : "scrollLeft";
				i[t] = e.target.getBoundingClientRect()[t] + document.body[n] + document.documentElement[n] - Number.parseInt(XR(document.body, `margin-${t}`), 10) + "px";
			}
			for (const t of ["height", "width"]) i[t] = `${e.target.getBoundingClientRect()[t]}px`;
		} else n.originalPosition.value = XR(t, "position");
		for (const [s, o] of Object.entries(i)) n.$el.style[s] = o;
	},
	Y2 = (e, t, n) => {
		const r = BD("loading");
		"absolute" !== n.originalPosition.value && "fixed" !== n.originalPosition.value ? GR(t, r.bm("parent", "relative")) : YR(t, r.bm("parent", "relative")), e.fullscreen && e.lock ? GR(t, r.bm("parent", "hidden")) : YR(t, r.bm("parent", "hidden"));
	},
	X2 = Symbol("ElLoading"),
	K2 = (e, t) => {
		var n, r, i, s;
		const o = t.instance,
			a = (e) => (ER(t.value) ? t.value[e] : void 0),
			l = (t) =>
				((e) => {
					const t = (SR(e) && (null == o ? void 0 : o[e])) || e;
					return t ? Qe(t) : t;
				})(a(t) || e.getAttribute(`element-loading-${NR(t)}`)),
			u = null != (n = a("fullscreen")) ? n : t.modifiers.fullscreen,
			c = {
				text: l("text"),
				svg: l("svg"),
				svgViewBox: l("svgViewBox"),
				spinner: l("spinner"),
				background: l("background"),
				customClass: l("customClass"),
				fullscreen: u,
				target: null != (r = a("target")) ? r : u ? void 0 : e,
				body: null != (i = a("body")) ? i : t.modifiers.body,
				lock: null != (s = a("lock")) ? s : t.modifiers.lock
			};
		e[X2] = { options: c, instance: j2(c) };
	},
	q2 = {
		mounted(e, t) {
			t.value && K2(e, t);
		},
		updated(e, t) {
			const n = e[X2];
			t.oldValue !== t.value &&
				(t.value && !t.oldValue
					? K2(e, t)
					: t.value && t.oldValue
					? ER(t.value) &&
					  ((e, t) => {
							for (const n of Object.keys(t)) Je(t[n]) && (t[n].value = e[n]);
					  })(t.value, n.options)
					: null == n || n.instance.close());
		},
		unmounted(e) {
			var t;
			null == (t = e[X2]) || t.instance.close();
		}
	},
	Z2 = {
		install(e) {
			e.directive("loading", q2), (e.config.globalProperties.$loading = j2);
		},
		directive: q2,
		service: j2
	},
	J2 = ["success", "info", "warning", "error"],
	Q2 = uN({
		customClass: { type: String, default: "" },
		center: { type: Boolean, default: !1 },
		dangerouslyUseHTMLString: { type: Boolean, default: !1 },
		duration: { type: Number, default: 3e3 },
		icon: { type: cN, default: "" },
		id: { type: String, default: "" },
		message: { type: [String, Object, Function], default: "" },
		onClose: { type: Function, required: !1 },
		showClose: { type: Boolean, default: !1 },
		type: { type: String, values: J2, default: "info" },
		offset: { type: Number, default: 20 },
		zIndex: { type: Number, default: 0 },
		grouping: { type: Boolean, default: !1 },
		repeatNum: { type: Number, default: 1 }
	}),
	e3 = Tn({
		name: "ElMessage",
		components: u({ ElBadge: vV, ElIcon: OB }, dN),
		props: Q2,
		emits: { destroy: () => !0 },
		setup(e) {
			const t = BD("message"),
				n = Qe(!1),
				r = Qe(e.type ? ("error" === e.type ? "danger" : e.type) : "info");
			let i;
			const s = ht(() => {
					const n = e.type;
					return { [t.bm("icon", n)]: n && pN[n] };
				}),
				o = ht(() => e.icon || pN[e.type] || ""),
				a = ht(() => ({ top: `${e.offset}px`, zIndex: e.zIndex }));
			function l() {
				e.duration > 0 &&
					({ stop: i } = eR(() => {
						n.value && c();
					}, e.duration));
			}
			function u() {
				null == i || i();
			}
			function c() {
				n.value = !1;
			}
			return (
				Vn(() => {
					l(), (n.value = !0);
				}),
				ds(
					() => e.repeatNum,
					() => {
						u(), l();
					}
				),
				iR(document, "keydown", function ({ code: e }) {
					e === bN.esc ? n.value && c() : l();
				}),
				{ ns: t, typeClass: s, iconComponent: o, customStyle: a, visible: n, badgeType: r, close: c, clearTimer: u, startTimer: l }
			);
		}
	}),
	t3 = ["id"],
	n3 = ["innerHTML"];
var r3 = IB(e3, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-badge"),
				a = Or("el-icon"),
				l = Or("close");
			return (
				Wr(),
				qr(
					lo,
					{ name: e.ns.b("fade"), onBeforeLeave: e.onClose, onAfterLeave: t[2] || (t[2] = (t) => e.$emit("destroy")), persisted: "" },
					{
						default: cn(() => [
							yr(
								ni(
									"div",
									{
										id: e.id,
										class: gt([e.ns.b(), { [e.ns.m(e.type)]: e.type && !e.icon }, e.ns.is("center", e.center), e.ns.is("closable", e.showClose), e.customClass]),
										style: pt(e.customStyle),
										role: "alert",
										onMouseenter: t[0] || (t[0] = (...t) => e.clearTimer && e.clearTimer(...t)),
										onMouseleave: t[1] || (t[1] = (...t) => e.startTimer && e.startTimer(...t))
									},
									[
										e.repeatNum > 1 ? (Wr(), qr(o, { key: 0, value: e.repeatNum, type: e.badgeType, class: gt(e.ns.e("badge")) }, null, 8, ["value", "type", "class"])) : ai("v-if", !0),
										e.iconComponent ? (Wr(), qr(a, { key: 1, class: gt([e.ns.e("icon"), e.typeClass]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
										mi(e.$slots, "default", {}, () => [
											e.dangerouslyUseHTMLString
												? (Wr(), Kr(Hr, { key: 1 }, [ai(" Caution here, message could've been compromised, never use user's input as message "), ni("p", { class: gt(e.ns.e("content")), innerHTML: e.message }, null, 10, n3)], 2112))
												: (Wr(), Kr("p", { key: 0, class: gt(e.ns.e("content")) }, bt(e.message), 3))
										]),
										e.showClose ? (Wr(), qr(a, { key: 2, class: gt(e.ns.e("closeBtn")), onClick: zo(e.close, ["stop"]) }, { default: cn(() => [ri(l)]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)
									],
									46,
									t3
								),
								[[Wo, e.visible]]
							)
						]),
						_: 3
					},
					8,
					["name", "onBeforeLeave"]
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]
]);
const i3 = [];
let s3 = 1;
const o3 = function (e = {}, t) {
	if (!GI) return { close: () => {} };
	if (XI(Bj.max) && i3.length >= Bj.max) return { close: () => {} };
	if (!Zr(e) && ER(e) && e.grouping && !Zr(e.message) && i3.length) {
		const t = i3.find((t) => {
			var n, r, i;
			return `${null != (r = null == (n = t.vm.props) ? void 0 : n.message) ? r : ""}` == `${null != (i = e.message) ? i : ""}`;
		});
		if (t) return (t.vm.component.props.repeatNum += 1), (t.vm.component.props.type = (null == e ? void 0 : e.type) || "info"), { close: () => (d.component.proxy.visible = !1) };
	}
	(SR(e) || Zr(e)) && (e = { message: e });
	let n = e.offset || 20;
	i3.forEach(({ vm: e }) => {
		var t;
		n += ((null == (t = e.el) ? void 0 : t.offsetHeight) || 0) + 16;
	}),
		(n += 16);
	const { nextZIndex: r } = HD(),
		i = "message_" + s3++,
		s = e.onClose,
		o = c(u({ zIndex: r() }, e), {
			offset: n,
			id: i,
			onClose: () => {
				!(function (e, t) {
					const n = i3.findIndex(({ vm: t }) => e === t.component.props.id);
					if (-1 === n) return;
					const { vm: r } = i3[n];
					if (!r) return;
					null == t || t(r);
					const i = r.el.offsetHeight;
					i3.splice(n, 1);
					const s = i3.length;
					if (s < 1) return;
					for (let o = n; o < s; o++) {
						const e = Number.parseInt(i3[o].vm.el.style.top, 10) - i - 16;
						i3[o].vm.component.props.offset = e;
					}
				})(i, s);
			}
		});
	let a = document.body;
	HR(e.appendTo) ? (a = e.appendTo) : SR(e.appendTo) && (a = document.querySelector(e.appendTo)), HR(a) || (a = document.body);
	const l = document.createElement("div");
	l.className = `container_${i}`;
	const h = o.message,
		d = ri(r3, o, CR(h) ? { default: h } : Zr(h) ? { default: () => h } : null);
	return (
		(d.appContext = t || o3._context),
		(d.props.onDestroy = () => {
			qo(null, l);
		}),
		qo(d, l),
		i3.push({ vm: d }),
		a.appendChild(l.firstElementChild),
		{ close: () => (d.component.proxy.visible = !1) }
	);
};
J2.forEach((e) => {
	o3[e] = (t = {}, n) => ((SR(t) || Zr(t)) && (t = { message: t }), o3(c(u({}, t), { type: e }), n));
}),
	(o3.closeAll = function () {
		var e;
		for (let t = i3.length - 1; t >= 0; t--) {
			const n = i3[t].vm.component;
			null == (e = null == n ? void 0 : n.proxy) || e.close();
		}
	}),
	(o3._context = null);
const a3 = vN(o3, "$message"),
	l3 = Tn({
		name: "ElMessageBox",
		directives: { TrapFocus: kU },
		components: u({ ElButton: qV, ElFocusTrap: LH, ElInput: WB, ElOverlay: fG, ElIcon: OB }, dN),
		inheritAttrs: !1,
		props: {
			buttonSize: { type: String, validator: EN },
			modal: { type: Boolean, default: !0 },
			lockScroll: { type: Boolean, default: !0 },
			showClose: { type: Boolean, default: !0 },
			closeOnClickModal: { type: Boolean, default: !0 },
			closeOnPressEscape: { type: Boolean, default: !0 },
			closeOnHashChange: { type: Boolean, default: !0 },
			center: Boolean,
			draggable: Boolean,
			roundButton: { default: !1, type: Boolean },
			container: { type: String, default: "body" },
			boxType: { type: String, default: "" }
		},
		emits: ["vanish", "action"],
		setup(e, { emit: t }) {
			const { t: n } = CD(),
				r = BD("message-box"),
				i = Qe(!1),
				{ nextZIndex: s } = HD(),
				o = Fe({
					beforeClose: null,
					callback: null,
					cancelButtonText: "",
					cancelButtonClass: "",
					confirmButtonText: "",
					confirmButtonClass: "",
					customClass: "",
					customStyle: {},
					dangerouslyUseHTMLString: !1,
					distinguishCancelAndClose: !1,
					icon: "",
					inputPattern: null,
					inputPlaceholder: "",
					inputType: "text",
					inputValue: null,
					inputValidator: null,
					inputErrorMessage: "",
					message: null,
					modalFade: !0,
					modalClass: "",
					showCancelButton: !1,
					showConfirmButton: !0,
					type: "",
					title: void 0,
					showInput: !1,
					action: "",
					confirmButtonLoading: !1,
					cancelButtonLoading: !1,
					confirmButtonDisabled: !1,
					editorErrorMessage: "",
					validateError: !1,
					zIndex: s()
				}),
				a = ht(() => {
					const e = o.type;
					return { [r.bm("icon", e)]: e && pN[e] };
				}),
				l = gD(),
				h = gD(),
				d = hD(
					ht(() => e.buttonSize),
					{ prop: !0, form: !0, formItem: !0 }
				),
				p = ht(() => o.icon || pN[o.type] || ""),
				f = ht(() => !!o.message),
				m = Qe(),
				v = Qe(),
				g = Qe(),
				y = Qe(),
				b = Qe(),
				x = ht(() => o.confirmButtonClass);
			ds(
				() => o.inputValue,
				async (t) => {
					await ns(), "prompt" === e.boxType && null !== t && T();
				},
				{ immediate: !0 }
			),
				ds(
					() => i.value,
					(t) => {
						var n, r;
						t && (("alert" !== e.boxType && "confirm" !== e.boxType) || (g.value = null != (r = null == (n = b.value) ? void 0 : n.$el) ? r : m.value), (o.zIndex = s())),
							"prompt" === e.boxType &&
								(t
									? ns().then(() => {
											var e;
											y.value && y.value.$el && (g.value = null != (e = k()) ? e : m.value);
									  })
									: ((o.editorErrorMessage = ""), (o.validateError = !1)));
					}
				);
			const _ = ht(() => e.draggable);
			function w() {
				i.value &&
					((i.value = !1),
					ns(() => {
						o.action && t("action", o.action);
					}));
			}
			fD(m, v, _),
				Vn(async () => {
					await ns(), e.closeOnHashChange && RI(window, "hashchange", w);
				}),
				$n(() => {
					e.closeOnHashChange && LI(window, "hashchange", w);
				});
			const C = () => {
					e.closeOnClickModal && E(o.distinguishCancelAndClose ? "close" : "cancel");
				},
				S = kD(C),
				E = (t) => {
					var n;
					("prompt" !== e.boxType || "confirm" !== t || T()) && ((o.action = t), o.beforeClose ? null == (n = o.beforeClose) || n.call(o, t, o, w) : w());
				},
				T = () => {
					if ("prompt" === e.boxType) {
						const e = o.inputPattern;
						if (e && !e.test(o.inputValue || "")) return (o.editorErrorMessage = o.inputErrorMessage || n("el.messagebox.error")), (o.validateError = !0), !1;
						const t = o.inputValidator;
						if ("function" == typeof t) {
							const e = t(o.inputValue);
							if (!1 === e) return (o.editorErrorMessage = o.inputErrorMessage || n("el.messagebox.error")), (o.validateError = !0), !1;
							if ("string" == typeof e) return (o.editorErrorMessage = e), (o.validateError = !0), !1;
						}
					}
					return (o.editorErrorMessage = ""), (o.validateError = !1), !0;
				},
				k = () => {
					const e = y.value.$refs;
					return e.input || e.textarea;
				},
				A = () => {
					E("close");
				};
			return (
				e.lockScroll && SD(i),
				((e, t) => {
					let n;
					ds(
						() => e.value,
						(e) => {
							var r, i;
							e ? ((n = document.activeElement), Je(t) && (null == (i = (r = t.value).focus) || i.call(r))) : n.focus();
						}
					);
				})(i),
				c(u({}, at(o)), {
					ns: r,
					overlayEvent: S,
					visible: i,
					hasMessage: f,
					typeClass: a,
					contentId: l,
					inputId: h,
					btnSize: d,
					iconComponent: p,
					confirmButtonClasses: x,
					rootRef: m,
					focusStartRef: g,
					headerRef: v,
					inputRef: y,
					confirmRef: b,
					doClose: w,
					handleClose: A,
					onCloseRequested: () => {
						e.closeOnPressEscape && A();
					},
					handleWrapperClick: C,
					handleInputEnter: (e) => {
						if ("textarea" !== o.inputType) return e.preventDefault(), E("confirm");
					},
					handleAction: E,
					t: n
				})
			);
		}
	}),
	u3 = ["aria-label", "aria-describedby"],
	c3 = ["aria-label"],
	h3 = ["id"];
var d3 = IB(l3, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-icon"),
				a = Or("close"),
				l = Or("el-input"),
				u = Or("el-button"),
				c = Or("el-focus-trap"),
				h = Or("el-overlay");
			return (
				Wr(),
				qr(
					lo,
					{ name: "fade-in-linear", onAfterLeave: t[11] || (t[11] = (t) => e.$emit("vanish")), persisted: "" },
					{
						default: cn(() => [
							yr(
								ri(
									h,
									{ "z-index": e.zIndex, "overlay-class": [e.ns.is("message-box"), e.modalClass], mask: e.modal },
									{
										default: cn(() => [
											ni(
												"div",
												{
													role: "dialog",
													"aria-label": e.title,
													"aria-modal": "true",
													"aria-describedby": e.showInput ? void 0 : e.contentId,
													class: gt(`${e.ns.namespace.value}-overlay-message-box`),
													onClick: t[8] || (t[8] = (...t) => e.overlayEvent.onClick && e.overlayEvent.onClick(...t)),
													onMousedown: t[9] || (t[9] = (...t) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...t)),
													onMouseup: t[10] || (t[10] = (...t) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...t))
												},
												[
													ri(
														c,
														{ loop: "", trapped: e.visible, "focus-trap-el": e.rootRef, "focus-start-el": e.focusStartRef, onReleaseRequested: e.onCloseRequested },
														{
															default: cn(() => [
																ni(
																	"div",
																	{ ref: "rootRef", class: gt([e.ns.b(), e.customClass, e.ns.is("draggable", e.draggable), { [e.ns.m("center")]: e.center }]), style: pt(e.customStyle), tabindex: "-1", onClick: t[7] || (t[7] = zo(() => {}, ["stop"])) },
																	[
																		null !== e.title && void 0 !== e.title
																			? (Wr(),
																			  Kr(
																					"div",
																					{ key: 0, ref: "headerRef", class: gt(e.ns.e("header")) },
																					[
																						ni(
																							"div",
																							{ class: gt(e.ns.e("title")) },
																							[
																								e.iconComponent && e.center ? (Wr(), qr(o, { key: 0, class: gt([e.ns.e("status"), e.typeClass]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
																								ni("span", null, bt(e.title), 1)
																							],
																							2
																						),
																						e.showClose
																							? (Wr(),
																							  Kr(
																									"button",
																									{
																										key: 0,
																										type: "button",
																										class: gt(e.ns.e("headerbtn")),
																										"aria-label": e.t("el.messagebox.close"),
																										onClick: t[0] || (t[0] = (t) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
																										onKeydown:
																											t[1] ||
																											(t[1] = jo(
																												zo((t) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]),
																												["enter"]
																											))
																									},
																									[ri(o, { class: gt(e.ns.e("close")) }, { default: cn(() => [ri(a)]), _: 1 }, 8, ["class"])],
																									42,
																									c3
																							  ))
																							: ai("v-if", !0)
																					],
																					2
																			  ))
																			: ai("v-if", !0),
																		ni(
																			"div",
																			{ id: e.contentId, class: gt(e.ns.e("content")) },
																			[
																				ni(
																					"div",
																					{ class: gt(e.ns.e("container")) },
																					[
																						e.iconComponent && !e.center && e.hasMessage ? (Wr(), qr(o, { key: 0, class: gt([e.ns.e("status"), e.typeClass]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
																						e.hasMessage
																							? (Wr(),
																							  Kr(
																									"div",
																									{ key: 1, class: gt(e.ns.e("message")) },
																									[
																										mi(e.$slots, "default", {}, () => [
																											e.dangerouslyUseHTMLString
																												? (Wr(), qr(Nr(e.showInput ? "label" : "p"), { key: 1, for: e.showInput ? e.inputId : void 0, innerHTML: e.message }, null, 8, ["for", "innerHTML"]))
																												: (Wr(),
																												  qr(Nr(e.showInput ? "label" : "p"), { key: 0, for: e.showInput ? e.inputId : void 0 }, { default: cn(() => [oi(bt(e.dangerouslyUseHTMLString ? "" : e.message), 1)]), _: 1 }, 8, ["for"]))
																										])
																									],
																									2
																							  ))
																							: ai("v-if", !0)
																					],
																					2
																				),
																				yr(
																					ni(
																						"div",
																						{ class: gt(e.ns.e("input")) },
																						[
																							ri(
																								l,
																								{
																									id: e.inputId,
																									ref: "inputRef",
																									modelValue: e.inputValue,
																									"onUpdate:modelValue": t[2] || (t[2] = (t) => (e.inputValue = t)),
																									type: e.inputType,
																									placeholder: e.inputPlaceholder,
																									"aria-invalid": e.validateError,
																									class: gt({ invalid: e.validateError }),
																									onKeydown: jo(e.handleInputEnter, ["enter"])
																								},
																								null,
																								8,
																								["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]
																							),
																							ni("div", { class: gt(e.ns.e("errormsg")), style: pt({ visibility: e.editorErrorMessage ? "visible" : "hidden" }) }, bt(e.editorErrorMessage), 7)
																						],
																						2
																					),
																					[[Wo, e.showInput]]
																				)
																			],
																			10,
																			h3
																		),
																		ni(
																			"div",
																			{ class: gt(e.ns.e("btns")) },
																			[
																				e.showCancelButton
																					? (Wr(),
																					  qr(
																							u,
																							{
																								key: 0,
																								loading: e.cancelButtonLoading,
																								class: gt([e.cancelButtonClass]),
																								round: e.roundButton,
																								size: e.btnSize,
																								onClick: t[3] || (t[3] = (t) => e.handleAction("cancel")),
																								onKeydown:
																									t[4] ||
																									(t[4] = jo(
																										zo((t) => e.handleAction("cancel"), ["prevent"]),
																										["enter"]
																									))
																							},
																							{ default: cn(() => [oi(bt(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)]), _: 1 },
																							8,
																							["loading", "class", "round", "size"]
																					  ))
																					: ai("v-if", !0),
																				yr(
																					ri(
																						u,
																						{
																							ref: "confirmRef",
																							type: "primary",
																							loading: e.confirmButtonLoading,
																							class: gt([e.confirmButtonClasses]),
																							round: e.roundButton,
																							disabled: e.confirmButtonDisabled,
																							size: e.btnSize,
																							onClick: t[5] || (t[5] = (t) => e.handleAction("confirm")),
																							onKeydown:
																								t[6] ||
																								(t[6] = jo(
																									zo((t) => e.handleAction("confirm"), ["prevent"]),
																									["enter"]
																								))
																						},
																						{ default: cn(() => [oi(bt(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)]), _: 1 },
																						8,
																						["loading", "class", "round", "disabled", "size"]
																					),
																					[[Wo, e.showConfirmButton]]
																				)
																			],
																			2
																		)
																	],
																	6
																)
															]),
															_: 3
														},
														8,
														["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"]
													)
												],
												42,
												u3
											)
										]),
										_: 3
									},
									8,
									["z-index", "overlay-class", "mask"]
								),
								[[Wo, e.visible]]
							)
						]),
						_: 3
					}
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]
]);
const p3 = new Map(),
	f3 = (e, t) => {
		const n = document.createElement("div");
		(e.onVanish = () => {
			qo(null, n), p3.delete(i);
		}),
			(e.onAction = (t) => {
				const n = p3.get(i);
				let s;
				(s = e.showInput ? { value: i.inputValue, action: t } : t), e.callback ? e.callback(s, r.proxy) : "cancel" === t || "close" === t ? (e.distinguishCancelAndClose && "cancel" !== t ? n.reject("close") : n.reject("cancel")) : n.resolve(s);
			});
		const r = ((e, t, n = null) => {
				const r = xs(d3, e);
				return (r.appContext = n), qo(r, t), document.body.appendChild(t.firstElementChild), r.component;
			})(e, n, t),
			i = r.proxy;
		for (const s in e) xR(e, s) && !xR(i.$props, s) && (i[s] = e[s]);
		return (
			ds(
				() => i.message,
				(e, t) => {
					Zr(e) ? (r.slots.default = () => [e]) : Zr(t) && !Zr(e) && delete r.slots.default;
				},
				{ immediate: !0 }
			),
			(i.visible = !0),
			i
		);
	};
function m3(e, t = null) {
	if (!GI) return Promise.reject();
	let n;
	return (
		SR(e) || Zr(e) ? (e = { message: e }) : (n = e.callback),
		new Promise((r, i) => {
			const s = f3(e, null != t ? t : m3._context);
			p3.set(s, { options: e, callback: n, resolve: r, reject: i });
		})
	);
}
const v3 = { alert: { closeOnPressEscape: !1, closeOnClickModal: !1 }, confirm: { showCancelButton: !0 }, prompt: { showCancelButton: !0, showInput: !0 } };
["alert", "confirm", "prompt"].forEach((e) => {
	m3[e] = (function (e) {
		return (t, n, r, i) => {
			let s;
			return ER(n) ? ((r = n), (s = "")) : (s = BR(n) ? "" : n), m3(Object.assign(u({ title: s, message: t, type: "" }, v3[e]), r, { boxType: e }), i);
		};
	})(e);
}),
	(m3.close = () => {
		p3.forEach((e, t) => {
			t.doClose();
		}),
			p3.clear();
	}),
	(m3._context = null);
const g3 = m3;
g3.install = (e) => {
	(g3._context = e._context), (e.config.globalProperties.$msgbox = g3), (e.config.globalProperties.$messageBox = g3), (e.config.globalProperties.$alert = g3.alert), (e.config.globalProperties.$confirm = g3.confirm), (e.config.globalProperties.$prompt = g3.prompt);
};
const y3 = g3,
	b3 = ["success", "info", "warning", "error"],
	x3 = uN({
		customClass: { type: String, default: "" },
		dangerouslyUseHTMLString: { type: Boolean, default: !1 },
		duration: { type: Number, default: 4500 },
		icon: { type: [String, Object], default: "" },
		id: { type: String, default: "" },
		message: { type: [String, Object], default: "" },
		offset: { type: Number, default: 0 },
		onClick: { type: Function, default: () => {} },
		onClose: { type: Function, required: !0 },
		position: { type: String, values: ["top-right", "top-left", "bottom-right", "bottom-left"], default: "top-right" },
		showClose: { type: Boolean, default: !0 },
		title: { type: String, default: "" },
		type: { type: String, values: [...b3, ""], default: "" },
		zIndex: { type: Number, default: 0 }
	}),
	_3 = Tn({
		name: "ElNotification",
		components: u({ ElIcon: OB }, dN),
		props: x3,
		emits: { destroy: () => !0 },
		setup(e) {
			const t = BD("notification"),
				n = Qe(!1);
			let r;
			const i = ht(() => {
					const n = e.type;
					return n && pN[e.type] ? t.m(n) : "";
				}),
				s = ht(() => pN[e.type] || e.icon || ""),
				o = ht(() => (e.position.endsWith("right") ? "right" : "left")),
				a = ht(() => (e.position.startsWith("top") ? "top" : "bottom")),
				l = ht(() => ({ [a.value]: `${e.offset}px`, zIndex: e.zIndex }));
			function u() {
				e.duration > 0 &&
					({ stop: r } = eR(() => {
						n.value && h();
					}, e.duration));
			}
			function c() {
				null == r || r();
			}
			function h() {
				n.value = !1;
			}
			return (
				Vn(() => {
					u(), (n.value = !0);
				}),
				iR(document, "keydown", function ({ code: e }) {
					e === bN.delete || e === bN.backspace ? c() : e === bN.esc ? n.value && h() : u();
				}),
				{ ns: t, horizontalClass: o, typeClass: i, iconComponent: s, positionStyle: l, visible: n, close: h, clearTimer: c, startTimer: u }
			);
		}
	}),
	w3 = ["id"],
	C3 = ["textContent"],
	S3 = { key: 0 },
	E3 = ["innerHTML"];
var T3 = IB(_3, [
	[
		"render",
		function (e, t, n, r, i, s) {
			const o = Or("el-icon"),
				a = Or("close");
			return (
				Wr(),
				qr(
					lo,
					{ name: e.ns.b("fade"), onBeforeLeave: e.onClose, onAfterLeave: t[3] || (t[3] = (t) => e.$emit("destroy")), persisted: "" },
					{
						default: cn(() => [
							yr(
								ni(
									"div",
									{
										id: e.id,
										class: gt([e.ns.b(), e.customClass, e.horizontalClass]),
										style: pt(e.positionStyle),
										role: "alert",
										onMouseenter: t[0] || (t[0] = (...t) => e.clearTimer && e.clearTimer(...t)),
										onMouseleave: t[1] || (t[1] = (...t) => e.startTimer && e.startTimer(...t)),
										onClick: t[2] || (t[2] = (...t) => e.onClick && e.onClick(...t))
									},
									[
										e.iconComponent ? (Wr(), qr(o, { key: 0, class: gt([e.ns.e("icon"), e.typeClass]) }, { default: cn(() => [(Wr(), qr(Nr(e.iconComponent)))]), _: 1 }, 8, ["class"])) : ai("v-if", !0),
										ni(
											"div",
											{ class: gt(e.ns.e("group")) },
											[
												ni("h2", { class: gt(e.ns.e("title")), textContent: bt(e.title) }, null, 10, C3),
												yr(
													ni(
														"div",
														{ class: gt(e.ns.e("content")), style: pt(e.title ? void 0 : { margin: 0 }) },
														[
															mi(e.$slots, "default", {}, () => [
																e.dangerouslyUseHTMLString
																	? (Wr(), Kr(Hr, { key: 1 }, [ai(" Caution here, message could've been compromized, nerver use user's input as message "), ai(" eslint-disable-next-line "), ni("p", { innerHTML: e.message }, null, 8, E3)], 2112))
																	: (Wr(), Kr("p", S3, bt(e.message), 1))
															])
														],
														6
													),
													[[Wo, e.message]]
												),
												e.showClose ? (Wr(), qr(o, { key: 0, class: gt(e.ns.e("closeBtn")), onClick: zo(e.close, ["stop"]) }, { default: cn(() => [ri(a)]), _: 1 }, 8, ["class", "onClick"])) : ai("v-if", !0)
											],
											2
										)
									],
									46,
									w3
								),
								[[Wo, e.visible]]
							)
						]),
						_: 3
					},
					8,
					["name", "onBeforeLeave"]
				)
			);
		}
	],
	["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]
]);
const k3 = { "top-left": [], "top-right": [], "bottom-left": [], "bottom-right": [] };
let A3 = 1;
const M3 = function (e = {}, t = null) {
	if (!GI) return { close: () => {} };
	("string" == typeof e || Zr(e)) && (e = { message: e });
	const n = e.position || "top-right";
	let r = e.offset || 0;
	k3[n].forEach(({ vm: e }) => {
		var t;
		r += ((null == (t = e.el) ? void 0 : t.offsetHeight) || 0) + 16;
	}),
		(r += 16);
	const { nextZIndex: i } = HD(),
		s = "notification_" + A3++,
		o = e.onClose,
		a = c(u({ zIndex: i(), offset: r }, e), {
			id: s,
			onClose: () => {
				!(function (e, t, n) {
					const r = k3[t],
						i = r.findIndex(({ vm: t }) => {
							var n;
							return (null == (n = t.component) ? void 0 : n.props.id) === e;
						});
					if (-1 === i) return;
					const { vm: s } = r[i];
					if (!s) return;
					null == n || n(s);
					const o = s.el.offsetHeight,
						a = t.split("-")[0];
					r.splice(i, 1);
					const l = r.length;
					if (l < 1) return;
					for (let u = i; u < l; u++) {
						const { el: e, component: t } = r[u].vm,
							n = Number.parseInt(e.style[a], 10) - o - 16;
						t.props.offset = n;
					}
				})(s, n, o);
			}
		});
	let l = document.body;
	HR(e.appendTo) ? (l = e.appendTo) : SR(e.appendTo) && (l = document.querySelector(e.appendTo)), HR(l) || (l = document.body);
	const h = document.createElement("div"),
		d = ri(T3, a, Zr(a.message) ? { default: () => a.message } : null);
	return (
		(d.appContext = null != t ? t : M3._context),
		(d.props.onDestroy = () => {
			qo(null, h);
		}),
		qo(d, h),
		k3[n].push({ vm: d }),
		l.appendChild(h.firstElementChild),
		{
			close: () => {
				d.component.proxy.visible = !1;
			}
		}
	);
};
b3.forEach((e) => {
	M3[e] = (t = {}) => (("string" == typeof t || Zr(t)) && (t = { message: t }), M3(c(u({}, t), { type: e })));
}),
	(M3.closeAll = function () {
		for (const e of Object.values(k3))
			e.forEach(({ vm: e }) => {
				e.component.proxy.visible = !1;
			});
	}),
	(M3._context = null);
var I3 = ((e = []) => ({
	version: "2.2.5",
	install: (t, n) => {
		t[wN] || ((t[wN] = !0), e.forEach((e) => t.use(e)), n && lD(n, t, !0));
	}
}))([...P2, ...[z2, Z2, a3, y3, vN(M3, "$notify"), oq]]);
const R3 = {
	all: (L3 = L3 || new Map()),
	on: function (e, t) {
		var n = L3.get(e);
		(n && n.push(t)) || L3.set(e, [t]);
	},
	off: function (e, t) {
		var n = L3.get(e);
		n && n.splice(n.indexOf(t) >>> 0, 1);
	},
	emit: function (e, t) {
		(L3.get(e) || []).slice().map(function (e) {
			e(t);
		}),
			(L3.get("*") || []).slice().map(function (n) {
				n(e, t);
			});
	}
};
var L3;
const O3 = new Map(),
	P3 = { x: ["left", "center", "right"], y: ["top", "bottom"] },
	N3 = ((D3 = 0), () => D3++);
var D3;
class B3 {
	constructor(e, t, n) {
		(this.remaining = t), (this.callback = e), (this.notifyItem = n), this.resume();
	}
	pause() {
		clearTimeout(this.notifyItem.timer), (this.remaining -= Date.now() - this.start);
	}
	resume() {
		(this.start = Date.now()), clearTimeout(this.notifyItem.timer), (this.notifyItem.timer = setTimeout(this.callback, this.remaining));
	}
}
var F3 = { position: ["top", "right"], cssAnimation: "vn-fade", velocityAnimation: { enter: (e) => ({ height: [e.clientHeight, 0], opacity: [1, 0] }), leave: { height: 0, opacity: [0, 1] } } },
	H3 = Tn({
		name: "velocity-group",
		emits: ["after-leave", "leave", "enter"],
		methods: {
			enter(e, t) {
				this.$emit("enter", { el: e, complete: t });
			},
			leave(e, t) {
				this.$emit("leave", { el: e, complete: t });
			},
			afterLeave() {
				this.$emit("after-leave");
			}
		}
	});
(H3.render = function (e, t, n, r, i, s) {
	return Wr(), qr(ko, { tag: "span", css: !1, onEnter: e.enter, onLeave: e.leave, onAfterLeave: e.afterLeave }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["onEnter", "onLeave", "onAfterLeave"]);
}),
	(H3.__file = "src/VelocityGroup.vue");
var V3 = Tn({ name: "css-group", inheritAttrs: !1, props: { name: { type: String, required: !0 } } });
(V3.render = function (e, t, n, r, i, s) {
	return Wr(), qr(ko, { tag: "span", name: e.name }, { default: cn(() => [mi(e.$slots, "default")]), _: 3 }, 8, ["name"]);
}),
	(V3.__file = "src/CssGroup.vue");
const U3 = [
		{ name: "px", regexp: new RegExp("^[-+]?[0-9]*.?[0-9]+px$") },
		{ name: "%", regexp: new RegExp("^[-+]?[0-9]*.?[0-9]+%$") },
		{ name: "px", regexp: new RegExp("^[-+]?[0-9]*.?[0-9]+$") }
	],
	z3 = (e) => {
		switch (typeof e) {
			case "number":
				return { type: "px", value: e };
			case "string":
				return ((e) => {
					if ("auto" === e) return { type: e, value: 0 };
					for (let t = 0; t < U3.length; t++) {
						const n = U3[t];
						if (n.regexp.test(e)) return { type: n.name, value: parseFloat(e) };
					}
					return { type: "", value: e };
				})(e);
			default:
				return { type: "", value: e };
		}
	},
	$3 = 0,
	j3 = 2;
var W3 = Tn({
	name: "notifications",
	components: { VelocityGroup: H3, CssGroup: V3 },
	props: {
		group: { type: String, default: "" },
		width: { type: [Number, String], default: 300 },
		reverse: { type: Boolean, default: !1 },
		position: { type: [String, Array], default: F3.position },
		classes: { type: String, default: "vue-notification" },
		animationType: { type: String, default: "css" },
		animation: { type: Object, default: F3.velocityAnimation },
		animationName: { type: String, default: F3.cssAnimation },
		speed: { type: Number, default: 300 },
		cooldown: { type: Number, default: 0 },
		duration: { type: Number, default: 3e3 },
		delay: { type: Number, default: 0 },
		max: { type: Number, default: 1 / 0 },
		ignoreDuplicates: { type: Boolean, default: !1 },
		closeOnClick: { type: Boolean, default: !0 },
		pauseOnHover: { type: Boolean, default: !1 }
	},
	emits: ["click", "destroy"],
	data: () => ({ list: [], velocity: O3.get("velocity"), timerControl: null }),
	computed: {
		actualWidth() {
			return z3(this.width);
		},
		isVA() {
			return "velocity" === this.animationType;
		},
		componentName() {
			return this.isVA ? "velocity-group" : "css-group";
		},
		styles() {
			const { x: e, y: t } = ((e) => {
					"string" == typeof e && (e = ((e) => ("string" != typeof e ? [] : e.split(/\s+/gi).filter((e) => e)))(e));
					let t = null,
						n = null;
					return (
						e.forEach((e) => {
							-1 !== P3.y.indexOf(e) && (n = e), -1 !== P3.x.indexOf(e) && (t = e);
						}),
						{ x: t, y: n }
					);
				})(this.position),
				n = this.actualWidth.value,
				r = this.actualWidth.type,
				i = { width: n + r };
			return t && (i[t] = "0px"), e && ("center" === e ? (i.left = `calc(50% - ${+n / 2}${r})`) : (i[e] = "0px")), i;
		},
		active() {
			return this.list.filter((e) => e.state !== j3);
		},
		botToTop() {
			return this.styles.hasOwnProperty("bottom");
		}
	},
	mounted() {
		R3.on("add", this.addItem), R3.on("close", this.closeItem);
	},
	methods: {
		destroyIfNecessary(e) {
			this.$emit("click", e), this.closeOnClick && this.destroy(e);
		},
		pauseTimeout() {
			var e;
			this.pauseOnHover && (null === (e = this.timerControl) || void 0 === e || e.pause());
		},
		resumeTimeout() {
			var e;
			this.pauseOnHover && (null === (e = this.timerControl) || void 0 === e || e.resume());
		},
		addItem(e = {}) {
			if ((e.group || (e.group = ""), e.data || (e.data = {}), this.group !== e.group)) return;
			if (e.clean || e.clear) return void this.destroyAll();
			const t = "number" == typeof e.duration ? e.duration : this.duration,
				n = "number" == typeof e.speed ? e.speed : this.speed,
				r = "boolean" == typeof e.ignoreDuplicates ? e.ignoreDuplicates : this.ignoreDuplicates,
				{ title: i, text: s, type: o, data: a, id: l } = e,
				u = { id: l || N3(), title: i, text: s, type: o, state: $3, speed: n, length: t + 2 * n, data: a };
			t >= 0 && (this.timerControl = new B3(() => this.destroy(u), u.length, u));
			const c = this.reverse ? !this.botToTop : this.botToTop;
			let h = -1;
			const d = this.active.some((t) => t.title === e.title && t.text === e.text);
			(!r || !d) && (c ? (this.list.push(u), this.active.length > this.max && (h = 0)) : (this.list.unshift(u), this.active.length > this.max && (h = this.active.length - 1)), -1 !== h && this.destroy(this.active[h]));
		},
		closeItem(e) {
			this.destroyById(e);
		},
		notifyClass(e) {
			var t;
			return ["vue-notification-template", this.classes, null !== (t = e.type) && void 0 !== t ? t : ""];
		},
		notifyWrapperStyle(e) {
			return this.isVA ? void 0 : { transition: `all ${e.speed}ms` };
		},
		destroy(e) {
			clearTimeout(e.timer), (e.state = j3), this.isVA || this.clean(), this.$emit("destroy", e);
		},
		destroyById(e) {
			const t = this.list.find((t) => t.id === e);
			t && this.destroy(t);
		},
		destroyAll() {
			this.active.forEach(this.destroy);
		},
		getAnimation(e, t) {
			var n;
			const r = null === (n = this.animation) || void 0 === n ? void 0 : n[e];
			return "function" == typeof r ? r.call(this, t) : r;
		},
		enter(e, t) {
			if (!this.isVA) return;
			const n = this.getAnimation("enter", e);
			this.velocity(e, n, { duration: this.speed, complete: t });
		},
		leave(e, t) {
			if (!this.isVA) return;
			const n = this.getAnimation("leave", e);
			this.velocity(e, n, { duration: this.speed, complete: t });
		},
		clean() {
			this.list = this.list.filter((e) => e.state !== j3);
		}
	}
});
!(function (e, t) {
	void 0 === t && (t = {});
	var n = t.insertAt;
	if (e && "undefined" != typeof document) {
		var r = document.head || document.getElementsByTagName("head")[0],
			i = document.createElement("style");
		(i.type = "text/css"), "top" === n && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i), i.styleSheet ? (i.styleSheet.cssText = e) : i.appendChild(document.createTextNode(e));
	}
})(
	"\n.vue-notification-group {\n    display: block;\n    position: fixed;\n    z-index: 5000;\n}\n.vue-notification-wrapper {\n    display: block;\n    overflow: hidden;\n    width: 100%;\n    margin: 0;\n    padding: 0;\n}\n.notification-title {\n    font-weight: 600;\n}\n.vue-notification-template {\n    display: block;\n    box-sizing: border-box;\n    background: white;\n    text-align: left;\n}\n.vue-notification {\n    display: block;\n    box-sizing: border-box;\n    text-align: left;\n    font-size: 12px;\n    padding: 10px;\n    margin: 0 5px 5px;\n\n    color: white;\n    background: #44A4FC;\n    border-left: 5px solid #187FE7;\n}\n.vue-notification.warn {\n    background: #ffb648;\n    border-left-color: #f48a06;\n}\n.vue-notification.error {\n    background: #E54D42;\n    border-left-color: #B82E24;\n}\n.vue-notification.success {\n    background: #68CD86;\n    border-left-color: #42A85F;\n}\n.vn-fade-enter-active, .vn-fade-leave-active, .vn-fade-move    {\n    transition: all .5s;\n}\n.vn-fade-enter-from, .vn-fade-leave-to {\n    opacity: 0;\n}\n\n"
),
	(W3.render = function (e, t, n, r, i, s) {
		return (
			Wr(),
			qr(
				"div",
				{ class: "vue-notification-group", style: e.styles },
				[
					(Wr(),
					qr(
						Nr(e.componentName),
						{ name: e.animationName, onEnter: e.enter, onLeave: e.leave, onAfterLeave: e.clean },
						{
							default: cn(() => [
								(Wr(!0),
								qr(
									Hr,
									null,
									pi(
										e.active,
										(n) => (
											Wr(),
											qr(
												"div",
												{
													key: n.id,
													class: "vue-notification-wrapper",
													style: e.notifyWrapperStyle(n),
													"data-id": n.id,
													onMouseenter: t[1] || (t[1] = (...t) => e.pauseTimeout && e.pauseTimeout(...t)),
													onMouseleave: t[2] || (t[2] = (...t) => e.resumeTimeout && e.resumeTimeout(...t))
												},
												[
													mi(e.$slots, "body", { class: [e.classes, n.type], item: n, close: () => e.destroy(n) }, () => [
														ai(" Default slot template "),
														ri(
															"div",
															{ class: e.notifyClass(n), onClick: (t) => e.destroyIfNecessary(n) },
															[n.title ? (Wr(), qr("div", { key: 0, class: "notification-title", innerHTML: n.title }, null, 8, ["innerHTML"])) : ai("v-if", !0), ri("div", { class: "notification-content", innerHTML: n.text }, null, 8, ["innerHTML"])],
															10,
															["onClick"]
														)
													])
												],
												44,
												["data-id"]
											)
										)
									),
									128
								))
							]),
							_: 3
						},
						8,
						["name", "onEnter", "onLeave", "onAfterLeave"]
					))
				],
				4
			)
		);
	}),
	(W3.__file = "src/Notifications.vue");
const G3 = (e) => {
	"string" == typeof e && (e = { title: "", text: e }), "object" == typeof e && R3.emit("add", e);
};
G3.close = function (e) {
	R3.emit("close", e);
};
var Y3,
	X3 = {
		install: function (e, t = {}) {
			Object.entries(t).forEach((e) => O3.set(...e));
			const n = t.name || "notify";
			(e.config.globalProperties["$" + n] = G3), e.component(t.componentName || "notifications", W3);
		}
	};
function K3(e) {
	return !!A() && (M(e), !0);
}
const q3 = "undefined" != typeof window,
	Z3 = (e) => "number" == typeof e,
	J3 = () => {};
function Q3(e) {
	return e;
}
function e5(e, t = 1e3, n = {}) {
	const { immediate: r = !0, immediateCallback: i = !1 } = n;
	let s = null;
	const o = Qe(!1);
	function a() {
		s && (clearInterval(s), (s = null));
	}
	function l() {
		(o.value = !1), a();
	}
	function u() {
		it(t) <= 0 || ((o.value = !0), i && e(), a(), (s = setInterval(e, it(t))));
	}
	if ((r && q3 && u(), Je(t))) {
		K3(
			ds(t, () => {
				r && q3 && u();
			})
		);
	}
	return K3(l), { isActive: o, pause: l, resume: u };
}
function t5(e, t, n = {}) {
	const { immediate: r = !0 } = n,
		i = Qe(!1);
	let s = null;
	function o() {
		s && (clearTimeout(s), (s = null));
	}
	function a() {
		(i.value = !1), o();
	}
	function l(...n) {
		o(),
			(i.value = !0),
			(s = setTimeout(() => {
				(i.value = !1), (s = null), e(...n);
			}, it(t)));
	}
	return r && ((i.value = !0), q3 && l()), K3(a), { isPending: i, start: l, stop: a };
}
function n5(e, t, n) {
	return ds(
		e,
		(e, n, r) => {
			e && t(e, n, r);
		},
		n
	);
}
function r5(e) {
	var t;
	const n = it(e);
	return null != (t = null == n ? void 0 : n.$el) ? t : n;
}
q3 && (null == (Y3 = null == window ? void 0 : window.navigator) ? void 0 : Y3.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const i5 = q3 ? window : void 0;
function s5(...e) {
	let t, n, r, i;
	if (("string" == typeof e[0] ? (([n, r, i] = e), (t = i5)) : ([t, n, r, i] = e), !t)) return J3;
	let s = J3;
	const o = ds(
			() => r5(t),
			(e) => {
				s(),
					e &&
						(e.addEventListener(n, r, i),
						(s = () => {
							e.removeEventListener(n, r, i), (s = J3);
						}));
			},
			{ immediate: !0, flush: "post" }
		),
		a = () => {
			o(), s();
		};
	return K3(a), a;
}
function o5(e, t, n = {}) {
	const { window: r = i5, ignore: i, capture: s = !0 } = n;
	if (!r) return;
	const o = Qe(!0);
	let a;
	const l = (n) => {
			r.clearTimeout(a);
			const s = r5(e),
				l = n.composedPath();
			s &&
				s !== n.target &&
				!l.includes(s) &&
				o.value &&
				((i &&
					i.length > 0 &&
					i.some((e) => {
						const t = r5(e);
						return t && (n.target === t || l.includes(t));
					})) ||
					t(n));
		},
		u = [
			s5(r, "click", l, { passive: !0, capture: s }),
			s5(
				r,
				"pointerdown",
				(t) => {
					const n = r5(e);
					o.value = !!n && !t.composedPath().includes(n);
				},
				{ passive: !0 }
			),
			s5(
				r,
				"pointerup",
				(e) => {
					a = r.setTimeout(() => l(e), 50);
				},
				{ passive: !0 }
			)
		];
	return () => u.forEach((e) => e());
}
const a5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
	l5 = "__vueuse_ssr_handlers__";
(a5[l5] = a5[l5] || {}), a5[l5];
const u5 = { ctrl: "control", command: "meta", cmd: "meta", option: "alt", up: "arrowup", down: "arrowdown", left: "arrowleft", right: "arrowright" };
function c5(e = {}) {
	const { reactive: t = !1, target: n = i5, aliasMap: r = u5, passive: i = !0, onEventFired: s = J3 } = e,
		o = Fe(new Set()),
		a = { toJSON: () => ({}), current: o },
		l = t ? Fe(a) : a,
		u = new Set();
	function c(e, n) {
		e in l && (t ? (l[e] = n) : (l[e].value = n));
	}
	function h(e, t) {
		var n, r;
		const i = null == (n = e.key) ? void 0 : n.toLowerCase(),
			s = null == (r = e.code) ? void 0 : r.toLowerCase(),
			a = [s, i].filter(Boolean);
		s && (t ? o.add(e.code) : o.delete(e.code));
		for (const o of a) c(o, t);
		"meta" !== i || t
			? e.getModifierState("Meta") && t && [...o, ...a].forEach((e) => u.add(e))
			: (u.forEach((e) => {
					o.delete(e), c(e, !1);
			  }),
			  u.clear());
	}
	n && (s5(n, "keydown", (e) => (h(e, !0), s(e)), { passive: i }), s5(n, "keyup", (e) => (h(e, !1), s(e)), { passive: i }));
	const d = new Proxy(l, {
		get(e, n, i) {
			if ("string" != typeof n) return Reflect.get(e, n, i);
			if (((n = n.toLowerCase()) in r && (n = r[n]), !(n in l)))
				if (/[+_-]/.test(n)) {
					const e = n.split(/[+_-]/g).map((e) => e.trim());
					l[n] = ht(() => e.every((e) => it(d[e])));
				} else l[n] = Qe(!1);
			const s = Reflect.get(e, n, i);
			return t ? it(s) : s;
		}
	});
	return d;
}
function h5(e = {}) {
	const { type: t = "page", touch: n = !0, resetOnTouchEnds: r = !1, initialValue: i = { x: 0, y: 0 }, window: s = i5, eventFilter: o } = e,
		a = Qe(i.x),
		l = Qe(i.y),
		u = Qe(null),
		c = (e) => {
			"page" === t ? ((a.value = e.pageX), (l.value = e.pageY)) : "client" === t && ((a.value = e.clientX), (l.value = e.clientY)), (u.value = "mouse");
		},
		h = () => {
			(a.value = i.x), (l.value = i.y);
		},
		d = (e) => {
			if (e.touches.length > 0) {
				const n = e.touches[0];
				"page" === t ? ((a.value = n.pageX), (l.value = n.pageY)) : "client" === t && ((a.value = n.clientX), (l.value = n.clientY)), (u.value = "touch");
			}
		},
		p = (e) => (void 0 === o ? c(e) : o(() => c(e), {})),
		f = (e) => (void 0 === o ? d(e) : o(() => d(e), {}));
	return s && (s5(s, "mousemove", p, { passive: !0 }), s5(s, "dragover", p, { passive: !0 }), n && (s5(s, "touchstart", f, { passive: !0 }), s5(s, "touchmove", f, { passive: !0 }), r && s5(s, "touchend", h, { passive: !0 }))), { x: a, y: l, sourceType: u };
}
var d5;
!(function (e) {
	(e.UP = "UP"), (e.RIGHT = "RIGHT"), (e.DOWN = "DOWN"), (e.LEFT = "LEFT"), (e.NONE = "NONE");
})(d5 || (d5 = {}));
const p5 = {
	linear: Q3,
	easeInSine: [0.12, 0, 0.39, 0],
	easeOutSine: [0.61, 1, 0.88, 1],
	easeInOutSine: [0.37, 0, 0.63, 1],
	easeInQuad: [0.11, 0, 0.5, 0],
	easeOutQuad: [0.5, 1, 0.89, 1],
	easeInOutQuad: [0.45, 0, 0.55, 1],
	easeInCubic: [0.32, 0, 0.67, 0],
	easeOutCubic: [0.33, 1, 0.68, 1],
	easeInOutCubic: [0.65, 0, 0.35, 1],
	easeInQuart: [0.5, 0, 0.75, 0],
	easeOutQuart: [0.25, 1, 0.5, 1],
	easeInOutQuart: [0.76, 0, 0.24, 1],
	easeInQuint: [0.64, 0, 0.78, 0],
	easeOutQuint: [0.22, 1, 0.36, 1],
	easeInOutQuint: [0.83, 0, 0.17, 1],
	easeInExpo: [0.7, 0, 0.84, 0],
	easeOutExpo: [0.16, 1, 0.3, 1],
	easeInOutExpo: [0.87, 0, 0.13, 1],
	easeInCirc: [0.55, 0, 1, 0.45],
	easeOutCirc: [0, 0.55, 0.45, 1],
	easeInOutCirc: [0.85, 0, 0.15, 1],
	easeInBack: [0.36, 0, 0.66, -0.56],
	easeOutBack: [0.34, 1.56, 0.64, 1],
	easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
function f5([e, t, n, r]) {
	const i = (e, t) => 1 - 3 * t + 3 * e,
		s = (e, t) => 3 * t - 6 * e,
		o = (e) => 3 * e,
		a = (e, t, n) => ((i(t, n) * e + s(t, n)) * e + o(t)) * e,
		l = (e, t, n) => 3 * i(t, n) * e * e + 2 * s(t, n) * e + o(t);
	return (i) =>
		e === t && n === r
			? i
			: a(
					((t) => {
						let r = t;
						for (let i = 0; i < 4; ++i) {
							const i = l(r, e, n);
							if (0 === i) return r;
							r -= (a(r, e, n) - t) / i;
						}
						return r;
					})(i),
					t,
					r
			  );
}
function m5(e, t = {}) {
	const { delay: n = 0, disabled: r = !1, duration: i = 1e3, onFinished: s = J3, onStarted: o = J3, transition: a = Q3 } = t,
		l = ht(() => {
			const e = it(a);
			return "function" == typeof e ? e : f5(e);
		}),
		u = ht(() => {
			const t = it(e);
			return Z3(t) ? t : t.map(it);
		}),
		c = ht(() => (Z3(u.value) ? [u.value] : u.value)),
		h = Qe(c.value.slice(0));
	let d, p, f, m, v;
	const { resume: g, pause: y } = (function (e, t = {}) {
			const { immediate: n = !0, window: r = i5 } = t,
				i = Qe(!1);
			let s = null;
			function o() {
				i.value && r && (e(), (s = r.requestAnimationFrame(o)));
			}
			function a() {
				!i.value && r && ((i.value = !0), o());
			}
			function l() {
				(i.value = !1), null != s && r && (r.cancelAnimationFrame(s), (s = null));
			}
			return n && a(), K3(l), { isActive: i, pause: l, resume: a };
		})(
			() => {
				const e = Date.now(),
					t = ((e, t, n) => Math.min(n, Math.max(t, e)))(1 - (f - e) / d, 0, 1);
				(h.value = v.map((e, n) => {
					var r;
					return e + (null != (r = p[n]) ? r : 0) * l.value(t);
				})),
					t >= 1 && (y(), s());
			},
			{ immediate: !1 }
		),
		b = () => {
			y(),
				(d = it(i)),
				(p = h.value.map((e, t) => {
					var n, r;
					return (null != (n = c.value[t]) ? n : 0) - (null != (r = h.value[t]) ? r : 0);
				})),
				(v = h.value.slice(0)),
				(m = Date.now()),
				(f = m + d),
				g(),
				o();
		},
		x = t5(b, n, { immediate: !1 });
	return (
		ds(
			c,
			() => {
				it(r) ? (h.value = c.value.slice(0)) : it(n) <= 0 ? b() : x.start();
			},
			{ deep: !0 }
		),
		ht(() => {
			const e = it(r) ? c : h;
			return Z3(u.value) ? e.value[0] : e.value;
		})
	);
}
function v5({ window: e = i5, initialWidth: t = 1 / 0, initialHeight: n = 1 / 0 } = {}) {
	const r = Qe(t),
		i = Qe(n),
		s = () => {
			e && ((r.value = e.innerWidth), (i.value = e.innerHeight));
		};
	return (
		s(),
		(function (e, t = !0) {
			Si() ? Vn(e) : t ? e() : ns(e);
		})(s),
		s5("resize", s, { passive: !0 }),
		{ width: r, height: i }
	);
}
function g5(e, t) {
	if (t.length < e) throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function y5(e) {
	g5(1, arguments);
	var t = Object.prototype.toString.call(e);
	return e instanceof Date || ("object" == typeof e && "[object Date]" === t)
		? new Date(e.getTime())
		: "number" == typeof e || "[object Number]" === t
		? new Date(e)
		: (("string" != typeof e && "[object String]" !== t) || "undefined" == typeof console || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"), console.warn(new Error().stack)),
		  new Date(NaN));
}
function b5(e) {
	var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
	return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime();
}
function x5(e, t) {
	g5(2, arguments);
	var n = y5(e),
		r = y5(t),
		i = n.getTime() - r.getTime();
	return i < 0 ? -1 : i > 0 ? 1 : i;
}
var _5 = {
	lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" },
	xSeconds: { one: "1 second", other: "{{count}} seconds" },
	halfAMinute: "half a minute",
	lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" },
	xMinutes: { one: "1 minute", other: "{{count}} minutes" },
	aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" },
	xHours: { one: "1 hour", other: "{{count}} hours" },
	xDays: { one: "1 day", other: "{{count}} days" },
	aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" },
	xWeeks: { one: "1 week", other: "{{count}} weeks" },
	aboutXMonths: { one: "about 1 month", other: "about {{count}} months" },
	xMonths: { one: "1 month", other: "{{count}} months" },
	aboutXYears: { one: "about 1 year", other: "about {{count}} years" },
	xYears: { one: "1 year", other: "{{count}} years" },
	overXYears: { one: "over 1 year", other: "over {{count}} years" },
	almostXYears: { one: "almost 1 year", other: "almost {{count}} years" }
};
function w5(e) {
	return function (t) {
		var n = t || {},
			r = n.width ? String(n.width) : e.defaultWidth;
		return e.formats[r] || e.formats[e.defaultWidth];
	};
}
var C5 = {
		date: w5({ formats: { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, defaultWidth: "full" }),
		time: w5({ formats: { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, defaultWidth: "full" }),
		dateTime: w5({ formats: { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, defaultWidth: "full" })
	},
	S5 = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" };
function E5(e) {
	return function (t, n) {
		var r,
			i = n || {};
		if ("formatting" === (i.context ? String(i.context) : "standalone") && e.formattingValues) {
			var s = e.defaultFormattingWidth || e.defaultWidth,
				o = i.width ? String(i.width) : s;
			r = e.formattingValues[o] || e.formattingValues[s];
		} else {
			var a = e.defaultWidth,
				l = i.width ? String(i.width) : e.defaultWidth;
			r = e.values[l] || e.values[a];
		}
		return r[e.argumentCallback ? e.argumentCallback(t) : t];
	};
}
function T5(e) {
	return function (t, n) {
		var r = String(t),
			i = n || {},
			s = i.width,
			o = (s && e.matchPatterns[s]) || e.matchPatterns[e.defaultMatchWidth],
			a = r.match(o);
		if (!a) return null;
		var l,
			u = a[0],
			c = (s && e.parsePatterns[s]) || e.parsePatterns[e.defaultParseWidth];
		return (
			(l =
				"[object Array]" === Object.prototype.toString.call(c)
					? (function (e, t) {
							for (var n = 0; n < e.length; n++) if (t(e[n])) return n;
					  })(c, function (e) {
							return e.test(u);
					  })
					: (function (e, t) {
							for (var n in e) if (e.hasOwnProperty(n) && t(e[n])) return n;
					  })(c, function (e) {
							return e.test(u);
					  })),
			(l = e.valueCallback ? e.valueCallback(l) : l),
			{ value: (l = i.valueCallback ? i.valueCallback(l) : l), rest: r.slice(u.length) }
		);
	};
}
var k5,
	A5 = {
		code: "en-US",
		formatDistance: function (e, t, n) {
			var r;
			return (n = n || {}), (r = "string" == typeof _5[e] ? _5[e] : 1 === t ? _5[e].one : _5[e].other.replace("{{count}}", t)), n.addSuffix ? (n.comparison > 0 ? "in " + r : r + " ago") : r;
		},
		formatLong: C5,
		formatRelative: function (e, t, n, r) {
			return S5[e];
		},
		localize: {
			ordinalNumber: function (e, t) {
				var n = Number(e),
					r = n % 100;
				if (r > 20 || r < 10)
					switch (r % 10) {
						case 1:
							return n + "st";
						case 2:
							return n + "nd";
						case 3:
							return n + "rd";
					}
				return n + "th";
			},
			era: E5({ values: { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, defaultWidth: "wide" }),
			quarter: E5({
				values: { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] },
				defaultWidth: "wide",
				argumentCallback: function (e) {
					return Number(e) - 1;
				}
			}),
			month: E5({
				values: {
					narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
					abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
					wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
				},
				defaultWidth: "wide"
			}),
			day: E5({
				values: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] },
				defaultWidth: "wide"
			}),
			dayPeriod: E5({
				values: {
					narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" },
					abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" },
					wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }
				},
				defaultWidth: "wide",
				formattingValues: {
					narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" },
					abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" },
					wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }
				},
				defaultFormattingWidth: "wide"
			})
		},
		match: {
			ordinalNumber:
				((k5 = {
					matchPattern: /^(\d+)(th|st|nd|rd)?/i,
					parsePattern: /\d+/i,
					valueCallback: function (e) {
						return parseInt(e, 10);
					}
				}),
				function (e, t) {
					var n = String(e),
						r = t || {},
						i = n.match(k5.matchPattern);
					if (!i) return null;
					var s = i[0],
						o = n.match(k5.parsePattern);
					if (!o) return null;
					var a = k5.valueCallback ? k5.valueCallback(o[0]) : o[0];
					return { value: (a = r.valueCallback ? r.valueCallback(a) : a), rest: n.slice(s.length) };
				}),
			era: T5({
				matchPatterns: { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i },
				defaultMatchWidth: "wide",
				parsePatterns: { any: [/^b/i, /^(a|c)/i] },
				defaultParseWidth: "any"
			}),
			quarter: T5({
				matchPatterns: { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i },
				defaultMatchWidth: "wide",
				parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] },
				defaultParseWidth: "any",
				valueCallback: function (e) {
					return e + 1;
				}
			}),
			month: T5({
				matchPatterns: { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i },
				defaultMatchWidth: "wide",
				parsePatterns: { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] },
				defaultParseWidth: "any"
			}),
			day: T5({
				matchPatterns: { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i },
				defaultMatchWidth: "wide",
				parsePatterns: { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] },
				defaultParseWidth: "any"
			}),
			dayPeriod: T5({
				matchPatterns: { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i },
				defaultMatchWidth: "any",
				parsePatterns: { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } },
				defaultParseWidth: "any"
			})
		},
		options: { weekStartsOn: 0, firstWeekContainsDate: 1 }
	};
function M5(e) {
	return (function (e, t) {
		if (null == e) throw new TypeError("assign requires that input parameter not be null or undefined");
		for (var n in (t = t || {})) t.hasOwnProperty(n) && (e[n] = t[n]);
		return e;
	})({}, e);
}
function I5(e, t) {
	var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
	g5(2, arguments);
	var r = n.locale || A5;
	if (!r.formatDistance) throw new RangeError("locale must contain localize.formatDistance property");
	var i = x5(e, t);
	if (isNaN(i)) throw new RangeError("Invalid time value");
	var s,
		o,
		a = M5(n);
	(a.addSuffix = Boolean(n.addSuffix)), (a.comparison = i), i > 0 ? ((s = y5(t)), (o = y5(e))) : ((s = y5(e)), (o = y5(t)));
	var l,
		u = null == n.roundingMethod ? "round" : String(n.roundingMethod);
	if ("floor" === u) l = Math.floor;
	else if ("ceil" === u) l = Math.ceil;
	else {
		if ("round" !== u) throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
		l = Math.round;
	}
	var c,
		h = o.getTime() - s.getTime(),
		d = h / 6e4,
		p = b5(o) - b5(s),
		f = (h - p) / 6e4;
	if ("second" === (c = null == n.unit ? (d < 1 ? "second" : d < 60 ? "minute" : d < 1440 ? "hour" : f < 43200 ? "day" : f < 525600 ? "month" : "year") : String(n.unit))) {
		var m = l(h / 1e3);
		return r.formatDistance("xSeconds", m, a);
	}
	if ("minute" === c) {
		var v = l(d);
		return r.formatDistance("xMinutes", v, a);
	}
	if ("hour" === c) {
		var g = l(d / 60);
		return r.formatDistance("xHours", g, a);
	}
	if ("day" === c) {
		var y = l(f / 1440);
		return r.formatDistance("xDays", y, a);
	}
	if ("month" === c) {
		var b = l(f / 43200);
		return 12 === b && "month" !== n.unit ? r.formatDistance("xYears", 1, a) : r.formatDistance("xMonths", b, a);
	}
	if ("year" === c) {
		var x = l(f / 525600);
		return r.formatDistance("xYears", x, a);
	}
	throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}
function R5(e, t) {
	return g5(1, arguments), I5(e, Date.now(), t);
}
function L5(e, t, n) {
	var r, i;
	return g5(1, arguments), O5(t) ? (i = t) : (n = t), new Intl.DateTimeFormat(null === (r = n) || void 0 === r ? void 0 : r.locale, i).format(e);
}
function O5(e) {
	return void 0 !== e && !("locale" in e);
}
var P5 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ !(function (e, t) {
	(function () {
		var n,
			r = "Expected a function",
			i = "__lodash_hash_undefined__",
			s = "__lodash_placeholder__",
			o = 16,
			a = 32,
			l = 64,
			u = 128,
			c = 256,
			h = 1 / 0,
			d = 9007199254740991,
			p = NaN,
			f = 4294967295,
			m = [
				["ary", u],
				["bind", 1],
				["bindKey", 2],
				["curry", 8],
				["curryRight", o],
				["flip", 512],
				["partial", a],
				["partialRight", l],
				["rearg", c]
			],
			v = "[object Arguments]",
			g = "[object Array]",
			y = "[object Boolean]",
			b = "[object Date]",
			x = "[object Error]",
			_ = "[object Function]",
			w = "[object GeneratorFunction]",
			C = "[object Map]",
			S = "[object Number]",
			E = "[object Object]",
			T = "[object Promise]",
			k = "[object RegExp]",
			A = "[object Set]",
			M = "[object String]",
			I = "[object Symbol]",
			R = "[object WeakMap]",
			L = "[object ArrayBuffer]",
			O = "[object DataView]",
			P = "[object Float32Array]",
			N = "[object Float64Array]",
			D = "[object Int8Array]",
			B = "[object Int16Array]",
			F = "[object Int32Array]",
			H = "[object Uint8Array]",
			V = "[object Uint8ClampedArray]",
			U = "[object Uint16Array]",
			z = "[object Uint32Array]",
			$ = /\b__p \+= '';/g,
			j = /\b(__p \+=) '' \+/g,
			W = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
			G = /&(?:amp|lt|gt|quot|#39);/g,
			Y = /[&<>"']/g,
			X = RegExp(G.source),
			K = RegExp(Y.source),
			q = /<%-([\s\S]+?)%>/g,
			Z = /<%([\s\S]+?)%>/g,
			J = /<%=([\s\S]+?)%>/g,
			Q = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
			ee = /^\w*$/,
			te = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
			ne = /[\\^$.*+?()[\]{}|]/g,
			re = RegExp(ne.source),
			ie = /^\s+/,
			se = /\s/,
			oe = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
			ae = /\{\n\/\* \[wrapped with (.+)\] \*/,
			le = /,? & /,
			ue = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
			ce = /[()=,{}\[\]\/\s]/,
			he = /\\(\\)?/g,
			de = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
			pe = /\w*$/,
			fe = /^[-+]0x[0-9a-f]+$/i,
			me = /^0b[01]+$/i,
			ve = /^\[object .+?Constructor\]$/,
			ge = /^0o[0-7]+$/i,
			ye = /^(?:0|[1-9]\d*)$/,
			be = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
			xe = /($^)/,
			_e = /['\n\r\u2028\u2029\\]/g,
			we = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
			Ce = "\\u2700-\\u27bf",
			Se = "a-z\\xdf-\\xf6\\xf8-\\xff",
			Ee = "A-Z\\xc0-\\xd6\\xd8-\\xde",
			Te = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
			ke = "['’]",
			Ae = "[\\ud800-\\udfff]",
			Me = "[" + Te + "]",
			Ie = "[" + we + "]",
			Re = "\\d+",
			Le = "[\\u2700-\\u27bf]",
			Oe = "[" + Se + "]",
			Pe = "[^\\ud800-\\udfff" + Te + Re + Ce + Se + Ee + "]",
			Ne = "\\ud83c[\\udffb-\\udfff]",
			De = "[^\\ud800-\\udfff]",
			Be = "(?:\\ud83c[\\udde6-\\uddff]){2}",
			Fe = "[\\ud800-\\udbff][\\udc00-\\udfff]",
			He = "[" + Ee + "]",
			Ve = "(?:" + Oe + "|" + Pe + ")",
			Ue = "(?:" + He + "|" + Pe + ")",
			ze = "(?:['’](?:d|ll|m|re|s|t|ve))?",
			$e = "(?:['’](?:D|LL|M|RE|S|T|VE))?",
			je = "(?:" + Ie + "|" + Ne + ")" + "?",
			We = "[\\ufe0e\\ufe0f]?",
			Ge = We + je + ("(?:\\u200d(?:" + [De, Be, Fe].join("|") + ")" + We + je + ")*"),
			Ye = "(?:" + [Le, Be, Fe].join("|") + ")" + Ge,
			Xe = "(?:" + [De + Ie + "?", Ie, Be, Fe, Ae].join("|") + ")",
			Ke = RegExp(ke, "g"),
			qe = RegExp(Ie, "g"),
			Ze = RegExp(Ne + "(?=" + Ne + ")|" + Xe + Ge, "g"),
			Je = RegExp(
				[
					He + "?" + Oe + "+" + ze + "(?=" + [Me, He, "$"].join("|") + ")",
					Ue + "+" + $e + "(?=" + [Me, He + Ve, "$"].join("|") + ")",
					He + "?" + Ve + "+" + ze,
					He + "+" + $e,
					"\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
					"\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
					Re,
					Ye
				].join("|"),
				"g"
			),
			Qe = RegExp("[\\u200d\\ud800-\\udfff" + we + "\\ufe0e\\ufe0f]"),
			et = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
			tt = [
				"Array",
				"Buffer",
				"DataView",
				"Date",
				"Error",
				"Float32Array",
				"Float64Array",
				"Function",
				"Int8Array",
				"Int16Array",
				"Int32Array",
				"Map",
				"Math",
				"Object",
				"Promise",
				"RegExp",
				"Set",
				"String",
				"Symbol",
				"TypeError",
				"Uint8Array",
				"Uint8ClampedArray",
				"Uint16Array",
				"Uint32Array",
				"WeakMap",
				"_",
				"clearTimeout",
				"isFinite",
				"parseInt",
				"setTimeout"
			],
			nt = -1,
			rt = {};
		(rt[P] = rt[N] = rt[D] = rt[B] = rt[F] = rt[H] = rt[V] = rt[U] = rt[z] = !0), (rt[v] = rt[g] = rt[L] = rt[y] = rt[O] = rt[b] = rt[x] = rt[_] = rt[C] = rt[S] = rt[E] = rt[k] = rt[A] = rt[M] = rt[R] = !1);
		var it = {};
		(it[v] = it[g] = it[L] = it[O] = it[y] = it[b] = it[P] = it[N] = it[D] = it[B] = it[F] = it[C] = it[S] = it[E] = it[k] = it[A] = it[M] = it[I] = it[H] = it[V] = it[U] = it[z] = !0), (it[x] = it[_] = it[R] = !1);
		var st = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" },
			ot = parseFloat,
			at = parseInt,
			lt = "object" == typeof Jo && Jo && Jo.Object === Object && Jo,
			ut = "object" == typeof self && self && self.Object === Object && self,
			ct = lt || ut || Function("return this")(),
			ht = t && !t.nodeType && t,
			dt = ht && e && !e.nodeType && e,
			pt = dt && dt.exports === ht,
			ft = pt && lt.process,
			mt = (function () {
				try {
					var e = dt && dt.require && dt.require("util").types;
					return e || (ft && ft.binding && ft.binding("util"));
				} catch (Kj) {}
			})(),
			vt = mt && mt.isArrayBuffer,
			gt = mt && mt.isDate,
			yt = mt && mt.isMap,
			bt = mt && mt.isRegExp,
			xt = mt && mt.isSet,
			_t = mt && mt.isTypedArray;
		function wt(e, t, n) {
			switch (n.length) {
				case 0:
					return e.call(t);
				case 1:
					return e.call(t, n[0]);
				case 2:
					return e.call(t, n[0], n[1]);
				case 3:
					return e.call(t, n[0], n[1], n[2]);
			}
			return e.apply(t, n);
		}
		function Ct(e, t, n, r) {
			for (var i = -1, s = null == e ? 0 : e.length; ++i < s; ) {
				var o = e[i];
				t(r, o, n(o), e);
			}
			return r;
		}
		function St(e, t) {
			for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e); );
			return e;
		}
		function Et(e, t) {
			for (var n = null == e ? 0 : e.length; n-- && !1 !== t(e[n], n, e); );
			return e;
		}
		function Tt(e, t) {
			for (var n = -1, r = null == e ? 0 : e.length; ++n < r; ) if (!t(e[n], n, e)) return !1;
			return !0;
		}
		function kt(e, t) {
			for (var n = -1, r = null == e ? 0 : e.length, i = 0, s = []; ++n < r; ) {
				var o = e[n];
				t(o, n, e) && (s[i++] = o);
			}
			return s;
		}
		function At(e, t) {
			return !!(null == e ? 0 : e.length) && Ft(e, t, 0) > -1;
		}
		function Mt(e, t, n) {
			for (var r = -1, i = null == e ? 0 : e.length; ++r < i; ) if (n(t, e[r])) return !0;
			return !1;
		}
		function It(e, t) {
			for (var n = -1, r = null == e ? 0 : e.length, i = Array(r); ++n < r; ) i[n] = t(e[n], n, e);
			return i;
		}
		function Rt(e, t) {
			for (var n = -1, r = t.length, i = e.length; ++n < r; ) e[i + n] = t[n];
			return e;
		}
		function Lt(e, t, n, r) {
			var i = -1,
				s = null == e ? 0 : e.length;
			for (r && s && (n = e[++i]); ++i < s; ) n = t(n, e[i], i, e);
			return n;
		}
		function Ot(e, t, n, r) {
			var i = null == e ? 0 : e.length;
			for (r && i && (n = e[--i]); i--; ) n = t(n, e[i], i, e);
			return n;
		}
		function Pt(e, t) {
			for (var n = -1, r = null == e ? 0 : e.length; ++n < r; ) if (t(e[n], n, e)) return !0;
			return !1;
		}
		var Nt = zt("length");
		function Dt(e, t, n) {
			var r;
			return (
				n(e, function (e, n, i) {
					if (t(e, n, i)) return (r = n), !1;
				}),
				r
			);
		}
		function Bt(e, t, n, r) {
			for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; ) if (t(e[s], s, e)) return s;
			return -1;
		}
		function Ft(e, t, n) {
			return t == t
				? (function (e, t, n) {
						var r = n - 1,
							i = e.length;
						for (; ++r < i; ) if (e[r] === t) return r;
						return -1;
				  })(e, t, n)
				: Bt(e, Vt, n);
		}
		function Ht(e, t, n, r) {
			for (var i = n - 1, s = e.length; ++i < s; ) if (r(e[i], t)) return i;
			return -1;
		}
		function Vt(e) {
			return e != e;
		}
		function Ut(e, t) {
			var n = null == e ? 0 : e.length;
			return n ? Wt(e, t) / n : p;
		}
		function zt(e) {
			return function (t) {
				return null == t ? n : t[e];
			};
		}
		function $t(e) {
			return function (t) {
				return null == e ? n : e[t];
			};
		}
		function jt(e, t, n, r, i) {
			return (
				i(e, function (e, i, s) {
					n = r ? ((r = !1), e) : t(n, e, i, s);
				}),
				n
			);
		}
		function Wt(e, t) {
			for (var r, i = -1, s = e.length; ++i < s; ) {
				var o = t(e[i]);
				o !== n && (r = r === n ? o : r + o);
			}
			return r;
		}
		function Gt(e, t) {
			for (var n = -1, r = Array(e); ++n < e; ) r[n] = t(n);
			return r;
		}
		function Yt(e) {
			return e ? e.slice(0, hn(e) + 1).replace(ie, "") : e;
		}
		function Xt(e) {
			return function (t) {
				return e(t);
			};
		}
		function Kt(e, t) {
			return It(t, function (t) {
				return e[t];
			});
		}
		function qt(e, t) {
			return e.has(t);
		}
		function Zt(e, t) {
			for (var n = -1, r = e.length; ++n < r && Ft(t, e[n], 0) > -1; );
			return n;
		}
		function Jt(e, t) {
			for (var n = e.length; n-- && Ft(t, e[n], 0) > -1; );
			return n;
		}
		function Qt(e, t) {
			for (var n = e.length, r = 0; n--; ) e[n] === t && ++r;
			return r;
		}
		var en = $t({
				À: "A",
				Á: "A",
				Â: "A",
				Ã: "A",
				Ä: "A",
				Å: "A",
				à: "a",
				á: "a",
				â: "a",
				ã: "a",
				ä: "a",
				å: "a",
				Ç: "C",
				ç: "c",
				Ð: "D",
				ð: "d",
				È: "E",
				É: "E",
				Ê: "E",
				Ë: "E",
				è: "e",
				é: "e",
				ê: "e",
				ë: "e",
				Ì: "I",
				Í: "I",
				Î: "I",
				Ï: "I",
				ì: "i",
				í: "i",
				î: "i",
				ï: "i",
				Ñ: "N",
				ñ: "n",
				Ò: "O",
				Ó: "O",
				Ô: "O",
				Õ: "O",
				Ö: "O",
				Ø: "O",
				ò: "o",
				ó: "o",
				ô: "o",
				õ: "o",
				ö: "o",
				ø: "o",
				Ù: "U",
				Ú: "U",
				Û: "U",
				Ü: "U",
				ù: "u",
				ú: "u",
				û: "u",
				ü: "u",
				Ý: "Y",
				ý: "y",
				ÿ: "y",
				Æ: "Ae",
				æ: "ae",
				Þ: "Th",
				þ: "th",
				ß: "ss",
				Ā: "A",
				Ă: "A",
				Ą: "A",
				ā: "a",
				ă: "a",
				ą: "a",
				Ć: "C",
				Ĉ: "C",
				Ċ: "C",
				Č: "C",
				ć: "c",
				ĉ: "c",
				ċ: "c",
				č: "c",
				Ď: "D",
				Đ: "D",
				ď: "d",
				đ: "d",
				Ē: "E",
				Ĕ: "E",
				Ė: "E",
				Ę: "E",
				Ě: "E",
				ē: "e",
				ĕ: "e",
				ė: "e",
				ę: "e",
				ě: "e",
				Ĝ: "G",
				Ğ: "G",
				Ġ: "G",
				Ģ: "G",
				ĝ: "g",
				ğ: "g",
				ġ: "g",
				ģ: "g",
				Ĥ: "H",
				Ħ: "H",
				ĥ: "h",
				ħ: "h",
				Ĩ: "I",
				Ī: "I",
				Ĭ: "I",
				Į: "I",
				İ: "I",
				ĩ: "i",
				ī: "i",
				ĭ: "i",
				į: "i",
				ı: "i",
				Ĵ: "J",
				ĵ: "j",
				Ķ: "K",
				ķ: "k",
				ĸ: "k",
				Ĺ: "L",
				Ļ: "L",
				Ľ: "L",
				Ŀ: "L",
				Ł: "L",
				ĺ: "l",
				ļ: "l",
				ľ: "l",
				ŀ: "l",
				ł: "l",
				Ń: "N",
				Ņ: "N",
				Ň: "N",
				Ŋ: "N",
				ń: "n",
				ņ: "n",
				ň: "n",
				ŋ: "n",
				Ō: "O",
				Ŏ: "O",
				Ő: "O",
				ō: "o",
				ŏ: "o",
				ő: "o",
				Ŕ: "R",
				Ŗ: "R",
				Ř: "R",
				ŕ: "r",
				ŗ: "r",
				ř: "r",
				Ś: "S",
				Ŝ: "S",
				Ş: "S",
				Š: "S",
				ś: "s",
				ŝ: "s",
				ş: "s",
				š: "s",
				Ţ: "T",
				Ť: "T",
				Ŧ: "T",
				ţ: "t",
				ť: "t",
				ŧ: "t",
				Ũ: "U",
				Ū: "U",
				Ŭ: "U",
				Ů: "U",
				Ű: "U",
				Ų: "U",
				ũ: "u",
				ū: "u",
				ŭ: "u",
				ů: "u",
				ű: "u",
				ų: "u",
				Ŵ: "W",
				ŵ: "w",
				Ŷ: "Y",
				ŷ: "y",
				Ÿ: "Y",
				Ź: "Z",
				Ż: "Z",
				Ž: "Z",
				ź: "z",
				ż: "z",
				ž: "z",
				Ĳ: "IJ",
				ĳ: "ij",
				Œ: "Oe",
				œ: "oe",
				ŉ: "'n",
				ſ: "s"
			}),
			tn = $t({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" });
		function nn(e) {
			return "\\" + st[e];
		}
		function rn(e) {
			return Qe.test(e);
		}
		function sn(e) {
			var t = -1,
				n = Array(e.size);
			return (
				e.forEach(function (e, r) {
					n[++t] = [r, e];
				}),
				n
			);
		}
		function on(e, t) {
			return function (n) {
				return e(t(n));
			};
		}
		function an(e, t) {
			for (var n = -1, r = e.length, i = 0, o = []; ++n < r; ) {
				var a = e[n];
				(a !== t && a !== s) || ((e[n] = s), (o[i++] = n));
			}
			return o;
		}
		function ln(e) {
			var t = -1,
				n = Array(e.size);
			return (
				e.forEach(function (e) {
					n[++t] = e;
				}),
				n
			);
		}
		function un(e) {
			return rn(e)
				? (function (e) {
						var t = (Ze.lastIndex = 0);
						for (; Ze.test(e); ) ++t;
						return t;
				  })(e)
				: Nt(e);
		}
		function cn(e) {
			return rn(e)
				? (function (e) {
						return e.match(Ze) || [];
				  })(e)
				: (function (e) {
						return e.split("");
				  })(e);
		}
		function hn(e) {
			for (var t = e.length; t-- && se.test(e.charAt(t)); );
			return t;
		}
		var dn = $t({ "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" });
		var pn = (function e(t) {
			var se = (t = null == t ? ct : pn.defaults(ct.Object(), t, pn.pick(ct, tt))).Array,
				we = t.Date,
				Ce = t.Error,
				Se = t.Function,
				Ee = t.Math,
				Te = t.Object,
				ke = t.RegExp,
				Ae = t.String,
				Me = t.TypeError,
				Ie = se.prototype,
				Re = Se.prototype,
				Le = Te.prototype,
				Oe = t["__core-js_shared__"],
				Pe = Re.toString,
				Ne = Le.hasOwnProperty,
				De = 0,
				Be = (function () {
					var e = /[^.]+$/.exec((Oe && Oe.keys && Oe.keys.IE_PROTO) || "");
					return e ? "Symbol(src)_1." + e : "";
				})(),
				Fe = Le.toString,
				He = Pe.call(Te),
				Ve = ct._,
				Ue = ke(
					"^" +
						Pe.call(Ne)
							.replace(ne, "\\$&")
							.replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
						"$"
				),
				ze = pt ? t.Buffer : n,
				$e = t.Symbol,
				je = t.Uint8Array,
				We = ze ? ze.allocUnsafe : n,
				Ge = on(Te.getPrototypeOf, Te),
				Ye = Te.create,
				Xe = Le.propertyIsEnumerable,
				Ze = Ie.splice,
				Qe = $e ? $e.isConcatSpreadable : n,
				st = $e ? $e.iterator : n,
				lt = $e ? $e.toStringTag : n,
				ut = (function () {
					try {
						var e = hs(Te, "defineProperty");
						return e({}, "", {}), e;
					} catch (Kj) {}
				})(),
				ht = t.clearTimeout !== ct.clearTimeout && t.clearTimeout,
				dt = we && we.now !== ct.Date.now && we.now,
				ft = t.setTimeout !== ct.setTimeout && t.setTimeout,
				mt = Ee.ceil,
				Nt = Ee.floor,
				$t = Te.getOwnPropertySymbols,
				fn = ze ? ze.isBuffer : n,
				mn = t.isFinite,
				vn = Ie.join,
				gn = on(Te.keys, Te),
				yn = Ee.max,
				bn = Ee.min,
				xn = we.now,
				_n = t.parseInt,
				wn = Ee.random,
				Cn = Ie.reverse,
				Sn = hs(t, "DataView"),
				En = hs(t, "Map"),
				Tn = hs(t, "Promise"),
				kn = hs(t, "Set"),
				An = hs(t, "WeakMap"),
				Mn = hs(Te, "create"),
				In = An && new An(),
				Rn = {},
				Ln = Fs(Sn),
				On = Fs(En),
				Pn = Fs(Tn),
				Nn = Fs(kn),
				Dn = Fs(An),
				Bn = $e ? $e.prototype : n,
				Fn = Bn ? Bn.valueOf : n,
				Hn = Bn ? Bn.toString : n;
			function Vn(e) {
				if (na(e) && !Wo(e) && !(e instanceof jn)) {
					if (e instanceof $n) return e;
					if (Ne.call(e, "__wrapped__")) return Hs(e);
				}
				return new $n(e);
			}
			var Un = (function () {
				function e() {}
				return function (t) {
					if (!ta(t)) return {};
					if (Ye) return Ye(t);
					e.prototype = t;
					var r = new e();
					return (e.prototype = n), r;
				};
			})();
			function zn() {}
			function $n(e, t) {
				(this.__wrapped__ = e), (this.__actions__ = []), (this.__chain__ = !!t), (this.__index__ = 0), (this.__values__ = n);
			}
			function jn(e) {
				(this.__wrapped__ = e), (this.__actions__ = []), (this.__dir__ = 1), (this.__filtered__ = !1), (this.__iteratees__ = []), (this.__takeCount__ = f), (this.__views__ = []);
			}
			function Wn(e) {
				var t = -1,
					n = null == e ? 0 : e.length;
				for (this.clear(); ++t < n; ) {
					var r = e[t];
					this.set(r[0], r[1]);
				}
			}
			function Gn(e) {
				var t = -1,
					n = null == e ? 0 : e.length;
				for (this.clear(); ++t < n; ) {
					var r = e[t];
					this.set(r[0], r[1]);
				}
			}
			function Yn(e) {
				var t = -1,
					n = null == e ? 0 : e.length;
				for (this.clear(); ++t < n; ) {
					var r = e[t];
					this.set(r[0], r[1]);
				}
			}
			function Xn(e) {
				var t = -1,
					n = null == e ? 0 : e.length;
				for (this.__data__ = new Yn(); ++t < n; ) this.add(e[t]);
			}
			function Kn(e) {
				var t = (this.__data__ = new Gn(e));
				this.size = t.size;
			}
			function qn(e, t) {
				var n = Wo(e),
					r = !n && jo(e),
					i = !n && !r && Ko(e),
					s = !n && !r && !i && ca(e),
					o = n || r || i || s,
					a = o ? Gt(e.length, Ae) : [],
					l = a.length;
				for (var u in e) (!t && !Ne.call(e, u)) || (o && ("length" == u || (i && ("offset" == u || "parent" == u)) || (s && ("buffer" == u || "byteLength" == u || "byteOffset" == u)) || ys(u, l))) || a.push(u);
				return a;
			}
			function Zn(e) {
				var t = e.length;
				return t ? e[Xr(0, t - 1)] : n;
			}
			function Jn(e, t) {
				return Ns(Mi(e), ar(t, 0, e.length));
			}
			function Qn(e) {
				return Ns(Mi(e));
			}
			function er(e, t, r) {
				((r !== n && !Uo(e[t], r)) || (r === n && !(t in e))) && sr(e, t, r);
			}
			function tr(e, t, r) {
				var i = e[t];
				(Ne.call(e, t) && Uo(i, r) && (r !== n || t in e)) || sr(e, t, r);
			}
			function nr(e, t) {
				for (var n = e.length; n--; ) if (Uo(e[n][0], t)) return n;
				return -1;
			}
			function rr(e, t, n, r) {
				return (
					dr(e, function (e, i, s) {
						t(r, e, n(e), s);
					}),
					r
				);
			}
			function ir(e, t) {
				return e && Ii(t, La(t), e);
			}
			function sr(e, t, n) {
				"__proto__" == t && ut ? ut(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : (e[t] = n);
			}
			function or(e, t) {
				for (var r = -1, i = t.length, s = se(i), o = null == e; ++r < i; ) s[r] = o ? n : ka(e, t[r]);
				return s;
			}
			function ar(e, t, r) {
				return e == e && (r !== n && (e = e <= r ? e : r), t !== n && (e = e >= t ? e : t)), e;
			}
			function lr(e, t, r, i, s, o) {
				var a,
					l = 1 & t,
					u = 2 & t,
					c = 4 & t;
				if ((r && (a = s ? r(e, i, s, o) : r(e)), a !== n)) return a;
				if (!ta(e)) return e;
				var h = Wo(e);
				if (h) {
					if (
						((a = (function (e) {
							var t = e.length,
								n = new e.constructor(t);
							t && "string" == typeof e[0] && Ne.call(e, "index") && ((n.index = e.index), (n.input = e.input));
							return n;
						})(e)),
						!l)
					)
						return Mi(e, a);
				} else {
					var d = fs(e),
						p = d == _ || d == w;
					if (Ko(e)) return Ci(e, l);
					if (d == E || d == v || (p && !s)) {
						if (((a = u || p ? {} : vs(e)), !l))
							return u
								? (function (e, t) {
										return Ii(e, ps(e), t);
								  })(
										e,
										(function (e, t) {
											return e && Ii(t, Oa(t), e);
										})(a, e)
								  )
								: (function (e, t) {
										return Ii(e, ds(e), t);
								  })(e, ir(a, e));
					} else {
						if (!it[d]) return s ? e : {};
						a = (function (e, t, n) {
							var r = e.constructor;
							switch (t) {
								case L:
									return Si(e);
								case y:
								case b:
									return new r(+e);
								case O:
									return (function (e, t) {
										var n = t ? Si(e.buffer) : e.buffer;
										return new e.constructor(n, e.byteOffset, e.byteLength);
									})(e, n);
								case P:
								case N:
								case D:
								case B:
								case F:
								case H:
								case V:
								case U:
								case z:
									return Ei(e, n);
								case C:
									return new r();
								case S:
								case M:
									return new r(e);
								case k:
									return (function (e) {
										var t = new e.constructor(e.source, pe.exec(e));
										return (t.lastIndex = e.lastIndex), t;
									})(e);
								case A:
									return new r();
								case I:
									return (i = e), Fn ? Te(Fn.call(i)) : {};
							}
							var i;
						})(e, d, l);
					}
				}
				o || (o = new Kn());
				var f = o.get(e);
				if (f) return f;
				o.set(e, a),
					aa(e)
						? e.forEach(function (n) {
								a.add(lr(n, t, r, n, e, o));
						  })
						: ra(e) &&
						  e.forEach(function (n, i) {
								a.set(i, lr(n, t, r, i, e, o));
						  });
				var m = h ? n : (c ? (u ? is : rs) : u ? Oa : La)(e);
				return (
					St(m || e, function (n, i) {
						m && (n = e[(i = n)]), tr(a, i, lr(n, t, r, i, e, o));
					}),
					a
				);
			}
			function ur(e, t, r) {
				var i = r.length;
				if (null == e) return !i;
				for (e = Te(e); i--; ) {
					var s = r[i],
						o = t[s],
						a = e[s];
					if ((a === n && !(s in e)) || !o(a)) return !1;
				}
				return !0;
			}
			function cr(e, t, i) {
				if ("function" != typeof e) throw new Me(r);
				return Rs(function () {
					e.apply(n, i);
				}, t);
			}
			function hr(e, t, n, r) {
				var i = -1,
					s = At,
					o = !0,
					a = e.length,
					l = [],
					u = t.length;
				if (!a) return l;
				n && (t = It(t, Xt(n))), r ? ((s = Mt), (o = !1)) : t.length >= 200 && ((s = qt), (o = !1), (t = new Xn(t)));
				e: for (; ++i < a; ) {
					var c = e[i],
						h = null == n ? c : n(c);
					if (((c = r || 0 !== c ? c : 0), o && h == h)) {
						for (var d = u; d--; ) if (t[d] === h) continue e;
						l.push(c);
					} else s(t, h, r) || l.push(c);
				}
				return l;
			}
			(Vn.templateSettings = { escape: q, evaluate: Z, interpolate: J, variable: "", imports: { _: Vn } }),
				(Vn.prototype = zn.prototype),
				(Vn.prototype.constructor = Vn),
				($n.prototype = Un(zn.prototype)),
				($n.prototype.constructor = $n),
				(jn.prototype = Un(zn.prototype)),
				(jn.prototype.constructor = jn),
				(Wn.prototype.clear = function () {
					(this.__data__ = Mn ? Mn(null) : {}), (this.size = 0);
				}),
				(Wn.prototype.delete = function (e) {
					var t = this.has(e) && delete this.__data__[e];
					return (this.size -= t ? 1 : 0), t;
				}),
				(Wn.prototype.get = function (e) {
					var t = this.__data__;
					if (Mn) {
						var r = t[e];
						return r === i ? n : r;
					}
					return Ne.call(t, e) ? t[e] : n;
				}),
				(Wn.prototype.has = function (e) {
					var t = this.__data__;
					return Mn ? t[e] !== n : Ne.call(t, e);
				}),
				(Wn.prototype.set = function (e, t) {
					var r = this.__data__;
					return (this.size += this.has(e) ? 0 : 1), (r[e] = Mn && t === n ? i : t), this;
				}),
				(Gn.prototype.clear = function () {
					(this.__data__ = []), (this.size = 0);
				}),
				(Gn.prototype.delete = function (e) {
					var t = this.__data__,
						n = nr(t, e);
					return !(n < 0) && (n == t.length - 1 ? t.pop() : Ze.call(t, n, 1), --this.size, !0);
				}),
				(Gn.prototype.get = function (e) {
					var t = this.__data__,
						r = nr(t, e);
					return r < 0 ? n : t[r][1];
				}),
				(Gn.prototype.has = function (e) {
					return nr(this.__data__, e) > -1;
				}),
				(Gn.prototype.set = function (e, t) {
					var n = this.__data__,
						r = nr(n, e);
					return r < 0 ? (++this.size, n.push([e, t])) : (n[r][1] = t), this;
				}),
				(Yn.prototype.clear = function () {
					(this.size = 0), (this.__data__ = { hash: new Wn(), map: new (En || Gn)(), string: new Wn() });
				}),
				(Yn.prototype.delete = function (e) {
					var t = us(this, e).delete(e);
					return (this.size -= t ? 1 : 0), t;
				}),
				(Yn.prototype.get = function (e) {
					return us(this, e).get(e);
				}),
				(Yn.prototype.has = function (e) {
					return us(this, e).has(e);
				}),
				(Yn.prototype.set = function (e, t) {
					var n = us(this, e),
						r = n.size;
					return n.set(e, t), (this.size += n.size == r ? 0 : 1), this;
				}),
				(Xn.prototype.add = Xn.prototype.push =
					function (e) {
						return this.__data__.set(e, i), this;
					}),
				(Xn.prototype.has = function (e) {
					return this.__data__.has(e);
				}),
				(Kn.prototype.clear = function () {
					(this.__data__ = new Gn()), (this.size = 0);
				}),
				(Kn.prototype.delete = function (e) {
					var t = this.__data__,
						n = t.delete(e);
					return (this.size = t.size), n;
				}),
				(Kn.prototype.get = function (e) {
					return this.__data__.get(e);
				}),
				(Kn.prototype.has = function (e) {
					return this.__data__.has(e);
				}),
				(Kn.prototype.set = function (e, t) {
					var n = this.__data__;
					if (n instanceof Gn) {
						var r = n.__data__;
						if (!En || r.length < 199) return r.push([e, t]), (this.size = ++n.size), this;
						n = this.__data__ = new Yn(r);
					}
					return n.set(e, t), (this.size = n.size), this;
				});
			var dr = Oi(xr),
				pr = Oi(_r, !0);
			function fr(e, t) {
				var n = !0;
				return (
					dr(e, function (e, r, i) {
						return (n = !!t(e, r, i));
					}),
					n
				);
			}
			function mr(e, t, r) {
				for (var i = -1, s = e.length; ++i < s; ) {
					var o = e[i],
						a = t(o);
					if (null != a && (l === n ? a == a && !ua(a) : r(a, l)))
						var l = a,
							u = o;
				}
				return u;
			}
			function vr(e, t) {
				var n = [];
				return (
					dr(e, function (e, r, i) {
						t(e, r, i) && n.push(e);
					}),
					n
				);
			}
			function gr(e, t, n, r, i) {
				var s = -1,
					o = e.length;
				for (n || (n = gs), i || (i = []); ++s < o; ) {
					var a = e[s];
					t > 0 && n(a) ? (t > 1 ? gr(a, t - 1, n, r, i) : Rt(i, a)) : r || (i[i.length] = a);
				}
				return i;
			}
			var yr = Pi(),
				br = Pi(!0);
			function xr(e, t) {
				return e && yr(e, t, La);
			}
			function _r(e, t) {
				return e && br(e, t, La);
			}
			function wr(e, t) {
				return kt(t, function (t) {
					return Jo(e[t]);
				});
			}
			function Cr(e, t) {
				for (var r = 0, i = (t = bi(t, e)).length; null != e && r < i; ) e = e[Bs(t[r++])];
				return r && r == i ? e : n;
			}
			function Sr(e, t, n) {
				var r = t(e);
				return Wo(e) ? r : Rt(r, n(e));
			}
			function Er(e) {
				return null == e
					? e === n
						? "[object Undefined]"
						: "[object Null]"
					: lt && lt in Te(e)
					? (function (e) {
							var t = Ne.call(e, lt),
								r = e[lt];
							try {
								e[lt] = n;
								var i = !0;
							} catch (Kj) {}
							var s = Fe.call(e);
							i && (t ? (e[lt] = r) : delete e[lt]);
							return s;
					  })(e)
					: (function (e) {
							return Fe.call(e);
					  })(e);
			}
			function Tr(e, t) {
				return e > t;
			}
			function kr(e, t) {
				return null != e && Ne.call(e, t);
			}
			function Ar(e, t) {
				return null != e && t in Te(e);
			}
			function Mr(e, t, r) {
				for (var i = r ? Mt : At, s = e[0].length, o = e.length, a = o, l = se(o), u = 1 / 0, c = []; a--; ) {
					var h = e[a];
					a && t && (h = It(h, Xt(t))), (u = bn(h.length, u)), (l[a] = !r && (t || (s >= 120 && h.length >= 120)) ? new Xn(a && h) : n);
				}
				h = e[0];
				var d = -1,
					p = l[0];
				e: for (; ++d < s && c.length < u; ) {
					var f = h[d],
						m = t ? t(f) : f;
					if (((f = r || 0 !== f ? f : 0), !(p ? qt(p, m) : i(c, m, r)))) {
						for (a = o; --a; ) {
							var v = l[a];
							if (!(v ? qt(v, m) : i(e[a], m, r))) continue e;
						}
						p && p.push(m), c.push(f);
					}
				}
				return c;
			}
			function Ir(e, t, r) {
				var i = null == (e = ks(e, (t = bi(t, e)))) ? e : e[Bs(qs(t))];
				return null == i ? n : wt(i, e, r);
			}
			function Rr(e) {
				return na(e) && Er(e) == v;
			}
			function Lr(e, t, r, i, s) {
				return (
					e === t ||
					(null == e || null == t || (!na(e) && !na(t))
						? e != e && t != t
						: (function (e, t, r, i, s, o) {
								var a = Wo(e),
									l = Wo(t),
									u = a ? g : fs(e),
									c = l ? g : fs(t),
									h = (u = u == v ? E : u) == E,
									d = (c = c == v ? E : c) == E,
									p = u == c;
								if (p && Ko(e)) {
									if (!Ko(t)) return !1;
									(a = !0), (h = !1);
								}
								if (p && !h)
									return (
										o || (o = new Kn()),
										a || ca(e)
											? ts(e, t, r, i, s, o)
											: (function (e, t, n, r, i, s, o) {
													switch (n) {
														case O:
															if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
															(e = e.buffer), (t = t.buffer);
														case L:
															return !(e.byteLength != t.byteLength || !s(new je(e), new je(t)));
														case y:
														case b:
														case S:
															return Uo(+e, +t);
														case x:
															return e.name == t.name && e.message == t.message;
														case k:
														case M:
															return e == t + "";
														case C:
															var a = sn;
														case A:
															var l = 1 & r;
															if ((a || (a = ln), e.size != t.size && !l)) return !1;
															var u = o.get(e);
															if (u) return u == t;
															(r |= 2), o.set(e, t);
															var c = ts(a(e), a(t), r, i, s, o);
															return o.delete(e), c;
														case I:
															if (Fn) return Fn.call(e) == Fn.call(t);
													}
													return !1;
											  })(e, t, u, r, i, s, o)
									);
								if (!(1 & r)) {
									var f = h && Ne.call(e, "__wrapped__"),
										m = d && Ne.call(t, "__wrapped__");
									if (f || m) {
										var _ = f ? e.value() : e,
											w = m ? t.value() : t;
										return o || (o = new Kn()), s(_, w, r, i, o);
									}
								}
								if (!p) return !1;
								return (
									o || (o = new Kn()),
									(function (e, t, r, i, s, o) {
										var a = 1 & r,
											l = rs(e),
											u = l.length,
											c = rs(t).length;
										if (u != c && !a) return !1;
										var h = u;
										for (; h--; ) {
											var d = l[h];
											if (!(a ? d in t : Ne.call(t, d))) return !1;
										}
										var p = o.get(e),
											f = o.get(t);
										if (p && f) return p == t && f == e;
										var m = !0;
										o.set(e, t), o.set(t, e);
										var v = a;
										for (; ++h < u; ) {
											var g = e[(d = l[h])],
												y = t[d];
											if (i) var b = a ? i(y, g, d, t, e, o) : i(g, y, d, e, t, o);
											if (!(b === n ? g === y || s(g, y, r, i, o) : b)) {
												m = !1;
												break;
											}
											v || (v = "constructor" == d);
										}
										if (m && !v) {
											var x = e.constructor,
												_ = t.constructor;
											x == _ || !("constructor" in e) || !("constructor" in t) || ("function" == typeof x && x instanceof x && "function" == typeof _ && _ instanceof _) || (m = !1);
										}
										return o.delete(e), o.delete(t), m;
									})(e, t, r, i, s, o)
								);
						  })(e, t, r, i, Lr, s))
				);
			}
			function Or(e, t, r, i) {
				var s = r.length,
					o = s,
					a = !i;
				if (null == e) return !o;
				for (e = Te(e); s--; ) {
					var l = r[s];
					if (a && l[2] ? l[1] !== e[l[0]] : !(l[0] in e)) return !1;
				}
				for (; ++s < o; ) {
					var u = (l = r[s])[0],
						c = e[u],
						h = l[1];
					if (a && l[2]) {
						if (c === n && !(u in e)) return !1;
					} else {
						var d = new Kn();
						if (i) var p = i(c, h, u, e, t, d);
						if (!(p === n ? Lr(h, c, 3, i, d) : p)) return !1;
					}
				}
				return !0;
			}
			function Pr(e) {
				return (
					!(
						!ta(e) ||
						(function (e) {
							return !!Be && Be in e;
						})(e)
					) && (Jo(e) ? Ue : ve).test(Fs(e))
				);
			}
			function Nr(e) {
				return "function" == typeof e ? e : null == e ? il : "object" == typeof e ? (Wo(e) ? Ur(e[0], e[1]) : Vr(e)) : pl(e);
			}
			function Dr(e) {
				if (!Cs(e)) return gn(e);
				var t = [];
				for (var n in Te(e)) Ne.call(e, n) && "constructor" != n && t.push(n);
				return t;
			}
			function Br(e) {
				if (!ta(e))
					return (function (e) {
						var t = [];
						if (null != e) for (var n in Te(e)) t.push(n);
						return t;
					})(e);
				var t = Cs(e),
					n = [];
				for (var r in e) ("constructor" != r || (!t && Ne.call(e, r))) && n.push(r);
				return n;
			}
			function Fr(e, t) {
				return e < t;
			}
			function Hr(e, t) {
				var n = -1,
					r = Yo(e) ? se(e.length) : [];
				return (
					dr(e, function (e, i, s) {
						r[++n] = t(e, i, s);
					}),
					r
				);
			}
			function Vr(e) {
				var t = cs(e);
				return 1 == t.length && t[0][2]
					? Es(t[0][0], t[0][1])
					: function (n) {
							return n === e || Or(n, e, t);
					  };
			}
			function Ur(e, t) {
				return xs(e) && Ss(t)
					? Es(Bs(e), t)
					: function (r) {
							var i = ka(r, e);
							return i === n && i === t ? Aa(r, e) : Lr(t, i, 3);
					  };
			}
			function zr(e, t, r, i, s) {
				e !== t &&
					yr(
						t,
						function (o, a) {
							if ((s || (s = new Kn()), ta(o)))
								!(function (e, t, r, i, s, o, a) {
									var l = Ms(e, r),
										u = Ms(t, r),
										c = a.get(u);
									if (c) return void er(e, r, c);
									var h = o ? o(l, u, r + "", e, t, a) : n,
										d = h === n;
									if (d) {
										var p = Wo(u),
											f = !p && Ko(u),
											m = !p && !f && ca(u);
										(h = u), p || f || m ? (Wo(l) ? (h = l) : Xo(l) ? (h = Mi(l)) : f ? ((d = !1), (h = Ci(u, !0))) : m ? ((d = !1), (h = Ei(u, !0))) : (h = [])) : sa(u) || jo(u) ? ((h = l), jo(l) ? (h = ya(l)) : (ta(l) && !Jo(l)) || (h = vs(u))) : (d = !1);
									}
									d && (a.set(u, h), s(h, u, i, o, a), a.delete(u));
									er(e, r, h);
								})(e, t, a, r, zr, i, s);
							else {
								var l = i ? i(Ms(e, a), o, a + "", e, t, s) : n;
								l === n && (l = o), er(e, a, l);
							}
						},
						Oa
					);
			}
			function $r(e, t) {
				var r = e.length;
				if (r) return ys((t += t < 0 ? r : 0), r) ? e[t] : n;
			}
			function jr(e, t, n) {
				t = t.length
					? It(t, function (e) {
							return Wo(e)
								? function (t) {
										return Cr(t, 1 === e.length ? e[0] : e);
								  }
								: e;
					  })
					: [il];
				var r = -1;
				return (
					(t = It(t, Xt(ls()))),
					(function (e, t) {
						var n = e.length;
						for (e.sort(t); n--; ) e[n] = e[n].value;
						return e;
					})(
						Hr(e, function (e, n, i) {
							return {
								criteria: It(t, function (t) {
									return t(e);
								}),
								index: ++r,
								value: e
							};
						}),
						function (e, t) {
							return (function (e, t, n) {
								var r = -1,
									i = e.criteria,
									s = t.criteria,
									o = i.length,
									a = n.length;
								for (; ++r < o; ) {
									var l = Ti(i[r], s[r]);
									if (l) return r >= a ? l : l * ("desc" == n[r] ? -1 : 1);
								}
								return e.index - t.index;
							})(e, t, n);
						}
					)
				);
			}
			function Wr(e, t, n) {
				for (var r = -1, i = t.length, s = {}; ++r < i; ) {
					var o = t[r],
						a = Cr(e, o);
					n(a, o) && Qr(s, bi(o, e), a);
				}
				return s;
			}
			function Gr(e, t, n, r) {
				var i = r ? Ht : Ft,
					s = -1,
					o = t.length,
					a = e;
				for (e === t && (t = Mi(t)), n && (a = It(e, Xt(n))); ++s < o; ) for (var l = 0, u = t[s], c = n ? n(u) : u; (l = i(a, c, l, r)) > -1; ) a !== e && Ze.call(a, l, 1), Ze.call(e, l, 1);
				return e;
			}
			function Yr(e, t) {
				for (var n = e ? t.length : 0, r = n - 1; n--; ) {
					var i = t[n];
					if (n == r || i !== s) {
						var s = i;
						ys(i) ? Ze.call(e, i, 1) : hi(e, i);
					}
				}
				return e;
			}
			function Xr(e, t) {
				return e + Nt(wn() * (t - e + 1));
			}
			function Kr(e, t) {
				var n = "";
				if (!e || t < 1 || t > d) return n;
				do {
					t % 2 && (n += e), (t = Nt(t / 2)) && (e += e);
				} while (t);
				return n;
			}
			function qr(e, t) {
				return Ls(Ts(e, t, il), e + "");
			}
			function Zr(e) {
				return Zn(Ua(e));
			}
			function Jr(e, t) {
				var n = Ua(e);
				return Ns(n, ar(t, 0, n.length));
			}
			function Qr(e, t, r, i) {
				if (!ta(e)) return e;
				for (var s = -1, o = (t = bi(t, e)).length, a = o - 1, l = e; null != l && ++s < o; ) {
					var u = Bs(t[s]),
						c = r;
					if ("__proto__" === u || "constructor" === u || "prototype" === u) return e;
					if (s != a) {
						var h = l[u];
						(c = i ? i(h, u, l) : n) === n && (c = ta(h) ? h : ys(t[s + 1]) ? [] : {});
					}
					tr(l, u, c), (l = l[u]);
				}
				return e;
			}
			var ei = In
					? function (e, t) {
							return In.set(e, t), e;
					  }
					: il,
				ti = ut
					? function (e, t) {
							return ut(e, "toString", { configurable: !0, enumerable: !1, value: tl(t), writable: !0 });
					  }
					: il;
			function ni(e) {
				return Ns(Ua(e));
			}
			function ri(e, t, n) {
				var r = -1,
					i = e.length;
				t < 0 && (t = -t > i ? 0 : i + t), (n = n > i ? i : n) < 0 && (n += i), (i = t > n ? 0 : (n - t) >>> 0), (t >>>= 0);
				for (var s = se(i); ++r < i; ) s[r] = e[r + t];
				return s;
			}
			function ii(e, t) {
				var n;
				return (
					dr(e, function (e, r, i) {
						return !(n = t(e, r, i));
					}),
					!!n
				);
			}
			function si(e, t, n) {
				var r = 0,
					i = null == e ? r : e.length;
				if ("number" == typeof t && t == t && i <= 2147483647) {
					for (; r < i; ) {
						var s = (r + i) >>> 1,
							o = e[s];
						null !== o && !ua(o) && (n ? o <= t : o < t) ? (r = s + 1) : (i = s);
					}
					return i;
				}
				return oi(e, t, il, n);
			}
			function oi(e, t, r, i) {
				var s = 0,
					o = null == e ? 0 : e.length;
				if (0 === o) return 0;
				for (var a = (t = r(t)) != t, l = null === t, u = ua(t), c = t === n; s < o; ) {
					var h = Nt((s + o) / 2),
						d = r(e[h]),
						p = d !== n,
						f = null === d,
						m = d == d,
						v = ua(d);
					if (a) var g = i || m;
					else g = c ? m && (i || p) : l ? m && p && (i || !f) : u ? m && p && !f && (i || !v) : !f && !v && (i ? d <= t : d < t);
					g ? (s = h + 1) : (o = h);
				}
				return bn(o, 4294967294);
			}
			function ai(e, t) {
				for (var n = -1, r = e.length, i = 0, s = []; ++n < r; ) {
					var o = e[n],
						a = t ? t(o) : o;
					if (!n || !Uo(a, l)) {
						var l = a;
						s[i++] = 0 === o ? 0 : o;
					}
				}
				return s;
			}
			function li(e) {
				return "number" == typeof e ? e : ua(e) ? p : +e;
			}
			function ui(e) {
				if ("string" == typeof e) return e;
				if (Wo(e)) return It(e, ui) + "";
				if (ua(e)) return Hn ? Hn.call(e) : "";
				var t = e + "";
				return "0" == t && 1 / e == -1 / 0 ? "-0" : t;
			}
			function ci(e, t, n) {
				var r = -1,
					i = At,
					s = e.length,
					o = !0,
					a = [],
					l = a;
				if (n) (o = !1), (i = Mt);
				else if (s >= 200) {
					var u = t ? null : Ki(e);
					if (u) return ln(u);
					(o = !1), (i = qt), (l = new Xn());
				} else l = t ? [] : a;
				e: for (; ++r < s; ) {
					var c = e[r],
						h = t ? t(c) : c;
					if (((c = n || 0 !== c ? c : 0), o && h == h)) {
						for (var d = l.length; d--; ) if (l[d] === h) continue e;
						t && l.push(h), a.push(c);
					} else i(l, h, n) || (l !== a && l.push(h), a.push(c));
				}
				return a;
			}
			function hi(e, t) {
				return null == (e = ks(e, (t = bi(t, e)))) || delete e[Bs(qs(t))];
			}
			function di(e, t, n, r) {
				return Qr(e, t, n(Cr(e, t)), r);
			}
			function pi(e, t, n, r) {
				for (var i = e.length, s = r ? i : -1; (r ? s-- : ++s < i) && t(e[s], s, e); );
				return n ? ri(e, r ? 0 : s, r ? s + 1 : i) : ri(e, r ? s + 1 : 0, r ? i : s);
			}
			function fi(e, t) {
				var n = e;
				return (
					n instanceof jn && (n = n.value()),
					Lt(
						t,
						function (e, t) {
							return t.func.apply(t.thisArg, Rt([e], t.args));
						},
						n
					)
				);
			}
			function mi(e, t, n) {
				var r = e.length;
				if (r < 2) return r ? ci(e[0]) : [];
				for (var i = -1, s = se(r); ++i < r; ) for (var o = e[i], a = -1; ++a < r; ) a != i && (s[i] = hr(s[i] || o, e[a], t, n));
				return ci(gr(s, 1), t, n);
			}
			function vi(e, t, r) {
				for (var i = -1, s = e.length, o = t.length, a = {}; ++i < s; ) {
					var l = i < o ? t[i] : n;
					r(a, e[i], l);
				}
				return a;
			}
			function gi(e) {
				return Xo(e) ? e : [];
			}
			function yi(e) {
				return "function" == typeof e ? e : il;
			}
			function bi(e, t) {
				return Wo(e) ? e : xs(e, t) ? [e] : Ds(ba(e));
			}
			var xi = qr;
			function _i(e, t, r) {
				var i = e.length;
				return (r = r === n ? i : r), !t && r >= i ? e : ri(e, t, r);
			}
			var wi =
				ht ||
				function (e) {
					return ct.clearTimeout(e);
				};
			function Ci(e, t) {
				if (t) return e.slice();
				var n = e.length,
					r = We ? We(n) : new e.constructor(n);
				return e.copy(r), r;
			}
			function Si(e) {
				var t = new e.constructor(e.byteLength);
				return new je(t).set(new je(e)), t;
			}
			function Ei(e, t) {
				var n = t ? Si(e.buffer) : e.buffer;
				return new e.constructor(n, e.byteOffset, e.length);
			}
			function Ti(e, t) {
				if (e !== t) {
					var r = e !== n,
						i = null === e,
						s = e == e,
						o = ua(e),
						a = t !== n,
						l = null === t,
						u = t == t,
						c = ua(t);
					if ((!l && !c && !o && e > t) || (o && a && u && !l && !c) || (i && a && u) || (!r && u) || !s) return 1;
					if ((!i && !o && !c && e < t) || (c && r && s && !i && !o) || (l && r && s) || (!a && s) || !u) return -1;
				}
				return 0;
			}
			function ki(e, t, n, r) {
				for (var i = -1, s = e.length, o = n.length, a = -1, l = t.length, u = yn(s - o, 0), c = se(l + u), h = !r; ++a < l; ) c[a] = t[a];
				for (; ++i < o; ) (h || i < s) && (c[n[i]] = e[i]);
				for (; u--; ) c[a++] = e[i++];
				return c;
			}
			function Ai(e, t, n, r) {
				for (var i = -1, s = e.length, o = -1, a = n.length, l = -1, u = t.length, c = yn(s - a, 0), h = se(c + u), d = !r; ++i < c; ) h[i] = e[i];
				for (var p = i; ++l < u; ) h[p + l] = t[l];
				for (; ++o < a; ) (d || i < s) && (h[p + n[o]] = e[i++]);
				return h;
			}
			function Mi(e, t) {
				var n = -1,
					r = e.length;
				for (t || (t = se(r)); ++n < r; ) t[n] = e[n];
				return t;
			}
			function Ii(e, t, r, i) {
				var s = !r;
				r || (r = {});
				for (var o = -1, a = t.length; ++o < a; ) {
					var l = t[o],
						u = i ? i(r[l], e[l], l, r, e) : n;
					u === n && (u = e[l]), s ? sr(r, l, u) : tr(r, l, u);
				}
				return r;
			}
			function Ri(e, t) {
				return function (n, r) {
					var i = Wo(n) ? Ct : rr,
						s = t ? t() : {};
					return i(n, e, ls(r, 2), s);
				};
			}
			function Li(e) {
				return qr(function (t, r) {
					var i = -1,
						s = r.length,
						o = s > 1 ? r[s - 1] : n,
						a = s > 2 ? r[2] : n;
					for (o = e.length > 3 && "function" == typeof o ? (s--, o) : n, a && bs(r[0], r[1], a) && ((o = s < 3 ? n : o), (s = 1)), t = Te(t); ++i < s; ) {
						var l = r[i];
						l && e(t, l, i, o);
					}
					return t;
				});
			}
			function Oi(e, t) {
				return function (n, r) {
					if (null == n) return n;
					if (!Yo(n)) return e(n, r);
					for (var i = n.length, s = t ? i : -1, o = Te(n); (t ? s-- : ++s < i) && !1 !== r(o[s], s, o); );
					return n;
				};
			}
			function Pi(e) {
				return function (t, n, r) {
					for (var i = -1, s = Te(t), o = r(t), a = o.length; a--; ) {
						var l = o[e ? a : ++i];
						if (!1 === n(s[l], l, s)) break;
					}
					return t;
				};
			}
			function Ni(e) {
				return function (t) {
					var r = rn((t = ba(t))) ? cn(t) : n,
						i = r ? r[0] : t.charAt(0),
						s = r ? _i(r, 1).join("") : t.slice(1);
					return i[e]() + s;
				};
			}
			function Di(e) {
				return function (t) {
					return Lt(Ja(ja(t).replace(Ke, "")), e, "");
				};
			}
			function Bi(e) {
				return function () {
					var t = arguments;
					switch (t.length) {
						case 0:
							return new e();
						case 1:
							return new e(t[0]);
						case 2:
							return new e(t[0], t[1]);
						case 3:
							return new e(t[0], t[1], t[2]);
						case 4:
							return new e(t[0], t[1], t[2], t[3]);
						case 5:
							return new e(t[0], t[1], t[2], t[3], t[4]);
						case 6:
							return new e(t[0], t[1], t[2], t[3], t[4], t[5]);
						case 7:
							return new e(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
					}
					var n = Un(e.prototype),
						r = e.apply(n, t);
					return ta(r) ? r : n;
				};
			}
			function Fi(e) {
				return function (t, r, i) {
					var s = Te(t);
					if (!Yo(t)) {
						var o = ls(r, 3);
						(t = La(t)),
							(r = function (e) {
								return o(s[e], e, s);
							});
					}
					var a = e(t, r, i);
					return a > -1 ? s[o ? t[a] : a] : n;
				};
			}
			function Hi(e) {
				return ns(function (t) {
					var i = t.length,
						s = i,
						o = $n.prototype.thru;
					for (e && t.reverse(); s--; ) {
						var a = t[s];
						if ("function" != typeof a) throw new Me(r);
						if (o && !l && "wrapper" == os(a)) var l = new $n([], !0);
					}
					for (s = l ? s : i; ++s < i; ) {
						var u = os((a = t[s])),
							c = "wrapper" == u ? ss(a) : n;
						l = c && _s(c[0]) && 424 == c[1] && !c[4].length && 1 == c[9] ? l[os(c[0])].apply(l, c[3]) : 1 == a.length && _s(a) ? l[u]() : l.thru(a);
					}
					return function () {
						var e = arguments,
							n = e[0];
						if (l && 1 == e.length && Wo(n)) return l.plant(n).value();
						for (var r = 0, s = i ? t[r].apply(this, e) : n; ++r < i; ) s = t[r].call(this, s);
						return s;
					};
				});
			}
			function Vi(e, t, r, i, s, o, a, l, c, h) {
				var d = t & u,
					p = 1 & t,
					f = 2 & t,
					m = 24 & t,
					v = 512 & t,
					g = f ? n : Bi(e);
				return function n() {
					for (var u = arguments.length, y = se(u), b = u; b--; ) y[b] = arguments[b];
					if (m)
						var x = as(n),
							_ = Qt(y, x);
					if ((i && (y = ki(y, i, s, m)), o && (y = Ai(y, o, a, m)), (u -= _), m && u < h)) {
						var w = an(y, x);
						return Yi(e, t, Vi, n.placeholder, r, y, w, l, c, h - u);
					}
					var C = p ? r : this,
						S = f ? C[e] : e;
					return (u = y.length), l ? (y = As(y, l)) : v && u > 1 && y.reverse(), d && c < u && (y.length = c), this && this !== ct && this instanceof n && (S = g || Bi(S)), S.apply(C, y);
				};
			}
			function Ui(e, t) {
				return function (n, r) {
					return (function (e, t, n, r) {
						return (
							xr(e, function (e, i, s) {
								t(r, n(e), i, s);
							}),
							r
						);
					})(n, e, t(r), {});
				};
			}
			function zi(e, t) {
				return function (r, i) {
					var s;
					if (r === n && i === n) return t;
					if ((r !== n && (s = r), i !== n)) {
						if (s === n) return i;
						"string" == typeof r || "string" == typeof i ? ((r = ui(r)), (i = ui(i))) : ((r = li(r)), (i = li(i))), (s = e(r, i));
					}
					return s;
				};
			}
			function $i(e) {
				return ns(function (t) {
					return (
						(t = It(t, Xt(ls()))),
						qr(function (n) {
							var r = this;
							return e(t, function (e) {
								return wt(e, r, n);
							});
						})
					);
				});
			}
			function ji(e, t) {
				var r = (t = t === n ? " " : ui(t)).length;
				if (r < 2) return r ? Kr(t, e) : t;
				var i = Kr(t, mt(e / un(t)));
				return rn(t) ? _i(cn(i), 0, e).join("") : i.slice(0, e);
			}
			function Wi(e) {
				return function (t, r, i) {
					return (
						i && "number" != typeof i && bs(t, r, i) && (r = i = n),
						(t = fa(t)),
						r === n ? ((r = t), (t = 0)) : (r = fa(r)),
						(function (e, t, n, r) {
							for (var i = -1, s = yn(mt((t - e) / (n || 1)), 0), o = se(s); s--; ) (o[r ? s : ++i] = e), (e += n);
							return o;
						})(t, r, (i = i === n ? (t < r ? 1 : -1) : fa(i)), e)
					);
				};
			}
			function Gi(e) {
				return function (t, n) {
					return ("string" == typeof t && "string" == typeof n) || ((t = ga(t)), (n = ga(n))), e(t, n);
				};
			}
			function Yi(e, t, r, i, s, o, u, c, h, d) {
				var p = 8 & t;
				(t |= p ? a : l), 4 & (t &= ~(p ? l : a)) || (t &= -4);
				var f = [e, t, s, p ? o : n, p ? u : n, p ? n : o, p ? n : u, c, h, d],
					m = r.apply(n, f);
				return _s(e) && Is(m, f), (m.placeholder = i), Os(m, e, t);
			}
			function Xi(e) {
				var t = Ee[e];
				return function (e, n) {
					if (((e = ga(e)), (n = null == n ? 0 : bn(ma(n), 292)) && mn(e))) {
						var r = (ba(e) + "e").split("e");
						return +((r = (ba(t(r[0] + "e" + (+r[1] + n))) + "e").split("e"))[0] + "e" + (+r[1] - n));
					}
					return t(e);
				};
			}
			var Ki =
				kn && 1 / ln(new kn([, -0]))[1] == h
					? function (e) {
							return new kn(e);
					  }
					: ul;
			function qi(e) {
				return function (t) {
					var n = fs(t);
					return n == C
						? sn(t)
						: n == A
						? (function (e) {
								var t = -1,
									n = Array(e.size);
								return (
									e.forEach(function (e) {
										n[++t] = [e, e];
									}),
									n
								);
						  })(t)
						: (function (e, t) {
								return It(t, function (t) {
									return [t, e[t]];
								});
						  })(t, e(t));
				};
			}
			function Zi(e, t, i, h, d, p, f, m) {
				var v = 2 & t;
				if (!v && "function" != typeof e) throw new Me(r);
				var g = h ? h.length : 0;
				if ((g || ((t &= -97), (h = d = n)), (f = f === n ? f : yn(ma(f), 0)), (m = m === n ? m : ma(m)), (g -= d ? d.length : 0), t & l)) {
					var y = h,
						b = d;
					h = d = n;
				}
				var x = v ? n : ss(e),
					_ = [e, t, i, h, d, y, b, p, f, m];
				if (
					(x &&
						(function (e, t) {
							var n = e[1],
								r = t[1],
								i = n | r,
								o = i < 131,
								a = (r == u && 8 == n) || (r == u && n == c && e[7].length <= t[8]) || (384 == r && t[7].length <= t[8] && 8 == n);
							if (!o && !a) return e;
							1 & r && ((e[2] = t[2]), (i |= 1 & n ? 0 : 4));
							var l = t[3];
							if (l) {
								var h = e[3];
								(e[3] = h ? ki(h, l, t[4]) : l), (e[4] = h ? an(e[3], s) : t[4]);
							}
							(l = t[5]) && ((h = e[5]), (e[5] = h ? Ai(h, l, t[6]) : l), (e[6] = h ? an(e[5], s) : t[6]));
							(l = t[7]) && (e[7] = l);
							r & u && (e[8] = null == e[8] ? t[8] : bn(e[8], t[8]));
							null == e[9] && (e[9] = t[9]);
							(e[0] = t[0]), (e[1] = i);
						})(_, x),
					(e = _[0]),
					(t = _[1]),
					(i = _[2]),
					(h = _[3]),
					(d = _[4]),
					!(m = _[9] = _[9] === n ? (v ? 0 : e.length) : yn(_[9] - g, 0)) && 24 & t && (t &= -25),
					t && 1 != t)
				)
					w =
						8 == t || t == o
							? (function (e, t, r) {
									var i = Bi(e);
									return function s() {
										for (var o = arguments.length, a = se(o), l = o, u = as(s); l--; ) a[l] = arguments[l];
										var c = o < 3 && a[0] !== u && a[o - 1] !== u ? [] : an(a, u);
										return (o -= c.length) < r ? Yi(e, t, Vi, s.placeholder, n, a, c, n, n, r - o) : wt(this && this !== ct && this instanceof s ? i : e, this, a);
									};
							  })(e, t, m)
							: (t != a && 33 != t) || d.length
							? Vi.apply(n, _)
							: (function (e, t, n, r) {
									var i = 1 & t,
										s = Bi(e);
									return function t() {
										for (var o = -1, a = arguments.length, l = -1, u = r.length, c = se(u + a), h = this && this !== ct && this instanceof t ? s : e; ++l < u; ) c[l] = r[l];
										for (; a--; ) c[l++] = arguments[++o];
										return wt(h, i ? n : this, c);
									};
							  })(e, t, i, h);
				else
					var w = (function (e, t, n) {
						var r = 1 & t,
							i = Bi(e);
						return function t() {
							return (this && this !== ct && this instanceof t ? i : e).apply(r ? n : this, arguments);
						};
					})(e, t, i);
				return Os((x ? ei : Is)(w, _), e, t);
			}
			function Ji(e, t, r, i) {
				return e === n || (Uo(e, Le[r]) && !Ne.call(i, r)) ? t : e;
			}
			function Qi(e, t, r, i, s, o) {
				return ta(e) && ta(t) && (o.set(t, e), zr(e, t, n, Qi, o), o.delete(t)), e;
			}
			function es(e) {
				return sa(e) ? n : e;
			}
			function ts(e, t, r, i, s, o) {
				var a = 1 & r,
					l = e.length,
					u = t.length;
				if (l != u && !(a && u > l)) return !1;
				var c = o.get(e),
					h = o.get(t);
				if (c && h) return c == t && h == e;
				var d = -1,
					p = !0,
					f = 2 & r ? new Xn() : n;
				for (o.set(e, t), o.set(t, e); ++d < l; ) {
					var m = e[d],
						v = t[d];
					if (i) var g = a ? i(v, m, d, t, e, o) : i(m, v, d, e, t, o);
					if (g !== n) {
						if (g) continue;
						p = !1;
						break;
					}
					if (f) {
						if (
							!Pt(t, function (e, t) {
								if (!qt(f, t) && (m === e || s(m, e, r, i, o))) return f.push(t);
							})
						) {
							p = !1;
							break;
						}
					} else if (m !== v && !s(m, v, r, i, o)) {
						p = !1;
						break;
					}
				}
				return o.delete(e), o.delete(t), p;
			}
			function ns(e) {
				return Ls(Ts(e, n, Ws), e + "");
			}
			function rs(e) {
				return Sr(e, La, ds);
			}
			function is(e) {
				return Sr(e, Oa, ps);
			}
			var ss = In
				? function (e) {
						return In.get(e);
				  }
				: ul;
			function os(e) {
				for (var t = e.name + "", n = Rn[t], r = Ne.call(Rn, t) ? n.length : 0; r--; ) {
					var i = n[r],
						s = i.func;
					if (null == s || s == e) return i.name;
				}
				return t;
			}
			function as(e) {
				return (Ne.call(Vn, "placeholder") ? Vn : e).placeholder;
			}
			function ls() {
				var e = Vn.iteratee || sl;
				return (e = e === sl ? Nr : e), arguments.length ? e(arguments[0], arguments[1]) : e;
			}
			function us(e, t) {
				var n,
					r,
					i = e.__data__;
				return ("string" == (r = typeof (n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? i["string" == typeof t ? "string" : "hash"] : i.map;
			}
			function cs(e) {
				for (var t = La(e), n = t.length; n--; ) {
					var r = t[n],
						i = e[r];
					t[n] = [r, i, Ss(i)];
				}
				return t;
			}
			function hs(e, t) {
				var r = (function (e, t) {
					return null == e ? n : e[t];
				})(e, t);
				return Pr(r) ? r : n;
			}
			var ds = $t
					? function (e) {
							return null == e
								? []
								: ((e = Te(e)),
								  kt($t(e), function (t) {
										return Xe.call(e, t);
								  }));
					  }
					: vl,
				ps = $t
					? function (e) {
							for (var t = []; e; ) Rt(t, ds(e)), (e = Ge(e));
							return t;
					  }
					: vl,
				fs = Er;
			function ms(e, t, n) {
				for (var r = -1, i = (t = bi(t, e)).length, s = !1; ++r < i; ) {
					var o = Bs(t[r]);
					if (!(s = null != e && n(e, o))) break;
					e = e[o];
				}
				return s || ++r != i ? s : !!(i = null == e ? 0 : e.length) && ea(i) && ys(o, i) && (Wo(e) || jo(e));
			}
			function vs(e) {
				return "function" != typeof e.constructor || Cs(e) ? {} : Un(Ge(e));
			}
			function gs(e) {
				return Wo(e) || jo(e) || !!(Qe && e && e[Qe]);
			}
			function ys(e, t) {
				var n = typeof e;
				return !!(t = null == t ? d : t) && ("number" == n || ("symbol" != n && ye.test(e))) && e > -1 && e % 1 == 0 && e < t;
			}
			function bs(e, t, n) {
				if (!ta(n)) return !1;
				var r = typeof t;
				return !!("number" == r ? Yo(n) && ys(t, n.length) : "string" == r && t in n) && Uo(n[t], e);
			}
			function xs(e, t) {
				if (Wo(e)) return !1;
				var n = typeof e;
				return !("number" != n && "symbol" != n && "boolean" != n && null != e && !ua(e)) || ee.test(e) || !Q.test(e) || (null != t && e in Te(t));
			}
			function _s(e) {
				var t = os(e),
					n = Vn[t];
				if ("function" != typeof n || !(t in jn.prototype)) return !1;
				if (e === n) return !0;
				var r = ss(n);
				return !!r && e === r[0];
			}
			((Sn && fs(new Sn(new ArrayBuffer(1))) != O) || (En && fs(new En()) != C) || (Tn && fs(Tn.resolve()) != T) || (kn && fs(new kn()) != A) || (An && fs(new An()) != R)) &&
				(fs = function (e) {
					var t = Er(e),
						r = t == E ? e.constructor : n,
						i = r ? Fs(r) : "";
					if (i)
						switch (i) {
							case Ln:
								return O;
							case On:
								return C;
							case Pn:
								return T;
							case Nn:
								return A;
							case Dn:
								return R;
						}
					return t;
				});
			var ws = Oe ? Jo : gl;
			function Cs(e) {
				var t = e && e.constructor;
				return e === (("function" == typeof t && t.prototype) || Le);
			}
			function Ss(e) {
				return e == e && !ta(e);
			}
			function Es(e, t) {
				return function (r) {
					return null != r && r[e] === t && (t !== n || e in Te(r));
				};
			}
			function Ts(e, t, r) {
				return (
					(t = yn(t === n ? e.length - 1 : t, 0)),
					function () {
						for (var n = arguments, i = -1, s = yn(n.length - t, 0), o = se(s); ++i < s; ) o[i] = n[t + i];
						i = -1;
						for (var a = se(t + 1); ++i < t; ) a[i] = n[i];
						return (a[t] = r(o)), wt(e, this, a);
					}
				);
			}
			function ks(e, t) {
				return t.length < 2 ? e : Cr(e, ri(t, 0, -1));
			}
			function As(e, t) {
				for (var r = e.length, i = bn(t.length, r), s = Mi(e); i--; ) {
					var o = t[i];
					e[i] = ys(o, r) ? s[o] : n;
				}
				return e;
			}
			function Ms(e, t) {
				if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t];
			}
			var Is = Ps(ei),
				Rs =
					ft ||
					function (e, t) {
						return ct.setTimeout(e, t);
					},
				Ls = Ps(ti);
			function Os(e, t, n) {
				var r = t + "";
				return Ls(
					e,
					(function (e, t) {
						var n = t.length;
						if (!n) return e;
						var r = n - 1;
						return (t[r] = (n > 1 ? "& " : "") + t[r]), (t = t.join(n > 2 ? ", " : " ")), e.replace(oe, "{\n/* [wrapped with " + t + "] */\n");
					})(
						r,
						(function (e, t) {
							return (
								St(m, function (n) {
									var r = "_." + n[0];
									t & n[1] && !At(e, r) && e.push(r);
								}),
								e.sort()
							);
						})(
							(function (e) {
								var t = e.match(ae);
								return t ? t[1].split(le) : [];
							})(r),
							n
						)
					)
				);
			}
			function Ps(e) {
				var t = 0,
					r = 0;
				return function () {
					var i = xn(),
						s = 16 - (i - r);
					if (((r = i), s > 0)) {
						if (++t >= 800) return arguments[0];
					} else t = 0;
					return e.apply(n, arguments);
				};
			}
			function Ns(e, t) {
				var r = -1,
					i = e.length,
					s = i - 1;
				for (t = t === n ? i : t; ++r < t; ) {
					var o = Xr(r, s),
						a = e[o];
					(e[o] = e[r]), (e[r] = a);
				}
				return (e.length = t), e;
			}
			var Ds = (function (e) {
				var t = No(e, function (e) {
						return 500 === n.size && n.clear(), e;
					}),
					n = t.cache;
				return t;
			})(function (e) {
				var t = [];
				return (
					46 === e.charCodeAt(0) && t.push(""),
					e.replace(te, function (e, n, r, i) {
						t.push(r ? i.replace(he, "$1") : n || e);
					}),
					t
				);
			});
			function Bs(e) {
				if ("string" == typeof e || ua(e)) return e;
				var t = e + "";
				return "0" == t && 1 / e == -1 / 0 ? "-0" : t;
			}
			function Fs(e) {
				if (null != e) {
					try {
						return Pe.call(e);
					} catch (Kj) {}
					try {
						return e + "";
					} catch (Kj) {}
				}
				return "";
			}
			function Hs(e) {
				if (e instanceof jn) return e.clone();
				var t = new $n(e.__wrapped__, e.__chain__);
				return (t.__actions__ = Mi(e.__actions__)), (t.__index__ = e.__index__), (t.__values__ = e.__values__), t;
			}
			var Vs = qr(function (e, t) {
					return Xo(e) ? hr(e, gr(t, 1, Xo, !0)) : [];
				}),
				Us = qr(function (e, t) {
					var r = qs(t);
					return Xo(r) && (r = n), Xo(e) ? hr(e, gr(t, 1, Xo, !0), ls(r, 2)) : [];
				}),
				zs = qr(function (e, t) {
					var r = qs(t);
					return Xo(r) && (r = n), Xo(e) ? hr(e, gr(t, 1, Xo, !0), n, r) : [];
				});
			function $s(e, t, n) {
				var r = null == e ? 0 : e.length;
				if (!r) return -1;
				var i = null == n ? 0 : ma(n);
				return i < 0 && (i = yn(r + i, 0)), Bt(e, ls(t, 3), i);
			}
			function js(e, t, r) {
				var i = null == e ? 0 : e.length;
				if (!i) return -1;
				var s = i - 1;
				return r !== n && ((s = ma(r)), (s = r < 0 ? yn(i + s, 0) : bn(s, i - 1))), Bt(e, ls(t, 3), s, !0);
			}
			function Ws(e) {
				return (null == e ? 0 : e.length) ? gr(e, 1) : [];
			}
			function Gs(e) {
				return e && e.length ? e[0] : n;
			}
			var Ys = qr(function (e) {
					var t = It(e, gi);
					return t.length && t[0] === e[0] ? Mr(t) : [];
				}),
				Xs = qr(function (e) {
					var t = qs(e),
						r = It(e, gi);
					return t === qs(r) ? (t = n) : r.pop(), r.length && r[0] === e[0] ? Mr(r, ls(t, 2)) : [];
				}),
				Ks = qr(function (e) {
					var t = qs(e),
						r = It(e, gi);
					return (t = "function" == typeof t ? t : n) && r.pop(), r.length && r[0] === e[0] ? Mr(r, n, t) : [];
				});
			function qs(e) {
				var t = null == e ? 0 : e.length;
				return t ? e[t - 1] : n;
			}
			var Zs = qr(Js);
			function Js(e, t) {
				return e && e.length && t && t.length ? Gr(e, t) : e;
			}
			var Qs = ns(function (e, t) {
				var n = null == e ? 0 : e.length,
					r = or(e, t);
				return (
					Yr(
						e,
						It(t, function (e) {
							return ys(e, n) ? +e : e;
						}).sort(Ti)
					),
					r
				);
			});
			function eo(e) {
				return null == e ? e : Cn.call(e);
			}
			var to = qr(function (e) {
					return ci(gr(e, 1, Xo, !0));
				}),
				no = qr(function (e) {
					var t = qs(e);
					return Xo(t) && (t = n), ci(gr(e, 1, Xo, !0), ls(t, 2));
				}),
				ro = qr(function (e) {
					var t = qs(e);
					return (t = "function" == typeof t ? t : n), ci(gr(e, 1, Xo, !0), n, t);
				});
			function io(e) {
				if (!e || !e.length) return [];
				var t = 0;
				return (
					(e = kt(e, function (e) {
						if (Xo(e)) return (t = yn(e.length, t)), !0;
					})),
					Gt(t, function (t) {
						return It(e, zt(t));
					})
				);
			}
			function so(e, t) {
				if (!e || !e.length) return [];
				var r = io(e);
				return null == t
					? r
					: It(r, function (e) {
							return wt(t, n, e);
					  });
			}
			var oo = qr(function (e, t) {
					return Xo(e) ? hr(e, t) : [];
				}),
				ao = qr(function (e) {
					return mi(kt(e, Xo));
				}),
				lo = qr(function (e) {
					var t = qs(e);
					return Xo(t) && (t = n), mi(kt(e, Xo), ls(t, 2));
				}),
				uo = qr(function (e) {
					var t = qs(e);
					return (t = "function" == typeof t ? t : n), mi(kt(e, Xo), n, t);
				}),
				co = qr(io);
			var ho = qr(function (e) {
				var t = e.length,
					r = t > 1 ? e[t - 1] : n;
				return (r = "function" == typeof r ? (e.pop(), r) : n), so(e, r);
			});
			function po(e) {
				var t = Vn(e);
				return (t.__chain__ = !0), t;
			}
			function fo(e, t) {
				return t(e);
			}
			var mo = ns(function (e) {
				var t = e.length,
					r = t ? e[0] : 0,
					i = this.__wrapped__,
					s = function (t) {
						return or(t, e);
					};
				return !(t > 1 || this.__actions__.length) && i instanceof jn && ys(r)
					? ((i = i.slice(r, +r + (t ? 1 : 0))).__actions__.push({ func: fo, args: [s], thisArg: n }),
					  new $n(i, this.__chain__).thru(function (e) {
							return t && !e.length && e.push(n), e;
					  }))
					: this.thru(s);
			});
			var vo = Ri(function (e, t, n) {
				Ne.call(e, n) ? ++e[n] : sr(e, n, 1);
			});
			var go = Fi($s),
				yo = Fi(js);
			function bo(e, t) {
				return (Wo(e) ? St : dr)(e, ls(t, 3));
			}
			function xo(e, t) {
				return (Wo(e) ? Et : pr)(e, ls(t, 3));
			}
			var _o = Ri(function (e, t, n) {
				Ne.call(e, n) ? e[n].push(t) : sr(e, n, [t]);
			});
			var wo = qr(function (e, t, n) {
					var r = -1,
						i = "function" == typeof t,
						s = Yo(e) ? se(e.length) : [];
					return (
						dr(e, function (e) {
							s[++r] = i ? wt(t, e, n) : Ir(e, t, n);
						}),
						s
					);
				}),
				Co = Ri(function (e, t, n) {
					sr(e, n, t);
				});
			function So(e, t) {
				return (Wo(e) ? It : Hr)(e, ls(t, 3));
			}
			var Eo = Ri(
				function (e, t, n) {
					e[n ? 0 : 1].push(t);
				},
				function () {
					return [[], []];
				}
			);
			var To = qr(function (e, t) {
					if (null == e) return [];
					var n = t.length;
					return n > 1 && bs(e, t[0], t[1]) ? (t = []) : n > 2 && bs(t[0], t[1], t[2]) && (t = [t[0]]), jr(e, gr(t, 1), []);
				}),
				ko =
					dt ||
					function () {
						return ct.Date.now();
					};
			function Ao(e, t, r) {
				return (t = r ? n : t), (t = e && null == t ? e.length : t), Zi(e, u, n, n, n, n, t);
			}
			function Mo(e, t) {
				var i;
				if ("function" != typeof t) throw new Me(r);
				return (
					(e = ma(e)),
					function () {
						return --e > 0 && (i = t.apply(this, arguments)), e <= 1 && (t = n), i;
					}
				);
			}
			var Io = qr(function (e, t, n) {
					var r = 1;
					if (n.length) {
						var i = an(n, as(Io));
						r |= a;
					}
					return Zi(e, r, t, n, i);
				}),
				Ro = qr(function (e, t, n) {
					var r = 3;
					if (n.length) {
						var i = an(n, as(Ro));
						r |= a;
					}
					return Zi(t, r, e, n, i);
				});
			function Lo(e, t, i) {
				var s,
					o,
					a,
					l,
					u,
					c,
					h = 0,
					d = !1,
					p = !1,
					f = !0;
				if ("function" != typeof e) throw new Me(r);
				function m(t) {
					var r = s,
						i = o;
					return (s = o = n), (h = t), (l = e.apply(i, r));
				}
				function v(e) {
					return (h = e), (u = Rs(y, t)), d ? m(e) : l;
				}
				function g(e) {
					var r = e - c;
					return c === n || r >= t || r < 0 || (p && e - h >= a);
				}
				function y() {
					var e = ko();
					if (g(e)) return b(e);
					u = Rs(
						y,
						(function (e) {
							var n = t - (e - c);
							return p ? bn(n, a - (e - h)) : n;
						})(e)
					);
				}
				function b(e) {
					return (u = n), f && s ? m(e) : ((s = o = n), l);
				}
				function x() {
					var e = ko(),
						r = g(e);
					if (((s = arguments), (o = this), (c = e), r)) {
						if (u === n) return v(c);
						if (p) return wi(u), (u = Rs(y, t)), m(c);
					}
					return u === n && (u = Rs(y, t)), l;
				}
				return (
					(t = ga(t) || 0),
					ta(i) && ((d = !!i.leading), (a = (p = "maxWait" in i) ? yn(ga(i.maxWait) || 0, t) : a), (f = "trailing" in i ? !!i.trailing : f)),
					(x.cancel = function () {
						u !== n && wi(u), (h = 0), (s = c = o = u = n);
					}),
					(x.flush = function () {
						return u === n ? l : b(ko());
					}),
					x
				);
			}
			var Oo = qr(function (e, t) {
					return cr(e, 1, t);
				}),
				Po = qr(function (e, t, n) {
					return cr(e, ga(t) || 0, n);
				});
			function No(e, t) {
				if ("function" != typeof e || (null != t && "function" != typeof t)) throw new Me(r);
				var n = function () {
					var r = arguments,
						i = t ? t.apply(this, r) : r[0],
						s = n.cache;
					if (s.has(i)) return s.get(i);
					var o = e.apply(this, r);
					return (n.cache = s.set(i, o) || s), o;
				};
				return (n.cache = new (No.Cache || Yn)()), n;
			}
			function Do(e) {
				if ("function" != typeof e) throw new Me(r);
				return function () {
					var t = arguments;
					switch (t.length) {
						case 0:
							return !e.call(this);
						case 1:
							return !e.call(this, t[0]);
						case 2:
							return !e.call(this, t[0], t[1]);
						case 3:
							return !e.call(this, t[0], t[1], t[2]);
					}
					return !e.apply(this, t);
				};
			}
			No.Cache = Yn;
			var Bo = xi(function (e, t) {
					var n = (t = 1 == t.length && Wo(t[0]) ? It(t[0], Xt(ls())) : It(gr(t, 1), Xt(ls()))).length;
					return qr(function (r) {
						for (var i = -1, s = bn(r.length, n); ++i < s; ) r[i] = t[i].call(this, r[i]);
						return wt(e, this, r);
					});
				}),
				Fo = qr(function (e, t) {
					var r = an(t, as(Fo));
					return Zi(e, a, n, t, r);
				}),
				Ho = qr(function (e, t) {
					var r = an(t, as(Ho));
					return Zi(e, l, n, t, r);
				}),
				Vo = ns(function (e, t) {
					return Zi(e, c, n, n, n, t);
				});
			function Uo(e, t) {
				return e === t || (e != e && t != t);
			}
			var zo = Gi(Tr),
				$o = Gi(function (e, t) {
					return e >= t;
				}),
				jo = Rr(
					(function () {
						return arguments;
					})()
				)
					? Rr
					: function (e) {
							return na(e) && Ne.call(e, "callee") && !Xe.call(e, "callee");
					  },
				Wo = se.isArray,
				Go = vt
					? Xt(vt)
					: function (e) {
							return na(e) && Er(e) == L;
					  };
			function Yo(e) {
				return null != e && ea(e.length) && !Jo(e);
			}
			function Xo(e) {
				return na(e) && Yo(e);
			}
			var Ko = fn || gl,
				qo = gt
					? Xt(gt)
					: function (e) {
							return na(e) && Er(e) == b;
					  };
			function Zo(e) {
				if (!na(e)) return !1;
				var t = Er(e);
				return t == x || "[object DOMException]" == t || ("string" == typeof e.message && "string" == typeof e.name && !sa(e));
			}
			function Jo(e) {
				if (!ta(e)) return !1;
				var t = Er(e);
				return t == _ || t == w || "[object AsyncFunction]" == t || "[object Proxy]" == t;
			}
			function Qo(e) {
				return "number" == typeof e && e == ma(e);
			}
			function ea(e) {
				return "number" == typeof e && e > -1 && e % 1 == 0 && e <= d;
			}
			function ta(e) {
				var t = typeof e;
				return null != e && ("object" == t || "function" == t);
			}
			function na(e) {
				return null != e && "object" == typeof e;
			}
			var ra = yt
				? Xt(yt)
				: function (e) {
						return na(e) && fs(e) == C;
				  };
			function ia(e) {
				return "number" == typeof e || (na(e) && Er(e) == S);
			}
			function sa(e) {
				if (!na(e) || Er(e) != E) return !1;
				var t = Ge(e);
				if (null === t) return !0;
				var n = Ne.call(t, "constructor") && t.constructor;
				return "function" == typeof n && n instanceof n && Pe.call(n) == He;
			}
			var oa = bt
				? Xt(bt)
				: function (e) {
						return na(e) && Er(e) == k;
				  };
			var aa = xt
				? Xt(xt)
				: function (e) {
						return na(e) && fs(e) == A;
				  };
			function la(e) {
				return "string" == typeof e || (!Wo(e) && na(e) && Er(e) == M);
			}
			function ua(e) {
				return "symbol" == typeof e || (na(e) && Er(e) == I);
			}
			var ca = _t
				? Xt(_t)
				: function (e) {
						return na(e) && ea(e.length) && !!rt[Er(e)];
				  };
			var ha = Gi(Fr),
				da = Gi(function (e, t) {
					return e <= t;
				});
			function pa(e) {
				if (!e) return [];
				if (Yo(e)) return la(e) ? cn(e) : Mi(e);
				if (st && e[st])
					return (function (e) {
						for (var t, n = []; !(t = e.next()).done; ) n.push(t.value);
						return n;
					})(e[st]());
				var t = fs(e);
				return (t == C ? sn : t == A ? ln : Ua)(e);
			}
			function fa(e) {
				return e ? ((e = ga(e)) === h || e === -1 / 0 ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0) : 0 === e ? e : 0;
			}
			function ma(e) {
				var t = fa(e),
					n = t % 1;
				return t == t ? (n ? t - n : t) : 0;
			}
			function va(e) {
				return e ? ar(ma(e), 0, f) : 0;
			}
			function ga(e) {
				if ("number" == typeof e) return e;
				if (ua(e)) return p;
				if (ta(e)) {
					var t = "function" == typeof e.valueOf ? e.valueOf() : e;
					e = ta(t) ? t + "" : t;
				}
				if ("string" != typeof e) return 0 === e ? e : +e;
				e = Yt(e);
				var n = me.test(e);
				return n || ge.test(e) ? at(e.slice(2), n ? 2 : 8) : fe.test(e) ? p : +e;
			}
			function ya(e) {
				return Ii(e, Oa(e));
			}
			function ba(e) {
				return null == e ? "" : ui(e);
			}
			var xa = Li(function (e, t) {
					if (Cs(t) || Yo(t)) Ii(t, La(t), e);
					else for (var n in t) Ne.call(t, n) && tr(e, n, t[n]);
				}),
				_a = Li(function (e, t) {
					Ii(t, Oa(t), e);
				}),
				wa = Li(function (e, t, n, r) {
					Ii(t, Oa(t), e, r);
				}),
				Ca = Li(function (e, t, n, r) {
					Ii(t, La(t), e, r);
				}),
				Sa = ns(or);
			var Ea = qr(function (e, t) {
					e = Te(e);
					var r = -1,
						i = t.length,
						s = i > 2 ? t[2] : n;
					for (s && bs(t[0], t[1], s) && (i = 1); ++r < i; )
						for (var o = t[r], a = Oa(o), l = -1, u = a.length; ++l < u; ) {
							var c = a[l],
								h = e[c];
							(h === n || (Uo(h, Le[c]) && !Ne.call(e, c))) && (e[c] = o[c]);
						}
					return e;
				}),
				Ta = qr(function (e) {
					return e.push(n, Qi), wt(Na, n, e);
				});
			function ka(e, t, r) {
				var i = null == e ? n : Cr(e, t);
				return i === n ? r : i;
			}
			function Aa(e, t) {
				return null != e && ms(e, t, Ar);
			}
			var Ma = Ui(function (e, t, n) {
					null != t && "function" != typeof t.toString && (t = Fe.call(t)), (e[t] = n);
				}, tl(il)),
				Ia = Ui(function (e, t, n) {
					null != t && "function" != typeof t.toString && (t = Fe.call(t)), Ne.call(e, t) ? e[t].push(n) : (e[t] = [n]);
				}, ls),
				Ra = qr(Ir);
			function La(e) {
				return Yo(e) ? qn(e) : Dr(e);
			}
			function Oa(e) {
				return Yo(e) ? qn(e, !0) : Br(e);
			}
			var Pa = Li(function (e, t, n) {
					zr(e, t, n);
				}),
				Na = Li(function (e, t, n, r) {
					zr(e, t, n, r);
				}),
				Da = ns(function (e, t) {
					var n = {};
					if (null == e) return n;
					var r = !1;
					(t = It(t, function (t) {
						return (t = bi(t, e)), r || (r = t.length > 1), t;
					})),
						Ii(e, is(e), n),
						r && (n = lr(n, 7, es));
					for (var i = t.length; i--; ) hi(n, t[i]);
					return n;
				});
			var Ba = ns(function (e, t) {
				return null == e
					? {}
					: (function (e, t) {
							return Wr(e, t, function (t, n) {
								return Aa(e, n);
							});
					  })(e, t);
			});
			function Fa(e, t) {
				if (null == e) return {};
				var n = It(is(e), function (e) {
					return [e];
				});
				return (
					(t = ls(t)),
					Wr(e, n, function (e, n) {
						return t(e, n[0]);
					})
				);
			}
			var Ha = qi(La),
				Va = qi(Oa);
			function Ua(e) {
				return null == e ? [] : Kt(e, La(e));
			}
			var za = Di(function (e, t, n) {
				return (t = t.toLowerCase()), e + (n ? $a(t) : t);
			});
			function $a(e) {
				return Za(ba(e).toLowerCase());
			}
			function ja(e) {
				return (e = ba(e)) && e.replace(be, en).replace(qe, "");
			}
			var Wa = Di(function (e, t, n) {
					return e + (n ? "-" : "") + t.toLowerCase();
				}),
				Ga = Di(function (e, t, n) {
					return e + (n ? " " : "") + t.toLowerCase();
				}),
				Ya = Ni("toLowerCase");
			var Xa = Di(function (e, t, n) {
				return e + (n ? "_" : "") + t.toLowerCase();
			});
			var Ka = Di(function (e, t, n) {
				return e + (n ? " " : "") + Za(t);
			});
			var qa = Di(function (e, t, n) {
					return e + (n ? " " : "") + t.toUpperCase();
				}),
				Za = Ni("toUpperCase");
			function Ja(e, t, r) {
				return (
					(e = ba(e)),
					(t = r ? n : t) === n
						? (function (e) {
								return et.test(e);
						  })(e)
							? (function (e) {
									return e.match(Je) || [];
							  })(e)
							: (function (e) {
									return e.match(ue) || [];
							  })(e)
						: e.match(t) || []
				);
			}
			var Qa = qr(function (e, t) {
					try {
						return wt(e, n, t);
					} catch (Kj) {
						return Zo(Kj) ? Kj : new Ce(Kj);
					}
				}),
				el = ns(function (e, t) {
					return (
						St(t, function (t) {
							(t = Bs(t)), sr(e, t, Io(e[t], e));
						}),
						e
					);
				});
			function tl(e) {
				return function () {
					return e;
				};
			}
			var nl = Hi(),
				rl = Hi(!0);
			function il(e) {
				return e;
			}
			function sl(e) {
				return Nr("function" == typeof e ? e : lr(e, 1));
			}
			var ol = qr(function (e, t) {
					return function (n) {
						return Ir(n, e, t);
					};
				}),
				al = qr(function (e, t) {
					return function (n) {
						return Ir(e, n, t);
					};
				});
			function ll(e, t, n) {
				var r = La(t),
					i = wr(t, r);
				null != n || (ta(t) && (i.length || !r.length)) || ((n = t), (t = e), (e = this), (i = wr(t, La(t))));
				var s = !(ta(n) && "chain" in n && !n.chain),
					o = Jo(e);
				return (
					St(i, function (n) {
						var r = t[n];
						(e[n] = r),
							o &&
								(e.prototype[n] = function () {
									var t = this.__chain__;
									if (s || t) {
										var n = e(this.__wrapped__),
											i = (n.__actions__ = Mi(this.__actions__));
										return i.push({ func: r, args: arguments, thisArg: e }), (n.__chain__ = t), n;
									}
									return r.apply(e, Rt([this.value()], arguments));
								});
					}),
					e
				);
			}
			function ul() {}
			var cl = $i(It),
				hl = $i(Tt),
				dl = $i(Pt);
			function pl(e) {
				return xs(e)
					? zt(Bs(e))
					: (function (e) {
							return function (t) {
								return Cr(t, e);
							};
					  })(e);
			}
			var fl = Wi(),
				ml = Wi(!0);
			function vl() {
				return [];
			}
			function gl() {
				return !1;
			}
			var yl = zi(function (e, t) {
					return e + t;
				}, 0),
				bl = Xi("ceil"),
				xl = zi(function (e, t) {
					return e / t;
				}, 1),
				_l = Xi("floor");
			var wl,
				Cl = zi(function (e, t) {
					return e * t;
				}, 1),
				Sl = Xi("round"),
				El = zi(function (e, t) {
					return e - t;
				}, 0);
			return (
				(Vn.after = function (e, t) {
					if ("function" != typeof t) throw new Me(r);
					return (
						(e = ma(e)),
						function () {
							if (--e < 1) return t.apply(this, arguments);
						}
					);
				}),
				(Vn.ary = Ao),
				(Vn.assign = xa),
				(Vn.assignIn = _a),
				(Vn.assignInWith = wa),
				(Vn.assignWith = Ca),
				(Vn.at = Sa),
				(Vn.before = Mo),
				(Vn.bind = Io),
				(Vn.bindAll = el),
				(Vn.bindKey = Ro),
				(Vn.castArray = function () {
					if (!arguments.length) return [];
					var e = arguments[0];
					return Wo(e) ? e : [e];
				}),
				(Vn.chain = po),
				(Vn.chunk = function (e, t, r) {
					t = (r ? bs(e, t, r) : t === n) ? 1 : yn(ma(t), 0);
					var i = null == e ? 0 : e.length;
					if (!i || t < 1) return [];
					for (var s = 0, o = 0, a = se(mt(i / t)); s < i; ) a[o++] = ri(e, s, (s += t));
					return a;
				}),
				(Vn.compact = function (e) {
					for (var t = -1, n = null == e ? 0 : e.length, r = 0, i = []; ++t < n; ) {
						var s = e[t];
						s && (i[r++] = s);
					}
					return i;
				}),
				(Vn.concat = function () {
					var e = arguments.length;
					if (!e) return [];
					for (var t = se(e - 1), n = arguments[0], r = e; r--; ) t[r - 1] = arguments[r];
					return Rt(Wo(n) ? Mi(n) : [n], gr(t, 1));
				}),
				(Vn.cond = function (e) {
					var t = null == e ? 0 : e.length,
						n = ls();
					return (
						(e = t
							? It(e, function (e) {
									if ("function" != typeof e[1]) throw new Me(r);
									return [n(e[0]), e[1]];
							  })
							: []),
						qr(function (n) {
							for (var r = -1; ++r < t; ) {
								var i = e[r];
								if (wt(i[0], this, n)) return wt(i[1], this, n);
							}
						})
					);
				}),
				(Vn.conforms = function (e) {
					return (function (e) {
						var t = La(e);
						return function (n) {
							return ur(n, e, t);
						};
					})(lr(e, 1));
				}),
				(Vn.constant = tl),
				(Vn.countBy = vo),
				(Vn.create = function (e, t) {
					var n = Un(e);
					return null == t ? n : ir(n, t);
				}),
				(Vn.curry = function e(t, r, i) {
					var s = Zi(t, 8, n, n, n, n, n, (r = i ? n : r));
					return (s.placeholder = e.placeholder), s;
				}),
				(Vn.curryRight = function e(t, r, i) {
					var s = Zi(t, o, n, n, n, n, n, (r = i ? n : r));
					return (s.placeholder = e.placeholder), s;
				}),
				(Vn.debounce = Lo),
				(Vn.defaults = Ea),
				(Vn.defaultsDeep = Ta),
				(Vn.defer = Oo),
				(Vn.delay = Po),
				(Vn.difference = Vs),
				(Vn.differenceBy = Us),
				(Vn.differenceWith = zs),
				(Vn.drop = function (e, t, r) {
					var i = null == e ? 0 : e.length;
					return i ? ri(e, (t = r || t === n ? 1 : ma(t)) < 0 ? 0 : t, i) : [];
				}),
				(Vn.dropRight = function (e, t, r) {
					var i = null == e ? 0 : e.length;
					return i ? ri(e, 0, (t = i - (t = r || t === n ? 1 : ma(t))) < 0 ? 0 : t) : [];
				}),
				(Vn.dropRightWhile = function (e, t) {
					return e && e.length ? pi(e, ls(t, 3), !0, !0) : [];
				}),
				(Vn.dropWhile = function (e, t) {
					return e && e.length ? pi(e, ls(t, 3), !0) : [];
				}),
				(Vn.fill = function (e, t, r, i) {
					var s = null == e ? 0 : e.length;
					return s
						? (r && "number" != typeof r && bs(e, t, r) && ((r = 0), (i = s)),
						  (function (e, t, r, i) {
								var s = e.length;
								for ((r = ma(r)) < 0 && (r = -r > s ? 0 : s + r), (i = i === n || i > s ? s : ma(i)) < 0 && (i += s), i = r > i ? 0 : va(i); r < i; ) e[r++] = t;
								return e;
						  })(e, t, r, i))
						: [];
				}),
				(Vn.filter = function (e, t) {
					return (Wo(e) ? kt : vr)(e, ls(t, 3));
				}),
				(Vn.flatMap = function (e, t) {
					return gr(So(e, t), 1);
				}),
				(Vn.flatMapDeep = function (e, t) {
					return gr(So(e, t), h);
				}),
				(Vn.flatMapDepth = function (e, t, r) {
					return (r = r === n ? 1 : ma(r)), gr(So(e, t), r);
				}),
				(Vn.flatten = Ws),
				(Vn.flattenDeep = function (e) {
					return (null == e ? 0 : e.length) ? gr(e, h) : [];
				}),
				(Vn.flattenDepth = function (e, t) {
					return (null == e ? 0 : e.length) ? gr(e, (t = t === n ? 1 : ma(t))) : [];
				}),
				(Vn.flip = function (e) {
					return Zi(e, 512);
				}),
				(Vn.flow = nl),
				(Vn.flowRight = rl),
				(Vn.fromPairs = function (e) {
					for (var t = -1, n = null == e ? 0 : e.length, r = {}; ++t < n; ) {
						var i = e[t];
						r[i[0]] = i[1];
					}
					return r;
				}),
				(Vn.functions = function (e) {
					return null == e ? [] : wr(e, La(e));
				}),
				(Vn.functionsIn = function (e) {
					return null == e ? [] : wr(e, Oa(e));
				}),
				(Vn.groupBy = _o),
				(Vn.initial = function (e) {
					return (null == e ? 0 : e.length) ? ri(e, 0, -1) : [];
				}),
				(Vn.intersection = Ys),
				(Vn.intersectionBy = Xs),
				(Vn.intersectionWith = Ks),
				(Vn.invert = Ma),
				(Vn.invertBy = Ia),
				(Vn.invokeMap = wo),
				(Vn.iteratee = sl),
				(Vn.keyBy = Co),
				(Vn.keys = La),
				(Vn.keysIn = Oa),
				(Vn.map = So),
				(Vn.mapKeys = function (e, t) {
					var n = {};
					return (
						(t = ls(t, 3)),
						xr(e, function (e, r, i) {
							sr(n, t(e, r, i), e);
						}),
						n
					);
				}),
				(Vn.mapValues = function (e, t) {
					var n = {};
					return (
						(t = ls(t, 3)),
						xr(e, function (e, r, i) {
							sr(n, r, t(e, r, i));
						}),
						n
					);
				}),
				(Vn.matches = function (e) {
					return Vr(lr(e, 1));
				}),
				(Vn.matchesProperty = function (e, t) {
					return Ur(e, lr(t, 1));
				}),
				(Vn.memoize = No),
				(Vn.merge = Pa),
				(Vn.mergeWith = Na),
				(Vn.method = ol),
				(Vn.methodOf = al),
				(Vn.mixin = ll),
				(Vn.negate = Do),
				(Vn.nthArg = function (e) {
					return (
						(e = ma(e)),
						qr(function (t) {
							return $r(t, e);
						})
					);
				}),
				(Vn.omit = Da),
				(Vn.omitBy = function (e, t) {
					return Fa(e, Do(ls(t)));
				}),
				(Vn.once = function (e) {
					return Mo(2, e);
				}),
				(Vn.orderBy = function (e, t, r, i) {
					return null == e ? [] : (Wo(t) || (t = null == t ? [] : [t]), Wo((r = i ? n : r)) || (r = null == r ? [] : [r]), jr(e, t, r));
				}),
				(Vn.over = cl),
				(Vn.overArgs = Bo),
				(Vn.overEvery = hl),
				(Vn.overSome = dl),
				(Vn.partial = Fo),
				(Vn.partialRight = Ho),
				(Vn.partition = Eo),
				(Vn.pick = Ba),
				(Vn.pickBy = Fa),
				(Vn.property = pl),
				(Vn.propertyOf = function (e) {
					return function (t) {
						return null == e ? n : Cr(e, t);
					};
				}),
				(Vn.pull = Zs),
				(Vn.pullAll = Js),
				(Vn.pullAllBy = function (e, t, n) {
					return e && e.length && t && t.length ? Gr(e, t, ls(n, 2)) : e;
				}),
				(Vn.pullAllWith = function (e, t, r) {
					return e && e.length && t && t.length ? Gr(e, t, n, r) : e;
				}),
				(Vn.pullAt = Qs),
				(Vn.range = fl),
				(Vn.rangeRight = ml),
				(Vn.rearg = Vo),
				(Vn.reject = function (e, t) {
					return (Wo(e) ? kt : vr)(e, Do(ls(t, 3)));
				}),
				(Vn.remove = function (e, t) {
					var n = [];
					if (!e || !e.length) return n;
					var r = -1,
						i = [],
						s = e.length;
					for (t = ls(t, 3); ++r < s; ) {
						var o = e[r];
						t(o, r, e) && (n.push(o), i.push(r));
					}
					return Yr(e, i), n;
				}),
				(Vn.rest = function (e, t) {
					if ("function" != typeof e) throw new Me(r);
					return qr(e, (t = t === n ? t : ma(t)));
				}),
				(Vn.reverse = eo),
				(Vn.sampleSize = function (e, t, r) {
					return (t = (r ? bs(e, t, r) : t === n) ? 1 : ma(t)), (Wo(e) ? Jn : Jr)(e, t);
				}),
				(Vn.set = function (e, t, n) {
					return null == e ? e : Qr(e, t, n);
				}),
				(Vn.setWith = function (e, t, r, i) {
					return (i = "function" == typeof i ? i : n), null == e ? e : Qr(e, t, r, i);
				}),
				(Vn.shuffle = function (e) {
					return (Wo(e) ? Qn : ni)(e);
				}),
				(Vn.slice = function (e, t, r) {
					var i = null == e ? 0 : e.length;
					return i ? (r && "number" != typeof r && bs(e, t, r) ? ((t = 0), (r = i)) : ((t = null == t ? 0 : ma(t)), (r = r === n ? i : ma(r))), ri(e, t, r)) : [];
				}),
				(Vn.sortBy = To),
				(Vn.sortedUniq = function (e) {
					return e && e.length ? ai(e) : [];
				}),
				(Vn.sortedUniqBy = function (e, t) {
					return e && e.length ? ai(e, ls(t, 2)) : [];
				}),
				(Vn.split = function (e, t, r) {
					return r && "number" != typeof r && bs(e, t, r) && (t = r = n), (r = r === n ? f : r >>> 0) ? ((e = ba(e)) && ("string" == typeof t || (null != t && !oa(t))) && !(t = ui(t)) && rn(e) ? _i(cn(e), 0, r) : e.split(t, r)) : [];
				}),
				(Vn.spread = function (e, t) {
					if ("function" != typeof e) throw new Me(r);
					return (
						(t = null == t ? 0 : yn(ma(t), 0)),
						qr(function (n) {
							var r = n[t],
								i = _i(n, 0, t);
							return r && Rt(i, r), wt(e, this, i);
						})
					);
				}),
				(Vn.tail = function (e) {
					var t = null == e ? 0 : e.length;
					return t ? ri(e, 1, t) : [];
				}),
				(Vn.take = function (e, t, r) {
					return e && e.length ? ri(e, 0, (t = r || t === n ? 1 : ma(t)) < 0 ? 0 : t) : [];
				}),
				(Vn.takeRight = function (e, t, r) {
					var i = null == e ? 0 : e.length;
					return i ? ri(e, (t = i - (t = r || t === n ? 1 : ma(t))) < 0 ? 0 : t, i) : [];
				}),
				(Vn.takeRightWhile = function (e, t) {
					return e && e.length ? pi(e, ls(t, 3), !1, !0) : [];
				}),
				(Vn.takeWhile = function (e, t) {
					return e && e.length ? pi(e, ls(t, 3)) : [];
				}),
				(Vn.tap = function (e, t) {
					return t(e), e;
				}),
				(Vn.throttle = function (e, t, n) {
					var i = !0,
						s = !0;
					if ("function" != typeof e) throw new Me(r);
					return ta(n) && ((i = "leading" in n ? !!n.leading : i), (s = "trailing" in n ? !!n.trailing : s)), Lo(e, t, { leading: i, maxWait: t, trailing: s });
				}),
				(Vn.thru = fo),
				(Vn.toArray = pa),
				(Vn.toPairs = Ha),
				(Vn.toPairsIn = Va),
				(Vn.toPath = function (e) {
					return Wo(e) ? It(e, Bs) : ua(e) ? [e] : Mi(Ds(ba(e)));
				}),
				(Vn.toPlainObject = ya),
				(Vn.transform = function (e, t, n) {
					var r = Wo(e),
						i = r || Ko(e) || ca(e);
					if (((t = ls(t, 4)), null == n)) {
						var s = e && e.constructor;
						n = i ? (r ? new s() : []) : ta(e) && Jo(s) ? Un(Ge(e)) : {};
					}
					return (
						(i ? St : xr)(e, function (e, r, i) {
							return t(n, e, r, i);
						}),
						n
					);
				}),
				(Vn.unary = function (e) {
					return Ao(e, 1);
				}),
				(Vn.union = to),
				(Vn.unionBy = no),
				(Vn.unionWith = ro),
				(Vn.uniq = function (e) {
					return e && e.length ? ci(e) : [];
				}),
				(Vn.uniqBy = function (e, t) {
					return e && e.length ? ci(e, ls(t, 2)) : [];
				}),
				(Vn.uniqWith = function (e, t) {
					return (t = "function" == typeof t ? t : n), e && e.length ? ci(e, n, t) : [];
				}),
				(Vn.unset = function (e, t) {
					return null == e || hi(e, t);
				}),
				(Vn.unzip = io),
				(Vn.unzipWith = so),
				(Vn.update = function (e, t, n) {
					return null == e ? e : di(e, t, yi(n));
				}),
				(Vn.updateWith = function (e, t, r, i) {
					return (i = "function" == typeof i ? i : n), null == e ? e : di(e, t, yi(r), i);
				}),
				(Vn.values = Ua),
				(Vn.valuesIn = function (e) {
					return null == e ? [] : Kt(e, Oa(e));
				}),
				(Vn.without = oo),
				(Vn.words = Ja),
				(Vn.wrap = function (e, t) {
					return Fo(yi(t), e);
				}),
				(Vn.xor = ao),
				(Vn.xorBy = lo),
				(Vn.xorWith = uo),
				(Vn.zip = co),
				(Vn.zipObject = function (e, t) {
					return vi(e || [], t || [], tr);
				}),
				(Vn.zipObjectDeep = function (e, t) {
					return vi(e || [], t || [], Qr);
				}),
				(Vn.zipWith = ho),
				(Vn.entries = Ha),
				(Vn.entriesIn = Va),
				(Vn.extend = _a),
				(Vn.extendWith = wa),
				ll(Vn, Vn),
				(Vn.add = yl),
				(Vn.attempt = Qa),
				(Vn.camelCase = za),
				(Vn.capitalize = $a),
				(Vn.ceil = bl),
				(Vn.clamp = function (e, t, r) {
					return r === n && ((r = t), (t = n)), r !== n && (r = (r = ga(r)) == r ? r : 0), t !== n && (t = (t = ga(t)) == t ? t : 0), ar(ga(e), t, r);
				}),
				(Vn.clone = function (e) {
					return lr(e, 4);
				}),
				(Vn.cloneDeep = function (e) {
					return lr(e, 5);
				}),
				(Vn.cloneDeepWith = function (e, t) {
					return lr(e, 5, (t = "function" == typeof t ? t : n));
				}),
				(Vn.cloneWith = function (e, t) {
					return lr(e, 4, (t = "function" == typeof t ? t : n));
				}),
				(Vn.conformsTo = function (e, t) {
					return null == t || ur(e, t, La(t));
				}),
				(Vn.deburr = ja),
				(Vn.defaultTo = function (e, t) {
					return null == e || e != e ? t : e;
				}),
				(Vn.divide = xl),
				(Vn.endsWith = function (e, t, r) {
					(e = ba(e)), (t = ui(t));
					var i = e.length,
						s = (r = r === n ? i : ar(ma(r), 0, i));
					return (r -= t.length) >= 0 && e.slice(r, s) == t;
				}),
				(Vn.eq = Uo),
				(Vn.escape = function (e) {
					return (e = ba(e)) && K.test(e) ? e.replace(Y, tn) : e;
				}),
				(Vn.escapeRegExp = function (e) {
					return (e = ba(e)) && re.test(e) ? e.replace(ne, "\\$&") : e;
				}),
				(Vn.every = function (e, t, r) {
					var i = Wo(e) ? Tt : fr;
					return r && bs(e, t, r) && (t = n), i(e, ls(t, 3));
				}),
				(Vn.find = go),
				(Vn.findIndex = $s),
				(Vn.findKey = function (e, t) {
					return Dt(e, ls(t, 3), xr);
				}),
				(Vn.findLast = yo),
				(Vn.findLastIndex = js),
				(Vn.findLastKey = function (e, t) {
					return Dt(e, ls(t, 3), _r);
				}),
				(Vn.floor = _l),
				(Vn.forEach = bo),
				(Vn.forEachRight = xo),
				(Vn.forIn = function (e, t) {
					return null == e ? e : yr(e, ls(t, 3), Oa);
				}),
				(Vn.forInRight = function (e, t) {
					return null == e ? e : br(e, ls(t, 3), Oa);
				}),
				(Vn.forOwn = function (e, t) {
					return e && xr(e, ls(t, 3));
				}),
				(Vn.forOwnRight = function (e, t) {
					return e && _r(e, ls(t, 3));
				}),
				(Vn.get = ka),
				(Vn.gt = zo),
				(Vn.gte = $o),
				(Vn.has = function (e, t) {
					return null != e && ms(e, t, kr);
				}),
				(Vn.hasIn = Aa),
				(Vn.head = Gs),
				(Vn.identity = il),
				(Vn.includes = function (e, t, n, r) {
					(e = Yo(e) ? e : Ua(e)), (n = n && !r ? ma(n) : 0);
					var i = e.length;
					return n < 0 && (n = yn(i + n, 0)), la(e) ? n <= i && e.indexOf(t, n) > -1 : !!i && Ft(e, t, n) > -1;
				}),
				(Vn.indexOf = function (e, t, n) {
					var r = null == e ? 0 : e.length;
					if (!r) return -1;
					var i = null == n ? 0 : ma(n);
					return i < 0 && (i = yn(r + i, 0)), Ft(e, t, i);
				}),
				(Vn.inRange = function (e, t, r) {
					return (
						(t = fa(t)),
						r === n ? ((r = t), (t = 0)) : (r = fa(r)),
						(function (e, t, n) {
							return e >= bn(t, n) && e < yn(t, n);
						})((e = ga(e)), t, r)
					);
				}),
				(Vn.invoke = Ra),
				(Vn.isArguments = jo),
				(Vn.isArray = Wo),
				(Vn.isArrayBuffer = Go),
				(Vn.isArrayLike = Yo),
				(Vn.isArrayLikeObject = Xo),
				(Vn.isBoolean = function (e) {
					return !0 === e || !1 === e || (na(e) && Er(e) == y);
				}),
				(Vn.isBuffer = Ko),
				(Vn.isDate = qo),
				(Vn.isElement = function (e) {
					return na(e) && 1 === e.nodeType && !sa(e);
				}),
				(Vn.isEmpty = function (e) {
					if (null == e) return !0;
					if (Yo(e) && (Wo(e) || "string" == typeof e || "function" == typeof e.splice || Ko(e) || ca(e) || jo(e))) return !e.length;
					var t = fs(e);
					if (t == C || t == A) return !e.size;
					if (Cs(e)) return !Dr(e).length;
					for (var n in e) if (Ne.call(e, n)) return !1;
					return !0;
				}),
				(Vn.isEqual = function (e, t) {
					return Lr(e, t);
				}),
				(Vn.isEqualWith = function (e, t, r) {
					var i = (r = "function" == typeof r ? r : n) ? r(e, t) : n;
					return i === n ? Lr(e, t, n, r) : !!i;
				}),
				(Vn.isError = Zo),
				(Vn.isFinite = function (e) {
					return "number" == typeof e && mn(e);
				}),
				(Vn.isFunction = Jo),
				(Vn.isInteger = Qo),
				(Vn.isLength = ea),
				(Vn.isMap = ra),
				(Vn.isMatch = function (e, t) {
					return e === t || Or(e, t, cs(t));
				}),
				(Vn.isMatchWith = function (e, t, r) {
					return (r = "function" == typeof r ? r : n), Or(e, t, cs(t), r);
				}),
				(Vn.isNaN = function (e) {
					return ia(e) && e != +e;
				}),
				(Vn.isNative = function (e) {
					if (ws(e)) throw new Ce("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
					return Pr(e);
				}),
				(Vn.isNil = function (e) {
					return null == e;
				}),
				(Vn.isNull = function (e) {
					return null === e;
				}),
				(Vn.isNumber = ia),
				(Vn.isObject = ta),
				(Vn.isObjectLike = na),
				(Vn.isPlainObject = sa),
				(Vn.isRegExp = oa),
				(Vn.isSafeInteger = function (e) {
					return Qo(e) && e >= -9007199254740991 && e <= d;
				}),
				(Vn.isSet = aa),
				(Vn.isString = la),
				(Vn.isSymbol = ua),
				(Vn.isTypedArray = ca),
				(Vn.isUndefined = function (e) {
					return e === n;
				}),
				(Vn.isWeakMap = function (e) {
					return na(e) && fs(e) == R;
				}),
				(Vn.isWeakSet = function (e) {
					return na(e) && "[object WeakSet]" == Er(e);
				}),
				(Vn.join = function (e, t) {
					return null == e ? "" : vn.call(e, t);
				}),
				(Vn.kebabCase = Wa),
				(Vn.last = qs),
				(Vn.lastIndexOf = function (e, t, r) {
					var i = null == e ? 0 : e.length;
					if (!i) return -1;
					var s = i;
					return (
						r !== n && (s = (s = ma(r)) < 0 ? yn(i + s, 0) : bn(s, i - 1)),
						t == t
							? (function (e, t, n) {
									for (var r = n + 1; r--; ) if (e[r] === t) return r;
									return r;
							  })(e, t, s)
							: Bt(e, Vt, s, !0)
					);
				}),
				(Vn.lowerCase = Ga),
				(Vn.lowerFirst = Ya),
				(Vn.lt = ha),
				(Vn.lte = da),
				(Vn.max = function (e) {
					return e && e.length ? mr(e, il, Tr) : n;
				}),
				(Vn.maxBy = function (e, t) {
					return e && e.length ? mr(e, ls(t, 2), Tr) : n;
				}),
				(Vn.mean = function (e) {
					return Ut(e, il);
				}),
				(Vn.meanBy = function (e, t) {
					return Ut(e, ls(t, 2));
				}),
				(Vn.min = function (e) {
					return e && e.length ? mr(e, il, Fr) : n;
				}),
				(Vn.minBy = function (e, t) {
					return e && e.length ? mr(e, ls(t, 2), Fr) : n;
				}),
				(Vn.stubArray = vl),
				(Vn.stubFalse = gl),
				(Vn.stubObject = function () {
					return {};
				}),
				(Vn.stubString = function () {
					return "";
				}),
				(Vn.stubTrue = function () {
					return !0;
				}),
				(Vn.multiply = Cl),
				(Vn.nth = function (e, t) {
					return e && e.length ? $r(e, ma(t)) : n;
				}),
				(Vn.noConflict = function () {
					return ct._ === this && (ct._ = Ve), this;
				}),
				(Vn.noop = ul),
				(Vn.now = ko),
				(Vn.pad = function (e, t, n) {
					e = ba(e);
					var r = (t = ma(t)) ? un(e) : 0;
					if (!t || r >= t) return e;
					var i = (t - r) / 2;
					return ji(Nt(i), n) + e + ji(mt(i), n);
				}),
				(Vn.padEnd = function (e, t, n) {
					e = ba(e);
					var r = (t = ma(t)) ? un(e) : 0;
					return t && r < t ? e + ji(t - r, n) : e;
				}),
				(Vn.padStart = function (e, t, n) {
					e = ba(e);
					var r = (t = ma(t)) ? un(e) : 0;
					return t && r < t ? ji(t - r, n) + e : e;
				}),
				(Vn.parseInt = function (e, t, n) {
					return n || null == t ? (t = 0) : t && (t = +t), _n(ba(e).replace(ie, ""), t || 0);
				}),
				(Vn.random = function (e, t, r) {
					if ((r && "boolean" != typeof r && bs(e, t, r) && (t = r = n), r === n && ("boolean" == typeof t ? ((r = t), (t = n)) : "boolean" == typeof e && ((r = e), (e = n))), e === n && t === n ? ((e = 0), (t = 1)) : ((e = fa(e)), t === n ? ((t = e), (e = 0)) : (t = fa(t))), e > t)) {
						var i = e;
						(e = t), (t = i);
					}
					if (r || e % 1 || t % 1) {
						var s = wn();
						return bn(e + s * (t - e + ot("1e-" + ((s + "").length - 1))), t);
					}
					return Xr(e, t);
				}),
				(Vn.reduce = function (e, t, n) {
					var r = Wo(e) ? Lt : jt,
						i = arguments.length < 3;
					return r(e, ls(t, 4), n, i, dr);
				}),
				(Vn.reduceRight = function (e, t, n) {
					var r = Wo(e) ? Ot : jt,
						i = arguments.length < 3;
					return r(e, ls(t, 4), n, i, pr);
				}),
				(Vn.repeat = function (e, t, r) {
					return (t = (r ? bs(e, t, r) : t === n) ? 1 : ma(t)), Kr(ba(e), t);
				}),
				(Vn.replace = function () {
					var e = arguments,
						t = ba(e[0]);
					return e.length < 3 ? t : t.replace(e[1], e[2]);
				}),
				(Vn.result = function (e, t, r) {
					var i = -1,
						s = (t = bi(t, e)).length;
					for (s || ((s = 1), (e = n)); ++i < s; ) {
						var o = null == e ? n : e[Bs(t[i])];
						o === n && ((i = s), (o = r)), (e = Jo(o) ? o.call(e) : o);
					}
					return e;
				}),
				(Vn.round = Sl),
				(Vn.runInContext = e),
				(Vn.sample = function (e) {
					return (Wo(e) ? Zn : Zr)(e);
				}),
				(Vn.size = function (e) {
					if (null == e) return 0;
					if (Yo(e)) return la(e) ? un(e) : e.length;
					var t = fs(e);
					return t == C || t == A ? e.size : Dr(e).length;
				}),
				(Vn.snakeCase = Xa),
				(Vn.some = function (e, t, r) {
					var i = Wo(e) ? Pt : ii;
					return r && bs(e, t, r) && (t = n), i(e, ls(t, 3));
				}),
				(Vn.sortedIndex = function (e, t) {
					return si(e, t);
				}),
				(Vn.sortedIndexBy = function (e, t, n) {
					return oi(e, t, ls(n, 2));
				}),
				(Vn.sortedIndexOf = function (e, t) {
					var n = null == e ? 0 : e.length;
					if (n) {
						var r = si(e, t);
						if (r < n && Uo(e[r], t)) return r;
					}
					return -1;
				}),
				(Vn.sortedLastIndex = function (e, t) {
					return si(e, t, !0);
				}),
				(Vn.sortedLastIndexBy = function (e, t, n) {
					return oi(e, t, ls(n, 2), !0);
				}),
				(Vn.sortedLastIndexOf = function (e, t) {
					if (null == e ? 0 : e.length) {
						var n = si(e, t, !0) - 1;
						if (Uo(e[n], t)) return n;
					}
					return -1;
				}),
				(Vn.startCase = Ka),
				(Vn.startsWith = function (e, t, n) {
					return (e = ba(e)), (n = null == n ? 0 : ar(ma(n), 0, e.length)), (t = ui(t)), e.slice(n, n + t.length) == t;
				}),
				(Vn.subtract = El),
				(Vn.sum = function (e) {
					return e && e.length ? Wt(e, il) : 0;
				}),
				(Vn.sumBy = function (e, t) {
					return e && e.length ? Wt(e, ls(t, 2)) : 0;
				}),
				(Vn.template = function (e, t, r) {
					var i = Vn.templateSettings;
					r && bs(e, t, r) && (t = n), (e = ba(e)), (t = wa({}, t, i, Ji));
					var s,
						o,
						a = wa({}, t.imports, i.imports, Ji),
						l = La(a),
						u = Kt(a, l),
						c = 0,
						h = t.interpolate || xe,
						d = "__p += '",
						p = ke((t.escape || xe).source + "|" + h.source + "|" + (h === J ? de : xe).source + "|" + (t.evaluate || xe).source + "|$", "g"),
						f = "//# sourceURL=" + (Ne.call(t, "sourceURL") ? (t.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++nt + "]") + "\n";
					e.replace(p, function (t, n, r, i, a, l) {
						return r || (r = i), (d += e.slice(c, l).replace(_e, nn)), n && ((s = !0), (d += "' +\n__e(" + n + ") +\n'")), a && ((o = !0), (d += "';\n" + a + ";\n__p += '")), r && (d += "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"), (c = l + t.length), t;
					}),
						(d += "';\n");
					var m = Ne.call(t, "variable") && t.variable;
					if (m) {
						if (ce.test(m)) throw new Ce("Invalid `variable` option passed into `_.template`");
					} else d = "with (obj) {\n" + d + "\n}\n";
					(d = (o ? d.replace($, "") : d).replace(j, "$1").replace(W, "$1;")),
						(d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (s ? ", __e = _.escape" : "") + (o ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}");
					var v = Qa(function () {
						return Se(l, f + "return " + d).apply(n, u);
					});
					if (((v.source = d), Zo(v))) throw v;
					return v;
				}),
				(Vn.times = function (e, t) {
					if ((e = ma(e)) < 1 || e > d) return [];
					var n = f,
						r = bn(e, f);
					(t = ls(t)), (e -= f);
					for (var i = Gt(r, t); ++n < e; ) t(n);
					return i;
				}),
				(Vn.toFinite = fa),
				(Vn.toInteger = ma),
				(Vn.toLength = va),
				(Vn.toLower = function (e) {
					return ba(e).toLowerCase();
				}),
				(Vn.toNumber = ga),
				(Vn.toSafeInteger = function (e) {
					return e ? ar(ma(e), -9007199254740991, d) : 0 === e ? e : 0;
				}),
				(Vn.toString = ba),
				(Vn.toUpper = function (e) {
					return ba(e).toUpperCase();
				}),
				(Vn.trim = function (e, t, r) {
					if ((e = ba(e)) && (r || t === n)) return Yt(e);
					if (!e || !(t = ui(t))) return e;
					var i = cn(e),
						s = cn(t);
					return _i(i, Zt(i, s), Jt(i, s) + 1).join("");
				}),
				(Vn.trimEnd = function (e, t, r) {
					if ((e = ba(e)) && (r || t === n)) return e.slice(0, hn(e) + 1);
					if (!e || !(t = ui(t))) return e;
					var i = cn(e);
					return _i(i, 0, Jt(i, cn(t)) + 1).join("");
				}),
				(Vn.trimStart = function (e, t, r) {
					if ((e = ba(e)) && (r || t === n)) return e.replace(ie, "");
					if (!e || !(t = ui(t))) return e;
					var i = cn(e);
					return _i(i, Zt(i, cn(t))).join("");
				}),
				(Vn.truncate = function (e, t) {
					var r = 30,
						i = "...";
					if (ta(t)) {
						var s = "separator" in t ? t.separator : s;
						(r = "length" in t ? ma(t.length) : r), (i = "omission" in t ? ui(t.omission) : i);
					}
					var o = (e = ba(e)).length;
					if (rn(e)) {
						var a = cn(e);
						o = a.length;
					}
					if (r >= o) return e;
					var l = r - un(i);
					if (l < 1) return i;
					var u = a ? _i(a, 0, l).join("") : e.slice(0, l);
					if (s === n) return u + i;
					if ((a && (l += u.length - l), oa(s))) {
						if (e.slice(l).search(s)) {
							var c,
								h = u;
							for (s.global || (s = ke(s.source, ba(pe.exec(s)) + "g")), s.lastIndex = 0; (c = s.exec(h)); ) var d = c.index;
							u = u.slice(0, d === n ? l : d);
						}
					} else if (e.indexOf(ui(s), l) != l) {
						var p = u.lastIndexOf(s);
						p > -1 && (u = u.slice(0, p));
					}
					return u + i;
				}),
				(Vn.unescape = function (e) {
					return (e = ba(e)) && X.test(e) ? e.replace(G, dn) : e;
				}),
				(Vn.uniqueId = function (e) {
					var t = ++De;
					return ba(e) + t;
				}),
				(Vn.upperCase = qa),
				(Vn.upperFirst = Za),
				(Vn.each = bo),
				(Vn.eachRight = xo),
				(Vn.first = Gs),
				ll(
					Vn,
					((wl = {}),
					xr(Vn, function (e, t) {
						Ne.call(Vn.prototype, t) || (wl[t] = e);
					}),
					wl),
					{ chain: !1 }
				),
				(Vn.VERSION = "4.17.21"),
				St(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (e) {
					Vn[e].placeholder = Vn;
				}),
				St(["drop", "take"], function (e, t) {
					(jn.prototype[e] = function (r) {
						r = r === n ? 1 : yn(ma(r), 0);
						var i = this.__filtered__ && !t ? new jn(this) : this.clone();
						return i.__filtered__ ? (i.__takeCount__ = bn(r, i.__takeCount__)) : i.__views__.push({ size: bn(r, f), type: e + (i.__dir__ < 0 ? "Right" : "") }), i;
					}),
						(jn.prototype[e + "Right"] = function (t) {
							return this.reverse()[e](t).reverse();
						});
				}),
				St(["filter", "map", "takeWhile"], function (e, t) {
					var n = t + 1,
						r = 1 == n || 3 == n;
					jn.prototype[e] = function (e) {
						var t = this.clone();
						return t.__iteratees__.push({ iteratee: ls(e, 3), type: n }), (t.__filtered__ = t.__filtered__ || r), t;
					};
				}),
				St(["head", "last"], function (e, t) {
					var n = "take" + (t ? "Right" : "");
					jn.prototype[e] = function () {
						return this[n](1).value()[0];
					};
				}),
				St(["initial", "tail"], function (e, t) {
					var n = "drop" + (t ? "" : "Right");
					jn.prototype[e] = function () {
						return this.__filtered__ ? new jn(this) : this[n](1);
					};
				}),
				(jn.prototype.compact = function () {
					return this.filter(il);
				}),
				(jn.prototype.find = function (e) {
					return this.filter(e).head();
				}),
				(jn.prototype.findLast = function (e) {
					return this.reverse().find(e);
				}),
				(jn.prototype.invokeMap = qr(function (e, t) {
					return "function" == typeof e
						? new jn(this)
						: this.map(function (n) {
								return Ir(n, e, t);
						  });
				})),
				(jn.prototype.reject = function (e) {
					return this.filter(Do(ls(e)));
				}),
				(jn.prototype.slice = function (e, t) {
					e = ma(e);
					var r = this;
					return r.__filtered__ && (e > 0 || t < 0) ? new jn(r) : (e < 0 ? (r = r.takeRight(-e)) : e && (r = r.drop(e)), t !== n && (r = (t = ma(t)) < 0 ? r.dropRight(-t) : r.take(t - e)), r);
				}),
				(jn.prototype.takeRightWhile = function (e) {
					return this.reverse().takeWhile(e).reverse();
				}),
				(jn.prototype.toArray = function () {
					return this.take(f);
				}),
				xr(jn.prototype, function (e, t) {
					var r = /^(?:filter|find|map|reject)|While$/.test(t),
						i = /^(?:head|last)$/.test(t),
						s = Vn[i ? "take" + ("last" == t ? "Right" : "") : t],
						o = i || /^find/.test(t);
					s &&
						(Vn.prototype[t] = function () {
							var t = this.__wrapped__,
								a = i ? [1] : arguments,
								l = t instanceof jn,
								u = a[0],
								c = l || Wo(t),
								h = function (e) {
									var t = s.apply(Vn, Rt([e], a));
									return i && d ? t[0] : t;
								};
							c && r && "function" == typeof u && 1 != u.length && (l = c = !1);
							var d = this.__chain__,
								p = !!this.__actions__.length,
								f = o && !d,
								m = l && !p;
							if (!o && c) {
								t = m ? t : new jn(this);
								var v = e.apply(t, a);
								return v.__actions__.push({ func: fo, args: [h], thisArg: n }), new $n(v, d);
							}
							return f && m ? e.apply(this, a) : ((v = this.thru(h)), f ? (i ? v.value()[0] : v.value()) : v);
						});
				}),
				St(["pop", "push", "shift", "sort", "splice", "unshift"], function (e) {
					var t = Ie[e],
						n = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru",
						r = /^(?:pop|shift)$/.test(e);
					Vn.prototype[e] = function () {
						var e = arguments;
						if (r && !this.__chain__) {
							var i = this.value();
							return t.apply(Wo(i) ? i : [], e);
						}
						return this[n](function (n) {
							return t.apply(Wo(n) ? n : [], e);
						});
					};
				}),
				xr(jn.prototype, function (e, t) {
					var n = Vn[t];
					if (n) {
						var r = n.name + "";
						Ne.call(Rn, r) || (Rn[r] = []), Rn[r].push({ name: t, func: n });
					}
				}),
				(Rn[Vi(n, 2).name] = [{ name: "wrapper", func: n }]),
				(jn.prototype.clone = function () {
					var e = new jn(this.__wrapped__);
					return (e.__actions__ = Mi(this.__actions__)), (e.__dir__ = this.__dir__), (e.__filtered__ = this.__filtered__), (e.__iteratees__ = Mi(this.__iteratees__)), (e.__takeCount__ = this.__takeCount__), (e.__views__ = Mi(this.__views__)), e;
				}),
				(jn.prototype.reverse = function () {
					if (this.__filtered__) {
						var e = new jn(this);
						(e.__dir__ = -1), (e.__filtered__ = !0);
					} else (e = this.clone()).__dir__ *= -1;
					return e;
				}),
				(jn.prototype.value = function () {
					var e = this.__wrapped__.value(),
						t = this.__dir__,
						n = Wo(e),
						r = t < 0,
						i = n ? e.length : 0,
						s = (function (e, t, n) {
							var r = -1,
								i = n.length;
							for (; ++r < i; ) {
								var s = n[r],
									o = s.size;
								switch (s.type) {
									case "drop":
										e += o;
										break;
									case "dropRight":
										t -= o;
										break;
									case "take":
										t = bn(t, e + o);
										break;
									case "takeRight":
										e = yn(e, t - o);
								}
							}
							return { start: e, end: t };
						})(0, i, this.__views__),
						o = s.start,
						a = s.end,
						l = a - o,
						u = r ? a : o - 1,
						c = this.__iteratees__,
						h = c.length,
						d = 0,
						p = bn(l, this.__takeCount__);
					if (!n || (!r && i == l && p == l)) return fi(e, this.__actions__);
					var f = [];
					e: for (; l-- && d < p; ) {
						for (var m = -1, v = e[(u += t)]; ++m < h; ) {
							var g = c[m],
								y = g.iteratee,
								b = g.type,
								x = y(v);
							if (2 == b) v = x;
							else if (!x) {
								if (1 == b) continue e;
								break e;
							}
						}
						f[d++] = v;
					}
					return f;
				}),
				(Vn.prototype.at = mo),
				(Vn.prototype.chain = function () {
					return po(this);
				}),
				(Vn.prototype.commit = function () {
					return new $n(this.value(), this.__chain__);
				}),
				(Vn.prototype.next = function () {
					this.__values__ === n && (this.__values__ = pa(this.value()));
					var e = this.__index__ >= this.__values__.length;
					return { done: e, value: e ? n : this.__values__[this.__index__++] };
				}),
				(Vn.prototype.plant = function (e) {
					for (var t, r = this; r instanceof zn; ) {
						var i = Hs(r);
						(i.__index__ = 0), (i.__values__ = n), t ? (s.__wrapped__ = i) : (t = i);
						var s = i;
						r = r.__wrapped__;
					}
					return (s.__wrapped__ = e), t;
				}),
				(Vn.prototype.reverse = function () {
					var e = this.__wrapped__;
					if (e instanceof jn) {
						var t = e;
						return this.__actions__.length && (t = new jn(this)), (t = t.reverse()).__actions__.push({ func: fo, args: [eo], thisArg: n }), new $n(t, this.__chain__);
					}
					return this.thru(eo);
				}),
				(Vn.prototype.toJSON =
					Vn.prototype.valueOf =
					Vn.prototype.value =
						function () {
							return fi(this.__wrapped__, this.__actions__);
						}),
				(Vn.prototype.first = Vn.prototype.head),
				st &&
					(Vn.prototype[st] = function () {
						return this;
					}),
				Vn
			);
		})();
		dt ? (((dt.exports = pn)._ = pn), (ht._ = pn)) : (ct._ = pn);
	}).call(Jo);
})(P5, P5.exports);
var N5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function D5(e, t) {
	return e((t = { exports: {} }), t.exports), t.exports;
}
var B5 = D5(function (e, t) {
		(function () {
			var t;
			(function (t) {
				e.exports = t;
			})(
				(t = {
					linear: function (e, t, n, r) {
						return (n * e) / r + t;
					},
					easeInQuad: function (e, t, n, r) {
						return n * (e /= r) * e + t;
					},
					easeOutQuad: function (e, t, n, r) {
						return -n * (e /= r) * (e - 2) + t;
					},
					easeInOutQuad: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (n / 2) * e * e + t : (-n / 2) * (--e * (e - 2) - 1) + t;
					},
					easeInCubic: function (e, t, n, r) {
						return n * (e /= r) * e * e + t;
					},
					easeOutCubic: function (e, t, n, r) {
						return n * ((e = e / r - 1) * e * e + 1) + t;
					},
					easeInOutCubic: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (n / 2) * e * e * e + t : (n / 2) * ((e -= 2) * e * e + 2) + t;
					},
					easeInQuart: function (e, t, n, r) {
						return n * (e /= r) * e * e * e + t;
					},
					easeOutQuart: function (e, t, n, r) {
						return -n * ((e = e / r - 1) * e * e * e - 1) + t;
					},
					easeInOutQuart: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (n / 2) * e * e * e * e + t : (-n / 2) * ((e -= 2) * e * e * e - 2) + t;
					},
					easeInQuint: function (e, t, n, r) {
						return n * (e /= r) * e * e * e * e + t;
					},
					easeOutQuint: function (e, t, n, r) {
						return n * ((e = e / r - 1) * e * e * e * e + 1) + t;
					},
					easeInOutQuint: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (n / 2) * e * e * e * e * e + t : (n / 2) * ((e -= 2) * e * e * e * e + 2) + t;
					},
					easeInSine: function (e, t, n, r) {
						return -n * Math.cos((e / r) * (Math.PI / 2)) + n + t;
					},
					easeOutSine: function (e, t, n, r) {
						return n * Math.sin((e / r) * (Math.PI / 2)) + t;
					},
					easeInOutSine: function (e, t, n, r) {
						return (-n / 2) * (Math.cos((Math.PI * e) / r) - 1) + t;
					},
					easeInExpo: function (e, t, n, r) {
						return 0 === e ? t : n * Math.pow(2, 10 * (e / r - 1)) + t;
					},
					easeOutExpo: function (e, t, n, r) {
						return e === r ? t + n : n * (1 - Math.pow(2, (-10 * e) / r)) + t;
					},
					easeInOutExpo: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (n / 2) * Math.pow(2, 10 * (e - 1)) + t : (n / 2) * (2 - Math.pow(2, -10 * --e)) + t;
					},
					easeInCirc: function (e, t, n, r) {
						return -n * (Math.sqrt(1 - (e /= r) * e) - 1) + t;
					},
					easeOutCirc: function (e, t, n, r) {
						return n * Math.sqrt(1 - (e = e / r - 1) * e) + t;
					},
					easeInOutCirc: function (e, t, n, r) {
						return (e /= r / 2) < 1 ? (-n / 2) * (Math.sqrt(1 - e * e) - 1) + t : (n / 2) * (Math.sqrt(1 - (e -= 2) * e) + 1) + t;
					},
					easeInElastic: function (e, t, n, r) {
						var i, s, o;
						return (o = 1.70158), 0 === e || (e /= r), (s = 0) || (s = 0.3 * r), (i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)), -i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) + t;
					},
					easeOutElastic: function (e, t, n, r) {
						var i, s, o;
						return (o = 1.70158), 0 === e || (e /= r), (s = 0) || (s = 0.3 * r), (i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)), i * Math.pow(2, -10 * e) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) + n + t;
					},
					easeInOutElastic: function (e, t, n, r) {
						var i, s, o;
						return (
							(o = 1.70158),
							0 === e || (e /= r / 2),
							(s = 0) || (s = r * (0.3 * 1.5)),
							(i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)),
							e < 1 ? i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) * -0.5 + t : i * Math.pow(2, -10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) * 0.5 + n + t
						);
					},
					easeInBack: function (e, t, n, r, i) {
						return void 0 === i && (i = 1.70158), n * (e /= r) * e * ((i + 1) * e - i) + t;
					},
					easeOutBack: function (e, t, n, r, i) {
						return void 0 === i && (i = 1.70158), n * ((e = e / r - 1) * e * ((i + 1) * e + i) + 1) + t;
					},
					easeInOutBack: function (e, t, n, r, i) {
						return void 0 === i && (i = 1.70158), (e /= r / 2) < 1 ? (n / 2) * (e * e * ((1 + (i *= 1.525)) * e - i)) + t : (n / 2) * ((e -= 2) * e * ((1 + (i *= 1.525)) * e + i) + 2) + t;
					},
					easeInBounce: function (e, n, r, i) {
						return r - t.easeOutBounce(i - e, 0, r, i) + n;
					},
					easeOutBounce: function (e, t, n, r) {
						return (e /= r) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375) + t;
					},
					easeInOutBounce: function (e, n, r, i) {
						return e < i / 2 ? 0.5 * t.easeInBounce(2 * e, 0, r, i) + n : 0.5 * t.easeOutBounce(2 * e - i, 0, r, i) + 0.5 * r + n;
					}
				})
			);
		}).call(N5);
	}),
	F5 = D5(function (e) {
		var t = Object.prototype.hasOwnProperty,
			n = "~";
		function r() {}
		function i(e, t, n) {
			(this.fn = e), (this.context = t), (this.once = n || !1);
		}
		function s(e, t, r, s, o) {
			if ("function" != typeof r) throw new TypeError("The listener must be a function");
			var a = new i(r, s || e, o),
				l = n ? n + t : t;
			return e._events[l] ? (e._events[l].fn ? (e._events[l] = [e._events[l], a]) : e._events[l].push(a)) : ((e._events[l] = a), e._eventsCount++), e;
		}
		function o(e, t) {
			0 == --e._eventsCount ? (e._events = new r()) : delete e._events[t];
		}
		function a() {
			(this._events = new r()), (this._eventsCount = 0);
		}
		Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
			(a.prototype.eventNames = function () {
				var e,
					r,
					i = [];
				if (0 === this._eventsCount) return i;
				for (r in (e = this._events)) t.call(e, r) && i.push(n ? r.slice(1) : r);
				return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i;
			}),
			(a.prototype.listeners = function (e) {
				var t = n ? n + e : e,
					r = this._events[t];
				if (!r) return [];
				if (r.fn) return [r.fn];
				for (var i = 0, s = r.length, o = new Array(s); i < s; i++) o[i] = r[i].fn;
				return o;
			}),
			(a.prototype.listenerCount = function (e) {
				var t = n ? n + e : e,
					r = this._events[t];
				return r ? (r.fn ? 1 : r.length) : 0;
			}),
			(a.prototype.emit = function (e, t, r, i, s, o) {
				var a = n ? n + e : e;
				if (!this._events[a]) return !1;
				var l,
					u,
					c = this._events[a],
					h = arguments.length;
				if (c.fn) {
					switch ((c.once && this.removeListener(e, c.fn, void 0, !0), h)) {
						case 1:
							return c.fn.call(c.context), !0;
						case 2:
							return c.fn.call(c.context, t), !0;
						case 3:
							return c.fn.call(c.context, t, r), !0;
						case 4:
							return c.fn.call(c.context, t, r, i), !0;
						case 5:
							return c.fn.call(c.context, t, r, i, s), !0;
						case 6:
							return c.fn.call(c.context, t, r, i, s, o), !0;
					}
					for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
					c.fn.apply(c.context, l);
				} else {
					var d,
						p = c.length;
					for (u = 0; u < p; u++)
						switch ((c[u].once && this.removeListener(e, c[u].fn, void 0, !0), h)) {
							case 1:
								c[u].fn.call(c[u].context);
								break;
							case 2:
								c[u].fn.call(c[u].context, t);
								break;
							case 3:
								c[u].fn.call(c[u].context, t, r);
								break;
							case 4:
								c[u].fn.call(c[u].context, t, r, i);
								break;
							default:
								if (!l) for (d = 1, l = new Array(h - 1); d < h; d++) l[d - 1] = arguments[d];
								c[u].fn.apply(c[u].context, l);
						}
				}
				return !0;
			}),
			(a.prototype.on = function (e, t, n) {
				return s(this, e, t, n, !1);
			}),
			(a.prototype.once = function (e, t, n) {
				return s(this, e, t, n, !0);
			}),
			(a.prototype.removeListener = function (e, t, r, i) {
				var s = n ? n + e : e;
				if (!this._events[s]) return this;
				if (!t) return o(this, s), this;
				var a = this._events[s];
				if (a.fn) a.fn !== t || (i && !a.once) || (r && a.context !== r) || o(this, s);
				else {
					for (var l = 0, u = [], c = a.length; l < c; l++) (a[l].fn !== t || (i && !a[l].once) || (r && a[l].context !== r)) && u.push(a[l]);
					u.length ? (this._events[s] = 1 === u.length ? u[0] : u) : o(this, s);
				}
				return this;
			}),
			(a.prototype.removeAllListeners = function (e) {
				var t;
				return e ? ((t = n ? n + e : e), this._events[t] && o(this, t)) : ((this._events = new r()), (this._eventsCount = 0)), this;
			}),
			(a.prototype.off = a.prototype.removeListener),
			(a.prototype.addListener = a.prototype.on),
			(a.prefixed = n),
			(a.EventEmitter = a),
			(e.exports = a);
	});
class H5 extends F5 {
	constructor(e, t, n) {
		super(), (this.elements = Array.isArray(e) ? e : [e]), (this.eases = []), (this.options = n || {}), (this.time = 0);
		for (let r in t) for (let e of this.elements) this.addParam(e, r, t[r]);
	}
	addParam(e, t, n) {
		let r,
			i,
			s,
			o,
			a = t;
		switch (t) {
			case "scaleX":
			case "skewX":
				(a = t.substr(0, t.length - 1)), (r = e[a].x), (i = n), (s = n - r), (o = (e) => this.updateCoord(e, a, "x"));
				break;
			case "scaleY":
			case "skewY":
				(a = t.substr(0, t.length - 1)), (r = e[a].y), (i = n), (s = n - r), (o = (e) => this.updateCoord(e, a, "y"));
				break;
			case "tint":
			case "blend":
				const l = Array.isArray(n) ? n : [e.tint, n];
				(r = 0), (i = l.length), (s = i), (o = "tint" === t ? (e) => this.updateTint(e, l) : (e) => this.updateBlend(e, l));
				break;
			case "shake":
				(r = { x: e.x, y: e.y }), (i = n), (o = (e) => this.updateShake(e));
				break;
			case "position":
				(r = { x: e.x, y: e.y }), (i = { x: n.x, y: n.y }), (s = { x: i.x - r.x, y: i.y - r.y }), (o = (e) => this.updatePosition(e));
				break;
			case "skew":
			case "scale":
				(r = e[t].x), (i = n), (s = n - r), (o = (e) => this.updatePoint(e, t));
				break;
			case "face":
				(r = e.rotation), (i = H5.shortestAngle(r, Math.atan2(n.y - e.y, n.x - e.x))), (s = i - r), (o = (e) => this.updateOne(e, "rotation"));
				break;
			default:
				(r = e[t]), (i = n), (s = n - r), (o = (e) => this.updateOne(e, t));
		}
		this.eases.push({ element: e, entry: t, update: o, start: r, to: i, delta: s });
	}
	static shortestAngle(e, t) {
		const n = 2 * Math.PI;
		let r = Math.abs(e - t) % n;
		r = r > Math.PI ? n - r : r;
		return (
			r *
			((function (e, t) {
				return ((e % t) + t) % t;
			})(t - e + Math.PI, n) -
				Math.PI >
			0
				? 1
				: -1)
		);
	}
	remove(e, t) {
		if (0 === arguments.length) this.eases = [];
		else {
			t = void 0 !== t && ("string" == typeof t ? [t] : t);
			for (let n = 0; n < this.eases.length; n++) {
				const r = this.eases[n];
				(e && r.element !== e) || (!1 !== t && -1 === t.indexOf(r.entry)) || (this.eases.splice(n, 1), n--);
			}
		}
		if (0 === this.eases.length) return !0;
	}
	updateOne(e, t) {
		e.element[t] = this.options.ease(this.time, e.start, e.delta, this.options.duration);
	}
	updatePoint(e, t) {
		e.element[t].x = e.element[t].y = this.options.ease(this.time, e.start, e.delta, this.options.duration);
	}
	updatePosition(e) {
		(e.element.x = this.options.ease(this.time, e.start.x, e.delta.x, this.options.duration)), (e.element.y = this.options.ease(this.time, e.start.y, e.delta.y, this.options.duration));
	}
	updateCoord(e, t, n) {
		e.element[t][n] = this.options.ease(this.time, e.start, e.delta, this.options.duration);
	}
	updateTint(e, t) {
		let n = Math.floor(this.options.ease(this.time, e.start, e.delta, this.options.duration));
		n === t.length && (n = t.length - 1), (e.element.tint = t[n]);
	}
	updateBlend(e, t) {
		const n = this.options.ease(this.time, e.start, e.delta, this.options.duration);
		let r = Math.floor(n);
		r === t.length && (r = t.length - 1);
		let i = r + 1;
		i === t.length && (i = this.options.reverse ? r - 1 : this.options.repeat ? 0 : r);
		const s = n - r,
			o = t[r],
			a = t[i],
			l = 1 - s,
			u = l * (o >> 16) + s * (a >> 16),
			c = l * ((o >> 8) & 255) + s * ((a >> 8) & 255),
			h = l * (255 & o) + s * (255 & a);
		e.element.tint = (u << 16) | (c << 8) | h;
	}
	updateShake(e) {
		function t(e) {
			return Math.floor(Math.random() * e) - Math.floor(e / 2);
		}
		(e.element.x = e.start.x + t(e.to)), (e.element.y = e.start.y + t(e.to));
	}
	complete(e) {
		"shake" === e.entry && ((e.element.x = e.start.x), (e.element.y = e.start.y));
	}
	reverse(e) {
		if ("position" === e.entry) {
			const t = e.to.x,
				n = e.to.y;
			(e.to.x = e.start.x), (e.to.y = e.start.y), (e.start.x = t), (e.start.y = n), (e.delta.x = -e.delta.x), (e.delta.y = -e.delta.y);
		} else {
			const t = e.to;
			(e.to = e.start), (e.start = t), (e.delta = -e.delta);
		}
	}
	repeat(e) {
		switch (e.entry) {
			case "skewX":
				e.element.skew.x = e.start;
				break;
			case "skewY":
				e.element.skew.y = e.start;
				break;
			case "skew":
				(e.element.skew.x = e.start), (e.element.skew.y = e.start);
				break;
			case "scaleX":
				e.element.scale.x = e.start;
				break;
			case "scaleY":
				e.element.scale.y = e.start;
				break;
			case "scale":
				(e.element.scale.x = e.start), (e.element.scale.y = e.start);
				break;
			case "position":
				(e.element.x = e.start.x), (e.element.y = e.start.y);
				break;
			default:
				e.element[e.entry] = e.start;
		}
	}
	update(e) {
		if (0 === this.eases.length) return !0;
		if (this.options.wait) {
			if (((this.options.wait -= e), this.options.wait >= 0)) return void this.emit("wait", this);
			this.options.wait <= 0 && ((e = -this.options.wait), (this.options.wait = 0), this.emit("wait-end", this));
		}
		this.time += e;
		let t = 0;
		this.time >= this.options.duration && ((t = this.time - this.options.duration), (this.time = this.options.duration));
		for (let n = 0; n < this.eases.length; n++) {
			const e = this.eases[n];
			e.element._destroyed ? (this.eases.splice(n, 1), n--) : e.update(e);
		}
		if ((this.emit("each", this), this.time >= this.options.duration))
			if (this.options.reverse) this.eases.forEach((e) => this.reverse(e)), (this.time = t), t && this.eases.forEach((e) => e.update(e)), this.emit("reverse", this), this.options.repeat ? !0 !== this.options.repeat && this.options.repeat-- : (this.options.reverse = !1);
			else {
				if (!this.options.repeat) return this.eases.forEach((e) => this.complete(e)), this.emit("complete", this), !0;
				this.eases.forEach((e) => this.repeat(e)), (this.time = t), t && this.eases.forEach((e) => e.update(e)), !0 !== this.options.repeat && this.options.repeat--, this.emit("repeat", this);
			}
	}
	get count() {
		return this.eases.length;
	}
}
const V5 = { duration: 1e3, ease: B5.easeInOutSine, useTicker: !0, maxFrame: 1e3 / 60 };
class U5 extends F5 {
	constructor(e) {
		if ((super(), (this.options = Object.assign({}, V5, e)), (this.easings = []), (this.empty = !0), this.options.useTicker)) {
			if (this.options.ticker) this.ticker = this.options.ticker;
			else {
				const e = lb;
				parseInt(/^(\d+)\./.exec("7.2.4")[1]) < 5 ? (this.ticker = e.ticker.shared) : (this.ticker = e.Ticker.shared);
			}
			this.ticker.add(this.update, this);
		}
	}
	destroy() {
		this.removeAll(), this.options.useTicker && this.ticker.remove(this.update, this);
	}
	add(e, t, n) {
		((n = n || {}).duration = void 0 !== n.duration ? n.duration : this.options.duration), (n.ease = n.ease || this.options.ease), "string" == typeof n.ease && (n.ease = B5[n.ease]);
		const r = new H5(e, t, n);
		return this.easings.push(r), (this.empty = !1), r;
	}
	target(e, t, n, r) {
		const i = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) / n;
		return ((r = r || {}).duration = i), this.add(e, { x: t.x, y: t.y }, r);
	}
	face(e, t, n, r) {
		const i = H5.shortestAngle(e.rotation, Math.atan2(t.y - e.y, t.x - e.x)),
			s = Math.abs(i - e.rotation) / n;
		return ((r = r || {}).duration = s), this.add(e, { rotation: i }, r);
	}
	removeEase(e, t) {
		for (let n = 0; n < this.easings.length; n++) this.easings[n].remove(e, t) && (this.easings.splice(n, 1), n--);
		0 === this.easings.length && (this.empty = !0);
	}
	removeAll() {
		(this.easings = []), (this.empty = !0);
	}
	update(e) {
		if ((this.options.useTicker && (e = this.ticker.elapsedMS), (e = Math.min(e, this.options.maxFrame)), !this.empty)) {
			const t = this.easings.slice(0);
			for (let n of t) n.update(e) && this.easings.splice(this.easings.indexOf(n), 1);
			this.emit("each", this), 0 === this.easings.length && ((this.empty = !0), this.emit("complete", this));
		}
	}
	get count() {
		return this.easings.length;
	}
	countRunning() {
		let e = 0;
		for (let t of this.easings) e += t.count;
		return e;
	}
	set duration(e) {
		this.options.duration = e;
	}
	get duration() {
		return this.options.duration;
	}
	set ease(e) {
		this.options.ease = e;
	}
	get ease() {
		return this.options.ease;
	}
}
U5.id = 0;
let z5 = new U5();
U5.ease = z5;
/*!
 * @pixi/math - v6.0.4
 * Compiled Tue, 11 May 2021 18:00:23 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var $5,
	j5,
	W5 = 2 * Math.PI;
((j5 = $5 || ($5 = {}))[(j5.POLY = 0)] = "POLY"),
	(j5[(j5.RECT = 1)] = "RECT"),
	(j5[(j5.CIRC = 2)] = "CIRC"),
	(j5[(j5.ELIP = 3)] = "ELIP"),
	(j5[(j5.RREC = 4)] = "RREC"),
	(function () {
		function e(e, t, n, r) {
			void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), (this.x = Number(e)), (this.y = Number(t)), (this.width = Number(n)), (this.height = Number(r)), (this.type = $5.RECT);
		}
		Object.defineProperty(e.prototype, "left", {
			get: function () {
				return this.x;
			},
			enumerable: !1,
			configurable: !0
		}),
			Object.defineProperty(e.prototype, "right", {
				get: function () {
					return this.x + this.width;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e.prototype, "top", {
				get: function () {
					return this.y;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e.prototype, "bottom", {
				get: function () {
					return this.y + this.height;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e, "EMPTY", {
				get: function () {
					return new e(0, 0, 0, 0);
				},
				enumerable: !1,
				configurable: !0
			}),
			(e.prototype.clone = function () {
				return new e(this.x, this.y, this.width, this.height);
			}),
			(e.prototype.copyFrom = function (e) {
				return (this.x = e.x), (this.y = e.y), (this.width = e.width), (this.height = e.height), this;
			}),
			(e.prototype.copyTo = function (e) {
				return (e.x = this.x), (e.y = this.y), (e.width = this.width), (e.height = this.height), e;
			}),
			(e.prototype.contains = function (e, t) {
				return !(this.width <= 0 || this.height <= 0) && e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
			}),
			(e.prototype.pad = function (e, t) {
				return void 0 === e && (e = 0), void 0 === t && (t = e), (this.x -= e), (this.y -= t), (this.width += 2 * e), (this.height += 2 * t), this;
			}),
			(e.prototype.fit = function (e) {
				var t = Math.max(this.x, e.x),
					n = Math.min(this.x + this.width, e.x + e.width),
					r = Math.max(this.y, e.y),
					i = Math.min(this.y + this.height, e.y + e.height);
				return (this.x = t), (this.width = Math.max(n - t, 0)), (this.y = r), (this.height = Math.max(i - r, 0)), this;
			}),
			(e.prototype.ceil = function (e, t) {
				void 0 === e && (e = 1), void 0 === t && (t = 0.001);
				var n = Math.ceil((this.x + this.width - t) * e) / e,
					r = Math.ceil((this.y + this.height - t) * e) / e;
				return (this.x = Math.floor((this.x + t) * e) / e), (this.y = Math.floor((this.y + t) * e) / e), (this.width = n - this.x), (this.height = r - this.y), this;
			}),
			(e.prototype.enlarge = function (e) {
				var t = Math.min(this.x, e.x),
					n = Math.max(this.x + this.width, e.x + e.width),
					r = Math.min(this.y, e.y),
					i = Math.max(this.y + this.height, e.y + e.height);
				return (this.x = t), (this.width = n - t), (this.y = r), (this.height = i - r), this;
			}),
			(e.prototype.toString = function () {
				return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
			});
	})();
var G5 = (function () {
		function e(e, t) {
			void 0 === e && (e = 0), void 0 === t && (t = 0), (this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
		}
		return (
			(e.prototype.clone = function () {
				return new e(this.x, this.y);
			}),
			(e.prototype.copyFrom = function (e) {
				return this.set(e.x, e.y), this;
			}),
			(e.prototype.copyTo = function (e) {
				return e.set(this.x, this.y), e;
			}),
			(e.prototype.equals = function (e) {
				return e.x === this.x && e.y === this.y;
			}),
			(e.prototype.set = function (e, t) {
				return void 0 === e && (e = 0), void 0 === t && (t = e), (this.x = e), (this.y = t), this;
			}),
			(e.prototype.toString = function () {
				return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
			}),
			e
		);
	})(),
	Y5 = (function () {
		function e(e, t, n, r) {
			void 0 === n && (n = 0), void 0 === r && (r = 0), (this._x = n), (this._y = r), (this.cb = e), (this.scope = t);
		}
		return (
			(e.prototype.clone = function (t, n) {
				return void 0 === t && (t = this.cb), void 0 === n && (n = this.scope), new e(t, n, this._x, this._y);
			}),
			(e.prototype.set = function (e, t) {
				return void 0 === e && (e = 0), void 0 === t && (t = e), (this._x === e && this._y === t) || ((this._x = e), (this._y = t), this.cb.call(this.scope)), this;
			}),
			(e.prototype.copyFrom = function (e) {
				return (this._x === e.x && this._y === e.y) || ((this._x = e.x), (this._y = e.y), this.cb.call(this.scope)), this;
			}),
			(e.prototype.copyTo = function (e) {
				return e.set(this._x, this._y), e;
			}),
			(e.prototype.equals = function (e) {
				return e.x === this._x && e.y === this._y;
			}),
			(e.prototype.toString = function () {
				return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
			}),
			Object.defineProperty(e.prototype, "x", {
				get: function () {
					return this._x;
				},
				set: function (e) {
					this._x !== e && ((this._x = e), this.cb.call(this.scope));
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e.prototype, "y", {
				get: function () {
					return this._y;
				},
				set: function (e) {
					this._y !== e && ((this._y = e), this.cb.call(this.scope));
				},
				enumerable: !1,
				configurable: !0
			}),
			e
		);
	})(),
	X5 = (function () {
		function e(e, t, n, r, i, s) {
			void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === s && (s = 0), (this.array = null), (this.a = e), (this.b = t), (this.c = n), (this.d = r), (this.tx = i), (this.ty = s);
		}
		return (
			(e.prototype.fromArray = function (e) {
				(this.a = e[0]), (this.b = e[1]), (this.c = e[3]), (this.d = e[4]), (this.tx = e[2]), (this.ty = e[5]);
			}),
			(e.prototype.set = function (e, t, n, r, i, s) {
				return (this.a = e), (this.b = t), (this.c = n), (this.d = r), (this.tx = i), (this.ty = s), this;
			}),
			(e.prototype.toArray = function (e, t) {
				this.array || (this.array = new Float32Array(9));
				var n = t || this.array;
				return (
					e
						? ((n[0] = this.a), (n[1] = this.b), (n[2] = 0), (n[3] = this.c), (n[4] = this.d), (n[5] = 0), (n[6] = this.tx), (n[7] = this.ty), (n[8] = 1))
						: ((n[0] = this.a), (n[1] = this.c), (n[2] = this.tx), (n[3] = this.b), (n[4] = this.d), (n[5] = this.ty), (n[6] = 0), (n[7] = 0), (n[8] = 1)),
					n
				);
			}),
			(e.prototype.apply = function (e, t) {
				t = t || new G5();
				var n = e.x,
					r = e.y;
				return (t.x = this.a * n + this.c * r + this.tx), (t.y = this.b * n + this.d * r + this.ty), t;
			}),
			(e.prototype.applyInverse = function (e, t) {
				t = t || new G5();
				var n = 1 / (this.a * this.d + this.c * -this.b),
					r = e.x,
					i = e.y;
				return (t.x = this.d * n * r + -this.c * n * i + (this.ty * this.c - this.tx * this.d) * n), (t.y = this.a * n * i + -this.b * n * r + (-this.ty * this.a + this.tx * this.b) * n), t;
			}),
			(e.prototype.translate = function (e, t) {
				return (this.tx += e), (this.ty += t), this;
			}),
			(e.prototype.scale = function (e, t) {
				return (this.a *= e), (this.d *= t), (this.c *= e), (this.b *= t), (this.tx *= e), (this.ty *= t), this;
			}),
			(e.prototype.rotate = function (e) {
				var t = Math.cos(e),
					n = Math.sin(e),
					r = this.a,
					i = this.c,
					s = this.tx;
				return (this.a = r * t - this.b * n), (this.b = r * n + this.b * t), (this.c = i * t - this.d * n), (this.d = i * n + this.d * t), (this.tx = s * t - this.ty * n), (this.ty = s * n + this.ty * t), this;
			}),
			(e.prototype.append = function (e) {
				var t = this.a,
					n = this.b,
					r = this.c,
					i = this.d;
				return (this.a = e.a * t + e.b * r), (this.b = e.a * n + e.b * i), (this.c = e.c * t + e.d * r), (this.d = e.c * n + e.d * i), (this.tx = e.tx * t + e.ty * r + this.tx), (this.ty = e.tx * n + e.ty * i + this.ty), this;
			}),
			(e.prototype.setTransform = function (e, t, n, r, i, s, o, a, l) {
				return (this.a = Math.cos(o + l) * i), (this.b = Math.sin(o + l) * i), (this.c = -Math.sin(o - a) * s), (this.d = Math.cos(o - a) * s), (this.tx = e - (n * this.a + r * this.c)), (this.ty = t - (n * this.b + r * this.d)), this;
			}),
			(e.prototype.prepend = function (e) {
				var t = this.tx;
				if (1 !== e.a || 0 !== e.b || 0 !== e.c || 1 !== e.d) {
					var n = this.a,
						r = this.c;
					(this.a = n * e.a + this.b * e.c), (this.b = n * e.b + this.b * e.d), (this.c = r * e.a + this.d * e.c), (this.d = r * e.b + this.d * e.d);
				}
				return (this.tx = t * e.a + this.ty * e.c + e.tx), (this.ty = t * e.b + this.ty * e.d + e.ty), this;
			}),
			(e.prototype.decompose = function (e) {
				var t = this.a,
					n = this.b,
					r = this.c,
					i = this.d,
					s = e.pivot,
					o = -Math.atan2(-r, i),
					a = Math.atan2(n, t),
					l = Math.abs(o + a);
				return (
					l < 1e-5 || Math.abs(W5 - l) < 1e-5 ? ((e.rotation = a), (e.skew.x = e.skew.y = 0)) : ((e.rotation = 0), (e.skew.x = o), (e.skew.y = a)),
					(e.scale.x = Math.sqrt(t * t + n * n)),
					(e.scale.y = Math.sqrt(r * r + i * i)),
					(e.position.x = this.tx + (s.x * t + s.y * r)),
					(e.position.y = this.ty + (s.x * n + s.y * i)),
					e
				);
			}),
			(e.prototype.invert = function () {
				var e = this.a,
					t = this.b,
					n = this.c,
					r = this.d,
					i = this.tx,
					s = e * r - t * n;
				return (this.a = r / s), (this.b = -t / s), (this.c = -n / s), (this.d = e / s), (this.tx = (n * this.ty - r * i) / s), (this.ty = -(e * this.ty - t * i) / s), this;
			}),
			(e.prototype.identity = function () {
				return (this.a = 1), (this.b = 0), (this.c = 0), (this.d = 1), (this.tx = 0), (this.ty = 0), this;
			}),
			(e.prototype.clone = function () {
				var t = new e();
				return (t.a = this.a), (t.b = this.b), (t.c = this.c), (t.d = this.d), (t.tx = this.tx), (t.ty = this.ty), t;
			}),
			(e.prototype.copyTo = function (e) {
				return (e.a = this.a), (e.b = this.b), (e.c = this.c), (e.d = this.d), (e.tx = this.tx), (e.ty = this.ty), e;
			}),
			(e.prototype.copyFrom = function (e) {
				return (this.a = e.a), (this.b = e.b), (this.c = e.c), (this.d = e.d), (this.tx = e.tx), (this.ty = e.ty), this;
			}),
			(e.prototype.toString = function () {
				return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
			}),
			Object.defineProperty(e, "IDENTITY", {
				get: function () {
					return new e();
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e, "TEMP_MATRIX", {
				get: function () {
					return new e();
				},
				enumerable: !1,
				configurable: !0
			}),
			e
		);
	})(),
	K5 = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
	q5 = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
	Z5 = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
	J5 = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
	Q5 = Math.sign;
!(function () {
	for (var e = 0; e < 16; e++)
		for (var t = [], n = 0; n < 16; n++)
			for (var r = Q5(K5[e] * K5[n] + Z5[e] * q5[n]), i = Q5(q5[e] * K5[n] + J5[e] * q5[n]), s = Q5(K5[e] * Z5[n] + Z5[e] * J5[n]), o = Q5(q5[e] * Z5[n] + J5[e] * J5[n]), a = 0; a < 16; a++)
				if (K5[a] === r && q5[a] === i && Z5[a] === s && J5[a] === o) {
					t.push(a);
					break;
				}
	for (e = 0; e < 16; e++) {
		new X5().set(K5[e], q5[e], Z5[e], J5[e], 0, 0);
	}
})(),
	(function () {
		function e() {
			(this.worldTransform = new X5()),
				(this.localTransform = new X5()),
				(this.position = new Y5(this.onChange, this, 0, 0)),
				(this.scale = new Y5(this.onChange, this, 1, 1)),
				(this.pivot = new Y5(this.onChange, this, 0, 0)),
				(this.skew = new Y5(this.updateSkew, this, 0, 0)),
				(this._rotation = 0),
				(this._cx = 1),
				(this._sx = 0),
				(this._cy = 0),
				(this._sy = 1),
				(this._localID = 0),
				(this._currentLocalID = 0),
				(this._worldID = 0),
				(this._parentID = 0);
		}
		(e.prototype.onChange = function () {
			this._localID++;
		}),
			(e.prototype.updateSkew = function () {
				(this._cx = Math.cos(this._rotation + this.skew.y)), (this._sx = Math.sin(this._rotation + this.skew.y)), (this._cy = -Math.sin(this._rotation - this.skew.x)), (this._sy = Math.cos(this._rotation - this.skew.x)), this._localID++;
			}),
			(e.prototype.toString = function () {
				return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
			}),
			(e.prototype.updateLocalTransform = function () {
				var e = this.localTransform;
				this._localID !== this._currentLocalID &&
					((e.a = this._cx * this.scale.x),
					(e.b = this._sx * this.scale.x),
					(e.c = this._cy * this.scale.y),
					(e.d = this._sy * this.scale.y),
					(e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
					(e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
					(this._currentLocalID = this._localID),
					(this._parentID = -1));
			}),
			(e.prototype.updateTransform = function (e) {
				var t = this.localTransform;
				if (
					(this._localID !== this._currentLocalID &&
						((t.a = this._cx * this.scale.x),
						(t.b = this._sx * this.scale.x),
						(t.c = this._cy * this.scale.y),
						(t.d = this._sy * this.scale.y),
						(t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
						(t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
						(this._currentLocalID = this._localID),
						(this._parentID = -1)),
					this._parentID !== e._worldID)
				) {
					var n = e.worldTransform,
						r = this.worldTransform;
					(r.a = t.a * n.a + t.b * n.c), (r.b = t.a * n.b + t.b * n.d), (r.c = t.c * n.a + t.d * n.c), (r.d = t.c * n.b + t.d * n.d), (r.tx = t.tx * n.a + t.ty * n.c + n.tx), (r.ty = t.tx * n.b + t.ty * n.d + n.ty), (this._parentID = e._worldID), this._worldID++;
				}
			}),
			(e.prototype.setFromMatrix = function (e) {
				e.decompose(this), this._localID++;
			}),
			Object.defineProperty(e.prototype, "rotation", {
				get: function () {
					return this._rotation;
				},
				set: function (e) {
					this._rotation !== e && ((this._rotation = e), this.updateSkew());
				},
				enumerable: !1,
				configurable: !0
			}),
			(e.IDENTITY = new e());
	})();
/*!
 * @pixi/settings - v6.0.4
 * Compiled Tue, 11 May 2021 18:00:23 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var e4,
	t4,
	n4,
	r4,
	i4,
	s4,
	o4,
	a4,
	l4,
	u4,
	c4,
	h4,
	d4,
	p4,
	f4,
	m4,
	v4,
	g4,
	y4,
	b4,
	x4,
	_4,
	w4,
	C4,
	S4,
	E4,
	T4,
	k4,
	A4,
	M4,
	I4,
	R4,
	L4,
	O4,
	P4,
	N4,
	D4 = ru(self.navigator);
((t4 = e4 || (e4 = {}))[(t4.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
	(t4[(t4.WEBGL = 1)] = "WEBGL"),
	(t4[(t4.WEBGL2 = 2)] = "WEBGL2"),
	((r4 = n4 || (n4 = {}))[(r4.UNKNOWN = 0)] = "UNKNOWN"),
	(r4[(r4.WEBGL = 1)] = "WEBGL"),
	(r4[(r4.CANVAS = 2)] = "CANVAS"),
	((s4 = i4 || (i4 = {}))[(s4.COLOR = 16384)] = "COLOR"),
	(s4[(s4.DEPTH = 256)] = "DEPTH"),
	(s4[(s4.STENCIL = 1024)] = "STENCIL"),
	((a4 = o4 || (o4 = {}))[(a4.NORMAL = 0)] = "NORMAL"),
	(a4[(a4.ADD = 1)] = "ADD"),
	(a4[(a4.MULTIPLY = 2)] = "MULTIPLY"),
	(a4[(a4.SCREEN = 3)] = "SCREEN"),
	(a4[(a4.OVERLAY = 4)] = "OVERLAY"),
	(a4[(a4.DARKEN = 5)] = "DARKEN"),
	(a4[(a4.LIGHTEN = 6)] = "LIGHTEN"),
	(a4[(a4.COLOR_DODGE = 7)] = "COLOR_DODGE"),
	(a4[(a4.COLOR_BURN = 8)] = "COLOR_BURN"),
	(a4[(a4.HARD_LIGHT = 9)] = "HARD_LIGHT"),
	(a4[(a4.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
	(a4[(a4.DIFFERENCE = 11)] = "DIFFERENCE"),
	(a4[(a4.EXCLUSION = 12)] = "EXCLUSION"),
	(a4[(a4.HUE = 13)] = "HUE"),
	(a4[(a4.SATURATION = 14)] = "SATURATION"),
	(a4[(a4.COLOR = 15)] = "COLOR"),
	(a4[(a4.LUMINOSITY = 16)] = "LUMINOSITY"),
	(a4[(a4.NORMAL_NPM = 17)] = "NORMAL_NPM"),
	(a4[(a4.ADD_NPM = 18)] = "ADD_NPM"),
	(a4[(a4.SCREEN_NPM = 19)] = "SCREEN_NPM"),
	(a4[(a4.NONE = 20)] = "NONE"),
	(a4[(a4.SRC_OVER = 0)] = "SRC_OVER"),
	(a4[(a4.SRC_IN = 21)] = "SRC_IN"),
	(a4[(a4.SRC_OUT = 22)] = "SRC_OUT"),
	(a4[(a4.SRC_ATOP = 23)] = "SRC_ATOP"),
	(a4[(a4.DST_OVER = 24)] = "DST_OVER"),
	(a4[(a4.DST_IN = 25)] = "DST_IN"),
	(a4[(a4.DST_OUT = 26)] = "DST_OUT"),
	(a4[(a4.DST_ATOP = 27)] = "DST_ATOP"),
	(a4[(a4.ERASE = 26)] = "ERASE"),
	(a4[(a4.SUBTRACT = 28)] = "SUBTRACT"),
	(a4[(a4.XOR = 29)] = "XOR"),
	((u4 = l4 || (l4 = {}))[(u4.POINTS = 0)] = "POINTS"),
	(u4[(u4.LINES = 1)] = "LINES"),
	(u4[(u4.LINE_LOOP = 2)] = "LINE_LOOP"),
	(u4[(u4.LINE_STRIP = 3)] = "LINE_STRIP"),
	(u4[(u4.TRIANGLES = 4)] = "TRIANGLES"),
	(u4[(u4.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
	(u4[(u4.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN"),
	((h4 = c4 || (c4 = {}))[(h4.RGBA = 6408)] = "RGBA"),
	(h4[(h4.RGB = 6407)] = "RGB"),
	(h4[(h4.ALPHA = 6406)] = "ALPHA"),
	(h4[(h4.LUMINANCE = 6409)] = "LUMINANCE"),
	(h4[(h4.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
	(h4[(h4.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
	(h4[(h4.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
	((p4 = d4 || (d4 = {}))[(p4.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
	(p4[(p4.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
	(p4[(p4.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
	(p4[(p4.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] = "TEXTURE_CUBE_MAP_POSITIVE_X"),
	(p4[(p4.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] = "TEXTURE_CUBE_MAP_NEGATIVE_X"),
	(p4[(p4.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] = "TEXTURE_CUBE_MAP_POSITIVE_Y"),
	(p4[(p4.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] = "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
	(p4[(p4.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] = "TEXTURE_CUBE_MAP_POSITIVE_Z"),
	(p4[(p4.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
	((m4 = f4 || (f4 = {}))[(m4.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
	(m4[(m4.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
	(m4[(m4.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
	(m4[(m4.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
	(m4[(m4.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
	(m4[(m4.FLOAT = 5126)] = "FLOAT"),
	(m4[(m4.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
	((g4 = v4 || (v4 = {}))[(g4.FLOAT = 0)] = "FLOAT"),
	(g4[(g4.INT = 1)] = "INT"),
	(g4[(g4.UINT = 2)] = "UINT"),
	((b4 = y4 || (y4 = {}))[(b4.NEAREST = 0)] = "NEAREST"),
	(b4[(b4.LINEAR = 1)] = "LINEAR"),
	((_4 = x4 || (x4 = {}))[(_4.CLAMP = 33071)] = "CLAMP"),
	(_4[(_4.REPEAT = 10497)] = "REPEAT"),
	(_4[(_4.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT"),
	((C4 = w4 || (w4 = {}))[(C4.OFF = 0)] = "OFF"),
	(C4[(C4.POW2 = 1)] = "POW2"),
	(C4[(C4.ON = 2)] = "ON"),
	(C4[(C4.ON_MANUAL = 3)] = "ON_MANUAL"),
	((E4 = S4 || (S4 = {}))[(E4.NPM = 0)] = "NPM"),
	(E4[(E4.UNPACK = 1)] = "UNPACK"),
	(E4[(E4.PMA = 2)] = "PMA"),
	(E4[(E4.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
	(E4[(E4.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
	(E4[(E4.PREMULTIPLY_ALPHA = 2)] = "PREMULTIPLY_ALPHA"),
	((k4 = T4 || (T4 = {}))[(k4.NO = 0)] = "NO"),
	(k4[(k4.YES = 1)] = "YES"),
	(k4[(k4.AUTO = 2)] = "AUTO"),
	(k4[(k4.BLEND = 0)] = "BLEND"),
	(k4[(k4.CLEAR = 1)] = "CLEAR"),
	(k4[(k4.BLIT = 2)] = "BLIT"),
	((M4 = A4 || (A4 = {}))[(M4.AUTO = 0)] = "AUTO"),
	(M4[(M4.MANUAL = 1)] = "MANUAL"),
	((R4 = I4 || (I4 = {})).LOW = "lowp"),
	(R4.MEDIUM = "mediump"),
	(R4.HIGH = "highp"),
	((O4 = L4 || (L4 = {}))[(O4.NONE = 0)] = "NONE"),
	(O4[(O4.SCISSOR = 1)] = "SCISSOR"),
	(O4[(O4.STENCIL = 2)] = "STENCIL"),
	(O4[(O4.SPRITE = 3)] = "SPRITE"),
	((N4 = P4 || (P4 = {}))[(N4.NONE = 0)] = "NONE"),
	(N4[(N4.LOW = 2)] = "LOW"),
	(N4[(N4.MEDIUM = 4)] = "MEDIUM"),
	(N4[(N4.HIGH = 8)] = "HIGH");
var B4,
	F4,
	H4 = {
		MIPMAP_TEXTURES: w4.POW2,
		ANISOTROPIC_LEVEL: 0,
		RESOLUTION: 1,
		FILTER_RESOLUTION: 1,
		SPRITE_MAX_TEXTURES: (function (e) {
			var t = !0;
			if (D4.tablet || D4.phone) {
				var n;
				if (D4.apple.device) if ((n = navigator.userAgent.match(/OS (\d+)_(\d+)?/))) parseInt(n[1], 10) < 11 && (t = !1);
				if (D4.android.device) if ((n = navigator.userAgent.match(/Android\s([0-9.]*)/))) parseInt(n[1], 10) < 7 && (t = !1);
			}
			return t ? e : 4;
		})(32),
		SPRITE_BATCH_SIZE: 4096,
		RENDER_OPTIONS: { view: null, antialias: !1, autoDensity: !1, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: !0, clearBeforeRender: !0, preserveDrawingBuffer: !1, width: 800, height: 600, legacy: !1 },
		GC_MODE: A4.AUTO,
		GC_MAX_IDLE: 3600,
		GC_MAX_CHECK_COUNT: 600,
		WRAP_MODE: x4.CLAMP,
		SCALE_MODE: y4.LINEAR,
		PRECISION_VERTEX: I4.HIGH,
		PRECISION_FRAGMENT: D4.apple.device ? I4.HIGH : I4.MEDIUM,
		CAN_UPLOAD_SAME_BUFFER: !D4.apple.device,
		CREATE_IMAGE_BITMAP: !1,
		ROUND_PIXELS: !1
	};
/*!
 * @pixi/ticker - v6.0.4
 * Compiled Tue, 11 May 2021 18:00:23 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */ (H4.TARGET_FPMS = 0.06), ((F4 = B4 || (B4 = {}))[(F4.INTERACTION = 50)] = "INTERACTION"), (F4[(F4.HIGH = 25)] = "HIGH"), (F4[(F4.NORMAL = 0)] = "NORMAL"), (F4[(F4.LOW = -25)] = "LOW"), (F4[(F4.UTILITY = -50)] = "UTILITY");
var V4 = (function () {
		function e(e, t, n, r) {
			void 0 === t && (t = null), void 0 === n && (n = 0), void 0 === r && (r = !1), (this.next = null), (this.previous = null), (this._destroyed = !1), (this.fn = e), (this.context = t), (this.priority = n), (this.once = r);
		}
		return (
			(e.prototype.match = function (e, t) {
				return void 0 === t && (t = null), this.fn === e && this.context === t;
			}),
			(e.prototype.emit = function (e) {
				this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
				var t = this.next;
				return this.once && this.destroy(!0), this._destroyed && (this.next = null), t;
			}),
			(e.prototype.connect = function (e) {
				(this.previous = e), e.next && (e.next.previous = this), (this.next = e.next), (e.next = this);
			}),
			(e.prototype.destroy = function (e) {
				void 0 === e && (e = !1), (this._destroyed = !0), (this.fn = null), (this.context = null), this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
				var t = this.next;
				return (this.next = e ? null : t), (this.previous = null), t;
			}),
			e
		);
	})(),
	U4 = (function () {
		function e() {
			var e = this;
			(this.autoStart = !1),
				(this.deltaTime = 1),
				(this.lastTime = -1),
				(this.speed = 1),
				(this.started = !1),
				(this._requestId = null),
				(this._maxElapsedMS = 100),
				(this._minElapsedMS = 0),
				(this._protected = !1),
				(this._lastFrame = -1),
				(this._head = new V4(null, null, 1 / 0)),
				(this.deltaMS = 1 / H4.TARGET_FPMS),
				(this.elapsedMS = 1 / H4.TARGET_FPMS),
				(this._tick = function (t) {
					(e._requestId = null), e.started && (e.update(t), e.started && null === e._requestId && e._head.next && (e._requestId = requestAnimationFrame(e._tick)));
				});
		}
		return (
			(e.prototype._requestIfNeeded = function () {
				null === this._requestId && this._head.next && ((this.lastTime = performance.now()), (this._lastFrame = this.lastTime), (this._requestId = requestAnimationFrame(this._tick)));
			}),
			(e.prototype._cancelIfNeeded = function () {
				null !== this._requestId && (cancelAnimationFrame(this._requestId), (this._requestId = null));
			}),
			(e.prototype._startIfPossible = function () {
				this.started ? this._requestIfNeeded() : this.autoStart && this.start();
			}),
			(e.prototype.add = function (e, t, n) {
				return void 0 === n && (n = B4.NORMAL), this._addListener(new V4(e, t, n));
			}),
			(e.prototype.addOnce = function (e, t, n) {
				return void 0 === n && (n = B4.NORMAL), this._addListener(new V4(e, t, n, !0));
			}),
			(e.prototype._addListener = function (e) {
				var t = this._head.next,
					n = this._head;
				if (t) {
					for (; t; ) {
						if (e.priority > t.priority) {
							e.connect(n);
							break;
						}
						(n = t), (t = t.next);
					}
					e.previous || e.connect(n);
				} else e.connect(n);
				return this._startIfPossible(), this;
			}),
			(e.prototype.remove = function (e, t) {
				for (var n = this._head.next; n; ) n = n.match(e, t) ? n.destroy() : n.next;
				return this._head.next || this._cancelIfNeeded(), this;
			}),
			Object.defineProperty(e.prototype, "count", {
				get: function () {
					if (!this._head) return 0;
					for (var e = 0, t = this._head; (t = t.next); ) e++;
					return e;
				},
				enumerable: !1,
				configurable: !0
			}),
			(e.prototype.start = function () {
				this.started || ((this.started = !0), this._requestIfNeeded());
			}),
			(e.prototype.stop = function () {
				this.started && ((this.started = !1), this._cancelIfNeeded());
			}),
			(e.prototype.destroy = function () {
				if (!this._protected) {
					this.stop();
					for (var e = this._head.next; e; ) e = e.destroy(!0);
					this._head.destroy(), (this._head = null);
				}
			}),
			(e.prototype.update = function (e) {
				var t;
				if ((void 0 === e && (e = performance.now()), e > this.lastTime)) {
					if (((t = this.elapsedMS = e - this.lastTime) > this._maxElapsedMS && (t = this._maxElapsedMS), (t *= this.speed), this._minElapsedMS)) {
						var n = (e - this._lastFrame) | 0;
						if (n < this._minElapsedMS) return;
						this._lastFrame = e - (n % this._minElapsedMS);
					}
					(this.deltaMS = t), (this.deltaTime = this.deltaMS * H4.TARGET_FPMS);
					for (var r = this._head, i = r.next; i; ) i = i.emit(this.deltaTime);
					r.next || this._cancelIfNeeded();
				} else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
				this.lastTime = e;
			}),
			Object.defineProperty(e.prototype, "FPS", {
				get: function () {
					return 1e3 / this.elapsedMS;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e.prototype, "minFPS", {
				get: function () {
					return 1e3 / this._maxElapsedMS;
				},
				set: function (e) {
					var t = Math.min(this.maxFPS, e),
						n = Math.min(Math.max(0, t) / 1e3, H4.TARGET_FPMS);
					this._maxElapsedMS = 1 / n;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e.prototype, "maxFPS", {
				get: function () {
					return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
				},
				set: function (e) {
					if (0 === e) this._minElapsedMS = 0;
					else {
						var t = Math.max(this.minFPS, e);
						this._minElapsedMS = 1 / (t / 1e3);
					}
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e, "shared", {
				get: function () {
					if (!e._shared) {
						var t = (e._shared = new e());
						(t.autoStart = !0), (t._protected = !0);
					}
					return e._shared;
				},
				enumerable: !1,
				configurable: !0
			}),
			Object.defineProperty(e, "system", {
				get: function () {
					if (!e._system) {
						var t = (e._system = new e());
						(t.autoStart = !0), (t._protected = !0);
					}
					return e._system;
				},
				enumerable: !1,
				configurable: !0
			}),
			e
		);
	})();
/*!
 * @pixi/particle-emitter - v5.0.8
 * Compiled Mon, 28 Nov 2022 04:01:38 UTC
 *
 * @pixi/particle-emitter is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
class z4 {
	constructor(e, t, n) {
		(this.value = e), (this.time = t), (this.next = null), (this.isStepped = !1), (this.ease = n ? ("function" == typeof n ? n : q4(n)) : null);
	}
	static createList(e) {
		if ("list" in e) {
			const t = e.list;
			let n;
			const { value: r, time: i } = t[0],
				s = (n = new z4("string" == typeof r ? K4(r) : r, i, e.ease));
			if (t.length > 2 || (2 === t.length && t[1].value !== r))
				for (let e = 1; e < t.length; ++e) {
					const { value: r, time: i } = t[e];
					(n.next = new z4("string" == typeof r ? K4(r) : r, i)), (n = n.next);
				}
			return (s.isStepped = !!e.isStepped), s;
		}
		const t = new z4("string" == typeof e.start ? K4(e.start) : e.start, 0);
		return e.end !== e.start && (t.next = new z4("string" == typeof e.end ? K4(e.end) : e.end, 1)), t;
	}
}
let $4 = lp.from;
const j4 = Math.PI / 180;
function W4(e, t) {
	if (!e) return;
	const n = Math.sin(e),
		r = Math.cos(e),
		i = t.x * r - t.y * n,
		s = t.x * n + t.y * r;
	(t.x = i), (t.y = s);
}
function G4(e, t, n) {
	return (e << 16) | (t << 8) | n;
}
function Y4(e) {
	return Math.sqrt(e.x * e.x + e.y * e.y);
}
function X4(e, t) {
	(e.x *= t), (e.y *= t);
}
function K4(e, t) {
	let n;
	return (
		t || (t = {}),
		"#" === e.charAt(0) ? (e = e.substr(1)) : 0 === e.indexOf("0x") && (e = e.substr(2)),
		8 === e.length && ((n = e.substr(0, 2)), (e = e.substr(2))),
		(t.r = parseInt(e.substr(0, 2), 16)),
		(t.g = parseInt(e.substr(2, 2), 16)),
		(t.b = parseInt(e.substr(4, 2), 16)),
		n && (t.a = parseInt(n, 16)),
		t
	);
}
function q4(e) {
	const t = e.length,
		n = 1 / t;
	return function (r) {
		const i = (t * r) | 0,
			s = (r - i * n) * t,
			o = e[i] || e[t - 1];
		return o.s + s * (2 * (1 - s) * (o.cp - o.s) + s * (o.e - o.s));
	};
}
class Z4 extends tm {
	constructor(e) {
		super(),
			(this.prevChild = this.nextChild = null),
			(this.emitter = e),
			(this.config = {}),
			(this.anchor.x = this.anchor.y = 0.5),
			(this.maxLife = 0),
			(this.age = 0),
			(this.agePercent = 0),
			(this.oneOverLife = 0),
			(this.next = null),
			(this.prev = null),
			(this.init = this.init),
			(this.kill = this.kill);
	}
	init(e) {
		(this.maxLife = e), (this.age = this.agePercent = 0), (this.rotation = 0), (this.position.x = this.position.y = 0), (this.scale.x = this.scale.y = 1), (this.tint = 16777215), (this.alpha = 1), (this.oneOverLife = 1 / this.maxLife), (this.visible = !0);
	}
	kill() {
		this.emitter.recycle(this);
	}
	destroy() {
		this.parent && this.parent.removeChild(this), (this.emitter = this.next = this.prev = null), super.destroy();
	}
}
var J4, Q4;
((Q4 = J4 || (J4 = {}))[(Q4.Spawn = 0)] = "Spawn"), (Q4[(Q4.Normal = 2)] = "Normal"), (Q4[(Q4.Late = 5)] = "Late");
const e6 = U4.shared,
	t6 = Symbol("Position particle per emitter position");
class n6 {
	constructor(e, t) {
		(this.initBehaviors = []),
			(this.updateBehaviors = []),
			(this.recycleBehaviors = []),
			(this.minLifetime = 0),
			(this.maxLifetime = 0),
			(this.customEase = null),
			(this._frequency = 1),
			(this.spawnChance = 1),
			(this.maxParticles = 1e3),
			(this.emitterLifetime = -1),
			(this.spawnPos = new G5()),
			(this.particlesPerWave = 1),
			(this.rotation = 0),
			(this.ownerPos = new G5()),
			(this._prevEmitterPos = new G5()),
			(this._prevPosIsValid = !1),
			(this._posChanged = !1),
			(this._parent = null),
			(this.addAtBack = !1),
			(this.particleCount = 0),
			(this._emit = !1),
			(this._spawnTimer = 0),
			(this._emitterLife = -1),
			(this._activeParticlesFirst = null),
			(this._activeParticlesLast = null),
			(this._poolFirst = null),
			(this._origConfig = null),
			(this._autoUpdate = !1),
			(this._destroyWhenComplete = !1),
			(this._completeCallback = null),
			(this.parent = e),
			t && this.init(t),
			(this.recycle = this.recycle),
			(this.update = this.update),
			(this.rotate = this.rotate),
			(this.updateSpawnPos = this.updateSpawnPos),
			(this.updateOwnerPos = this.updateOwnerPos);
	}
	static registerBehavior(e) {
		n6.knownBehaviors[e.type] = e;
	}
	get frequency() {
		return this._frequency;
	}
	set frequency(e) {
		this._frequency = "number" == typeof e && e > 0 ? e : 1;
	}
	get parent() {
		return this._parent;
	}
	set parent(e) {
		this.cleanup(), (this._parent = e);
	}
	init(e) {
		if (!e) return;
		this.cleanup(),
			(this._origConfig = e),
			(this.minLifetime = e.lifetime.min),
			(this.maxLifetime = e.lifetime.max),
			e.ease ? (this.customEase = "function" == typeof e.ease ? e.ease : q4(e.ease)) : (this.customEase = null),
			(this.particlesPerWave = 1),
			e.particlesPerWave && e.particlesPerWave > 1 && (this.particlesPerWave = e.particlesPerWave),
			(this.frequency = e.frequency),
			(this.spawnChance = "number" == typeof e.spawnChance && e.spawnChance > 0 ? e.spawnChance : 1),
			(this.emitterLifetime = e.emitterLifetime || -1),
			(this.maxParticles = e.maxParticles > 0 ? e.maxParticles : 1e3),
			(this.addAtBack = !!e.addAtBack),
			(this.rotation = 0),
			this.ownerPos.set(0),
			e.pos ? this.spawnPos.copyFrom(e.pos) : this.spawnPos.set(0),
			this._prevEmitterPos.copyFrom(this.spawnPos),
			(this._prevPosIsValid = !1),
			(this._spawnTimer = 0),
			(this.emit = void 0 === e.emit || !!e.emit),
			(this.autoUpdate = !!e.autoUpdate);
		const t = e.behaviors
			.map((e) => {
				const t = n6.knownBehaviors[e.type];
				return t ? new t(e.config) : (console.error(`Unknown behavior: ${e.type}`), null);
			})
			.filter((e) => !!e);
		t.push(t6),
			t.sort((e, t) => (e === t6 ? (t.order === J4.Spawn ? 1 : -1) : t === t6 ? (e.order === J4.Spawn ? -1 : 1) : e.order - t.order)),
			(this.initBehaviors = t.slice()),
			(this.updateBehaviors = t.filter((e) => e !== t6 && e.updateParticle)),
			(this.recycleBehaviors = t.filter((e) => e !== t6 && e.recycleParticle));
	}
	getBehavior(e) {
		return (n6.knownBehaviors[e] && this.initBehaviors.find((t) => t instanceof n6.knownBehaviors[e])) || null;
	}
	fillPool(e) {
		for (; e > 0; --e) {
			const e = new Z4(this);
			(e.next = this._poolFirst), (this._poolFirst = e);
		}
	}
	recycle(e, t = !1) {
		for (let n = 0; n < this.recycleBehaviors.length; ++n) this.recycleBehaviors[n].recycleParticle(e, !t);
		e.next && (e.next.prev = e.prev),
			e.prev && (e.prev.next = e.next),
			e === this._activeParticlesLast && (this._activeParticlesLast = e.prev),
			e === this._activeParticlesFirst && (this._activeParticlesFirst = e.next),
			(e.prev = null),
			(e.next = this._poolFirst),
			(this._poolFirst = e),
			e.parent && e.parent.removeChild(e),
			--this.particleCount;
	}
	rotate(e) {
		if (this.rotation === e) return;
		const t = e - this.rotation;
		(this.rotation = e), W4(t, this.spawnPos), (this._posChanged = !0);
	}
	updateSpawnPos(e, t) {
		(this._posChanged = !0), (this.spawnPos.x = e), (this.spawnPos.y = t);
	}
	updateOwnerPos(e, t) {
		(this._posChanged = !0), (this.ownerPos.x = e), (this.ownerPos.y = t);
	}
	resetPositionTracking() {
		this._prevPosIsValid = !1;
	}
	get emit() {
		return this._emit;
	}
	set emit(e) {
		(this._emit = !!e), (this._emitterLife = this.emitterLifetime);
	}
	get autoUpdate() {
		return this._autoUpdate;
	}
	set autoUpdate(e) {
		this._autoUpdate && !e ? e6.remove(this.update, this) : !this._autoUpdate && e && e6.add(this.update, this), (this._autoUpdate = !!e);
	}
	playOnceAndDestroy(e) {
		(this.autoUpdate = !0), (this.emit = !0), (this._destroyWhenComplete = !0), (this._completeCallback = e);
	}
	playOnce(e) {
		(this.emit = !0), (this._completeCallback = e);
	}
	update(e) {
		if ((this._autoUpdate && (e = 0.001 * e6.elapsedMS), !this._parent)) return;
		for (let s, o = this._activeParticlesFirst; o; o = s)
			if (((s = o.next), (o.age += e), o.age > o.maxLife || o.age < 0)) this.recycle(o);
			else {
				let t = o.age * o.oneOverLife;
				this.customEase && (t = 4 === this.customEase.length ? this.customEase(t, 0, 1, 1) : this.customEase(t)), (o.agePercent = t);
				for (let n = 0; n < this.updateBehaviors.length; ++n)
					if (this.updateBehaviors[n].updateParticle(o, e)) {
						this.recycle(o);
						break;
					}
			}
		let t, n;
		this._prevPosIsValid && ((t = this._prevEmitterPos.x), (n = this._prevEmitterPos.y));
		const r = this.ownerPos.x + this.spawnPos.x,
			i = this.ownerPos.y + this.spawnPos.y;
		if (this._emit)
			for (this._spawnTimer -= e < 0 ? 0 : e; this._spawnTimer <= 0; ) {
				if (this._emitterLife >= 0 && ((this._emitterLife -= this._frequency), this._emitterLife <= 0)) {
					(this._spawnTimer = 0), (this._emitterLife = 0), (this.emit = !1);
					break;
				}
				if (this.particleCount >= this.maxParticles) {
					this._spawnTimer += this._frequency;
					continue;
				}
				let s, o;
				if (this._prevPosIsValid && this._posChanged) {
					const a = 1 + this._spawnTimer / e;
					(s = (r - t) * a + t), (o = (i - n) * a + n);
				} else (s = r), (o = i);
				let a = null,
					l = null;
				for (let e = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), t = 0; t < e; ++t) {
					if (this.spawnChance < 1 && Math.random() >= this.spawnChance) continue;
					let e, t;
					((e = this.minLifetime === this.maxLifetime ? this.minLifetime : Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime), -this._spawnTimer >= e) ||
						(this._poolFirst ? ((t = this._poolFirst), (this._poolFirst = this._poolFirst.next), (t.next = null)) : (t = new Z4(this)),
						t.init(e),
						this.addAtBack ? this._parent.addChildAt(t, 0) : this._parent.addChild(t),
						a ? ((l.next = t), (t.prev = l), (l = t)) : (l = a = t),
						++this.particleCount);
				}
				if (a) {
					this._activeParticlesLast ? ((this._activeParticlesLast.next = a), (a.prev = this._activeParticlesLast), (this._activeParticlesLast = l)) : ((this._activeParticlesFirst = a), (this._activeParticlesLast = l));
					for (let e = 0; e < this.initBehaviors.length; ++e) {
						const t = this.initBehaviors[e];
						if (t === t6)
							for (let e, n = a; n; n = e) {
								(e = n.next), 0 !== this.rotation && (W4(this.rotation, n.position), (n.rotation += this.rotation)), (n.position.x += s), (n.position.y += o), (n.age += -this._spawnTimer);
								let t = n.age * n.oneOverLife;
								this.customEase && (t = 4 === this.customEase.length ? this.customEase(t, 0, 1, 1) : this.customEase(t)), (n.agePercent = t);
							}
						else t.initParticles(a);
					}
					for (let e, t = a; t; t = e) {
						e = t.next;
						for (let e = 0; e < this.updateBehaviors.length; ++e)
							if (this.updateBehaviors[e].updateParticle(t, -this._spawnTimer)) {
								this.recycle(t);
								break;
							}
					}
				}
				this._spawnTimer += this._frequency;
			}
		if ((this._posChanged && ((this._prevEmitterPos.x = r), (this._prevEmitterPos.y = i), (this._prevPosIsValid = !0), (this._posChanged = !1)), !this._emit && !this._activeParticlesFirst)) {
			if (this._completeCallback) {
				const e = this._completeCallback;
				(this._completeCallback = null), e();
			}
			this._destroyWhenComplete && this.destroy();
		}
	}
	emitNow() {
		const e = this.ownerPos.x + this.spawnPos.x,
			t = this.ownerPos.y + this.spawnPos.y;
		let n = null,
			r = null;
		for (let i = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), s = 0; s < i; ++s) {
			if (this.spawnChance < 1 && Math.random() >= this.spawnChance) continue;
			let e, t;
			this._poolFirst ? ((e = this._poolFirst), (this._poolFirst = this._poolFirst.next), (e.next = null)) : (e = new Z4(this)),
				(t = this.minLifetime === this.maxLifetime ? this.minLifetime : Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime),
				e.init(t),
				this.addAtBack ? this._parent.addChildAt(e, 0) : this._parent.addChild(e),
				n ? ((r.next = e), (e.prev = r), (r = e)) : (r = n = e),
				++this.particleCount;
		}
		if (n) {
			this._activeParticlesLast ? ((this._activeParticlesLast.next = n), (n.prev = this._activeParticlesLast), (this._activeParticlesLast = r)) : ((this._activeParticlesFirst = n), (this._activeParticlesLast = r));
			for (let r = 0; r < this.initBehaviors.length; ++r) {
				const i = this.initBehaviors[r];
				if (i === t6) for (let r, s = n; s; s = r) (r = s.next), 0 !== this.rotation && (W4(this.rotation, s.position), (s.rotation += this.rotation)), (s.position.x += e), (s.position.y += t);
				else i.initParticles(n);
			}
		}
	}
	cleanup() {
		let e, t;
		for (e = this._activeParticlesFirst; e; e = t) (t = e.next), this.recycle(e, !0);
		(this._activeParticlesFirst = this._activeParticlesLast = null), (this.particleCount = 0);
	}
	get destroyed() {
		return !(this._parent && this.initBehaviors.length);
	}
	destroy() {
		let e;
		(this.autoUpdate = !1), this.cleanup();
		for (let t = this._poolFirst; t; t = e) (e = t.next), t.destroy();
		(this._poolFirst = this._parent = this.spawnPos = this.ownerPos = this.customEase = this._completeCallback = null), (this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0);
	}
}
n6.knownBehaviors = {};
class r6 {
	constructor(e) {
		(this.x = e.x), (this.y = e.y), (this.w = e.w), (this.h = e.h);
	}
	getRandPos(e) {
		(e.x = Math.random() * this.w + this.x), (e.y = Math.random() * this.h + this.y);
	}
}
(r6.type = "rect"), (r6.editorConfig = null);
class i6 {
	constructor(e) {
		(this.x = e.x || 0), (this.y = e.y || 0), (this.radius = e.radius), (this.innerRadius = e.innerRadius || 0), (this.rotation = !!e.affectRotation);
	}
	getRandPos(e) {
		this.innerRadius !== this.radius ? (e.x = Math.random() * (this.radius - this.innerRadius) + this.innerRadius) : (e.x = this.radius), (e.y = 0);
		const t = Math.random() * Math.PI * 2;
		this.rotation && (e.rotation += t), W4(t, e.position), (e.position.x += this.x), (e.position.y += this.y);
	}
}
(i6.type = "torus"), (i6.editorConfig = null);
class s6 {
	constructor(e) {
		(this.segments = []), (this.countingLengths = []), (this.totalLength = 0), this.init(e);
	}
	init(e) {
		if (e && e.length)
			if (Array.isArray(e[0]))
				for (let t = 0; t < e.length; ++t) {
					const n = e[t];
					let r = n[0];
					for (let e = 1; e < n.length; ++e) {
						const t = n[e];
						this.segments.push({ p1: r, p2: t, l: 0 }), (r = t);
					}
				}
			else {
				let t = e[0];
				for (let n = 1; n < e.length; ++n) {
					const r = e[n];
					this.segments.push({ p1: t, p2: r, l: 0 }), (t = r);
				}
			}
		else this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });
		for (let t = 0; t < this.segments.length; ++t) {
			const { p1: e, p2: n } = this.segments[t],
				r = Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y));
			(this.segments[t].l = r), (this.totalLength += r), this.countingLengths.push(this.totalLength);
		}
	}
	getRandPos(e) {
		const t = Math.random() * this.totalLength;
		let n, r;
		if (1 === this.segments.length) (n = this.segments[0]), (r = t);
		else
			for (let o = 0; o < this.countingLengths.length; ++o)
				if (t < this.countingLengths[o]) {
					(n = this.segments[o]), (r = 0 === o ? t : t - this.countingLengths[o - 1]);
					break;
				}
		r /= n.l || 1;
		const { p1: i, p2: s } = n;
		(e.x = i.x + r * (s.x - i.x)), (e.y = i.y + r * (s.y - i.y));
	}
}
(s6.type = "polygonalChain"), (s6.editorConfig = null);
class o6 {
	constructor(e) {
		var t;
		(this.order = J4.Late), (this.minStart = e.minStart), (this.maxStart = e.maxStart), (this.accel = e.accel), (this.rotate = !!e.rotate), (this.maxSpeed = null !== (t = e.maxSpeed) && void 0 !== t ? t : 0);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.random() * (this.maxStart - this.minStart) + this.minStart;
			t.config.velocity ? t.config.velocity.set(e, 0) : (t.config.velocity = new G5(e, 0)), W4(t.rotation, t.config.velocity), (t = t.next);
		}
	}
	updateParticle(e, t) {
		const n = e.config.velocity,
			r = n.x,
			i = n.y;
		if (((n.x += this.accel.x * t), (n.y += this.accel.y * t), this.maxSpeed)) {
			const e = Y4(n);
			e > this.maxSpeed && X4(n, this.maxSpeed / e);
		}
		(e.x += ((r + n.x) / 2) * t), (e.y += ((i + n.y) / 2) * t), this.rotate && (e.rotation = Math.atan2(n.y, n.x));
	}
}
function a6(e) {
	return this.ease && (e = this.ease(e)), (this.first.next.value - this.first.value) * e + this.first.value;
}
function l6(e) {
	this.ease && (e = this.ease(e));
	const t = this.first.value,
		n = this.first.next.value;
	return G4((n.r - t.r) * e + t.r, (n.g - t.g) * e + t.g, (n.b - t.b) * e + t.b);
}
function u6(e) {
	this.ease && (e = this.ease(e));
	let t = this.first,
		n = t.next;
	for (; e > n.time; ) (t = n), (n = n.next);
	return (e = (e - t.time) / (n.time - t.time)), (n.value - t.value) * e + t.value;
}
function c6(e) {
	this.ease && (e = this.ease(e));
	let t = this.first,
		n = t.next;
	for (; e > n.time; ) (t = n), (n = n.next);
	e = (e - t.time) / (n.time - t.time);
	const r = t.value,
		i = n.value;
	return G4((i.r - r.r) * e + r.r, (i.g - r.g) * e + r.g, (i.b - r.b) * e + r.b);
}
function h6(e) {
	this.ease && (e = this.ease(e));
	let t = this.first;
	for (; t.next && e > t.next.time; ) t = t.next;
	return t.value;
}
function d6(e) {
	this.ease && (e = this.ease(e));
	let t = this.first;
	for (; t.next && e > t.next.time; ) t = t.next;
	const n = t.value;
	return G4(n.r, n.g, n.b);
}
(o6.type = "moveAcceleration"), (o6.editorConfig = null);
class p6 {
	constructor(e = !1) {
		(this.first = null), (this.isColor = !!e), (this.interpolate = null), (this.ease = null);
	}
	reset(e) {
		this.first = e;
		e.next && e.next.time >= 1 ? (this.interpolate = this.isColor ? l6 : a6) : e.isStepped ? (this.interpolate = this.isColor ? d6 : h6) : (this.interpolate = this.isColor ? c6 : u6), (this.ease = this.first.ease);
	}
}
class f6 {
	constructor(e) {
		(this.order = J4.Normal), (this.list = new p6(!1)), this.list.reset(z4.createList(e.alpha));
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.alpha = this.list.first.value), (t = t.next);
	}
	updateParticle(e) {
		e.alpha = this.list.interpolate(e.agePercent);
	}
}
(f6.type = "alpha"), (f6.editorConfig = null);
class m6 {
	constructor(e) {
		(this.order = J4.Normal), (this.value = e.alpha);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.alpha = this.value), (t = t.next);
	}
}
function v6(e) {
	const t = [];
	for (let n = 0; n < e.length; ++n) {
		let r = e[n];
		if ("string" == typeof r) t.push($4(r));
		else if (r instanceof lp) t.push(r);
		else {
			let e = r.count || 1;
			for (r = "string" == typeof r.texture ? $4(r.texture) : r.texture; e > 0; --e) t.push(r);
		}
	}
	return t;
}
(m6.type = "alphaStatic"), (m6.editorConfig = null);
class g6 {
	constructor(e) {
		(this.order = J4.Normal), (this.anims = []);
		for (let t = 0; t < e.anims.length; ++t) {
			const n = e.anims[t],
				r = v6(n.textures),
				i = n.framerate < 0 ? -1 : n.framerate > 0 ? n.framerate : 60,
				s = { textures: r, duration: i > 0 ? r.length / i : 0, framerate: i, loop: i > 0 && !!n.loop };
			this.anims.push(s);
		}
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.floor(Math.random() * this.anims.length),
				n = (t.config.anim = this.anims[e]);
			(t.texture = n.textures[0]), (t.config.animElapsed = 0), -1 === n.framerate ? ((t.config.animDuration = t.maxLife), (t.config.animFramerate = n.textures.length / t.maxLife)) : ((t.config.animDuration = n.duration), (t.config.animFramerate = n.framerate)), (t = t.next);
		}
	}
	updateParticle(e, t) {
		const n = e.config,
			r = n.anim;
		(n.animElapsed += t), n.animElapsed >= n.animDuration && (n.anim.loop ? (n.animElapsed = n.animElapsed % n.animDuration) : (n.animElapsed = n.animDuration - 1e-6));
		const i = (n.animElapsed * n.animFramerate + 1e-7) | 0;
		e.texture = r.textures[i] || r.textures[r.textures.length - 1] || lp.EMPTY;
	}
}
(g6.type = "animatedRandom"), (g6.editorConfig = null);
class y6 {
	constructor(e) {
		this.order = J4.Normal;
		const t = e.anim,
			n = v6(t.textures),
			r = t.framerate < 0 ? -1 : t.framerate > 0 ? t.framerate : 60;
		this.anim = { textures: n, duration: r > 0 ? n.length / r : 0, framerate: r, loop: r > 0 && !!t.loop };
	}
	initParticles(e) {
		let t = e;
		const n = this.anim;
		for (; t; ) (t.texture = n.textures[0]), (t.config.animElapsed = 0), -1 === n.framerate ? ((t.config.animDuration = t.maxLife), (t.config.animFramerate = n.textures.length / t.maxLife)) : ((t.config.animDuration = n.duration), (t.config.animFramerate = n.framerate)), (t = t.next);
	}
	updateParticle(e, t) {
		const n = this.anim,
			r = e.config;
		(r.animElapsed += t), r.animElapsed >= r.animDuration && (n.loop ? (r.animElapsed = r.animElapsed % r.animDuration) : (r.animElapsed = r.animDuration - 1e-6));
		const i = (r.animElapsed * r.animFramerate + 1e-7) | 0;
		e.texture = n.textures[i] || n.textures[n.textures.length - 1] || lp.EMPTY;
	}
}
(y6.type = "animatedSingle"), (y6.editorConfig = null);
class b6 {
	constructor(e) {
		(this.order = J4.Normal), (this.value = e.blendMode);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.blendMode = (n = this.value) ? ((n = n.toUpperCase().replace(/ /g, "_")), wl[n] || wl.NORMAL) : wl.NORMAL), (t = t.next);
		var n;
	}
}
(b6.type = "blendMode"), (b6.editorConfig = null);
class x6 {
	constructor(e) {
		(this.order = J4.Spawn), (this.spacing = e.spacing * j4), (this.start = e.start * j4), (this.distance = e.distance);
	}
	initParticles(e) {
		let t = 0,
			n = e;
		for (; n; ) {
			let e;
			(e = this.spacing ? this.start + this.spacing * t : Math.random() * Math.PI * 2), (n.rotation = e), this.distance && ((n.position.x = this.distance), W4(e, n.position)), (n = n.next), ++t;
		}
	}
}
(x6.type = "spawnBurst"), (x6.editorConfig = null);
class _6 {
	constructor(e) {
		(this.order = J4.Normal), (this.list = new p6(!0)), this.list.reset(z4.createList(e.color));
	}
	initParticles(e) {
		let t = e;
		const n = this.list.first.value,
			r = G4(n.r, n.g, n.b);
		for (; t; ) (t.tint = r), (t = t.next);
	}
	updateParticle(e) {
		e.tint = this.list.interpolate(e.agePercent);
	}
}
(_6.type = "color"), (_6.editorConfig = null);
class w6 {
	constructor(e) {
		this.order = J4.Normal;
		let t = e.color;
		"#" === t.charAt(0) ? (t = t.substr(1)) : 0 === t.indexOf("0x") && (t = t.substr(2)), (this.value = parseInt(t, 16));
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.tint = this.value), (t = t.next);
	}
}
(w6.type = "colorStatic"), (w6.editorConfig = null);
class C6 {
	constructor(e) {
		(this.order = J4.Normal), (this.index = 0), (this.textures = e.textures.map((e) => ("string" == typeof e ? $4(e) : e)));
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.texture = this.textures[this.index]), ++this.index >= this.textures.length && (this.index = 0), (t = t.next);
	}
}
(C6.type = "textureOrdered"), (C6.editorConfig = null);
const S6 = new G5(),
	E6 = [
		"E",
		"LN2",
		"LN10",
		"LOG2E",
		"LOG10E",
		"PI",
		"SQRT1_2",
		"SQRT2",
		"abs",
		"acos",
		"acosh",
		"asin",
		"asinh",
		"atan",
		"atanh",
		"atan2",
		"cbrt",
		"ceil",
		"cos",
		"cosh",
		"exp",
		"expm1",
		"floor",
		"fround",
		"hypot",
		"log",
		"log1p",
		"log10",
		"log2",
		"max",
		"min",
		"pow",
		"random",
		"round",
		"sign",
		"sin",
		"sinh",
		"sqrt",
		"tan",
		"tanh"
	],
	T6 = new RegExp(["[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"].concat(E6).join("|"), "g");
class k6 {
	constructor(e) {
		var t;
		if (((this.order = J4.Late), e.path))
			if ("function" == typeof e.path) this.path = e.path;
			else
				try {
					this.path = (function (e) {
						const t = e.match(T6);
						for (let n = t.length - 1; n >= 0; --n) E6.indexOf(t[n]) >= 0 && (t[n] = `Math.${t[n]}`);
						return (e = t.join("")), new Function("x", `return ${e};`);
					})(e.path);
				} catch (Kj) {
					this.path = null;
				}
		else this.path = (e) => e;
		(this.list = new p6(!1)), this.list.reset(z4.createList(e.speed)), (this.minMult = null !== (t = e.minMult) && void 0 !== t ? t : 1);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			(t.config.initRotation = t.rotation), t.config.initPosition ? t.config.initPosition.copyFrom(t.position) : (t.config.initPosition = new G5(t.x, t.y)), (t.config.movement = 0);
			const e = Math.random() * (1 - this.minMult) + this.minMult;
			(t.config.speedMult = e), (t = t.next);
		}
	}
	updateParticle(e, t) {
		const n = this.list.interpolate(e.agePercent) * e.config.speedMult;
		(e.config.movement += n * t), (S6.x = e.config.movement), (S6.y = this.path(S6.x)), W4(e.config.initRotation, S6), (e.position.x = e.config.initPosition.x + S6.x), (e.position.y = e.config.initPosition.y + S6.y);
	}
}
(k6.type = "movePath"), (k6.editorConfig = null);
class A6 {
	constructor() {
		this.order = J4.Spawn;
	}
	initParticles(e) {}
}
(A6.type = "spawnPoint"), (A6.editorConfig = null);
class M6 {
	constructor(e) {
		(this.order = J4.Normal), (this.textures = e.textures.map((e) => ("string" == typeof e ? $4(e) : e)));
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.floor(Math.random() * this.textures.length);
			(t.texture = this.textures[e]), (t = t.next);
		}
	}
}
(M6.type = "textureRandom"), (M6.editorConfig = null);
class I6 {
	constructor(e) {
		(this.order = J4.Normal), (this.minStart = e.minStart * j4), (this.maxStart = e.maxStart * j4), (this.minSpeed = e.minSpeed * j4), (this.maxSpeed = e.maxSpeed * j4), (this.accel = e.accel * j4);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) this.minStart === this.maxStart ? (t.rotation += this.maxStart) : (t.rotation += Math.random() * (this.maxStart - this.minStart) + this.minStart), (t.config.rotSpeed = Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed), (t = t.next);
	}
	updateParticle(e, t) {
		if (this.accel) {
			const n = e.config.rotSpeed;
			(e.config.rotSpeed += this.accel * t), (e.rotation += ((e.config.rotSpeed + n) / 2) * t);
		} else e.rotation += e.config.rotSpeed * t;
	}
}
(I6.type = "rotation"), (I6.editorConfig = null);
class R6 {
	constructor(e) {
		(this.order = J4.Normal), (this.min = e.min * j4), (this.max = e.max * j4);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) this.min === this.max ? (t.rotation += this.max) : (t.rotation += Math.random() * (this.max - this.min) + this.min), (t = t.next);
	}
}
(R6.type = "rotationStatic"), (R6.editorConfig = null);
class L6 {
	constructor(e) {
		(this.order = J4.Late + 1), (this.rotation = (e.rotation || 0) * j4);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.rotation = this.rotation), (t = t.next);
	}
}
(L6.type = "noRotation"), (L6.editorConfig = null);
class O6 {
	constructor(e) {
		var t;
		(this.order = J4.Normal), (this.list = new p6(!1)), this.list.reset(z4.createList(e.scale)), (this.minMult = null !== (t = e.minMult) && void 0 !== t ? t : 1);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.random() * (1 - this.minMult) + this.minMult;
			(t.config.scaleMult = e), (t.scale.x = t.scale.y = this.list.first.value * e), (t = t.next);
		}
	}
	updateParticle(e) {
		e.scale.x = e.scale.y = this.list.interpolate(e.agePercent) * e.config.scaleMult;
	}
}
(O6.type = "scale"), (O6.editorConfig = null);
class P6 {
	constructor(e) {
		(this.order = J4.Normal), (this.min = e.min), (this.max = e.max);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.random() * (this.max - this.min) + this.min;
			(t.scale.x = t.scale.y = e), (t = t.next);
		}
	}
}
(P6.type = "scaleStatic"), (P6.editorConfig = null);
class N6 {
	constructor(e) {
		this.order = J4.Spawn;
		const t = N6.shapes[e.type];
		if (!t) throw new Error(`No shape found with type '${e.type}'`);
		this.shape = new t(e.data);
	}
	static registerShape(e, t) {
		N6.shapes[t || e.type] = e;
	}
	initParticles(e) {
		let t = e;
		for (; t; ) this.shape.getRandPos(t), (t = t.next);
	}
}
(N6.type = "spawnShape"), (N6.editorConfig = null), (N6.shapes = {}), N6.registerShape(s6), N6.registerShape(r6), N6.registerShape(i6), N6.registerShape(i6, "circle");
class D6 {
	constructor(e) {
		(this.order = J4.Normal), (this.texture = "string" == typeof e.texture ? $4(e.texture) : e.texture);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) (t.texture = this.texture), (t = t.next);
	}
}
(D6.type = "textureSingle"), (D6.editorConfig = null);
class B6 {
	constructor(e) {
		var t;
		(this.order = J4.Late), (this.list = new p6(!1)), this.list.reset(z4.createList(e.speed)), (this.minMult = null !== (t = e.minMult) && void 0 !== t ? t : 1);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.random() * (1 - this.minMult) + this.minMult;
			(t.config.speedMult = e), t.config.velocity ? t.config.velocity.set(this.list.first.value * e, 0) : (t.config.velocity = new G5(this.list.first.value * e, 0)), W4(t.rotation, t.config.velocity), (t = t.next);
		}
	}
	updateParticle(e, t) {
		const n = this.list.interpolate(e.agePercent) * e.config.speedMult,
			r = e.config.velocity;
		!(function (e) {
			const t = 1 / Y4(e);
			(e.x *= t), (e.y *= t);
		})(r),
			X4(r, n),
			(e.x += r.x * t),
			(e.y += r.y * t);
	}
}
(B6.type = "moveSpeed"), (B6.editorConfig = null);
class F6 {
	constructor(e) {
		(this.order = J4.Late), (this.min = e.min), (this.max = e.max);
	}
	initParticles(e) {
		let t = e;
		for (; t; ) {
			const e = Math.random() * (this.max - this.min) + this.min;
			t.config.velocity ? t.config.velocity.set(e, 0) : (t.config.velocity = new G5(e, 0)), W4(t.rotation, t.config.velocity), (t = t.next);
		}
	}
	updateParticle(e, t) {
		const n = e.config.velocity;
		(e.x += n.x * t), (e.y += n.y * t);
	}
}
/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
function H6(e) {
	return function (t) {
		(this._activeParentLayer && this._activeParentLayer !== t._activeLayer) ||
			(this.visible ? ((this.displayOrder = t.incDisplayOrder()), this.worldAlpha <= 0 || !this.renderable || ((t._activeLayer = null), e.call(this, t), (t._activeLayer = this._activeParentLayer))) : (this.displayOrder = 0));
	};
}
function V6(e) {
	(this._activeParentLayer && this._activeParentLayer !== e._activeLayer) ||
		(this.visible ? ((this.displayOrder = e.incDisplayOrder()), this.worldAlpha <= 0 || !this.renderable || ((e._activeLayer = null), this.containerRenderWebGL(e), (e._activeLayer = this._activeParentLayer))) : (this.displayOrder = 0));
}
function U6(e) {
	var t;
	(e.prototype.layerableChildren = !1), (t = e.prototype).originalRenderWebGL || ((t.originalRenderWebGL = t.render), (t.render = H6(t.render)), t.renderCanvas && ((t.originalRenderWebGL = t.renderCanvas), (t.renderCanvas = H6(t.renderCanvas))));
}
/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */ function z6(e) {
	const t = e.prototype;
	var n;
	t._oldRender ||
		(Object.assign(t, {
			_lastDisplayOrder: 0,
			_activeLayer: null,
			incDisplayOrder() {
				return ++this._lastDisplayOrder;
			},
			_oldRender: Cf.prototype.render
		}),
		(t._oldRender = t.render),
		(t.render =
			((n = t.render),
			function (e, t, r, i, s) {
				(t && (t.renderTexture || t.baseTexture)) || (this._lastDisplayOrder = 0), (this._activeLayer = null), e.isStage && e.updateStage(), n.call(this, e, t, r, i, s);
			})));
}
function $6(e) {
	if (!e) return void console.log("@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?");
	z6(e);
	const t = Jf.prototype;
	t.containerRenderCanvas || ((t.containerRenderCanvas = t.renderCanvas), (t.renderCanvas = H6(t.renderCanvas)));
}
/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */ (F6.type = "moveSpeedStatic"),
	(F6.editorConfig = null),
	n6.registerBehavior(o6),
	n6.registerBehavior(f6),
	n6.registerBehavior(m6),
	n6.registerBehavior(g6),
	n6.registerBehavior(y6),
	n6.registerBehavior(b6),
	n6.registerBehavior(x6),
	n6.registerBehavior(_6),
	n6.registerBehavior(w6),
	n6.registerBehavior(C6),
	n6.registerBehavior(k6),
	n6.registerBehavior(A6),
	n6.registerBehavior(M6),
	n6.registerBehavior(I6),
	n6.registerBehavior(R6),
	n6.registerBehavior(L6),
	n6.registerBehavior(O6),
	n6.registerBehavior(P6),
	n6.registerBehavior(N6),
	n6.registerBehavior(D6),
	n6.registerBehavior(B6),
	n6.registerBehavior(F6);
const j6 = class extends lu {
	constructor(e = 0, t = !1) {
		super(),
			(this.useRenderTexture = !1),
			(this.useDoubleBuffer = !1),
			(this.sortPriority = 0),
			(this.clearColor = new Float32Array([0, 0, 0, 0])),
			(this.canDrawWithoutLayer = !1),
			(this.canDrawInParentStage = !0),
			(this._activeLayer = null),
			(this._activeStage = null),
			(this._activeChildren = []),
			(this._lastUpdateId = -1),
			(this.zIndex = e || 0),
			(this.enableSort = !!t),
			"function" == typeof t && this.on("sort", t);
	}
	doSort(e, t) {
		if (this.listeners("sort", !0)) for (let n = 0; n < t.length; n++) this.emit("sort", t[n]);
		t.sort(j6.compareZIndex);
	}
	static compareZIndex(e, t) {
		return e.zOrder < t.zOrder ? -1 : e.zOrder > t.zOrder ? 1 : e.updateOrder - t.updateOrder;
	}
	clear() {
		(this._activeLayer = null), (this._activeStage = null), (this._activeChildren.length = 0);
	}
	_resolveChildDisplayObject(e, t) {
		this.check(e), (t._activeParentLayer = this._activeLayer), this._activeLayer ? this._activeLayer._activeChildren.push(t) : this._activeChildren.push(t);
	}
	_resolveLayer(e, t) {
		this.check(e), this._activeLayer && j6.conflict(), (this._activeLayer = t), (this._activeStage = e);
	}
	check(e) {
		if (this._lastUpdateId < j6._layerUpdateId) (this._lastUpdateId = j6._layerUpdateId), this.clear(), (this._activeStage = e);
		else if (this.canDrawInParentStage) {
			let t = this._activeStage;
			for (; t && t !== e; ) t = t._activeParentStage;
			(this._activeStage = t), null === t && this.clear();
		}
	}
	static conflict() {
		j6._lastLayerConflict + 5e3 < Date.now() && ((j6._lastLayerConflict = Date.now()), console.log("@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it"));
	}
};
let W6 = j6;
(W6._layerUpdateId = 0), (W6._lastLayerConflict = 0);
/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
class G6 {
	constructor(e) {
		(this.layer = e), (this.renderTexture = null), (this.doubleBuffer = null), (this.currentBufferIndex = 0), (this._tempRenderTarget = null), (this._tempRenderTargetSource = new ed()), (this._tempRenderTargetDestination = new ed());
	}
	init(e) {
		const t = e ? e.screen.width : 100,
			n = e ? e.screen.height : 100,
			r = e ? e.resolution : Vl.RESOLUTION;
		(this.renderTexture = up.create({ width: t, height: n, resolution: r })), this.layer.group.useDoubleBuffer && (this.doubleBuffer = [up.create({ width: t, height: n, resolution: r }), up.create({ width: t, height: n, resolution: r })]);
	}
	getRenderTexture() {
		return this.renderTexture || this.init(), this.renderTexture;
	}
	pushTexture(e) {
		const t = e.screen;
		this.renderTexture || this.init(e);
		const n = this.renderTexture,
			r = this.layer.group,
			i = this.doubleBuffer;
		if (
			((n.width === t.width && n.height === t.height && n.baseTexture.resolution === e.resolution) ||
				((n.baseTexture.resolution = e.resolution), n.resize(t.width, t.height), i && ((i[0].baseTexture.resolution = e.resolution), i[0].resize(t.width, t.height), (i[1].baseTexture.resolution = e.resolution), i[1].resize(t.width, t.height))),
			i && ((i[0].framebuffer.multisample = n.framebuffer.multisample), (i[1].framebuffer.multisample = n.framebuffer.multisample)),
			(this._tempRenderTarget = e.renderTexture.current),
			this._tempRenderTargetSource.copyFrom(e.renderTexture.sourceFrame),
			this._tempRenderTargetDestination.copyFrom(e.renderTexture.destinationFrame),
			e.batch.flush(),
			r.useDoubleBuffer)
		) {
			let t = i[this.currentBufferIndex];
			t.baseTexture._glTextures[e.CONTEXT_UID] || (e.renderTexture.bind(t, void 0, void 0), e.texture.bind(t), r.clearColor && e.renderTexture.clear(r.clearColor)),
				e.texture.unbind(n.baseTexture),
				(n.baseTexture._glTextures = t.baseTexture._glTextures),
				(n.baseTexture.framebuffer = t.baseTexture.framebuffer),
				(t = i[1 - this.currentBufferIndex]),
				e.renderTexture.bind(t, void 0, void 0);
		} else e.renderTexture.bind(n, void 0, void 0);
		r.clearColor && e.renderTexture.clear(r.clearColor);
		const s = e.filter.defaultFilterStack;
		s.length > 1 && (s[s.length - 1].renderTexture = e.renderTexture.current);
	}
	popTexture(e) {
		e.batch.flush(), e.framebuffer.blit();
		const t = e.filter.defaultFilterStack;
		t.length > 1 && (t[t.length - 1].renderTexture = this._tempRenderTarget), e.renderTexture.bind(this._tempRenderTarget, this._tempRenderTargetSource, this._tempRenderTargetDestination), (this._tempRenderTarget = null);
		const n = this.renderTexture,
			r = this.layer.group,
			i = this.doubleBuffer;
		if (r.useDoubleBuffer) {
			e.texture.unbind(n.baseTexture), (this.currentBufferIndex = 1 - this.currentBufferIndex);
			const t = i[this.currentBufferIndex];
			(n.baseTexture._glTextures = t.baseTexture._glTextures), (n.baseTexture.framebuffer = t.baseTexture.framebuffer);
		}
	}
	destroy() {
		this.renderTexture && (this.renderTexture.destroy(), this.doubleBuffer && (this.doubleBuffer[0].destroy(!0), this.doubleBuffer[1].destroy(!0)));
	}
}
class Y6 extends Jf {
	constructor(e = null) {
		super(),
			(this.isLayer = !0),
			(this.group = null),
			(this._activeChildren = []),
			(this._tempChildren = null),
			(this._activeStageParent = null),
			(this._sortedChildren = []),
			(this._tempLayerParent = null),
			(this.insertChildrenBeforeActive = !0),
			(this.insertChildrenAfterActive = !0),
			e ? ((this.group = e), (this.zIndex = e.zIndex)) : (this.group = new W6(0, !1)),
			(this._tempChildren = this.children);
	}
	get useRenderTexture() {
		return this.group.useRenderTexture;
	}
	set useRenderTexture(e) {
		this.group.useRenderTexture = e;
	}
	get useDoubleBuffer() {
		return this.group.useDoubleBuffer;
	}
	set useDoubleBuffer(e) {
		this.group.useDoubleBuffer = e;
	}
	get clearColor() {
		return this.group.clearColor;
	}
	set clearColor(e) {
		this.group.clearColor = e;
	}
	get sortPriority() {
		return this.group.sortPriority;
	}
	set sortPriority(e) {
		this.group.sortPriority = e;
	}
	getRenderTexture() {
		return this.textureCache || (this.textureCache = new G6(this)), this.textureCache.getRenderTexture();
	}
	doSort() {
		this.group.doSort(this, this._sortedChildren);
	}
	destroy(e) {
		this.textureCache && (this.textureCache.destroy(), (this.textureCache = null)), super.destroy(e);
	}
	render(e) {
		this.prerender(e) && (this.group.useRenderTexture && (this.textureCache || (this.textureCache = new G6(this)), this.textureCache.pushTexture(e)), this.containerRenderWebGL(e), this.postrender(e), this.group.useRenderTexture && this.textureCache.popTexture(e));
	}
	layerRenderCanvas(e) {
		this.prerender(e) && (this.containerRenderCanvas(e), this.postrender(e));
	}
	_onBeginLayerSubtreeTraversal(e) {
		const t = this._activeChildren;
		(this._activeStageParent = e), this.group._resolveLayer(e, this);
		const n = this.group._activeChildren;
		t.length = 0;
		for (let r = 0; r < n.length; r++) (n[r]._activeParentLayer = this), t.push(n[r]);
		n.length = 0;
	}
	_onEndLayerSubtreeTraversal() {
		const e = this.children,
			t = this._activeChildren,
			n = this._sortedChildren;
		for (let r = 0; r < t.length; r++) this.emit("display", t[r]);
		if (((n.length = 0), this.insertChildrenBeforeActive)) for (let r = 0; r < e.length; r++) n.push(e[r]);
		for (let r = 0; r < t.length; r++) n.push(t[r]);
		if (!this.insertChildrenBeforeActive && this.insertChildrenAfterActive) for (let r = 0; r < e.length; r++) n.push(e[r]);
		this.group.enableSort && this.doSort();
	}
	prerender(e) {
		return (
			(!this._activeParentLayer || this._activeParentLayer == e._activeLayer) &&
			(this.visible
				? ((this.displayOrder = e.incDisplayOrder()),
				  !(this.worldAlpha <= 0 || !this.renderable) &&
						(this.children !== this._sortedChildren && this._tempChildren !== this.children && (this._tempChildren = this.children), this._boundsID++, (this.children = this._sortedChildren), (this._tempLayerParent = e._activeLayer), (e._activeLayer = this), !0))
				: ((this.displayOrder = 0), !1))
		);
	}
	postrender(e) {
		(this.children = this._tempChildren), (e._activeLayer = this._tempLayerParent), (this._tempLayerParent = null);
	}
}
Y6.prototype.renderCanvas = Y6.prototype.layerRenderCanvas;
/*!
 * @pixi/layers - v2.0.1
 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
 *
 * @pixi/layers is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 *
 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
 */
const X6 = class extends Y6 {
	constructor() {
		super(...arguments), (this.isStage = !0), (this._tempGroups = []), (this._activeLayers = []), (this._activeParentStage = null);
	}
	clear() {
		(this._activeLayers.length = 0), (this._tempGroups.length = 0);
	}
	destroy(e) {
		this.clear(), super.destroy(e);
	}
	updateStage() {
		(this._activeParentStage = null), W6._layerUpdateId++, this._updateStageInner();
	}
	updateAsChildStage(e) {
		(this._activeParentStage = e), (X6._updateOrderCounter = 0), this._updateStageInner();
	}
	_updateStageInner() {
		this.clear(), this._addRecursive(this);
		const e = this._activeLayers;
		for (let t = 0; t < e.length; t++) {
			const n = e[t];
			if (n.group.sortPriority) {
				n._onEndLayerSubtreeTraversal();
				const e = n._sortedChildren;
				for (let t = 0; t < e.length; t++) this._addRecursiveChildren(e[t]);
			}
		}
		for (let t = 0; t < e.length; t++) {
			const n = e[t];
			n.group.sortPriority || n._onEndLayerSubtreeTraversal();
		}
	}
	_addRecursive(e) {
		if (!e.visible) return;
		if (e.isLayer) {
			const t = e;
			this._activeLayers.push(t), t._onBeginLayerSubtreeTraversal(this);
		}
		if (e !== this && e.isStage) {
			return void e.updateAsChildStage(this);
		}
		e._activeParentLayer = null;
		let t = e.parentGroup;
		t && t._resolveChildDisplayObject(this, e);
		const n = e.parentLayer;
		if ((n && ((t = n.group), t._resolveChildDisplayObject(this, e)), (e.updateOrder = ++X6._updateOrderCounter), e.alpha <= 0 || !e.renderable || !e.layerableChildren || (t && t.sortPriority))) return;
		const r = e.children;
		if (r && r.length) for (let i = 0; i < r.length; i++) this._addRecursive(r[i]);
	}
	_addRecursiveChildren(e) {
		if (e.alpha <= 0 || !e.renderable || !e.layerableChildren) return;
		const t = e.children;
		if (t && t.length) for (let n = 0; n < t.length; n++) this._addRecursive(t[n]);
	}
};
let K6 = X6;
(K6._updateOrderCounter = 0),
	/*!
	 * @pixi/layers - v2.0.1
	 * Compiled Wed, 21 Dec 2022 21:17:52 UTC
	 *
	 * @pixi/layers is licensed under the MIT License.
	 * http://www.opensource.org/licenses/mit-license
	 *
	 * Copyright 2017-2021, Ivan Popelyshev, All Rights Reserved
	 */
	(function () {
		if (void 0 !== Yf.prototype.displayOrder) return;
		Object.assign(Yf.prototype, { parentLayer: null, _activeParentLayer: null, parentGroup: null, zOrder: 0, zIndex: 0, updateOrder: 0, displayOrder: 0, layerableChildren: !0, isLayer: !1 });
		const e = Jf.prototype;
		(e.containerRenderWebGL = e.render), (e.render = V6);
	})(),
	z6(Cf);
var q6 = Object.defineProperty,
	Z6 = (e, t, n) => (
		((e, t, n) => {
			t in e ? q6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (e[t] = n);
		})(e, "symbol" != typeof t ? t + "" : t, n),
		n
	);
class J6 {
	constructor(e) {
		Z6(this, "parent"), Z6(this, "paused"), (this.parent = e), (this.paused = !1);
	}
	destroy() {}
	down(e) {
		return !1;
	}
	move(e) {
		return !1;
	}
	up(e) {
		return !1;
	}
	wheel(e) {
		return !1;
	}
	update(e) {}
	resize() {}
	reset() {}
	pause() {
		this.paused = !0;
	}
	resume() {
		this.paused = !1;
	}
}
var Q6,
	e8 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
	t8 = { exports: {} };
(Q6 = t8),
	function () {
		var e;
		!(function (e) {
			Q6.exports = e;
		})(
			(e = {
				linear: function (e, t, n, r) {
					return (n * e) / r + t;
				},
				easeInQuad: function (e, t, n, r) {
					return n * (e /= r) * e + t;
				},
				easeOutQuad: function (e, t, n, r) {
					return -n * (e /= r) * (e - 2) + t;
				},
				easeInOutQuad: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (n / 2) * e * e + t : (-n / 2) * (--e * (e - 2) - 1) + t;
				},
				easeInCubic: function (e, t, n, r) {
					return n * (e /= r) * e * e + t;
				},
				easeOutCubic: function (e, t, n, r) {
					return n * ((e = e / r - 1) * e * e + 1) + t;
				},
				easeInOutCubic: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (n / 2) * e * e * e + t : (n / 2) * ((e -= 2) * e * e + 2) + t;
				},
				easeInQuart: function (e, t, n, r) {
					return n * (e /= r) * e * e * e + t;
				},
				easeOutQuart: function (e, t, n, r) {
					return -n * ((e = e / r - 1) * e * e * e - 1) + t;
				},
				easeInOutQuart: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (n / 2) * e * e * e * e + t : (-n / 2) * ((e -= 2) * e * e * e - 2) + t;
				},
				easeInQuint: function (e, t, n, r) {
					return n * (e /= r) * e * e * e * e + t;
				},
				easeOutQuint: function (e, t, n, r) {
					return n * ((e = e / r - 1) * e * e * e * e + 1) + t;
				},
				easeInOutQuint: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (n / 2) * e * e * e * e * e + t : (n / 2) * ((e -= 2) * e * e * e * e + 2) + t;
				},
				easeInSine: function (e, t, n, r) {
					return -n * Math.cos((e / r) * (Math.PI / 2)) + n + t;
				},
				easeOutSine: function (e, t, n, r) {
					return n * Math.sin((e / r) * (Math.PI / 2)) + t;
				},
				easeInOutSine: function (e, t, n, r) {
					return (-n / 2) * (Math.cos((Math.PI * e) / r) - 1) + t;
				},
				easeInExpo: function (e, t, n, r) {
					return 0 === e ? t : n * Math.pow(2, 10 * (e / r - 1)) + t;
				},
				easeOutExpo: function (e, t, n, r) {
					return e === r ? t + n : n * (1 - Math.pow(2, (-10 * e) / r)) + t;
				},
				easeInOutExpo: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (n / 2) * Math.pow(2, 10 * (e - 1)) + t : (n / 2) * (2 - Math.pow(2, -10 * --e)) + t;
				},
				easeInCirc: function (e, t, n, r) {
					return -n * (Math.sqrt(1 - (e /= r) * e) - 1) + t;
				},
				easeOutCirc: function (e, t, n, r) {
					return n * Math.sqrt(1 - (e = e / r - 1) * e) + t;
				},
				easeInOutCirc: function (e, t, n, r) {
					return (e /= r / 2) < 1 ? (-n / 2) * (Math.sqrt(1 - e * e) - 1) + t : (n / 2) * (Math.sqrt(1 - (e -= 2) * e) + 1) + t;
				},
				easeInElastic: function (e, t, n, r) {
					var i, s, o;
					return (o = 1.70158), 0 === e || (e /= r), (s = 0) || (s = 0.3 * r), (i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)), -i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) + t;
				},
				easeOutElastic: function (e, t, n, r) {
					var i, s, o;
					return (o = 1.70158), 0 === e || (e /= r), (s = 0) || (s = 0.3 * r), (i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)), i * Math.pow(2, -10 * e) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) + n + t;
				},
				easeInOutElastic: function (e, t, n, r) {
					var i, s, o;
					return (
						(o = 1.70158),
						0 === e || (e /= r / 2),
						(s = 0) || (s = r * (0.3 * 1.5)),
						(i = n) < Math.abs(n) ? ((i = n), (o = s / 4)) : (o = (s / (2 * Math.PI)) * Math.asin(n / i)),
						e < 1 ? i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) * -0.5 + t : i * Math.pow(2, -10 * (e -= 1)) * Math.sin(((e * r - o) * (2 * Math.PI)) / s) * 0.5 + n + t
					);
				},
				easeInBack: function (e, t, n, r, i) {
					return void 0 === i && (i = 1.70158), n * (e /= r) * e * ((i + 1) * e - i) + t;
				},
				easeOutBack: function (e, t, n, r, i) {
					return void 0 === i && (i = 1.70158), n * ((e = e / r - 1) * e * ((i + 1) * e + i) + 1) + t;
				},
				easeInOutBack: function (e, t, n, r, i) {
					return void 0 === i && (i = 1.70158), (e /= r / 2) < 1 ? (n / 2) * (e * e * ((1 + (i *= 1.525)) * e - i)) + t : (n / 2) * ((e -= 2) * e * ((1 + (i *= 1.525)) * e + i) + 2) + t;
				},
				easeInBounce: function (t, n, r, i) {
					return r - e.easeOutBounce(i - t, 0, r, i) + n;
				},
				easeOutBounce: function (e, t, n, r) {
					return (e /= r) < 1 / 2.75 ? n * (7.5625 * e * e) + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375) + t;
				},
				easeInOutBounce: function (t, n, r, i) {
					return t < i / 2 ? 0.5 * e.easeInBounce(2 * t, 0, r, i) + n : 0.5 * e.easeOutBounce(2 * t - i, 0, r, i) + 0.5 * r + n;
				}
			})
		);
	}.call(e8);
const n8 = t8.exports;
function r8(e, t) {
	return e ? ("function" == typeof e ? e : "string" == typeof e ? n8[e] : void 0) : n8[t];
}
const i8 = { removeOnInterrupt: !1, ease: "linear", time: 1e3 };
class s8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "startX"),
			Z6(this, "startY"),
			Z6(this, "deltaX"),
			Z6(this, "deltaY"),
			Z6(this, "keepCenter"),
			Z6(this, "startWidth", null),
			Z6(this, "startHeight", null),
			Z6(this, "deltaWidth", null),
			Z6(this, "deltaHeight", null),
			Z6(this, "width", null),
			Z6(this, "height", null),
			Z6(this, "time", 0),
			(this.options = Object.assign({}, i8, t)),
			(this.options.ease = r8(this.options.ease)),
			this.setupPosition(),
			this.setupZoom(),
			(this.time = 0);
	}
	setupPosition() {
		typeof this.options.position < "u" ? ((this.startX = this.parent.center.x), (this.startY = this.parent.center.y), (this.deltaX = this.options.position.x - this.parent.center.x), (this.deltaY = this.options.position.y - this.parent.center.y), (this.keepCenter = !1)) : (this.keepCenter = !0);
	}
	setupZoom() {
		(this.width = null),
			(this.height = null),
			typeof this.options.scale < "u"
				? (this.width = this.parent.screenWidth / this.options.scale)
				: typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u"
				? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY))
				: (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)),
			null !== this.width && ((this.startWidth = this.parent.screenWidthInWorldPixels), (this.deltaWidth = this.width - this.startWidth)),
			null !== this.height && ((this.startHeight = this.parent.screenHeightInWorldPixels), (this.deltaHeight = this.height - this.startHeight));
	}
	down() {
		return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), !1;
	}
	complete() {
		this.parent.plugins.remove("animate"),
			null !== this.width && this.parent.fitWidth(this.width, this.keepCenter, null === this.height),
			null !== this.height && this.parent.fitHeight(this.height, this.keepCenter, null === this.width),
			!this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position),
			this.parent.emit("animate-end", this.parent),
			this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
	}
	update(e) {
		if (this.paused) return;
		this.time += e;
		const t = new Jh(this.parent.scale.x, this.parent.scale.y);
		if (this.time >= this.options.time) {
			const e = this.parent.width,
				n = this.parent.height;
			this.complete(), (e !== this.parent.width || n !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: t, type: "animate" });
		} else {
			const e = this.options.ease(this.time, 0, 1, this.options.time);
			if (null !== this.width) {
				const t = this.startWidth,
					n = this.deltaWidth;
				this.parent.fitWidth(t + n * e, this.keepCenter, null === this.height);
			}
			if (null !== this.height) {
				const t = this.startHeight,
					n = this.deltaHeight;
				this.parent.fitHeight(t + n * e, this.keepCenter, null === this.width);
			}
			if ((null === this.width ? (this.parent.scale.x = this.parent.scale.y) : null === this.height && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter)) {
				const t = this.startX,
					n = this.startY,
					r = this.deltaX,
					i = this.deltaY,
					s = new Jh(this.parent.x, this.parent.y);
				this.parent.moveCenter(t + r * e, n + i * e), this.parent.emit("moved", { viewport: this.parent, original: s, type: "animate" });
			}
			(this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: t, type: "animate" });
		}
	}
}
const o8 = { sides: "all", friction: 0.5, time: 150, ease: "easeInOutSine", underflow: "center", bounceBox: null };
class a8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "left"),
			Z6(this, "top"),
			Z6(this, "right"),
			Z6(this, "bottom"),
			Z6(this, "underflowX"),
			Z6(this, "underflowY"),
			Z6(this, "ease"),
			Z6(this, "toX"),
			Z6(this, "toY"),
			(this.options = Object.assign({}, o8, t)),
			(this.ease = r8(this.options.ease, "easeInOutSine")),
			this.options.sides
				? "all" === this.options.sides
					? (this.top = this.bottom = this.left = this.right = !0)
					: "horizontal" === this.options.sides
					? ((this.right = this.left = !0), (this.top = this.bottom = !1))
					: "vertical" === this.options.sides
					? ((this.left = this.right = !1), (this.top = this.bottom = !0))
					: ((this.top = -1 !== this.options.sides.indexOf("top")), (this.bottom = -1 !== this.options.sides.indexOf("bottom")), (this.left = -1 !== this.options.sides.indexOf("left")), (this.right = -1 !== this.options.sides.indexOf("right")))
				: (this.left = this.top = this.right = this.bottom = !1);
		const n = this.options.underflow.toLowerCase();
		"center" === n ? ((this.underflowX = 0), (this.underflowY = 0)) : ((this.underflowX = -1 !== n.indexOf("left") ? -1 : -1 !== n.indexOf("right") ? 1 : 0), (this.underflowY = -1 !== n.indexOf("top") ? -1 : -1 !== n.indexOf("bottom") ? 1 : 0)), this.reset();
	}
	isActive() {
		return null !== this.toX || null !== this.toY;
	}
	down() {
		return (this.toX = this.toY = null), !1;
	}
	up() {
		return this.bounce(), !1;
	}
	update(e) {
		if (!this.paused) {
			if ((this.bounce(), this.toX)) {
				const t = this.toX;
				(t.time += e), this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), t.time >= this.options.time ? ((this.parent.x = t.end), (this.toX = null), this.parent.emit("bounce-x-end", this.parent)) : (this.parent.x = this.ease(t.time, t.start, t.delta, this.options.time));
			}
			if (this.toY) {
				const t = this.toY;
				(t.time += e), this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), t.time >= this.options.time ? ((this.parent.y = t.end), (this.toY = null), this.parent.emit("bounce-y-end", this.parent)) : (this.parent.y = this.ease(t.time, t.start, t.delta, this.options.time));
			}
		}
	}
	calcUnderflowX() {
		let e;
		switch (this.underflowX) {
			case -1:
				e = 0;
				break;
			case 1:
				e = this.parent.screenWidth - this.parent.screenWorldWidth;
				break;
			default:
				e = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
		}
		return e;
	}
	calcUnderflowY() {
		let e;
		switch (this.underflowY) {
			case -1:
				e = 0;
				break;
			case 1:
				e = this.parent.screenHeight - this.parent.screenWorldHeight;
				break;
			default:
				e = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
		}
		return e;
	}
	oob() {
		const e = this.options.bounceBox;
		if (e) {
			const t = typeof e.x > "u" ? 0 : e.x,
				n = typeof e.y > "u" ? 0 : e.y,
				r = typeof e.width > "u" ? this.parent.worldWidth : e.width,
				i = typeof e.height > "u" ? this.parent.worldHeight : e.height;
			return {
				left: this.parent.left < t,
				right: this.parent.right > r,
				top: this.parent.top < n,
				bottom: this.parent.bottom > i,
				topLeft: new Jh(t * this.parent.scale.x, n * this.parent.scale.y),
				bottomRight: new Jh(r * this.parent.scale.x - this.parent.screenWidth, i * this.parent.scale.y - this.parent.screenHeight)
			};
		}
		return {
			left: this.parent.left < 0,
			right: this.parent.right > this.parent.worldWidth,
			top: this.parent.top < 0,
			bottom: this.parent.bottom > this.parent.worldHeight,
			topLeft: new Jh(0, 0),
			bottomRight: new Jh(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth, this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
		};
	}
	bounce() {
		var e, t;
		if (this.paused) return;
		let n,
			r = this.parent.plugins.get("decelerate", !0);
		r &&
			(r.x || r.y) &&
			((r.x && r.percentChangeX === (null == (e = r.options) ? void 0 : e.friction)) || (r.y && r.percentChangeY === (null == (t = r.options) ? void 0 : t.friction))) &&
			((n = this.oob()), ((n.left && this.left) || (n.right && this.right)) && (r.percentChangeX = this.options.friction), ((n.top && this.top) || (n.bottom && this.bottom)) && (r.percentChangeY = this.options.friction));
		const i = this.parent.plugins.get("drag", !0) || {},
			s = this.parent.plugins.get("pinch", !0) || {};
		if (((r = r || {}), !((null != i && i.active) || (null != s && s.active) || (this.toX && this.toY) || (r.x && r.y)))) {
			n = n || this.oob();
			const e = n.topLeft,
				t = n.bottomRight;
			if (!this.toX && !r.x) {
				let r = null;
				n.left && this.left ? (r = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -e.x) : n.right && this.right && (r = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -t.x),
					null !== r && this.parent.x !== r && ((this.toX = { time: 0, start: this.parent.x, delta: r - this.parent.x, end: r }), this.parent.emit("bounce-x-start", this.parent));
			}
			if (!this.toY && !r.y) {
				let r = null;
				n.top && this.top ? (r = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -e.y) : n.bottom && this.bottom && (r = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -t.y),
					null !== r && this.parent.y !== r && ((this.toY = { time: 0, start: this.parent.y, delta: r - this.parent.y, end: r }), this.parent.emit("bounce-y-start", this.parent));
			}
		}
	}
	reset() {
		(this.toX = this.toY = null), this.bounce();
	}
}
const l8 = { left: !1, right: !1, top: !1, bottom: !1, direction: null, underflow: "center" };
class u8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "last"),
			Z6(this, "noUnderflow"),
			Z6(this, "underflowX"),
			Z6(this, "underflowY"),
			(this.options = Object.assign({}, l8, t)),
			this.options.direction &&
				((this.options.left = "x" === this.options.direction || "all" === this.options.direction || null),
				(this.options.right = "x" === this.options.direction || "all" === this.options.direction || null),
				(this.options.top = "y" === this.options.direction || "all" === this.options.direction || null),
				(this.options.bottom = "y" === this.options.direction || "all" === this.options.direction || null)),
			this.parseUnderflow(),
			(this.last = { x: null, y: null, scaleX: null, scaleY: null }),
			this.update();
	}
	parseUnderflow() {
		const e = this.options.underflow.toLowerCase();
		"none" === e
			? (this.noUnderflow = !0)
			: "center" === e
			? ((this.underflowX = this.underflowY = 0), (this.noUnderflow = !1))
			: ((this.underflowX = -1 !== e.indexOf("left") ? -1 : -1 !== e.indexOf("right") ? 1 : 0), (this.underflowY = -1 !== e.indexOf("top") ? -1 : -1 !== e.indexOf("bottom") ? 1 : 0), (this.noUnderflow = !1));
	}
	move() {
		return this.update(), !1;
	}
	update() {
		if (this.paused || (this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)) return;
		const e = new Jh(this.parent.x, this.parent.y),
			t = this.parent.plugins.decelerate || {};
		if (null !== this.options.left || null !== this.options.right) {
			let n = !1;
			if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
				switch (this.underflowX) {
					case -1:
						0 !== this.parent.x && ((this.parent.x = 0), (n = !0));
						break;
					case 1:
						this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && ((this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth), (n = !0));
						break;
					default:
						this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && ((this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2), (n = !0));
				}
			else
				null !== this.options.left && this.parent.left < (!0 === this.options.left ? 0 : this.options.left) && ((this.parent.x = -(!0 === this.options.left ? 0 : this.options.left) * this.parent.scale.x), (t.x = 0), (n = !0)),
					null !== this.options.right &&
						this.parent.right > (!0 === this.options.right ? this.parent.worldWidth : this.options.right) &&
						((this.parent.x = -(!0 === this.options.right ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth), (t.x = 0), (n = !0));
			n && this.parent.emit("moved", { viewport: this.parent, original: e, type: "clamp-x" });
		}
		if (null !== this.options.top || null !== this.options.bottom) {
			let n = !1;
			if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
				switch (this.underflowY) {
					case -1:
						0 !== this.parent.y && ((this.parent.y = 0), (n = !0));
						break;
					case 1:
						this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && ((this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight), (n = !0));
						break;
					default:
						this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && ((this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2), (n = !0));
				}
			else
				null !== this.options.top && this.parent.top < (!0 === this.options.top ? 0 : this.options.top) && ((this.parent.y = -(!0 === this.options.top ? 0 : this.options.top) * this.parent.scale.y), (t.y = 0), (n = !0)),
					null !== this.options.bottom &&
						this.parent.bottom > (!0 === this.options.bottom ? this.parent.worldHeight : this.options.bottom) &&
						((this.parent.y = -(!0 === this.options.bottom ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight), (t.y = 0), (n = !0));
			n && this.parent.emit("moved", { viewport: this.parent, original: e, type: "clamp-y" });
		}
		(this.last.x = this.parent.x), (this.last.y = this.parent.y), (this.last.scaleX = this.parent.scale.x), (this.last.scaleY = this.parent.scale.y);
	}
	reset() {
		this.update();
	}
}
const c8 = { minWidth: null, minHeight: null, maxWidth: null, maxHeight: null, minScale: null, maxScale: null };
class h8 extends J6 {
	constructor(e, t = {}) {
		super(e), Z6(this, "options"), (this.options = Object.assign({}, c8, t)), this.clamp();
	}
	resize() {
		this.clamp();
	}
	clamp() {
		if (!this.paused)
			if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
				let e = this.parent.worldScreenWidth,
					t = this.parent.worldScreenHeight;
				if (null !== this.options.minWidth && e < this.options.minWidth) {
					const n = this.parent.scale.x;
					this.parent.fitWidth(this.options.minWidth, !1, !1, !0), (this.parent.scale.y *= this.parent.scale.x / n), (e = this.parent.worldScreenWidth), (t = this.parent.worldScreenHeight), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
				}
				if (null !== this.options.maxWidth && e > this.options.maxWidth) {
					const n = this.parent.scale.x;
					this.parent.fitWidth(this.options.maxWidth, !1, !1, !0), (this.parent.scale.y *= this.parent.scale.x / n), (e = this.parent.worldScreenWidth), (t = this.parent.worldScreenHeight), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
				}
				if (null !== this.options.minHeight && t < this.options.minHeight) {
					const n = this.parent.scale.y;
					this.parent.fitHeight(this.options.minHeight, !1, !1, !0), (this.parent.scale.x *= this.parent.scale.y / n), (e = this.parent.worldScreenWidth), (t = this.parent.worldScreenHeight), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
				}
				if (null !== this.options.maxHeight && t > this.options.maxHeight) {
					const e = this.parent.scale.y;
					this.parent.fitHeight(this.options.maxHeight, !1, !1, !0), (this.parent.scale.x *= this.parent.scale.y / e), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
				}
			} else if (this.options.minScale || this.options.maxScale) {
				const e = { x: null, y: null },
					t = { x: null, y: null };
				if ("number" == typeof this.options.minScale) (e.x = this.options.minScale), (e.y = this.options.minScale);
				else if (null !== this.options.minScale) {
					const t = this.options.minScale;
					(e.x = typeof t.x > "u" ? null : t.x), (e.y = typeof t.y > "u" ? null : t.y);
				}
				if ("number" == typeof this.options.maxScale) (t.x = this.options.maxScale), (t.y = this.options.maxScale);
				else if (null !== this.options.maxScale) {
					const e = this.options.maxScale;
					(t.x = typeof e.x > "u" ? null : e.x), (t.y = typeof e.y > "u" ? null : e.y);
				}
				let n = this.parent.scale.x,
					r = this.parent.scale.y;
				null !== e.x && n < e.x && (n = e.x),
					null !== t.x && n > t.x && (n = t.x),
					null !== e.y && r < e.y && (r = e.y),
					null !== t.y && r > t.y && (r = t.y),
					(n !== this.parent.scale.x || r !== this.parent.scale.y) && (this.parent.scale.set(n, r), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
			}
	}
	reset() {
		this.clamp();
	}
}
const d8 = { friction: 0.98, bounce: 0.8, minSpeed: 0.01 },
	p8 = 16;
class f8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "x"),
			Z6(this, "y"),
			Z6(this, "percentChangeX"),
			Z6(this, "percentChangeY"),
			Z6(this, "saved"),
			Z6(this, "timeSinceRelease"),
			(this.options = Object.assign({}, d8, t)),
			(this.saved = []),
			(this.timeSinceRelease = 0),
			this.reset(),
			this.parent.on("moved", (e) => this.handleMoved(e));
	}
	down() {
		return (this.saved = []), (this.x = this.y = null), !1;
	}
	isActive() {
		return !(!this.x && !this.y);
	}
	move() {
		if (this.paused) return !1;
		const e = this.parent.input.count();
		return (1 === e || (e > 1 && !this.parent.plugins.get("pinch", !0))) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), !1;
	}
	handleMoved(e) {
		if (this.saved.length) {
			const t = this.saved[this.saved.length - 1];
			"clamp-x" === e.type && e.original ? t.x === e.original.x && (t.x = this.parent.x) : "clamp-y" === e.type && e.original && t.y === e.original.y && (t.y = this.parent.y);
		}
	}
	up() {
		if (0 === this.parent.input.count() && this.saved.length) {
			const e = performance.now();
			for (const t of this.saved)
				if (t.time >= e - 100) {
					const n = e - t.time;
					(this.x = (this.parent.x - t.x) / n), (this.y = (this.parent.y - t.y) / n), (this.percentChangeX = this.percentChangeY = this.options.friction), (this.timeSinceRelease = 0);
					break;
				}
		}
		return !1;
	}
	activate(e) {
		typeof (e = e || {}).x < "u" && ((this.x = e.x), (this.percentChangeX = this.options.friction)), typeof e.y < "u" && ((this.y = e.y), (this.percentChangeY = this.options.friction));
	}
	update(e) {
		if (this.paused) return;
		const t = this.x || this.y,
			n = this.timeSinceRelease,
			r = this.timeSinceRelease + e;
		if (this.x) {
			const t = this.percentChangeX,
				i = Math.log(t);
			(this.parent.x += ((this.x * p8) / i) * (Math.pow(t, r / p8) - Math.pow(t, n / p8))), (this.x *= Math.pow(this.percentChangeX, e / p8));
		}
		if (this.y) {
			const t = this.percentChangeY,
				i = Math.log(t);
			(this.parent.y += ((this.y * p8) / i) * (Math.pow(t, r / p8) - Math.pow(t, n / p8))), (this.y *= Math.pow(this.percentChangeY, e / p8));
		}
		(this.timeSinceRelease += e),
			this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && ((this.x = 0), (this.y = 0)) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)),
			t && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
	}
	reset() {
		this.x = this.y = null;
	}
}
const m8 = { direction: "all", pressDrag: !0, wheel: !0, wheelScroll: 1, reverse: !1, clampWheel: !1, underflow: "center", factor: 1, mouseButtons: "all", keyToPress: null, ignoreKeyToPressOnTouch: !1, lineHeight: 20, wheelSwapAxes: !1 };
class v8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "moved"),
			Z6(this, "reverse"),
			Z6(this, "xDirection"),
			Z6(this, "yDirection"),
			Z6(this, "keyIsPressed"),
			Z6(this, "mouse"),
			Z6(this, "underflowX"),
			Z6(this, "underflowY"),
			Z6(this, "last"),
			Z6(this, "current"),
			Z6(this, "windowEventHandlers", []),
			(this.options = Object.assign({}, m8, t)),
			(this.moved = !1),
			(this.reverse = this.options.reverse ? 1 : -1),
			(this.xDirection = !this.options.direction || "all" === this.options.direction || "x" === this.options.direction),
			(this.yDirection = !this.options.direction || "all" === this.options.direction || "y" === this.options.direction),
			(this.keyIsPressed = !1),
			this.parseUnderflow(),
			this.mouseButtons(this.options.mouseButtons),
			this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
	}
	handleKeyPresses(e) {
		this.addWindowEventHandler("keyup", (t) => {
			e.includes(t.code) && (this.keyIsPressed = !1);
		}),
			this.addWindowEventHandler("keydown", (t) => {
				e.includes(t.code) && (this.keyIsPressed = !0);
			});
	}
	addWindowEventHandler(e, t) {
		window.addEventListener(e, t), this.windowEventHandlers.push({ event: e, handler: t });
	}
	destroy() {
		this.windowEventHandlers.forEach(({ event: e, handler: t }) => {
			window.removeEventListener(e, t);
		});
	}
	mouseButtons(e) {
		this.mouse = e && "all" !== e ? [-1 !== e.indexOf("left"), -1 !== e.indexOf("middle"), -1 !== e.indexOf("right")] : [!0, !0, !0];
	}
	parseUnderflow() {
		const e = this.options.underflow.toLowerCase();
		"center" === e
			? ((this.underflowX = 0), (this.underflowY = 0))
			: (e.includes("left") ? (this.underflowX = -1) : e.includes("right") ? (this.underflowX = 1) : (this.underflowX = 0), e.includes("top") ? (this.underflowY = -1) : e.includes("bottom") ? (this.underflowY = 1) : (this.underflowY = 0));
	}
	checkButtons(e) {
		const t = "mouse" === e.pointerType,
			n = this.parent.input.count();
		return !(!(1 === n || (n > 1 && !this.parent.plugins.get("pinch", !0))) || (t && !this.mouse[e.button]));
	}
	checkKeyPress(e) {
		return !this.options.keyToPress || this.keyIsPressed || (this.options.ignoreKeyToPressOnTouch && "touch" === e.data.pointerType);
	}
	down(e) {
		return !(this.paused || !this.options.pressDrag) && (this.checkButtons(e) && this.checkKeyPress(e) ? ((this.last = { x: e.global.x, y: e.global.y }), (this.current = e.pointerId), !0) : ((this.last = null), !1));
	}
	get active() {
		return this.moved;
	}
	move(e) {
		if (this.paused || !this.options.pressDrag) return !1;
		if (this.last && this.current === e.data.pointerId) {
			const t = e.global.x,
				n = e.global.y,
				r = this.parent.input.count();
			if (1 === r || (r > 1 && !this.parent.plugins.get("pinch", !0))) {
				const r = t - this.last.x,
					i = n - this.last.y;
				if (this.moved || (this.xDirection && this.parent.input.checkThreshold(r)) || (this.yDirection && this.parent.input.checkThreshold(i))) {
					const r = { x: t, y: n };
					return (
						this.xDirection && (this.parent.x += (r.x - this.last.x) * this.options.factor),
						this.yDirection && (this.parent.y += (r.y - this.last.y) * this.options.factor),
						(this.last = r),
						this.moved || this.parent.emit("drag-start", { event: e, screen: new Jh(this.last.x, this.last.y), world: this.parent.toWorld(new Jh(this.last.x, this.last.y)), viewport: this.parent }),
						(this.moved = !0),
						this.parent.emit("moved", { viewport: this.parent, type: "drag" }),
						!0
					);
				}
			} else this.moved = !1;
		}
		return !1;
	}
	up(e) {
		if (this.paused) return !1;
		const t = this.parent.input.touches;
		if (1 === t.length) {
			const e = t[0];
			return e.last && ((this.last = { x: e.last.x, y: e.last.y }), (this.current = e.id)), (this.moved = !1), !0;
		}
		if (this.last && this.moved) {
			const t = new Jh(this.last.x, this.last.y);
			return this.parent.emit("drag-end", { event: e, screen: t, world: this.parent.toWorld(t), viewport: this.parent }), (this.last = null), (this.moved = !1), !0;
		}
		return !1;
	}
	wheel(e) {
		if (this.paused) return !1;
		if (this.options.wheel) {
			const t = this.parent.plugins.get("wheel", !0);
			if (!t || (!t.options.wheelZoom && !e.ctrlKey)) {
				const t = e.deltaMode ? this.options.lineHeight : 1,
					n = [e.deltaX, e.deltaY],
					[r, i] = this.options.wheelSwapAxes ? n.reverse() : n;
				return (
					this.xDirection && (this.parent.x += r * t * this.options.wheelScroll * this.reverse),
					this.yDirection && (this.parent.y += i * t * this.options.wheelScroll * this.reverse),
					this.options.clampWheel && this.clamp(),
					this.parent.emit("wheel-scroll", this.parent),
					this.parent.emit("moved", { viewport: this.parent, type: "wheel" }),
					this.parent.options.passiveWheel || e.preventDefault(),
					this.parent.options.stopPropagation && e.stopPropagation(),
					!0
				);
			}
		}
		return !1;
	}
	resume() {
		(this.last = null), (this.paused = !1);
	}
	clamp() {
		const e = this.parent.plugins.get("decelerate", !0) || {};
		if ("y" !== this.options.clampWheel)
			if (this.parent.screenWorldWidth < this.parent.screenWidth)
				switch (this.underflowX) {
					case -1:
						this.parent.x = 0;
						break;
					case 1:
						this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
						break;
					default:
						this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
				}
			else this.parent.left < 0 ? ((this.parent.x = 0), (e.x = 0)) : this.parent.right > this.parent.worldWidth && ((this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth), (e.x = 0));
		if ("x" !== this.options.clampWheel)
			if (this.parent.screenWorldHeight < this.parent.screenHeight)
				switch (this.underflowY) {
					case -1:
						this.parent.y = 0;
						break;
					case 1:
						this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
						break;
					default:
						this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
				}
			else this.parent.top < 0 && ((this.parent.y = 0), (e.y = 0)), this.parent.bottom > this.parent.worldHeight && ((this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight), (e.y = 0));
	}
}
const g8 = { speed: 0, acceleration: null, radius: null };
class y8 extends J6 {
	constructor(e, t, n = {}) {
		super(e), Z6(this, "options"), Z6(this, "target"), Z6(this, "velocity"), (this.target = t), (this.options = Object.assign({}, g8, n)), (this.velocity = { x: 0, y: 0 });
	}
	update(e) {
		if (this.paused) return;
		const t = this.parent.center;
		let n = this.target.x,
			r = this.target.y;
		if (this.options.radius) {
			if (!(Math.sqrt(Math.pow(this.target.y - t.y, 2) + Math.pow(this.target.x - t.x, 2)) > this.options.radius)) return;
			{
				const e = Math.atan2(this.target.y - t.y, this.target.x - t.x);
				(n = this.target.x - Math.cos(e) * this.options.radius), (r = this.target.y - Math.sin(e) * this.options.radius);
			}
		}
		const i = n - t.x,
			s = r - t.y;
		if (i || s)
			if (this.options.speed)
				if (this.options.acceleration) {
					const e = Math.atan2(r - t.y, n - t.x),
						o = Math.sqrt(Math.pow(i, 2) + Math.pow(s, 2));
					if (o) {
						const a = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
						this.velocity =
							o > a
								? { x: Math.min(this.velocity.x + (this.options.acceleration, this.options.speed)), y: Math.min(this.velocity.y + (this.options.acceleration, this.options.speed)) }
								: { x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0), y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0) };
						const l = Math.cos(e) * this.velocity.x,
							u = Math.sin(e) * this.velocity.y,
							c = Math.abs(l) > Math.abs(i) ? n : t.x + l,
							h = Math.abs(u) > Math.abs(s) ? r : t.y + u;
						this.parent.moveCenter(c, h), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
					}
				} else {
					const e = Math.atan2(r - t.y, n - t.x),
						o = Math.cos(e) * this.options.speed,
						a = Math.sin(e) * this.options.speed,
						l = Math.abs(o) > Math.abs(i) ? n : t.x + o,
						u = Math.abs(a) > Math.abs(s) ? r : t.y + a;
					this.parent.moveCenter(l, u), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
				}
			else this.parent.moveCenter(n, r), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
	}
}
const b8 = { radius: null, distance: null, top: null, bottom: null, left: null, right: null, speed: 8, reverse: !1, noDecelerate: !1, linear: !1, allowButtons: !1 };
class x8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "reverse"),
			Z6(this, "radiusSquared"),
			Z6(this, "left"),
			Z6(this, "top"),
			Z6(this, "right"),
			Z6(this, "bottom"),
			Z6(this, "horizontal"),
			Z6(this, "vertical"),
			(this.options = Object.assign({}, b8, t)),
			(this.reverse = this.options.reverse ? 1 : -1),
			(this.radiusSquared = "number" == typeof this.options.radius ? Math.pow(this.options.radius, 2) : null),
			this.resize();
	}
	resize() {
		const e = this.options.distance;
		null !== e
			? ((this.left = e), (this.top = e), (this.right = this.parent.screenWidth - e), (this.bottom = this.parent.screenHeight - e))
			: this.options.radius ||
			  ((this.left = this.options.left), (this.top = this.options.top), (this.right = null === this.options.right ? null : this.parent.screenWidth - this.options.right), (this.bottom = null === this.options.bottom ? null : this.parent.screenHeight - this.options.bottom));
	}
	down() {
		return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), !1;
	}
	move(e) {
		if (this.paused || ("mouse" !== e.pointerType && 1 !== e.pointerId) || (!this.options.allowButtons && 0 !== e.buttons)) return !1;
		const t = e.global.x,
			n = e.global.y;
		if (this.radiusSquared) {
			const e = this.parent.toScreen(this.parent.center);
			if (Math.pow(e.x - t, 2) + Math.pow(e.y - n, 2) >= this.radiusSquared) {
				const r = Math.atan2(e.y - n, e.x - t);
				this.options.linear
					? ((this.horizontal = Math.round(Math.cos(r)) * this.options.speed * this.reverse * 0.06), (this.vertical = Math.round(Math.sin(r)) * this.options.speed * this.reverse * 0.06))
					: ((this.horizontal = Math.cos(r) * this.options.speed * this.reverse * 0.06), (this.vertical = Math.sin(r) * this.options.speed * this.reverse * 0.06));
			} else this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), (this.horizontal = this.vertical = 0);
		} else
			null !== this.left && t < this.left ? (this.horizontal = Number(this.reverse) * this.options.speed * 0.06) : null !== this.right && t > this.right ? (this.horizontal = -1 * this.reverse * this.options.speed * 0.06) : (this.decelerateHorizontal(), (this.horizontal = 0)),
				null !== this.top && n < this.top ? (this.vertical = Number(this.reverse) * this.options.speed * 0.06) : null !== this.bottom && n > this.bottom ? (this.vertical = -1 * this.reverse * this.options.speed * 0.06) : (this.decelerateVertical(), (this.vertical = 0));
		return !1;
	}
	decelerateHorizontal() {
		const e = this.parent.plugins.get("decelerate", !0);
		this.horizontal && e && !this.options.noDecelerate && e.activate({ x: (this.horizontal * this.options.speed * this.reverse) / (1e3 / 60) });
	}
	decelerateVertical() {
		const e = this.parent.plugins.get("decelerate", !0);
		this.vertical && e && !this.options.noDecelerate && e.activate({ y: (this.vertical * this.options.speed * this.reverse) / (1e3 / 60) });
	}
	up() {
		return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), (this.horizontal = this.vertical = null)), !1;
	}
	update() {
		if (!this.paused && (this.horizontal || this.vertical)) {
			const e = this.parent.center;
			this.horizontal && (e.x += this.horizontal * this.options.speed), this.vertical && (e.y += this.vertical * this.options.speed), this.parent.moveCenter(e), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
		}
	}
}
const _8 = { noDrag: !1, percent: 1, center: null, factor: 1, axis: "all" };
class w8 extends J6 {
	constructor(e, t = {}) {
		super(e), Z6(this, "options"), Z6(this, "active", !1), Z6(this, "pinching", !1), Z6(this, "moved", !1), Z6(this, "lastCenter"), (this.options = Object.assign({}, _8, t));
	}
	down() {
		return this.parent.input.count() >= 2 && ((this.active = !0), !0);
	}
	isAxisX() {
		return ["all", "x"].includes(this.options.axis);
	}
	isAxisY() {
		return ["all", "y"].includes(this.options.axis);
	}
	move(e) {
		if (this.paused || !this.active) return !1;
		const t = e.global.x,
			n = e.global.y,
			r = this.parent.input.touches;
		if (r.length >= 2) {
			const i = r[0],
				s = r[1],
				o = i.last && s.last ? Math.sqrt(Math.pow(s.last.x - i.last.x, 2) + Math.pow(s.last.y - i.last.y, 2)) : null;
			if ((i.id === e.pointerId ? (i.last = { x: t, y: n, data: e }) : s.id === e.pointerId && (s.last = { x: t, y: n, data: e }), o)) {
				let e;
				const t = new Jh(i.last.x + (s.last.x - i.last.x) / 2, i.last.y + (s.last.y - i.last.y) / 2);
				this.options.center || (e = this.parent.toLocal(t));
				let n = Math.sqrt(Math.pow(s.last.x - i.last.x, 2) + Math.pow(s.last.y - i.last.y, 2));
				n = 0 === n ? (n = 1e-10) : n;
				const r = (1 - o / n) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
				this.isAxisX() && (this.parent.scale.x += r), this.isAxisY() && (this.parent.scale.y += r), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: t });
				const a = this.parent.plugins.get("clamp-zoom", !0);
				if ((a && a.clamp(), this.options.center)) this.parent.moveCenter(this.options.center);
				else {
					const n = this.parent.toGlobal(e);
					(this.parent.x += (t.x - n.x) * this.options.factor), (this.parent.y += (t.y - n.y) * this.options.factor), this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
				}
				!this.options.noDrag && this.lastCenter && ((this.parent.x += (t.x - this.lastCenter.x) * this.options.factor), (this.parent.y += (t.y - this.lastCenter.y) * this.options.factor), this.parent.emit("moved", { viewport: this.parent, type: "pinch" })),
					(this.lastCenter = t),
					(this.moved = !0);
			} else this.pinching || (this.parent.emit("pinch-start", this.parent), (this.pinching = !0));
			return !0;
		}
		return !1;
	}
	up() {
		return !!(this.pinching && this.parent.input.touches.length <= 1) && ((this.active = !1), (this.lastCenter = null), (this.pinching = !1), (this.moved = !1), this.parent.emit("pinch-end", this.parent), !0);
	}
}
const C8 = { topLeft: !1, friction: 0.8, time: 1e3, ease: "easeInOutSine", interrupt: !0, removeOnComplete: !1, removeOnInterrupt: !1, forceStart: !1 };
class S8 extends J6 {
	constructor(e, t, n, r = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "ease"),
			Z6(this, "x"),
			Z6(this, "y"),
			Z6(this, "percent"),
			Z6(this, "snapping"),
			Z6(this, "deltaX"),
			Z6(this, "deltaY"),
			Z6(this, "startX"),
			Z6(this, "startY"),
			(this.options = Object.assign({}, C8, r)),
			(this.ease = r8(r.ease, "easeInOutSine")),
			(this.x = t),
			(this.y = n),
			this.options.forceStart && this.snapStart();
	}
	snapStart() {
		(this.percent = 0), (this.snapping = { time: 0 });
		const e = this.options.topLeft ? this.parent.corner : this.parent.center;
		(this.deltaX = this.x - e.x), (this.deltaY = this.y - e.y), (this.startX = e.x), (this.startY = e.y), this.parent.emit("snap-start", this.parent);
	}
	wheel() {
		return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), !1;
	}
	down() {
		return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), !1;
	}
	up() {
		if (0 === this.parent.input.count()) {
			const e = this.parent.plugins.get("decelerate", !0);
			e && (e.x || e.y) && (e.percentChangeX = e.percentChangeY = this.options.friction);
		}
		return !1;
	}
	update(e) {
		if (!(this.paused || (this.options.interrupt && 0 !== this.parent.input.count())))
			if (this.snapping) {
				const t = this.snapping;
				let n, r, i;
				t.time += e;
				const s = this.startX,
					o = this.startY,
					a = this.deltaX,
					l = this.deltaY;
				if (t.time > this.options.time) (n = !0), (r = s + a), (i = o + l);
				else {
					const e = this.ease(t.time, 0, 1, this.options.time);
					(r = s + a * e), (i = o + l * e);
				}
				this.options.topLeft ? this.parent.moveCorner(r, i) : this.parent.moveCenter(r, i),
					this.parent.emit("moved", { viewport: this.parent, type: "snap" }),
					n && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), (this.snapping = null));
			} else {
				const e = this.options.topLeft ? this.parent.corner : this.parent.center;
				(e.x !== this.x || e.y !== this.y) && this.snapStart();
			}
	}
}
const E8 = { width: 0, height: 0, time: 1e3, ease: "easeInOutSine", center: null, interrupt: !0, removeOnComplete: !1, removeOnInterrupt: !1, forceStart: !1, noMove: !1 };
class T8 extends J6 {
	constructor(e, t = {}) {
		super(e),
			Z6(this, "options"),
			Z6(this, "ease"),
			Z6(this, "xScale"),
			Z6(this, "yScale"),
			Z6(this, "xIndependent"),
			Z6(this, "yIndependent"),
			Z6(this, "snapping"),
			(this.options = Object.assign({}, E8, t)),
			(this.ease = r8(this.options.ease)),
			(this.xIndependent = !1),
			(this.yIndependent = !1),
			(this.xScale = 0),
			(this.yScale = 0),
			this.options.width > 0 && ((this.xScale = e.screenWidth / this.options.width), (this.xIndependent = !0)),
			this.options.height > 0 && ((this.yScale = e.screenHeight / this.options.height), (this.yIndependent = !0)),
			(this.xScale = this.xIndependent ? this.xScale : this.yScale),
			(this.yScale = this.yIndependent ? this.yScale : this.xScale),
			0 === this.options.time ? ((e.container.scale.x = this.xScale), (e.container.scale.y = this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : t.forceStart && this.createSnapping();
	}
	createSnapping() {
		const e = this.parent.worldScreenWidth,
			t = this.parent.worldScreenHeight,
			n = this.parent.screenWidth / this.xScale,
			r = this.parent.screenHeight / this.yScale;
		(this.snapping = { time: 0, startX: e, startY: t, deltaX: n - e, deltaY: r - t }), this.parent.emit("snap-zoom-start", this.parent);
	}
	resize() {
		(this.snapping = null),
			this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width),
			this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height),
			(this.xScale = this.xIndependent ? this.xScale : this.yScale),
			(this.yScale = this.yIndependent ? this.yScale : this.xScale);
	}
	wheel() {
		return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), !1;
	}
	down() {
		return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), !1;
	}
	update(e) {
		if (this.paused || (this.options.interrupt && 0 !== this.parent.input.count())) return;
		let t;
		if ((!this.options.center && !this.options.noMove && (t = this.parent.center), this.snapping)) {
			if (this.snapping) {
				const n = this.snapping;
				if (((n.time += e), n.time >= this.options.time)) this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), (this.snapping = null);
				else {
					const e = this.snapping,
						t = this.ease(e.time, e.startX, e.deltaX, this.options.time),
						n = this.ease(e.time, e.startY, e.deltaY, this.options.time);
					(this.parent.scale.x = this.parent.screenWidth / t), (this.parent.scale.y = this.parent.screenHeight / n);
				}
				const r = this.parent.plugins.get("clamp-zoom", !0);
				r && r.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(t));
			}
		} else (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
	}
	resume() {
		(this.snapping = null), super.resume();
	}
}
const k8 = { percent: 0.1, smooth: !1, interrupt: !0, reverse: !1, center: null, lineHeight: 20, axis: "all", keyToPress: null, trackpadPinch: !1, wheelZoom: !0 };
class A8 extends J6 {
	constructor(e, t = {}) {
		super(e), Z6(this, "options"), Z6(this, "smoothing"), Z6(this, "smoothingCenter"), Z6(this, "smoothingCount"), Z6(this, "keyIsPressed"), (this.options = Object.assign({}, k8, t)), (this.keyIsPressed = !1), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
	}
	handleKeyPresses(e) {
		window.addEventListener("keydown", (t) => {
			e.includes(t.code) && (this.keyIsPressed = !0);
		}),
			window.addEventListener("keyup", (t) => {
				e.includes(t.code) && (this.keyIsPressed = !1);
			});
	}
	checkKeyPress() {
		return !this.options.keyToPress || this.keyIsPressed;
	}
	down() {
		return this.options.interrupt && (this.smoothing = null), !1;
	}
	isAxisX() {
		return ["all", "x"].includes(this.options.axis);
	}
	isAxisY() {
		return ["all", "y"].includes(this.options.axis);
	}
	update() {
		if (this.smoothing) {
			const e = this.smoothingCenter,
				t = this.smoothing;
			let n;
			this.options.center || (n = this.parent.toLocal(e)), this.isAxisX() && (this.parent.scale.x += t.x), this.isAxisY() && (this.parent.scale.y += t.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
			const r = this.parent.plugins.get("clamp-zoom", !0);
			if ((r && r.clamp(), this.options.center)) this.parent.moveCenter(this.options.center);
			else {
				const t = this.parent.toGlobal(n);
				(this.parent.x += e.x - t.x), (this.parent.y += e.y - t.y);
			}
			this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
		}
	}
	pinch(e) {
		if (this.paused) return;
		const t = this.parent.input.getPointerPosition(e),
			n = (-e.deltaY * (e.deltaMode ? this.options.lineHeight : 1)) / 200,
			r = Math.pow(2, (1 + this.options.percent) * n);
		let i;
		this.options.center || (i = this.parent.toLocal(t)), this.isAxisX() && (this.parent.scale.x *= r), this.isAxisY() && (this.parent.scale.y *= r), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
		const s = this.parent.plugins.get("clamp-zoom", !0);
		if ((s && s.clamp(), this.options.center)) this.parent.moveCenter(this.options.center);
		else {
			const e = this.parent.toGlobal(i);
			(this.parent.x += t.x - e.x), (this.parent.y += t.y - e.y);
		}
		this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: e, viewport: this.parent });
	}
	wheel(e) {
		if (this.paused || !this.checkKeyPress()) return !1;
		if (e.ctrlKey && this.options.trackpadPinch) this.pinch(e);
		else if (this.options.wheelZoom) {
			const t = this.parent.input.getPointerPosition(e),
				n = ((this.options.reverse ? -1 : 1) * -e.deltaY * (e.deltaMode ? this.options.lineHeight : 1)) / 500,
				r = Math.pow(2, (1 + this.options.percent) * n);
			if (this.options.smooth) {
				const e = { x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0, y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0 };
				(this.smoothing = { x: ((this.parent.scale.x + e.x) * r - this.parent.scale.x) / this.options.smooth, y: ((this.parent.scale.y + e.y) * r - this.parent.scale.y) / this.options.smooth }), (this.smoothingCount = 0), (this.smoothingCenter = t);
			} else {
				let e;
				this.options.center || (e = this.parent.toLocal(t)), this.isAxisX() && (this.parent.scale.x *= r), this.isAxisY() && (this.parent.scale.y *= r), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
				const n = this.parent.plugins.get("clamp-zoom", !0);
				if ((n && n.clamp(), this.options.center)) this.parent.moveCenter(this.options.center);
				else {
					const n = this.parent.toGlobal(e);
					(this.parent.x += t.x - n.x), (this.parent.y += t.y - n.y);
				}
			}
			this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit("wheel-start", { event: e, viewport: this.parent });
		}
		return !this.parent.options.passiveWheel;
	}
}
class M8 {
	constructor(e) {
		Z6(this, "viewport"), Z6(this, "clickedAvailable"), Z6(this, "isMouseDown"), Z6(this, "last"), Z6(this, "wheelFunction"), Z6(this, "touches"), (this.viewport = e), (this.touches = []), this.addListeners();
	}
	addListeners() {
		(this.viewport.interactive = !0),
			this.viewport.forceHitArea || (this.viewport.hitArea = new ed(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)),
			this.viewport.on("pointerdown", this.down, this),
			this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this),
			this.viewport.on("pointerup", this.up, this),
			this.viewport.on("pointerupoutside", this.up, this),
			this.viewport.on("pointercancel", this.up, this),
			this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this),
			(this.wheelFunction = (e) => this.handleWheel(e)),
			this.viewport.options.events.domElement.addEventListener("wheel", this.wheelFunction, { passive: this.viewport.options.passiveWheel }),
			(this.isMouseDown = !1);
	}
	destroy() {
		this.viewport.options.events.domElement.removeEventListener("wheel", this.wheelFunction);
	}
	down(e) {
		if (!this.viewport.pause && this.viewport.worldVisible) {
			if (("mouse" === e.pointerType ? (this.isMouseDown = !0) : this.get(e.pointerId) || this.touches.push({ id: e.pointerId, last: null }), 1 === this.count())) {
				this.last = e.global.clone();
				const t = this.viewport.plugins.get("decelerate", !0),
					n = this.viewport.plugins.get("bounce", !0);
				(t && t.isActive()) || (n && n.isActive()) ? (this.clickedAvailable = !1) : (this.clickedAvailable = !0);
			} else this.clickedAvailable = !1;
			this.viewport.plugins.down(e) && this.viewport.options.stopPropagation && e.stopPropagation();
		}
	}
	clear() {
		(this.isMouseDown = !1), (this.touches = []), (this.last = null);
	}
	checkThreshold(e) {
		return Math.abs(e) >= this.viewport.threshold;
	}
	move(e) {
		if (this.viewport.pause || !this.viewport.worldVisible) return;
		const t = this.viewport.plugins.move(e);
		if (this.clickedAvailable && this.last) {
			const t = e.global.x - this.last.x,
				n = e.global.y - this.last.y;
			(this.checkThreshold(t) || this.checkThreshold(n)) && (this.clickedAvailable = !1);
		}
		t && this.viewport.options.stopPropagation && e.stopPropagation();
	}
	up(e) {
		if (this.viewport.pause || !this.viewport.worldVisible) return;
		"mouse" === e.pointerType && (this.isMouseDown = !1), "mouse" !== e.pointerType && this.remove(e.pointerId);
		const t = this.viewport.plugins.up(e);
		this.clickedAvailable && 0 === this.count() && this.last && (this.viewport.emit("clicked", { event: e, screen: this.last, world: this.viewport.toWorld(this.last), viewport: this.viewport }), (this.clickedAvailable = !1)), t && this.viewport.options.stopPropagation && e.stopPropagation();
	}
	getPointerPosition(e) {
		const t = new Jh();
		return this.viewport.options.events.mapPositionToPoint(t, e.clientX, e.clientY), t;
	}
	handleWheel(e) {
		if (this.viewport.pause || !this.viewport.worldVisible) return;
		const t = this.viewport.toLocal(this.getPointerPosition(e));
		this.viewport.left <= t.x && t.x <= this.viewport.right && this.viewport.top <= t.y && t.y <= this.viewport.bottom && this.viewport.plugins.wheel(e) && !this.viewport.options.passiveWheel && e.preventDefault();
	}
	pause() {
		(this.touches = []), (this.isMouseDown = !1);
	}
	get(e) {
		for (const t of this.touches) if (t.id === e) return t;
		return null;
	}
	remove(e) {
		for (let t = 0; t < this.touches.length; t++) if (this.touches[t].id === e) return void this.touches.splice(t, 1);
	}
	count() {
		return (this.isMouseDown ? 1 : 0) + this.touches.length;
	}
}
const I8 = ["drag", "pinch", "wheel", "follow", "mouse-edges", "decelerate", "animate", "bounce", "snap-zoom", "clamp-zoom", "snap", "clamp"];
class R8 {
	constructor(e) {
		Z6(this, "plugins"), Z6(this, "list"), Z6(this, "viewport"), (this.viewport = e), (this.list = []), (this.plugins = {});
	}
	add(e, t, n = I8.length) {
		const r = this.plugins[e];
		r && r.destroy(), (this.plugins[e] = t);
		const i = I8.indexOf(e);
		-1 !== i && I8.splice(i, 1), I8.splice(n, 0, e), this.sort();
	}
	get(e, t) {
		var n;
		return t && null != (n = this.plugins[e]) && n.paused ? null : this.plugins[e];
	}
	update(e) {
		for (const t of this.list) t.update(e);
	}
	resize() {
		for (const e of this.list) e.resize();
	}
	reset() {
		for (const e of this.list) e.reset();
	}
	removeAll() {
		this.list.forEach((e) => {
			e.destroy();
		}),
			(this.plugins = {}),
			this.sort();
	}
	remove(e) {
		var t;
		this.plugins[e] && (null == (t = this.plugins[e]) || t.destroy(), delete this.plugins[e], this.viewport.emit("plugin-remove", e), this.sort());
	}
	pause(e) {
		var t;
		null == (t = this.plugins[e]) || t.pause();
	}
	resume(e) {
		var t;
		null == (t = this.plugins[e]) || t.resume();
	}
	sort() {
		this.list = [];
		for (const e of I8) this.plugins[e] && this.list.push(this.plugins[e]);
	}
	down(e) {
		let t = !1;
		for (const n of this.list) n.down(e) && (t = !0);
		return t;
	}
	move(e) {
		let t = !1;
		for (const n of this.viewport.plugins.list) n.move(e) && (t = !0);
		return t;
	}
	up(e) {
		let t = !1;
		for (const n of this.list) n.up(e) && (t = !0);
		return t;
	}
	wheel(e) {
		let t = !1;
		for (const n of this.list) n.wheel(e) && (t = !0);
		return t;
	}
}
const L8 = { screenWidth: window.innerWidth, screenHeight: window.innerHeight, worldWidth: null, worldHeight: null, threshold: 5, passiveWheel: !0, stopPropagation: !1, forceHitArea: null, noTicker: !1, disableOnContextMenu: !1, ticker: df.shared, allowPreserveDragOutside: !1 };
class O8 extends Jf {
	constructor(e) {
		super(),
			Z6(this, "moving"),
			Z6(this, "screenWidth"),
			Z6(this, "screenHeight"),
			Z6(this, "threshold"),
			Z6(this, "input"),
			Z6(this, "plugins"),
			Z6(this, "zooming"),
			Z6(this, "lastViewport"),
			Z6(this, "options"),
			Z6(this, "_dirty"),
			Z6(this, "_forceHitArea"),
			Z6(this, "_hitAreaDefault"),
			Z6(this, "_pause"),
			Z6(this, "tickerFunction"),
			Z6(this, "_worldWidth"),
			Z6(this, "_worldHeight"),
			Z6(this, "_disableOnContextMenu", (e) => e.preventDefault()),
			(this.options = u(u({}, L8), e)),
			(this.screenWidth = this.options.screenWidth),
			(this.screenHeight = this.options.screenHeight),
			(this._worldWidth = this.options.worldWidth),
			(this._worldHeight = this.options.worldHeight),
			(this.forceHitArea = this.options.forceHitArea),
			(this.threshold = this.options.threshold),
			this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu),
			this.options.noTicker || ((this.tickerFunction = () => this.update(this.options.ticker.elapsedMS)), this.options.ticker.add(this.tickerFunction)),
			(this.input = new M8(this)),
			(this.plugins = new R8(this));
	}
	destroy(e) {
		!this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.events.domElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(e);
	}
	update(e) {
		this.pause ||
			(this.plugins.update(e),
			this.lastViewport &&
				(this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? (this.moving = !0) : this.moving && (this.emit("moved-end", this), (this.moving = !1)),
				this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? (this.zooming = !0) : this.zooming && (this.emit("zoomed-end", this), (this.zooming = !1))),
			this.forceHitArea || ((this._hitAreaDefault = new ed(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight)), (this.hitArea = this._hitAreaDefault)),
			(this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y),
			(this.lastViewport = { x: this.x, y: this.y, scaleX: this.scale.x, scaleY: this.scale.y }),
			this.emit("frame-end", this));
	}
	resize(e = window.innerWidth, t = window.innerHeight, n, r) {
		(this.screenWidth = e), (this.screenHeight = t), typeof n < "u" && (this._worldWidth = n), typeof r < "u" && (this._worldHeight = r), this.plugins.resize(), (this.dirty = !0);
	}
	get worldWidth() {
		return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
	}
	set worldWidth(e) {
		(this._worldWidth = e), this.plugins.resize();
	}
	get worldHeight() {
		return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
	}
	set worldHeight(e) {
		(this._worldHeight = e), this.plugins.resize();
	}
	getVisibleBounds() {
		return new ed(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
	}
	toWorld(e, t) {
		return 2 === arguments.length ? this.toLocal(new Jh(e, t)) : this.toLocal(e);
	}
	toScreen(e, t) {
		return 2 === arguments.length ? this.toGlobal(new Jh(e, t)) : this.toGlobal(e);
	}
	get worldScreenWidth() {
		return this.screenWidth / this.scale.x;
	}
	get worldScreenHeight() {
		return this.screenHeight / this.scale.y;
	}
	get screenWorldWidth() {
		return this.worldWidth * this.scale.x;
	}
	get screenWorldHeight() {
		return this.worldHeight * this.scale.y;
	}
	get center() {
		return new Jh(this.worldScreenWidth / 2 - this.x / this.scale.x, this.worldScreenHeight / 2 - this.y / this.scale.y);
	}
	set center(e) {
		this.moveCenter(e);
	}
	moveCenter(...e) {
		let t, n;
		"number" == typeof e[0] ? ((t = e[0]), (n = e[1])) : ((t = e[0].x), (n = e[0].y));
		const r = (this.worldScreenWidth / 2 - t) * this.scale.x,
			i = (this.worldScreenHeight / 2 - n) * this.scale.y;
		return (this.x !== r || this.y !== i) && (this.position.set(r, i), this.plugins.reset(), (this.dirty = !0)), this;
	}
	get corner() {
		return new Jh(-this.x / this.scale.x, -this.y / this.scale.y);
	}
	set corner(e) {
		this.moveCorner(e);
	}
	moveCorner(...e) {
		let t, n;
		return 1 === e.length ? ((t = -e[0].x * this.scale.x), (n = -e[0].y * this.scale.y)) : ((t = -e[0] * this.scale.x), (n = -e[1] * this.scale.y)), (t !== this.x || n !== this.y) && (this.position.set(t, n), this.plugins.reset(), (this.dirty = !0)), this;
	}
	get screenWidthInWorldPixels() {
		return this.screenWidth / this.scale.x;
	}
	get screenHeightInWorldPixels() {
		return this.screenHeight / this.scale.y;
	}
	findFitWidth(e) {
		return this.screenWidth / e;
	}
	findFitHeight(e) {
		return this.screenHeight / e;
	}
	findFit(e, t) {
		const n = this.screenWidth / e,
			r = this.screenHeight / t;
		return Math.min(n, r);
	}
	findCover(e, t) {
		const n = this.screenWidth / e,
			r = this.screenHeight / t;
		return Math.max(n, r);
	}
	fitWidth(e = this.worldWidth, t, n = !0, r) {
		let i;
		t && (i = this.center), (this.scale.x = this.screenWidth / e), n && (this.scale.y = this.scale.x);
		const s = this.plugins.get("clamp-zoom", !0);
		return !r && s && s.clamp(), t && i && this.moveCenter(i), this;
	}
	fitHeight(e = this.worldHeight, t, n = !0, r) {
		let i;
		t && (i = this.center), (this.scale.y = this.screenHeight / e), n && (this.scale.x = this.scale.y);
		const s = this.plugins.get("clamp-zoom", !0);
		return !r && s && s.clamp(), t && i && this.moveCenter(i), this;
	}
	fitWorld(e) {
		let t;
		e && (t = this.center), (this.scale.x = this.screenWidth / this.worldWidth), (this.scale.y = this.screenHeight / this.worldHeight), this.scale.x < this.scale.y ? (this.scale.y = this.scale.x) : (this.scale.x = this.scale.y);
		const n = this.plugins.get("clamp-zoom", !0);
		return n && n.clamp(), e && t && this.moveCenter(t), this;
	}
	fit(e, t = this.worldWidth, n = this.worldHeight) {
		let r;
		e && (r = this.center), (this.scale.x = this.screenWidth / t), (this.scale.y = this.screenHeight / n), this.scale.x < this.scale.y ? (this.scale.y = this.scale.x) : (this.scale.x = this.scale.y);
		const i = this.plugins.get("clamp-zoom", !0);
		return i && i.clamp(), e && r && this.moveCenter(r), this;
	}
	setZoom(e, t) {
		let n;
		t && (n = this.center), this.scale.set(e);
		const r = this.plugins.get("clamp-zoom", !0);
		return r && r.clamp(), t && n && this.moveCenter(n), this;
	}
	zoomPercent(e, t) {
		return this.setZoom(this.scale.x + this.scale.x * e, t);
	}
	zoom(e, t) {
		return this.fitWidth(e + this.worldScreenWidth, t), this;
	}
	get scaled() {
		return this.scale.x;
	}
	set scaled(e) {
		this.setZoom(e, !0);
	}
	snapZoom(e) {
		return this.plugins.add("snap-zoom", new T8(this, e)), this;
	}
	OOB() {
		return { left: this.left < 0, right: this.right > this.worldWidth, top: this.top < 0, bottom: this.bottom > this.worldHeight, cornerPoint: new Jh(this.worldWidth * this.scale.x - this.screenWidth, this.worldHeight * this.scale.y - this.screenHeight) };
	}
	get right() {
		return -this.x / this.scale.x + this.worldScreenWidth;
	}
	set right(e) {
		(this.x = -e * this.scale.x + this.screenWidth), this.plugins.reset();
	}
	get left() {
		return -this.x / this.scale.x;
	}
	set left(e) {
		(this.x = -e * this.scale.x), this.plugins.reset();
	}
	get top() {
		return -this.y / this.scale.y;
	}
	set top(e) {
		(this.y = -e * this.scale.y), this.plugins.reset();
	}
	get bottom() {
		return -this.y / this.scale.y + this.worldScreenHeight;
	}
	set bottom(e) {
		(this.y = -e * this.scale.y + this.screenHeight), this.plugins.reset();
	}
	get dirty() {
		return !!this._dirty;
	}
	set dirty(e) {
		this._dirty = e;
	}
	get forceHitArea() {
		return this._forceHitArea;
	}
	set forceHitArea(e) {
		e ? ((this._forceHitArea = e), (this.hitArea = e)) : ((this._forceHitArea = null), (this.hitArea = new ed(0, 0, this.worldWidth, this.worldHeight)));
	}
	drag(e) {
		return this.plugins.add("drag", new v8(this, e)), this;
	}
	clamp(e) {
		return this.plugins.add("clamp", new u8(this, e)), this;
	}
	decelerate(e) {
		return this.plugins.add("decelerate", new f8(this, e)), this;
	}
	bounce(e) {
		return this.plugins.add("bounce", new a8(this, e)), this;
	}
	pinch(e) {
		return this.plugins.add("pinch", new w8(this, e)), this;
	}
	snap(e, t, n) {
		return this.plugins.add("snap", new S8(this, e, t, n)), this;
	}
	follow(e, t) {
		return this.plugins.add("follow", new y8(this, e, t)), this;
	}
	wheel(e) {
		return this.plugins.add("wheel", new A8(this, e)), this;
	}
	animate(e) {
		return this.plugins.add("animate", new s8(this, e)), this;
	}
	clampZoom(e) {
		return this.plugins.add("clamp-zoom", new h8(this, e)), this;
	}
	mouseEdges(e) {
		return this.plugins.add("mouse-edges", new x8(this, e)), this;
	}
	get pause() {
		return !!this._pause;
	}
	set pause(e) {
		(this._pause = e), (this.lastViewport = null), (this.moving = !1), (this.zooming = !1), e && this.input.pause();
	}
	ensureVisible(e, t, n, r, i) {
		i && (n > this.worldScreenWidth || r > this.worldScreenHeight) && (this.fit(!0, n, r), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
		let s = !1;
		e < this.left ? ((this.left = e), (s = !0)) : e + n > this.right && ((this.right = e + n), (s = !0)), t < this.top ? ((this.top = t), (s = !0)) : t + r > this.bottom && ((this.bottom = t + r), (s = !0)), s && this.emit("moved", { viewport: this, type: "ensureVisible" });
	}
}
var P8 = {};
!(function e(t, n, r, i) {
	var s = !!(t.Worker && t.Blob && t.Promise && t.OffscreenCanvas && t.OffscreenCanvasRenderingContext2D && t.HTMLCanvasElement && t.HTMLCanvasElement.prototype.transferControlToOffscreen && t.URL && t.URL.createObjectURL);
	function o() {}
	function a(e) {
		var r = n.exports.Promise,
			i = void 0 !== r ? r : t.Promise;
		return "function" == typeof i ? new i(e) : (e(o, o), null);
	}
	var l,
		u,
		c,
		h,
		d,
		p,
		f,
		m,
		v =
			((c = Math.floor(1e3 / 60)),
			(h = {}),
			(d = 0),
			"function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame
				? ((l = function (e) {
						var t = Math.random();
						return (
							(h[t] = requestAnimationFrame(function n(r) {
								d === r || d + c - 1 < r ? ((d = r), delete h[t], e()) : (h[t] = requestAnimationFrame(n));
							})),
							t
						);
				  }),
				  (u = function (e) {
						h[e] && cancelAnimationFrame(h[e]);
				  }))
				: ((l = function (e) {
						return setTimeout(e, c);
				  }),
				  (u = function (e) {
						return clearTimeout(e);
				  })),
			{ frame: l, cancel: u }),
		g =
			((m = {}),
			function () {
				if (p) return p;
				if (!r && s) {
					var t = [
						"var CONFETTI, SIZE = {}, module = {};",
						"(" + e.toString() + ")(this, module, true, SIZE);",
						"onmessage = function(msg) {",
						"    if (msg.data.options) {",
						"        CONFETTI(msg.data.options).then(function () {",
						"            if (msg.data.callback) {",
						"                postMessage({ callback: msg.data.callback });",
						"            }",
						"        });",
						"    } else if (msg.data.reset) {",
						"        CONFETTI.reset();",
						"    } else if (msg.data.resize) {",
						"        SIZE.width = msg.data.resize.width;",
						"        SIZE.height = msg.data.resize.height;",
						"    } else if (msg.data.canvas) {",
						"        SIZE.width = msg.data.canvas.width;",
						"        SIZE.height = msg.data.canvas.height;",
						"        CONFETTI = module.exports.create(msg.data.canvas);",
						"    }",
						"}"
					].join("\n");
					try {
						p = new Worker(URL.createObjectURL(new Blob([t])));
					} catch (Kj) {
						return void 0 !== typeof console && "function" == typeof console.warn && console.warn("🎊 Could not load worker", Kj), null;
					}
					!(function (e) {
						function t(t, n) {
							e.postMessage({ options: t || {}, callback: n });
						}
						(e.init = function (t) {
							var n = t.transferControlToOffscreen();
							e.postMessage({ canvas: n }, [n]);
						}),
							(e.fire = function (n, r, i) {
								if (f) return t(n, null), f;
								var s = Math.random().toString(36).slice(2);
								return (f = a(function (r) {
									function o(t) {
										t.data.callback === s && (delete m[s], e.removeEventListener("message", o), (f = null), i(), r());
									}
									e.addEventListener("message", o), t(n, s), (m[s] = o.bind(null, { data: { callback: s } }));
								}));
							}),
							(e.reset = function () {
								for (var t in (e.postMessage({ reset: !0 }), m)) m[t](), delete m[t];
							});
					})(p);
				}
				return p;
			}),
		y = {
			particleCount: 50,
			angle: 90,
			spread: 45,
			startVelocity: 45,
			decay: 0.9,
			gravity: 1,
			drift: 0,
			ticks: 200,
			x: 0.5,
			y: 0.5,
			shapes: ["square", "circle"],
			zIndex: 100,
			colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"],
			disableForReducedMotion: !1,
			scalar: 1
		};
	function b(e, t, n) {
		return (function (e, t) {
			return t ? t(e) : e;
		})(e && null != e[t] ? e[t] : y[t], n);
	}
	function x(e) {
		return e < 0 ? 0 : Math.floor(e);
	}
	function _(e) {
		return parseInt(e, 16);
	}
	function w(e) {
		return e.map(C);
	}
	function C(e) {
		var t = String(e).replace(/[^0-9a-f]/gi, "");
		return t.length < 6 && (t = t[0] + t[0] + t[1] + t[1] + t[2] + t[2]), { r: _(t.substring(0, 2)), g: _(t.substring(2, 4)), b: _(t.substring(4, 6)) };
	}
	function S(e) {
		(e.width = document.documentElement.clientWidth), (e.height = document.documentElement.clientHeight);
	}
	function E(e) {
		var t = e.getBoundingClientRect();
		(e.width = t.width), (e.height = t.height);
	}
	function T(e, t, n, s, o) {
		var l,
			u,
			c = t.slice(),
			h = e.getContext("2d"),
			d = a(function (t) {
				function a() {
					(l = u = null), h.clearRect(0, 0, s.width, s.height), o(), t();
				}
				(l = v.frame(function t() {
					!r || (s.width === i.width && s.height === i.height) || ((s.width = e.width = i.width), (s.height = e.height = i.height)),
						s.width || s.height || (n(e), (s.width = e.width), (s.height = e.height)),
						h.clearRect(0, 0, s.width, s.height),
						(c = c.filter(function (e) {
							return (function (e, t) {
								(t.x += Math.cos(t.angle2D) * t.velocity + t.drift),
									(t.y += Math.sin(t.angle2D) * t.velocity + t.gravity),
									(t.wobble += 0.1),
									(t.velocity *= t.decay),
									(t.tiltAngle += 0.1),
									(t.tiltSin = Math.sin(t.tiltAngle)),
									(t.tiltCos = Math.cos(t.tiltAngle)),
									(t.random = Math.random() + 5),
									(t.wobbleX = t.x + 10 * t.scalar * Math.cos(t.wobble)),
									(t.wobbleY = t.y + 10 * t.scalar * Math.sin(t.wobble));
								var n = t.tick++ / t.totalTicks,
									r = t.x + t.random * t.tiltCos,
									i = t.y + t.random * t.tiltSin,
									s = t.wobbleX + t.random * t.tiltCos,
									o = t.wobbleY + t.random * t.tiltSin;
								return (
									(e.fillStyle = "rgba(" + t.color.r + ", " + t.color.g + ", " + t.color.b + ", " + (1 - n) + ")"),
									e.beginPath(),
									"circle" === t.shape
										? e.ellipse
											? e.ellipse(t.x, t.y, Math.abs(s - r) * t.ovalScalar, Math.abs(o - i) * t.ovalScalar, (Math.PI / 10) * t.wobble, 0, 2 * Math.PI)
											: (function (e, t, n, r, i, s, o, a, l) {
													e.save(), e.translate(t, n), e.rotate(s), e.scale(r, i), e.arc(0, 0, 1, o, a, l), e.restore();
											  })(e, t.x, t.y, Math.abs(s - r) * t.ovalScalar, Math.abs(o - i) * t.ovalScalar, (Math.PI / 10) * t.wobble, 0, 2 * Math.PI)
										: (e.moveTo(Math.floor(t.x), Math.floor(t.y)), e.lineTo(Math.floor(t.wobbleX), Math.floor(i)), e.lineTo(Math.floor(s), Math.floor(o)), e.lineTo(Math.floor(r), Math.floor(t.wobbleY))),
									e.closePath(),
									e.fill(),
									t.tick < t.totalTicks
								);
							})(h, e);
						})).length
							? (l = v.frame(t))
							: a();
				})),
					(u = a);
			});
		return {
			addFettis: function (e) {
				return (c = c.concat(e)), d;
			},
			canvas: e,
			promise: d,
			reset: function () {
				l && v.cancel(l), u && u();
			}
		};
	}
	function k(e, n) {
		var r,
			i = !e,
			o = !!b(n || {}, "resize"),
			l = b(n, "disableForReducedMotion", Boolean),
			u = s && !!b(n || {}, "useWorker") ? g() : null,
			c = i ? S : E,
			h = !(!e || !u) && !!e.__confetti_initialized,
			d = "function" == typeof matchMedia && matchMedia("(prefers-reduced-motion)").matches;
		function p(t, n, i) {
			for (
				var s,
					o,
					a,
					l,
					u,
					h = b(t, "particleCount", x),
					d = b(t, "angle", Number),
					p = b(t, "spread", Number),
					f = b(t, "startVelocity", Number),
					m = b(t, "decay", Number),
					v = b(t, "gravity", Number),
					g = b(t, "drift", Number),
					y = b(t, "colors", w),
					_ = b(t, "ticks", Number),
					C = b(t, "shapes"),
					S = b(t, "scalar"),
					E = (function (e) {
						var t = b(e, "origin", Object);
						return (t.x = b(t, "x", Number)), (t.y = b(t, "y", Number)), t;
					})(t),
					k = h,
					A = [],
					M = e.width * E.x,
					I = e.height * E.y;
				k--;

			)
				A.push(
					((s = { x: M, y: I, angle: d, spread: p, startVelocity: f, color: y[k % y.length], shape: C[((l = 0), (u = C.length), Math.floor(Math.random() * (u - l)) + l)], ticks: _, decay: m, gravity: v, drift: g, scalar: S }),
					(o = void 0),
					(a = void 0),
					(o = s.angle * (Math.PI / 180)),
					(a = s.spread * (Math.PI / 180)),
					{
						x: s.x,
						y: s.y,
						wobble: 10 * Math.random(),
						velocity: 0.5 * s.startVelocity + Math.random() * s.startVelocity,
						angle2D: -o + (0.5 * a - Math.random() * a),
						tiltAngle: Math.random() * Math.PI,
						color: s.color,
						shape: s.shape,
						tick: 0,
						totalTicks: s.ticks,
						decay: s.decay,
						drift: s.drift,
						random: Math.random() + 5,
						tiltSin: 0,
						tiltCos: 0,
						wobbleX: 0,
						wobbleY: 0,
						gravity: 3 * s.gravity,
						ovalScalar: 0.6,
						scalar: s.scalar
					})
				);
			return r ? r.addFettis(A) : (r = T(e, A, c, n, i)).promise;
		}
		function f(n) {
			var s = l || b(n, "disableForReducedMotion", Boolean),
				f = b(n, "zIndex", Number);
			if (s && d)
				return a(function (e) {
					e();
				});
			i && r
				? (e = r.canvas)
				: i &&
				  !e &&
				  ((e = (function (e) {
						var t = document.createElement("canvas");
						return (t.style.position = "fixed"), (t.style.top = "0px"), (t.style.left = "0px"), (t.style.pointerEvents = "none"), (t.style.zIndex = e), t;
				  })(f)),
				  document.body.appendChild(e)),
				o && !h && c(e);
			var m = { width: e.width, height: e.height };
			function v() {
				if (u) {
					var t = {
						getBoundingClientRect: function () {
							if (!i) return e.getBoundingClientRect();
						}
					};
					return c(t), void u.postMessage({ resize: { width: t.width, height: t.height } });
				}
				m.width = m.height = null;
			}
			function g() {
				(r = null), o && t.removeEventListener("resize", v), i && e && (document.body.removeChild(e), (e = null), (h = !1));
			}
			return u && !h && u.init(e), (h = !0), u && (e.__confetti_initialized = !0), o && t.addEventListener("resize", v, !1), u ? u.fire(n, m, g) : p(n, m, g);
		}
		return (
			(f.reset = function () {
				u && u.reset(), r && r.reset();
			}),
			f
		);
	}
	(n.exports = k(null, { useWorker: !0, resize: !0 })), (n.exports.create = k);
})(
	(function () {
		return "undefined" != typeof window ? window : "undefined" != typeof self ? self : this || {};
	})(),
	P8,
	!1
);
var N8 = P8.exports,
	D8 = P8.exports.create,
	B8 = Object.freeze(Object.defineProperty({ __proto__: null, default: N8, create: D8 }, Symbol.toStringTag, { value: "Module" })),
	F8 = {
		zh: {
			hint: "点击，或拖动图片至此处",
			loading: "正在上传……",
			noSupported: "浏览器不支持该功能，请使用IE10以上或其他现在浏览器！",
			success: "上传成功",
			fail: "图片上传失败",
			preview: "头像预览",
			btn: { off: "取消", close: "关闭", back: "上一步", save: "保存" },
			error: { onlyImg: "仅限图片格式", outOfSize: "单文件大小不能超过 ", lowestPx: "图片最低像素为（宽*高）：" }
		},
		"zh-tw": {
			hint: "點擊，或拖動圖片至此處",
			loading: "正在上傳……",
			noSupported: "瀏覽器不支持該功能，請使用IE10以上或其他現代瀏覽器！",
			success: "上傳成功",
			fail: "圖片上傳失敗",
			preview: "頭像預覽",
			btn: { off: "取消", close: "關閉", back: "上一步", save: "保存" },
			error: { onlyImg: "僅限圖片格式", outOfSize: "單文件大小不能超過 ", lowestPx: "圖片最低像素為（寬*高）：" }
		},
		en: {
			hint: "Click or drag the file here to upload",
			loading: "Uploading…",
			noSupported: "Browser is not supported, please use IE10+ or other browsers",
			success: "Upload success",
			fail: "Upload failed",
			preview: "Preview",
			btn: { off: "Cancel", close: "Close", back: "Back", save: "Save" },
			error: { onlyImg: "Image only", outOfSize: "Image exceeds size limit: ", lowestPx: "Image's size is too low. Expected at least: " }
		},
		ro: {
			hint: "Atinge sau trage fișierul aici",
			loading: "Se încarcă",
			noSupported: "Browser-ul tău nu suportă acest feature. Te rugăm încearcă cu alt browser.",
			success: "S-a încărcat cu succes",
			fail: "A apărut o problemă la încărcare",
			preview: "Previzualizează",
			btn: { off: "Anulează", close: "Închide", back: "Înapoi", save: "Salvează" },
			error: { onlyImg: "Doar imagini", outOfSize: "Imaginea depășește limita de: ", loewstPx: "Imaginea este prea mică; Minim: " }
		},
		ru: {
			hint: "Нажмите, или перетащите файл в это окно",
			loading: "Загружаю……",
			noSupported: "Ваш браузер не поддерживается, пожалуйста, используйте IE10 + или другие браузеры",
			success: "Загрузка выполнена успешно",
			fail: "Ошибка загрузки",
			preview: "Предпросмотр",
			btn: { off: "Отменить", close: "Закрыть", back: "Назад", save: "Сохранить" },
			error: { onlyImg: "Только изображения", outOfSize: "Изображение превышает предельный размер: ", lowestPx: "Минимальный размер изображения: " }
		},
		"pt-br": {
			hint: "Clique ou arraste o arquivo aqui para carregar",
			loading: "Carregando...",
			noSupported: "Browser não suportado, por favor utilize o Internet Explorer 10+ ou outro browser",
			success: "Imagem carregada com sucesso",
			fail: "Ocorreu um erro ao carregar a imagem",
			preview: "Pré-visualização",
			btn: { off: "Cancelar", close: "Fechar", back: "Voltar", save: "Salvar" },
			error: { onlyImg: "Por favor envie apenas imagens", outOfSize: "A imagem excede o limite de tamanho suportado: ", lowestPx: "O tamanho da imagem é muito pequeno. Tamanho mínimo: " }
		},
		"pt-pt": {
			hint: "Clique ou arraste o arquivo para a janela para carregar",
			loading: "A processar...",
			noSupported: "Browser não suportado, por favor utilize o Internet Explorer 10+ ou outro browser",
			success: "Imagem carregada com sucesso",
			fail: "Ocorreu um erro ao carregar a imagem",
			preview: "Pré-visualização",
			btn: { off: "Cancelar", close: "Fechar", back: "Voltar", save: "Guardar" },
			error: { onlyImg: "Por favor envie apenas imagens", outOfSize: "A imagem excede o limite de tamanho suportado: ", lowestPx: "O tamanho da imagem é muito pequeno. Tamanho mínimo: " }
		},
		fr: {
			hint: "Cliquez ou glissez le fichier ici.",
			loading: "Téléchargement…",
			noSupported: "Votre navigateur n'est pas supporté. Utilisez IE10 + ou un autre navigateur s'il vous plaît.",
			success: "Téléchargement réussi",
			fail: "Téléchargement echoué",
			preview: "Aperçu",
			btn: { off: "Annuler", close: "Fermer", back: "Retour", save: "Enregistrer" },
			error: { onlyImg: "Image uniquement", outOfSize: "L'image sélectionnée dépasse la taille maximum: ", lowestPx: "L'image sélectionnée est trop petite. Dimensions attendues: " }
		},
		nl: {
			hint: "Klik hier of sleep een afbeelding in dit vlak",
			loading: "Uploaden…",
			noSupported: "Je browser wordt helaas niet ondersteund. Gebruik IE10+ of een andere browser.",
			success: "Upload succesvol",
			fail: "Upload mislukt",
			preview: "Voorbeeld",
			btn: { off: "Annuleren", close: "Sluiten", back: "Terug", save: "Opslaan" },
			error: { onlyImg: "Alleen afbeeldingen", outOfSize: "De afbeelding is groter dan: ", lowestPx: "De afbeelding is te klein! Minimale afmetingen: " }
		},
		tr: {
			hint: "Tıkla veya yüklemek istediğini buraya sürükle",
			loading: "Yükleniyor…",
			noSupported: "Tarayıcı desteklenmiyor, lütfen IE10+ veya farklı tarayıcı kullanın",
			success: "Yükleme başarılı",
			fail: "Yüklemede hata oluştu",
			preview: "Önizle",
			btn: { off: "İptal", close: "Kapat", back: "Geri", save: "Kaydet" },
			error: { onlyImg: "Sadece resim", outOfSize: "Resim yükleme limitini aşıyor: ", lowestPx: "Resmin boyutu çok küçük. En az olması gereken: " }
		},
		"es-MX": {
			hint: "Selecciona o arrastra una imagen",
			loading: "Subiendo...",
			noSupported: "Tu navegador no es soportado, por favor usa IE10+ u otros navegadores más recientes",
			success: "Subido exitosamente",
			fail: "Sucedió un error",
			preview: "Vista previa",
			btn: { off: "Cancelar", close: "Cerrar", back: "Atrás", save: "Guardar" },
			error: { onlyImg: "Únicamente imágenes", outOfSize: "La imagen excede el tamaño maximo:", lowestPx: "La imagen es demasiado pequeña. Se espera por lo menos:" }
		},
		de: {
			hint: "Klick hier oder zieh eine Datei hier rein zum Hochladen",
			loading: "Hochladen…",
			noSupported: "Browser wird nicht unterstützt, bitte verwende IE10+ oder andere Browser",
			success: "Upload erfolgreich",
			fail: "Upload fehlgeschlagen",
			preview: "Vorschau",
			btn: { off: "Abbrechen", close: "Schließen", back: "Zurück", save: "Speichern" },
			error: { onlyImg: "Nur Bilder", outOfSize: "Das Bild ist zu groß: ", lowestPx: "Das Bild ist zu klein. Mindestens: " }
		},
		ja: {
			hint: "クリック・ドラッグしてファイルをアップロード",
			loading: "アップロード中...",
			noSupported: "このブラウザは対応されていません。IE10+かその他の主要ブラウザをお使いください。",
			success: "アップロード成功",
			fail: "アップロード失敗",
			preview: "プレビュー",
			btn: { off: "キャンセル", close: "閉じる", back: "戻る", save: "保存" },
			error: { onlyImg: "画像のみ", outOfSize: "画像サイズが上限を超えています。上限: ", lowestPx: "画像が小さすぎます。最小サイズ: " }
		},
		ua: {
			hint: "Натисніть, або перетягніть файл в це вікно",
			loading: "Завантажую……",
			noSupported: "Ваш браузер не підтримується, будь ласка скористайтесь IE10 + або іншими браузерами",
			success: "Завантаження виконано успішно",
			fail: "Помилка завантаження",
			preview: "Попередній перегляд",
			btn: { off: "Відмінити", close: "Закрити", back: "Назад", save: "Зберегти" },
			error: { onlyImg: "Тільки зображення", outOfSize: "Зображення перевищує граничний розмір: ", lowestPx: "Мінімальний розмір зображення: " }
		},
		it: {
			hint: "Clicca o trascina qui il file per caricarlo",
			loading: "Caricamento del file…",
			noSupported: "Browser non supportato, per favore usa IE10+ o un altro browser",
			success: "Caricamento completato",
			fail: "Caricamento fallito",
			preview: "Anteprima",
			btn: { off: "Annulla", close: "Chiudi", back: "Indietro", save: "Salva" },
			error: { onlyImg: "Sono accettate solo immagini", outOfSize: "L'immagine eccede i limiti di dimensione: ", lowestPx: "L'immagine è troppo piccola. Il requisito minimo è: " }
		},
		ar: {
			hint: "اضغط أو اسحب الملف هنا للتحميل",
			loading: "جاري التحميل...",
			noSupported: "المتصفح غير مدعوم ، يرجى استخدام IE10 + أو متصفح أخر",
			success: "تم التحميل بنجاح",
			fail: "فشل التحميل",
			preview: "معاينه",
			btn: { off: "إلغاء", close: "إغلاق", back: "رجوع", save: "حفظ" },
			error: { onlyImg: "صور فقط", outOfSize: "تتجاوز الصوره الحجم المحدد: ", lowestPx: "حجم الصورة صغير جدا. من المتوقع على الأقل: " }
		},
		ug: {
			hint: "مەزكۇر دائىرىنى چىكىپ رەسىم تاللاڭ ياكى رەسىمنى سۆرەپ ئەكىرىڭ",
			loading: "يوللىنىۋاتىدۇ...",
			noSupported: "تور كۆرگۈچ بۇ ئىقتىدارنى قوللىمايدۇ ، يۇقىرى نەشىردىكى تور كۆرگۈچنى ئىشلىتىڭ",
			success: "غەلبىلىك بولدى",
			fail: "مەغلۇب بولدى",
			preview: "ئۈنۈم رەسىم",
			btn: { off: "بولدى قىلىش", close: "تاقاش", back: "ئالدىنقى قەدەم", save: "ساقلاش" },
			error: { onlyImg: "پەقەت رەسىم فورماتىنىلا قوللايدۇ", outOfSize: "رەسىم چوڭ - كىچىكلىكى چەكتىن ئىشىپ كەتتى", lowestPx: "رەسىمنىڭ ئەڭ كىچىك ئۆلچىمى :" }
		},
		th: {
			hint: "คลิ๊กหรือลากรูปมาที่นี่",
			loading: "กำลังอัพโหลด…",
			noSupported: "เบราเซอร์ไม่รองรับ, กรุณาใช้ IE เวอร์ชั่น 10 ขึ้นไป หรือใช้เบราเซอร์ตัวอื่น",
			success: "อัพโหลดสำเร็จ",
			fail: "อัพโหลดล้มเหลว",
			preview: "ตัวอย่าง",
			btn: { off: "ยกเลิก", close: "ปิด", back: "กลับ", save: "บันทึก" },
			error: { onlyImg: "ไฟล์ภาพเท่านั้น", outOfSize: "ไฟล์ใหญ่เกินกำหนด: ", lowestPx: "ไฟล์เล็กเกินไป. อย่างน้อยต้องมีขนาด: " }
		},
		mm: {
			hint: "ဖိုင်ကို ဤနေရာတွင် နှိပ်၍ (သို့) ဆွဲထည့်၍ တင်ပါ",
			loading: "တင်နေသည်…",
			noSupported: "ဤဘရောက်ဇာကို အထောက်အပံ့ မပေးပါ၊ ကျေးဇူးပြု၍ IE10+ သို့မဟုတ် အခြား ဘရောက်ဇာ ကို အသုံးပြုပါ",
			success: "ဖိုင်တင်နေမှု မပြီးမြောက်ပါ",
			fail: "ဖိုင်တင်နေမှု မအောင်မြင်ပါ",
			preview: "အစမ်းကြည့်",
			btn: { off: "မလုပ်တော့ပါ", close: "ပိတ်မည်", back: "နောက်သို့", save: "သိမ်းမည်" },
			error: { onlyImg: "ဓာတ်ပုံ သီးသန့်သာ", outOfSize: "ဓာတ်ပုံဆိုဒ် ကြီးလွန်းသည် ။ အများဆုံး ဆိုဒ် : ", lowestPx: "ဓာတ်ပုံဆိုဒ် သေးလွန်းသည်။ အနည်းဆုံး ဆိုဒ် : " }
		},
		se: {
			hint: "Klicka eller dra en fil hit för att ladda upp den",
			loading: "Laddar upp…",
			noSupported: "Din webbläsare stöds inte, vänligen använd IE10+ eller andra webbläsare",
			success: "Uppladdning lyckades",
			fail: "Uppladdning misslyckades",
			preview: "Förhandsgranska",
			btn: { off: "Avbryt", close: "Stäng", back: "Tillbaka", save: "Spara" },
			error: { onlyImg: "Endast bilder", outOfSize: "Bilden är större än max-gränsen: ", lowestPx: "Bilden är för liten. Minimum är: " }
		},
		pl: {
			hint: "Kliknij lub upuść plik tutaj",
			loading: "Wgrywanie…",
			noSupported: "Twoja przeglądarka nie jest wspierana, użyj IE10+ lub innej przeglądarki",
			success: "Błąd",
			fail: "Sukces",
			preview: "Podgląd",
			btn: { off: "Anuluj", close: "Zamknij", back: "Wstecz", save: "Zapisz" },
			error: { onlyImg: "Tylko obrazki", outOfSize: "Rozmiar obrazka przekracza: ", lowestPx: "Obrazek jest za mały. Minimalne wymiary to: " }
		},
		vi: {
			hint: "Bấm hoặc kéo thả file để tải lên",
			loading: "Đang tải lên...",
			noSupported: "Trình duyệt không hỗ trợ, hãy sử dụng IE10+ hoặc trình duyệt khác",
			success: "Tải lên thành công",
			fail: "Tải lên thất bại",
			preview: "Xem trước",
			btn: { off: "Huỷ", close: "Đóng", back: "Trở lại", save: "Lưu" },
			error: { onlyImg: "Chỉ hình ảnh", outOfSize: "Hình ảnh vượt quá giới hạn cho phép: ", lowestPx: "Kích thước hình quá nhỏ. Kích thước tối thiểu: " }
		},
		fa: {
			hint: "برای بارگذاری تصویر کلیک کنید یا تصویر را به این ناحیه درگ کنید",
			loading: "در حال بارگذاری ...",
			noSupported: "نسخه یا نوع مرورگر شما از این قابلیت پشتیبانی نمیکند. لطفا از اینترنت اکسپلورر ورژن بالاتر از ده یا مرورگرهای دیگر استفاده کنید",
			success: "بارگذاری با موفقیت انجام شد",
			fail: "بارگذاری انجام نشد",
			preview: "پیشنمایش",
			btn: { off: "لغو", close: "بستن", back: "بازگشت", save: "ذخیره" },
			error: { onlyImg: "فقط تصویر", outOfSize: "حجم تصویر بیش از اندازه‌ی مجاز است: ", lowestPx: "حجم تصویر بسیار پایین است، حداقل سایز تصویر: " }
		},
		da: {
			hint: "Klik eller træk en fil herhen for at uploade",
			loading: "Uploader…",
			noSupported: "Din browser er ikke understøttet, benyt venligst IE10+ eller en anden browser",
			success: "Upload lykkedes",
			fail: "Upload mislykkedes",
			preview: "Preview",
			btn: { off: "Fortryd", close: "Luk", back: "Tilbage", save: "Gem" },
			error: { onlyImg: "Kun billeder", outOfSize: "Billedet overskrider størrelsesgrænsen: ", lowestPx: "Billedet er for lille. Minimumsstørrelsen er: " }
		},
		ko: {
			hint: "클릭 또는 드래그하여 이미지를 업로드하세요.",
			loading: "업로드 중…",
			noSupported: "죄송합니다, 인터넷 익스플로러 버전 10 이상 혹은 다른 브라우저를 사용해주세요.",
			success: "업로드 성공",
			fail: "업로드 실패",
			preview: "미리보기",
			btn: { off: "취소", close: "닫기", back: "뒤로가기", save: "저장" },
			error: { onlyImg: "이미지만 업로드 할 수 있습니다.", outOfSize: "업로드 할 수 있는 최대 이미지 사이즈를 초과했습니다: ", lowestPx: "이미지의 크기는 적어도 다음 사이즈보다 커야 합니다: " }
		}
	},
	H8 = { jpg: "image/jpeg", png: "image/png", gif: "image/gif", svg: "image/svg+xml", psd: "image/photoshop" };
const V8 = {
		props: {
			field: { type: String, default: "avatar" },
			ki: { type: String, default: "0" },
			modelValue: { type: Boolean, default: !0 },
			url: { type: String, default: "" },
			params: { type: Object, default: () => null },
			headers: { type: Object, default: () => null },
			width: { type: Number, default: 200 },
			height: { type: Number, default: 200 },
			noRotate: { type: Boolean, default: !0 },
			noCircle: { type: Boolean, default: !1 },
			noSquare: { type: Boolean, default: !1 },
			maxSize: { type: Number, default: 10240 },
			langType: { type: String, default: "zh" },
			langExt: { type: Object, default: () => null },
			imgFormat: { type: String, default: "png" },
			imgBgc: { type: String, default: "#fff" },
			withCredentials: { type: Boolean, default: !1 },
			method: { type: String, default: "POST" },
			initialImgUrl: { type: String, default: "" },
			allowImgFormat: { type: Array, default: () => ["gif", "jpg", "png"] }
		},
		data() {
			let { imgFormat: e, allowImgFormat: t, langType: n, langExt: r, width: i, height: s } = this,
				o = !0,
				a = -1 === t.indexOf(e) ? "jpg" : e,
				l = F8[n] ? F8[n] : F8.en,
				u = H8[a];
			return (
				r && Object.assign(l, r),
				"function" != typeof FormData && (o = !1),
				{
					mime: u,
					lang: l,
					isSupported: o,
					isSupportTouch: document.hasOwnProperty("ontouchstart"),
					step: 1,
					loading: 0,
					progress: 0,
					hasError: !1,
					errorMsg: "",
					ratio: i / s,
					sourceImg: null,
					sourceImgUrl: this.initialImgUrl,
					createImgUrl: this.initialImgUrl,
					sourceImgMouseDown: { on: !1, mX: 0, mY: 0, x: 0, y: 0 },
					previewContainer: { width: 100, height: 100 },
					sourceImgContainer: { width: 240, height: 184 },
					scale: { zoomAddOn: !1, zoomSubOn: !1, range: 1, x: 0, y: 0, width: 0, height: 0, maxWidth: 0, maxHeight: 0, minWidth: 0, minHeight: 0, naturalWidth: 0, naturalHeight: 0 }
				}
			);
		},
		computed: {
			progressStyle() {
				let { progress: e } = this;
				return { width: e + "%" };
			},
			sourceImgStyle() {
				let { scale: e, sourceImgMasking: t } = this;
				return { top: e.y + t.y + "px", left: e.x + t.x + "px", width: e.width + "px", height: e.height + "px" };
			},
			sourceImgMasking() {
				let { width: e, height: t, ratio: n, sourceImgContainer: r } = this,
					i = r,
					s = i.width / i.height,
					o = 0,
					a = 0,
					l = i.width,
					u = i.height,
					c = 1;
				return n < s && ((c = i.height / t), (l = i.height * n), (o = (i.width - l) / 2)), n > s && ((c = i.width / e), (u = i.width / n), (a = (i.height - u) / 2)), { scale: c, x: o, y: a, width: l, height: u };
			},
			sourceImgShadeStyle() {
				let { sourceImgMasking: e, sourceImgContainer: t } = this,
					n = t,
					r = e;
				return { width: (r.width == n.width ? r.width : (n.width - r.width) / 2) + "px", height: (r.height == n.height ? r.height : (n.height - r.height) / 2) + "px" };
			},
			previewStyle() {
				let { width: e, height: t, ratio: n, previewContainer: r } = this,
					i = r,
					s = i.width,
					o = i.height,
					a = s / o;
				return n < a && (s = i.height * n), n > a && (o = i.width / n), { width: s + "px", height: o + "px" };
			}
		},
		watch: {
			modelValue(e) {
				e && 1 != this.loading && this.reset();
			}
		},
		created() {
			document.addEventListener("keyup", this.handleEscClose);
		},
		beforeUnmount() {
			document.removeEventListener("keyup", this.handleEscClose);
		},
		mounted() {
			this.sourceImgUrl && this.startCrop();
		},
		methods: {
			handleEscClose(e) {
				!this.modelValue || ("Escape" != e.key && 27 != e.keyCode) || this.off();
			},
			ripple(e) {
				!(function (e, t) {
					var n = Object.assign({ ele: e.target, type: "hit", bgc: "rgba(0, 0, 0, 0.15)" }, t),
						r = n.ele;
					if (r) {
						var i = r.getBoundingClientRect(),
							s = r.querySelector(".e-ripple");
						switch ((s ? (s.className = "e-ripple") : (((s = document.createElement("span")).className = "e-ripple"), (s.style.height = s.style.width = Math.max(i.width, i.height) + "px"), r.appendChild(s)), n.type)) {
							case "center":
								(s.style.top = i.height / 2 - s.offsetHeight / 2 + "px"), (s.style.left = i.width / 2 - s.offsetWidth / 2 + "px");
								break;
							default:
								(s.style.top = e.pageY - i.top - s.offsetHeight / 2 - document.body.scrollTop + "px"), (s.style.left = e.pageX - i.left - s.offsetWidth / 2 - document.body.scrollLeft + "px");
						}
						(s.style.backgroundColor = n.bgc), (s.className = "e-ripple z-active");
					}
				})(e);
			},
			off() {
				setTimeout(() => {
					this.$emit("update:modelValue", !1), 3 == this.step && 2 == this.loading && this.setStep(1);
				}, 200);
			},
			setStep(e) {
				setTimeout(() => {
					this.step = e;
				}, 200);
			},
			preventDefault: (e) => (e.preventDefault(), !1),
			handleClick(e) {
				1 !== this.loading && e.target !== this.$refs.fileinput && (e.preventDefault(), document.activeElement !== this.$refs && this.$refs.fileinput.click());
			},
			handleChange(e) {
				if ((e.preventDefault(), 1 !== this.loading)) {
					let t = e.target.files || e.dataTransfer.files;
					this.reset(), this.checkFile(t[0]) && this.setSourceImg(t[0]);
				}
			},
			checkFile(e) {
				let t = this,
					{ lang: n, maxSize: r } = t;
				return -1 === e.type.indexOf("image") ? ((t.hasError = !0), (t.errorMsg = n.error.onlyImg), !1) : !(e.size / 1024 > r) || ((t.hasError = !0), (t.errorMsg = n.error.outOfSize + r + "kb"), !1);
			},
			reset() {
				let e = this;
				(e.loading = 0), (e.hasError = !1), (e.errorMsg = ""), (e.progress = 0);
			},
			setSourceImg(e) {
				this.$emit("src-file-set", e.name, e.type, e.size);
				let t = this,
					n = new FileReader();
				(n.onload = function (e) {
					(t.sourceImgUrl = n.result), t.startCrop();
				}),
					n.readAsDataURL(e);
			},
			startCrop() {
				let e = this,
					{ width: t, height: n, ratio: r, scale: i, sourceImgUrl: s, sourceImgMasking: o, lang: a } = e,
					l = o,
					u = new Image();
				(u.src = s),
					(u.onload = function () {
						let t = u.naturalWidth,
							n = u.naturalHeight,
							s = t / n,
							o = l.width,
							a = l.height,
							c = 0,
							h = 0;
						r > s && ((a = o / s), (h = (l.height - a) / 2)),
							r < s && ((o = a * s), (c = (l.width - o) / 2)),
							(i.range = 0),
							(i.x = c),
							(i.y = h),
							(i.width = o),
							(i.height = a),
							(i.minWidth = o),
							(i.minHeight = a),
							(i.maxWidth = t * l.scale),
							(i.maxHeight = n * l.scale),
							(i.naturalWidth = t),
							(i.naturalHeight = n),
							(e.sourceImg = u),
							e.createImg(),
							e.setStep(2);
					});
			},
			imgStartMove(e) {
				if ((e.preventDefault(), this.isSupportTouch && !e.targetTouches)) return !1;
				let t = e.targetTouches ? e.targetTouches[0] : e,
					{ sourceImgMouseDown: n, scale: r } = this,
					i = n;
				(i.mX = t.screenX), (i.mY = t.screenY), (i.x = r.x), (i.y = r.y), (i.on = !0);
			},
			imgMove(e) {
				if ((e.preventDefault(), this.isSupportTouch && !e.targetTouches)) return !1;
				let t = e.targetTouches ? e.targetTouches[0] : e,
					{
						sourceImgMouseDown: { on: n, mX: r, mY: i, x: s, y: o },
						scale: a,
						sourceImgMasking: l
					} = this,
					u = l,
					c = s + (t.screenX - r),
					h = o + (t.screenY - i);
				n && (c > 0 && (c = 0), h > 0 && (h = 0), c < u.width - a.width && (c = u.width - a.width), h < u.height - a.height && (h = u.height - a.height), (a.x = c), (a.y = h));
			},
			rotateImg(e) {
				let {
						sourceImg: t,
						scale: { naturalWidth: n, naturalHeight: r }
					} = this,
					i = r,
					s = n,
					o = this.$refs.canvas,
					a = o.getContext("2d");
				(o.width = i), (o.height = s), a.clearRect(0, 0, i, s), (a.fillStyle = "rgba(0,0,0,0)"), a.fillRect(0, 0, i, s), a.translate(i, 0), a.rotate((90 * Math.PI) / 180), a.drawImage(t, 0, 0, n, r);
				let l = o.toDataURL(H8.png);
				(this.sourceImgUrl = l), this.startCrop();
			},
			handleMouseWheel(e) {
				e = e || window.event;
				let { scale: t } = this;
				e.wheelDelta
					? (e.wheelDelta > 0 && this.zoomImg(t.range >= 100 ? 100 : ++t.range), e.wheelDelta < 0 && this.zoomImg(t.range <= 0 ? 0 : --t.range))
					: e.detail && (e.detail > 0 && this.zoomImg(t.range >= 100 ? 100 : ++t.range), e.detail < 0 && this.zoomImg(t.range <= 0 ? 0 : --t.range));
			},
			startZoomAdd(e) {
				let t = this,
					{ scale: n } = t;
				(n.zoomAddOn = !0),
					(function e() {
						if (n.zoomAddOn) {
							let r = n.range >= 100 ? 100 : ++n.range;
							t.zoomImg(r),
								setTimeout(function () {
									e();
								}, 60);
						}
					})();
			},
			endZoomAdd(e) {
				this.scale.zoomAddOn = !1;
			},
			startZoomSub(e) {
				let t = this,
					{ scale: n } = t;
				(n.zoomSubOn = !0),
					(function e() {
						if (n.zoomSubOn) {
							let r = n.range <= 0 ? 0 : --n.range;
							t.zoomImg(r),
								setTimeout(function () {
									e();
								}, 60);
						}
					})();
			},
			endZoomSub(e) {
				let { scale: t } = this;
				t.zoomSubOn = !1;
			},
			zoomChange(e) {
				this.zoomImg(e.target.value);
			},
			zoomImg(e) {
				let t = this,
					{ sourceImgMasking: n, sourceImgMouseDown: r, scale: i } = this,
					{ maxWidth: s, maxHeight: o, minWidth: a, minHeight: l, width: u, height: c, x: h, y: d, range: p } = i,
					f = n,
					m = f.width,
					v = f.height,
					g = a + ((s - a) * e) / 100,
					y = l + ((o - l) * e) / 100,
					b = m / 2 - (g / u) * (m / 2 - h),
					x = v / 2 - (y / c) * (v / 2 - d);
				b > 0 && (b = 0),
					x > 0 && (x = 0),
					b < m - g && (b = m - g),
					x < v - y && (x = v - y),
					(i.x = b),
					(i.y = x),
					(i.width = g),
					(i.height = y),
					(i.range = e),
					setTimeout(function () {
						i.range == e && t.createImg();
					}, 300);
			},
			createImg(e) {
				let t = this,
					{
						imgFormat: n,
						imgBgc: r,
						mime: i,
						sourceImg: s,
						scale: { x: o, y: a, width: l, height: u },
						sourceImgMasking: { scale: c }
					} = t,
					h = t.$refs.canvas,
					d = h.getContext("2d");
				e && (t.sourceImgMouseDown.on = !1), (h.width = t.width), (h.height = t.height), d.clearRect(0, 0, t.width, t.height), (d.fillStyle = "png" == n ? "rgba(0,0,0,0)" : r), d.fillRect(0, 0, t.width, t.height), d.drawImage(s, o / c, a / c, l / c, u / c), (t.createImgUrl = h.toDataURL(i));
			},
			prepareUpload() {
				this.createImgUrl = this.sourceImgUrl;
				let { url: e, createImgUrl: t, field: n, ki: r } = this;
				this.$emit("crop-success", t, n, r), "string" == typeof e && e ? this.upload() : this.off();
			},
			upload() {
				let e = this,
					{ lang: t, imgFormat: n, mime: r, url: i, params: s, headers: o, field: a, ki: l, createImgUrl: u, withCredentials: c, method: h } = this,
					d = new FormData();
				"object" == typeof s &&
					s &&
					Object.keys(s).forEach((e) => {
						d.append(e, s[e]);
					}),
					d.append(
						a,
						(function (e, t) {
							(e = e.split(",")[1]), (e = window.atob(e));
							for (var n = new Uint8Array(e.length), r = 0; r < e.length; r++) n[r] = e.charCodeAt(r);
							return new Blob([n], { type: t });
						})(u, r),
						a + "." + n
					);
				const p = function (t) {
					t.lengthComputable && (e.progress = (100 * Math.round(t.loaded)) / t.total);
				};
				e.reset(),
					(e.loading = 1),
					e.setStep(3),
					new Promise(function (e, t) {
						let n = new XMLHttpRequest();
						n.open(h, i, !0),
							(n.withCredentials = c),
							(n.onreadystatechange = function () {
								4 === this.readyState && (200 === this.status || 201 === this.status || 202 === this.staus ? e(JSON.parse(this.responseText)) : t(this.status));
							}),
							n.upload.addEventListener("progress", p, !1),
							"object" == typeof o &&
								o &&
								Object.keys(o).forEach((e) => {
									n.setRequestHeader(e, o[e]);
								}),
							n.send(d);
					}).then(
						function (t) {
							e.modelValue && ((e.loading = 2), e.$emit("crop-upload-success", t, a, l));
						},
						function (n) {
							e.modelValue && ((e.loading = 3), (e.hasError = !0), (e.errorMsg = t.fail), e.$emit("crop-upload-fail", n, a, l));
						}
					);
			}
		}
	},
	U8 = { class: "vue-image-crop-upload" },
	z8 = { class: "vicp-wrap" },
	$8 = [ni("i", { class: "vicp-icon4" }, null, -1)],
	j8 = { class: "vicp-step1" },
	W8 = { class: "vicp-icon1" },
	G8 = [ni("i", { class: "vicp-icon1-arrow" }, null, -1), ni("i", { class: "vicp-icon1-body" }, null, -1), ni("i", { class: "vicp-icon1-bottom" }, null, -1)],
	Y8 = { class: "vicp-error" },
	X8 = ni("i", { class: "vicp-icon2" }, null, -1),
	K8 = { class: "vicp-operate" },
	q8 = { key: 0, class: "vicp-step2" },
	Z8 = { class: "vicp-crop" },
	J8 = { class: "vicp-crop-left" },
	Q8 = ["src"],
	e7 = { class: "vicp-range" },
	t7 = { key: 0, class: "vicp-rotate" },
	n7 = { class: "vicp-crop-right" },
	r7 = { class: "vicp-preview" },
	i7 = { key: 0, class: "vicp-preview-item" },
	s7 = ["src"],
	o7 = { key: 1, class: "vicp-preview-item vicp-preview-item-circle" },
	a7 = ["src"],
	l7 = { class: "vicp-operate" },
	u7 = { key: 1, class: "vicp-step3" },
	c7 = { class: "vicp-upload" },
	h7 = { class: "vicp-progress-wrap" },
	d7 = { class: "vicp-error" },
	p7 = ni("i", { class: "vicp-icon2" }, null, -1),
	f7 = { class: "vicp-success" },
	m7 = ni("i", { class: "vicp-icon3" }, null, -1),
	v7 = { class: "vicp-operate" },
	g7 = ["width", "height"];
V8.render = function (e, t, n, r, i, s) {
	return yr(
		(Wr(),
		Kr(
			"div",
			U8,
			[
				ni("div", z8, [
					ni("div", { class: "vicp-close", onClick: t[0] || (t[0] = (...e) => s.off && s.off(...e)) }, $8),
					yr(
						ni(
							"div",
							j8,
							[
								ni(
									"div",
									{
										class: "vicp-drop-area",
										onDragleave: t[2] || (t[2] = (...e) => s.preventDefault && s.preventDefault(...e)),
										onDragover: t[3] || (t[3] = (...e) => s.preventDefault && s.preventDefault(...e)),
										onDragenter: t[4] || (t[4] = (...e) => s.preventDefault && s.preventDefault(...e)),
										onClick: t[5] || (t[5] = (...e) => s.handleClick && s.handleClick(...e)),
										onDrop: t[6] || (t[6] = (...e) => s.handleChange && s.handleChange(...e))
									},
									[
										yr(ni("i", W8, G8, 512), [[Wo, 1 != i.loading]]),
										yr(ni("span", { class: "vicp-hint" }, bt(i.lang.hint), 513), [[Wo, 1 !== i.loading]]),
										yr(ni("span", { class: "vicp-no-supported-hint" }, bt(i.lang.noSupported), 513), [[Wo, !i.isSupported]]),
										1 == i.step ? yr((Wr(), Kr("input", { key: 0, type: "file", accept: "image/*", onChange: t[1] || (t[1] = (...e) => s.handleChange && s.handleChange(...e)), ref: "fileinput" }, null, 544)), [[Wo, !1]]) : ai("", !0)
									],
									32
								),
								yr(ni("div", Y8, [X8, oi(" " + bt(i.errorMsg), 1)], 512), [[Wo, i.hasError]]),
								ni("div", K8, [ni("a", { onClick: t[7] || (t[7] = (...e) => s.off && s.off(...e)), onMousedown: t[8] || (t[8] = (...e) => s.ripple && s.ripple(...e)) }, bt(i.lang.btn.off), 33)])
							],
							512
						),
						[[Wo, 1 == i.step]]
					),
					2 == i.step
						? (Wr(),
						  Kr("div", q8, [
								ni("div", Z8, [
									yr(
										ni(
											"div",
											J8,
											[
												ni(
													"div",
													{ class: "vicp-img-container", onWheel: t[24] || (t[24] = zo((...e) => s.handleMouseWheel && s.handleMouseWheel(...e), ["prevent"])) },
													[
														ni(
															"img",
															{
																src: i.sourceImgUrl,
																style: pt(s.sourceImgStyle),
																class: "vicp-img",
																draggable: "false",
																onDrag: t[9] || (t[9] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDragstart: t[10] || (t[10] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDragend: t[11] || (t[11] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDragleave: t[12] || (t[12] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDragover: t[13] || (t[13] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDragenter: t[14] || (t[14] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onDrop: t[15] || (t[15] = (...e) => s.preventDefault && s.preventDefault(...e)),
																onTouchstart: t[16] || (t[16] = (...e) => s.imgStartMove && s.imgStartMove(...e)),
																onTouchmove: t[17] || (t[17] = (...e) => s.imgMove && s.imgMove(...e)),
																onTouchend: t[18] || (t[18] = (...e) => s.createImg && s.createImg(...e)),
																onTouchcancel: t[19] || (t[19] = (...e) => s.createImg && s.createImg(...e)),
																onMousedown: t[20] || (t[20] = (...e) => s.imgStartMove && s.imgStartMove(...e)),
																onMousemove: t[21] || (t[21] = (...e) => s.imgMove && s.imgMove(...e)),
																onMouseup: t[22] || (t[22] = (...e) => s.createImg && s.createImg(...e)),
																onMouseout: t[23] || (t[23] = (...e) => s.createImg && s.createImg(...e)),
																ref: "img"
															},
															null,
															44,
															Q8
														),
														ni("div", { class: "vicp-img-shade vicp-img-shade-1", style: pt(s.sourceImgShadeStyle) }, null, 4),
														ni("div", { class: "vicp-img-shade vicp-img-shade-2", style: pt(s.sourceImgShadeStyle) }, null, 4)
													],
													32
												),
												ni("div", e7, [
													yr(ni("input", { type: "range", "onUpdate:modelValue": t[25] || (t[25] = (e) => (i.scale.range = e)), step: "1", min: "0", max: "100", onMousemove: t[26] || (t[26] = (...e) => s.zoomChange && s.zoomChange(...e)) }, null, 544), [
														[Po, i.scale.range]
													]),
													ni(
														"i",
														{
															onMousedown: t[27] || (t[27] = (...e) => s.startZoomSub && s.startZoomSub(...e)),
															onMouseout: t[28] || (t[28] = (...e) => s.endZoomSub && s.endZoomSub(...e)),
															onMouseup: t[29] || (t[29] = (...e) => s.endZoomSub && s.endZoomSub(...e)),
															class: "vicp-icon5"
														},
														null,
														32
													),
													ni(
														"i",
														{
															onMousedown: t[30] || (t[30] = (...e) => s.startZoomAdd && s.startZoomAdd(...e)),
															onMouseout: t[31] || (t[31] = (...e) => s.endZoomAdd && s.endZoomAdd(...e)),
															onMouseup: t[32] || (t[32] = (...e) => s.endZoomAdd && s.endZoomAdd(...e)),
															class: "vicp-icon6"
														},
														null,
														32
													)
												]),
												n.noRotate ? ai("", !0) : (Wr(), Kr("div", t7, [ni("i", { onClick: t[33] || (t[33] = (...e) => s.rotateImg && s.rotateImg(...e)) }, "↻")]))
											],
											512
										),
										[[Wo, !0]]
									),
									yr(
										ni(
											"div",
											n7,
											[
												ni("div", r7, [
													n.noSquare ? ai("", !0) : (Wr(), Kr("div", i7, [ni("img", { src: i.createImgUrl, style: pt(s.previewStyle) }, null, 12, s7), ni("span", null, bt(i.lang.preview), 1)])),
													n.noCircle ? ai("", !0) : (Wr(), Kr("div", o7, [ni("img", { src: i.createImgUrl, style: pt(s.previewStyle) }, null, 12, a7), ni("span", null, bt(i.lang.preview), 1)]))
												])
											],
											512
										),
										[[Wo, !0]]
									)
								]),
								ni("div", l7, [
									ni("a", { onClick: t[34] || (t[34] = (e) => s.setStep(1)), onMousedown: t[35] || (t[35] = (...e) => s.ripple && s.ripple(...e)) }, bt(i.lang.btn.back), 33),
									ni("a", { class: "vicp-operate-btn", onClick: t[36] || (t[36] = (...e) => s.prepareUpload && s.prepareUpload(...e)), onMousedown: t[37] || (t[37] = (...e) => s.ripple && s.ripple(...e)) }, bt(i.lang.btn.save), 33)
								])
						  ]))
						: ai("", !0),
					3 == i.step
						? (Wr(),
						  Kr("div", u7, [
								ni("div", c7, [
									yr(ni("span", { class: "vicp-loading" }, bt(i.lang.loading), 513), [[Wo, 1 === i.loading]]),
									ni("div", h7, [yr(ni("span", { class: "vicp-progress", style: pt(s.progressStyle) }, null, 4), [[Wo, 1 === i.loading]])]),
									yr(ni("div", d7, [p7, oi(" " + bt(i.errorMsg), 1)], 512), [[Wo, i.hasError]]),
									yr(ni("div", f7, [m7, oi(" " + bt(i.lang.success), 1)], 512), [[Wo, 2 === i.loading]])
								]),
								ni("div", v7, [
									ni("a", { onClick: t[38] || (t[38] = (e) => s.setStep(2)), onMousedown: t[39] || (t[39] = (...e) => s.ripple && s.ripple(...e)) }, bt(i.lang.btn.back), 33),
									ni("a", { onClick: t[40] || (t[40] = (...e) => s.off && s.off(...e)), onMousedown: t[41] || (t[41] = (...e) => s.ripple && s.ripple(...e)) }, bt(i.lang.btn.close), 33)
								])
						  ]))
						: ai("", !0),
					yr(ni("canvas", { width: n.width, height: n.height, ref: "canvas" }, null, 8, g7), [[Wo, !1]])
				])
			],
			512
		)),
		[[Wo, n.modelValue]]
	);
};
let y7, b7;
const x7 = new Promise((e, t) => {
	(y7 = e), (b7 = t);
});
function _7(e) {
	if (window.hcaptcha) return y7(), x7;
	if (document.getElementById("hcaptcha-api-script-id")) return x7;
	window._hcaptchaOnLoad = y7;
	const t = (function (e) {
			let t = e.apiEndpoint;
			return (
				(t = w7(t, "render", "explicit")),
				(t = w7(t, "onload", "_hcaptchaOnLoad")),
				(t = w7(t, "recaptchacompat", !1 === e.reCaptchaCompat ? "off" : null)),
				(t = w7(t, "hl", e.language)),
				(t = w7(t, "sentry", e.sentry)),
				(t = w7(t, "endpoint", e.endpoint)),
				(t = w7(t, "assethost", e.assethost)),
				(t = w7(t, "imghost", e.imghost)),
				(t = w7(t, "reportapi", e.reportapi)),
				t
			);
		})(e),
		n = document.createElement("script");
	return (
		(n.id = "hcaptcha-api-script-id"),
		(n.src = t),
		(n.async = !0),
		(n.defer = !0),
		(n.onerror = (e) => {
			console.error("Failed to load api: " + t, e), b7("Failed to load api.js");
		}),
		document.head.appendChild(n),
		x7
	);
}
function w7(e, t, n) {
	if (null != n) {
		const r = e.includes("?") ? "&" : "?";
		return e + r + t + "=" + encodeURIComponent(n);
	}
	return e;
}
const C7 = {
		name: "VueHcaptcha",
		props: {
			sitekey: { type: String, required: !0 },
			theme: { type: String, default: void 0 },
			size: { type: String, default: void 0 },
			tabindex: { type: String, default: void 0 },
			language: { type: String, default: void 0 },
			reCaptchaCompat: { type: Boolean, default: !0 },
			challengeContainer: { type: String, default: void 0 },
			rqdata: { type: String, default: void 0 },
			sentry: { type: Boolean, default: !0 },
			apiEndpoint: { type: String, default: "https://hcaptcha.com/1/api.js" },
			endpoint: { type: String, default: void 0 },
			reportapi: { type: String, default: void 0 },
			assethost: { type: String, default: void 0 },
			imghost: { type: String, default: void 0 }
		},
		data: () => ({ widgetId: null, hcaptcha: null, renderedCb: null }),
		mounted() {
			return _7(this.$props).then(this.onApiLoaded).catch(this.onError);
		},
		unmounted() {
			this.teardown();
		},
		destroyed() {
			this.teardown();
		},
		methods: {
			teardown() {
				this.widgetId && (this.hcaptcha.reset(this.widgetId), this.hcaptcha.remove(this.widgetId));
			},
			onApiLoaded() {
				this.hcaptcha = window.hcaptcha;
				const e = {
					sitekey: this.sitekey,
					theme: this.theme,
					size: this.size,
					tabindex: this.tabindex,
					callback: this.onVerify,
					"expired-callback": this.onExpired,
					"chalexpired-callback": this.onChallengeExpired,
					"error-callback": this.onError,
					"open-callback": this.onOpen,
					"close-callback": this.onClose
				};
				this.challengeContainer && (e["challenge-container"] = this.challengeContainer), (this.widgetId = this.hcaptcha.render(this.$el, e)), this.rqdata && this.hcaptcha.setData(this.widgetId, { rqdata: this.rqdata }), this.onRendered();
			},
			execute() {
				this.widgetId
					? (this.hcaptcha.execute(this.widgetId), this.onExecuted())
					: (this.renderedCb = () => {
							(this.renderedCb = null), this.execute();
					  });
			},
			executeAsync() {
				if (this.widgetId) return this.onExecuted(), this.hcaptcha.execute(this.widgetId, { async: !0 });
				let e;
				const t = new Promise((t) => {
					e = t;
				});
				return (
					(this.renderedCb = () => {
						(this.renderedCb = null), e();
					}),
					t.then(this.executeAsync)
				);
			},
			reset() {
				this.widgetId ? (this.hcaptcha.reset(this.widgetId), this.onReset()) : this.$emit("error", "Element is not rendered yet and thus cannot reset it. Wait for `rendered` event to safely call reset.");
			},
			onRendered() {
				this.$emit("rendered"), this.renderedCb && this.renderedCb();
			},
			onExecuted() {
				this.$emit("executed");
			},
			onReset() {
				this.$emit("reset");
			},
			onError(e) {
				this.$emit("error", e), this.reset();
			},
			onVerify() {
				const e = this.hcaptcha.getResponse(this.widgetId),
					t = this.hcaptcha.getRespKey(this.widgetId);
				this.$emit("verify", e, t);
			},
			onExpired() {
				this.$emit("expired");
			},
			onChallengeExpired() {
				this.$emit("challengeExpired");
			},
			onOpen() {
				this.$emit("opened");
			},
			onClose() {
				this.$emit("closed");
			}
		}
	},
	S7 = { id: "hcap-script" };
var E7 = ((e, t) => {
	for (const [n, r] of t) e[n] = r;
	return e;
})(C7, [
	[
		"render",
		function (e, t, n, r, i, s) {
			return Wr(), Kr("div", S7);
		}
	]
]);
/*! Capacitor: https://capacitorjs.com/ - MIT License */ const T7 = ((e) =>
	(e.CapacitorPlatforms = ((e) => {
		const t = new Map();
		t.set("web", { name: "web" });
		const n = e.CapacitorPlatforms || { currentPlatform: { name: "web" }, platforms: t };
		return (
			(n.addPlatform = (e, t) => {
				n.platforms.set(e, t);
			}),
			(n.setPlatform = (e) => {
				n.platforms.has(e) && (n.currentPlatform = n.platforms.get(e));
			}),
			n
		);
	})(e)))("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
var k7, A7;
T7.addPlatform, T7.setPlatform, ((A7 = k7 || (k7 = {})).Unimplemented = "UNIMPLEMENTED"), (A7.Unavailable = "UNAVAILABLE");
class M7 extends Error {
	constructor(e, t) {
		super(e), (this.message = e), (this.code = t);
	}
}
const I7 = (e) => {
		var t, n, r, i, s;
		const o = e.CapacitorCustomPlatform || null,
			a = e.Capacitor || {},
			l = (a.Plugins = a.Plugins || {}),
			u = e.CapacitorPlatforms,
			c =
				(null === (t = null == u ? void 0 : u.currentPlatform) || void 0 === t ? void 0 : t.getPlatform) ||
				(() =>
					null !== o
						? o.name
						: ((e) => {
								var t, n;
								return (null == e ? void 0 : e.androidBridge) ? "android" : (null === (n = null === (t = null == e ? void 0 : e.webkit) || void 0 === t ? void 0 : t.messageHandlers) || void 0 === n ? void 0 : n.bridge) ? "ios" : "web";
						  })(e)),
			h = (null === (n = null == u ? void 0 : u.currentPlatform) || void 0 === n ? void 0 : n.isNativePlatform) || (() => "web" !== c()),
			d =
				(null === (r = null == u ? void 0 : u.currentPlatform) || void 0 === r ? void 0 : r.isPluginAvailable) ||
				((e) => {
					const t = f.get(e);
					return !!(null == t ? void 0 : t.platforms.has(c())) || !!p(e);
				}),
			p =
				(null === (i = null == u ? void 0 : u.currentPlatform) || void 0 === i ? void 0 : i.getPluginHeader) ||
				((e) => {
					var t;
					return null === (t = a.PluginHeaders) || void 0 === t ? void 0 : t.find((t) => t.name === e);
				}),
			f = new Map(),
			m =
				(null === (s = null == u ? void 0 : u.currentPlatform) || void 0 === s ? void 0 : s.registerPlugin) ||
				((e, t = {}) => {
					const n = f.get(e);
					if (n) return console.warn(`Capacitor plugin "${e}" already registered. Cannot register plugins twice.`), n.proxy;
					const r = c(),
						i = p(e);
					let s;
					const u = (n) => {
							let l;
							const u = (...u) => {
								const c = (async () => (!s && r in t ? (s = s = "function" == typeof t[r] ? await t[r]() : t[r]) : null !== o && !s && "web" in t && (s = s = "function" == typeof t.web ? await t.web() : t.web), s))().then((t) => {
									const s = ((t, n) => {
										var s, o;
										if (!i) {
											if (t) return null === (o = t[n]) || void 0 === o ? void 0 : o.bind(t);
											throw new M7(`"${e}" plugin is not implemented on ${r}`, k7.Unimplemented);
										}
										{
											const r = null == i ? void 0 : i.methods.find((e) => n === e.name);
											if (r) return "promise" === r.rtype ? (t) => a.nativePromise(e, n.toString(), t) : (t, r) => a.nativeCallback(e, n.toString(), t, r);
											if (t) return null === (s = t[n]) || void 0 === s ? void 0 : s.bind(t);
										}
									})(t, n);
									if (s) {
										const e = s(...u);
										return (l = null == e ? void 0 : e.remove), e;
									}
									throw new M7(`"${e}.${n}()" is not implemented on ${r}`, k7.Unimplemented);
								});
								return "addListener" === n && (c.remove = async () => l()), c;
							};
							return (u.toString = () => `${n.toString()}() { [capacitor code] }`), Object.defineProperty(u, "name", { value: n, writable: !1, configurable: !1 }), u;
						},
						h = u("addListener"),
						d = u("removeListener"),
						m = (e, t) => {
							const n = h({ eventName: e }, t),
								r = async () => {
									const r = await n;
									d({ eventName: e, callbackId: r }, t);
								},
								i = new Promise((e) => n.then(() => e({ remove: r })));
							return (
								(i.remove = async () => {
									console.warn("Using addListener() without 'await' is deprecated."), await r();
								}),
								i
							);
						},
						v = new Proxy(
							{},
							{
								get(e, t) {
									switch (t) {
										case "$$typeof":
											return;
										case "toJSON":
											return () => ({});
										case "addListener":
											return i ? m : h;
										case "removeListener":
											return d;
										default:
											return u(t);
									}
								}
							}
						);
					return (l[e] = v), f.set(e, { name: e, proxy: v, platforms: new Set([...Object.keys(t), ...(i ? [r] : [])]) }), v;
				});
		return (
			a.convertFileSrc || (a.convertFileSrc = (e) => e),
			(a.getPlatform = c),
			(a.handleError = (t) => e.console.error(t)),
			(a.isNativePlatform = h),
			(a.isPluginAvailable = d),
			(a.pluginMethodNoop = (e, t, n) => Promise.reject(`${n} does not have an implementation of "${t}".`)),
			(a.registerPlugin = m),
			(a.Exception = M7),
			(a.DEBUG = !!a.DEBUG),
			(a.isLoggingEnabled = !!a.isLoggingEnabled),
			(a.platform = a.getPlatform()),
			(a.isNative = a.isNativePlatform()),
			a
		);
	},
	R7 = ((e) => (e.Capacitor = I7(e)))("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {}),
	L7 = R7.registerPlugin;
R7.Plugins;
class O7 {
	constructor(e) {
		(this.listeners = {}), (this.windowListeners = {}), e && (console.warn(`Capacitor WebPlugin "${e.name}" config object was deprecated in v3 and will be removed in v4.`), (this.config = e));
	}
	addListener(e, t) {
		this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t);
		const n = this.windowListeners[e];
		n && !n.registered && this.addWindowListener(n);
		const r = async () => this.removeListener(e, t),
			i = Promise.resolve({ remove: r });
		return (
			Object.defineProperty(i, "remove", {
				value: async () => {
					console.warn("Using addListener() without 'await' is deprecated."), await r();
				}
			}),
			i
		);
	}
	async removeAllListeners() {
		this.listeners = {};
		for (const e in this.windowListeners) this.removeWindowListener(this.windowListeners[e]);
		this.windowListeners = {};
	}
	notifyListeners(e, t) {
		const n = this.listeners[e];
		n && n.forEach((e) => e(t));
	}
	hasListeners(e) {
		return !!this.listeners[e].length;
	}
	registerWindowListener(e, t) {
		this.windowListeners[t] = {
			registered: !1,
			windowEventName: e,
			pluginEventName: t,
			handler: (e) => {
				this.notifyListeners(t, e);
			}
		};
	}
	unimplemented(e = "not implemented") {
		return new R7.Exception(e, k7.Unimplemented);
	}
	unavailable(e = "not available") {
		return new R7.Exception(e, k7.Unavailable);
	}
	async removeListener(e, t) {
		const n = this.listeners[e];
		if (!n) return;
		const r = n.indexOf(t);
		this.listeners[e].splice(r, 1), this.listeners[e].length || this.removeWindowListener(this.windowListeners[e]);
	}
	addWindowListener(e) {
		window.addEventListener(e.windowEventName, e.handler), (e.registered = !0);
	}
	removeWindowListener(e) {
		e && (window.removeEventListener(e.windowEventName, e.handler), (e.registered = !1));
	}
}
const P7 = L7("SplashScreen", { web: () => import("./web.208d3f00.js").then((e) => new e.SplashScreenWeb()) }),
	N7 = L7("App", { web: () => import("./web.6996bdd7.js").then((e) => new e.AppWeb()) }),
	D7 = (e) => e == document.activeElement;
class B7 {
	constructor() {
		(this.root = null), (this.elements = []), (this.onKeyDown = this.onKeyDown.bind(this)), (this.enable = this.enable.bind(this)), (this.disable = this.disable.bind(this)), (this.firstElement = this.firstElement.bind(this)), (this.lastElement = this.lastElement.bind(this));
	}
	lastElement() {
		return this.elements[this.elements.length - 1] || null;
	}
	firstElement() {
		return this.elements[0] || null;
	}
	onKeyDown(e) {
		if (((e) => "Tab" === e.key || 9 === e.keyCode)(e)) {
			if (!e.shiftKey) return !document.activeElement || D7(this.lastElement()) ? (this.firstElement().focus(), void e.preventDefault()) : void 0;
			D7(this.firstElement()) && (this.lastElement().focus(), e.preventDefault());
		}
	}
	enabled() {
		return !!this.root;
	}
	enable(e) {
		e &&
			((this.root = e),
			(this.elements = ((e, t) => [...(e.querySelectorAll(t) || [])])(
				this.root,
				'button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])'
			)),
			this.root.addEventListener("keydown", this.onKeyDown));
	}
	disable() {
		this.root.removeEventListener("keydown", this.onKeyDown), (this.root = null);
	}
}
const F7 = (e) => {
		const { clientX: t, clientY: n } = e.targetTouches ? e.targetTouches[0] : e;
		return { x: t, y: n };
	},
	H7 = (e, t, n) => ("number" != typeof e && (e = Math.min(t, n) || t), "number" != typeof n && (n = Math.max(t, e)), Math.min(Math.max(t, e), n)),
	V7 = (e) => (e && Number(e.replace(/px$/, ""))) || 0,
	U7 = { down: { pc: "mousedown", m: "touchstart" }, move: { pc: "mousemove", m: "touchmove" }, up: { pc: "mouseup", m: "touchend" } },
	z7 = (e, t, n) => {
		t && t.addEventListener(U7[e].pc, n), t && t.addEventListener(U7[e].m, n, { passive: !1 });
	},
	$7 = (e, t, n) => {
		t && t.removeEventListener(U7[e].pc, n), t && t.removeEventListener(U7[e].m, n);
	};
let j7 = !1;
if ("undefined" != typeof window) {
	const e = {
		get passive() {
			j7 = !0;
		}
	};
	window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
const W7 = "undefined" != typeof window && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || ("MacIntel" === window.navigator.platform && window.navigator.maxTouchPoints > 1));
let G7,
	Y7,
	X7 = [],
	K7 = !1,
	q7 = 0,
	Z7 = -1;
const J7 = (e, t) => {
		let n = !1;
		return (
			((e) => {
				const t = [];
				for (; e; ) {
					if ((t.push(e), e.classList.contains("vfm"))) return t;
					e = e.parentElement;
				}
				return t;
			})(e).forEach((e) => {
				((e) => {
					if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
					const t = window.getComputedStyle(e);
					return ["auto", "scroll"].includes(t.overflowY) && e.scrollHeight > e.clientHeight;
				})(e) &&
					((e, t) => !((0 === e.scrollTop && t < 0) || (e.scrollTop + e.clientHeight + t >= e.scrollHeight && t > 0)))(e, t) &&
					(n = !0);
			}),
			n
		);
	},
	Q7 = (e) => X7.some(() => J7(e, -q7)),
	e9 = (e) => {
		const t = e || window.event;
		return !!Q7(t.target) || t.touches.length > 1 || (t.preventDefault && t.preventDefault(), !1);
	},
	t9 = (e, t) => {
		if (!e) return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
		if (X7.some((t) => t.targetElement === e)) return;
		const n = { targetElement: e, options: t || {} };
		(X7 = [...X7, n]),
			W7
				? ((e.ontouchstart = (e) => {
						1 === e.targetTouches.length && (Z7 = e.targetTouches[0].clientY);
				  }),
				  (e.ontouchmove = (t) => {
						1 === t.targetTouches.length &&
							((e, t) => {
								(q7 = e.targetTouches[0].clientY - Z7), !Q7(e.target) && ((t && 0 === t.scrollTop && q7 > 0) || (((e) => !!e && e.scrollHeight - e.scrollTop <= e.clientHeight)(t) && q7 < 0) ? e9(e) : e.stopPropagation());
							})(t, e);
				  }),
				  K7 || (document.addEventListener("touchmove", e9, j7 ? { passive: !1 } : void 0), (K7 = !0)))
				: ((e) => {
						if (void 0 === Y7) {
							const t = !!e && !0 === e.reserveScrollBarGap,
								n = window.innerWidth - document.documentElement.clientWidth;
							if (t && n > 0) {
								const e = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
								(Y7 = document.body.style.paddingRight), (document.body.style.paddingRight = `${e + n}px`);
							}
						}
						void 0 === G7 && ((G7 = document.body.style.overflow), (document.body.style.overflow = "hidden"));
				  })(t);
	},
	n9 = (e) => {
		e
			? ((X7 = X7.filter((t) => t.targetElement !== e)),
			  W7
					? ((e.ontouchstart = null), (e.ontouchmove = null), K7 && 0 === X7.length && (document.removeEventListener("touchmove", e9, j7 ? { passive: !1 } : void 0), (K7 = !1)))
					: X7.length || (void 0 !== Y7 && ((document.body.style.paddingRight = Y7), (Y7 = void 0)), void 0 !== G7 && ((document.body.style.overflow = G7), (G7 = void 0))))
			: console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
	};
const r9 = () => {},
	i9 = "enter",
	s9 = "entering",
	o9 = "leave",
	a9 = "leavng",
	l9 = { t: "ns-resize", tr: "nesw-resize", r: "ew-resize", br: "nwse-resize", b: "ns-resize", bl: "nesw-resize", l: "ew-resize", tl: "nwse-resize" },
	u9 = {
		props: {
			name: { type: String, default: null },
			modelValue: { type: Boolean, default: !1 },
			ssr: { type: Boolean, default: !0 },
			classes: { type: [String, Object, Array], default: "" },
			overlayClass: { type: [String, Object, Array], default: "" },
			contentClass: { type: [String, Object, Array], default: "" },
			styles: { type: [Object, Array], default: () => ({}) },
			overlayStyle: { type: [Object, Array], default: () => ({}) },
			contentStyle: { type: [Object, Array], default: () => ({}) },
			lockScroll: { type: Boolean, default: !0 },
			hideOverlay: { type: Boolean, default: !1 },
			clickToClose: { type: Boolean, default: !0 },
			escToClose: { type: Boolean, default: !1 },
			preventClick: { type: Boolean, default: !1 },
			attach: {
				type: null,
				default: !1,
				validator(e) {
					const t = typeof e;
					return "boolean" === t || "string" === t || e.nodeType === Node.ELEMENT_NODE;
				}
			},
			transition: { type: [String, Object], default: "vfm" },
			overlayTransition: { type: [String, Object], default: "vfm" },
			keepOverlay: { type: Boolean, default: !1 },
			zIndexAuto: { type: Boolean, default: !0 },
			zIndexBase: { type: [String, Number], default: 1e3 },
			zIndex: { type: [Boolean, String, Number], default: !1 },
			focusRetain: { type: Boolean, default: !0 },
			focusTrap: { type: Boolean, default: !1 },
			fitParent: { type: Boolean, default: !0 },
			drag: { type: Boolean, default: !1 },
			dragSelector: { type: String, default: "" },
			keepChangedStyle: { type: Boolean, default: !1 },
			resize: { type: Boolean, default: !1 },
			resizeDirections: { type: Array, default: () => ["t", "tr", "r", "br", "b", "bl", "l", "tl"], validator: (e) => ["t", "tr", "r", "br", "b", "bl", "l", "tl"].filter((t) => -1 !== e.indexOf(t)).length === e.length },
			minWidth: { type: Number, default: 0 },
			minHeight: { type: Number, default: 0 },
			maxWidth: { type: Number, default: 1 / 0 },
			maxHeight: { type: Number, default: 1 / 0 }
		},
		emits: ["update:modelValue", "click-outside", "before-open", "opened", "before-close", "closed", "_before-open", "_opened", "_closed", "drag:start", "drag:move", "drag:end", "resize:start", "resize:move", "resize:end"],
		setup(e, { emit: t }) {
			const n = Symbol("vfm"),
				r = Qe(null),
				i = Qe(null),
				s = Qe(null),
				o = Qe(null),
				a = Qe(null),
				l = Qe(null),
				c = Qe(null),
				h = new B7(),
				d = Qe(!1),
				p = Fe({ modal: !1, overlay: !1, resize: !1 }),
				f = Qe(null),
				m = Qe(null),
				v = Qe(!1),
				g = Qe({}),
				y = Qe({}),
				b = Qe(null),
				x = Qe(null);
			let _ = r9,
				w = r9;
			const C = ht(() => ("string" == typeof e.overlayTransition ? { name: e.overlayTransition } : u({}, e.overlayTransition))),
				S = ht(() => ("string" == typeof e.transition ? { name: e.transition } : u({}, e.transition))),
				E = ht(() => (e.hideOverlay || f.value === o9) && m.value === o9),
				T = ht(() => (!1 === e.zIndex ? !!e.zIndexAuto && +e.zIndexBase + 2 * (c.value || 0) : e.zIndex)),
				k = ht(() => u({}, !1 !== T.value && { zIndex: T.value })),
				A = ht(() => {
					let t = [y.value];
					return Array.isArray(e.contentStyle) ? t.push(...e.contentStyle) : t.push(e.contentStyle), t;
				});
			function M() {
				return { uid: n, props: e, emit: t, vfmContainer: i, vfmContent: s, vfmResize: o, vfmOverlayTransition: a, vfmTransition: l, getAttachElement: O, modalStackIndex: c, visibility: p, handleLockScroll: L, $focusTrap: h, toggle: B, params: g };
			}
			function I() {
				if (e.modelValue) {
					if ((t("_before-open", P({ type: "_before-open" })), N("before-open", !1))) return void w("show");
					let i = O();
					if (i || !1 === e.attach) {
						if (!1 !== e.attach) {
							if (!r.value)
								return (
									(d.value = !0),
									void ns(() => {
										I();
									})
								);
							i.appendChild(r.value);
						}
						let t = e.api.openedModals.findIndex((e) => e.uid === n);
						-1 !== t && e.api.openedModals.splice(t, 1),
							e.api.openedModals.push(M()),
							(c.value = e.api.openedModals.length - 1),
							L(),
							e.api.openedModals
								.filter((e) => e.uid !== n)
								.forEach((e, t) => {
									e.getAttachElement() === i && ((e.modalStackIndex.value = t), !e.props.keepOverlay && (e.visibility.overlay = !1));
								}),
							(d.value = !0),
							(p.overlay = !0),
							(p.modal = !0);
					} else !1 !== i && console.warn("Unable to locate target ".concat(e.attach));
				}
			}
			function R() {
				let t = e.api.openedModals.findIndex((e) => e.uid === n);
				if ((-1 !== t && e.api.openedModals.splice(t, 1), e.api.openedModals.length > 0)) {
					const t = e.api.openedModals[e.api.openedModals.length - 1];
					t.props.focusTrap && t.$focusTrap.firstElement().focus(), (t.props.focusRetain || t.props.focusTrap) && t.vfmContainer.value.focus(), !t.props.hideOverlay && (t.visibility.overlay = !0);
				}
				e.drag && V(), e.resize && z(), (b.value = null), (p.overlay = !1), (p.modal = !1);
			}
			function L() {
				e.modelValue &&
					ns(() => {
						e.lockScroll ? t9(i.value, { reserveScrollBarGap: !0 }) : n9(i.value);
					});
			}
			function O() {
				let t;
				return (t = !1 !== e.attach && ("string" == typeof e.attach ? !!window && window.document.querySelector(e.attach) : e.attach)), t;
			}
			function P(e = {}) {
				return u({ ref: M() }, e);
			}
			function N(e, n) {
				let r = !1;
				const i = P({
					type: e,
					stop() {
						r = !0;
					}
				});
				return (
					t(e, i),
					!!r &&
						((v.value = !0),
						ns(() => {
							t("update:modelValue", n);
						}),
						!0)
				);
			}
			function D(e, n, r) {
				(b.value = `${n}:${r}`), t(b.value, e);
			}
			function B(n, r) {
				return new Promise((i, s) => {
					(_ = (e) => {
						i(e), (_ = r9);
					}),
						(w = (e) => {
							s(e), (w = r9);
						});
					const o = "boolean" == typeof n ? n : !e.modelValue;
					o && 2 === arguments.length && (g.value = r), t("update:modelValue", o);
				});
			}
			function F(t) {
				t.stopPropagation();
				const n = "resize",
					r = "drag",
					o = t.target.getAttribute("direction");
				let a;
				if (o) a = n;
				else {
					if (!((e, t, n) => "" === n || [...t.querySelectorAll(n)].includes(e.target))(t, s.value, e.dragSelector)) return;
					a = r;
				}
				D(t, a, "start");
				const l = F7(t),
					c = i.value.getBoundingClientRect(),
					h = s.value.getBoundingClientRect(),
					d = "absolute" === window.getComputedStyle(s.value).position,
					p = V7(y.value.top),
					f = V7(y.value.left),
					m = (() => {
						if (e.fitParent) {
							const e = { absolute: () => ({ minTop: 0, minLeft: 0, maxTop: c.height - h.height, maxLeft: c.width - h.width }), relative: () => ({ minTop: p + c.top - h.top, minLeft: f + c.left - h.left, maxTop: p + c.bottom - h.bottom, maxLeft: f + c.right - h.right }) };
							return d ? e.absolute() : e.relative();
						}
						return {};
					})(),
					v =
						a === n &&
						((e, t, n) => {
							const r = e.style[t];
							return (
								(e.style[t] = n),
								() => {
									e.style[t] = r;
								}
							);
						})(document.body, "cursor", l9[o]),
					g = (t) => {
						t.stopPropagation(), D(t, a, "move");
						const i = F7(t);
						let s,
							v,
							g = { x: i.x - l.x, y: i.y - l.y };
						a === n &&
							(g = (function (t, n, r, i, s) {
								const o = (t) => {
										let r = n[t.axis];
										r = e.fitParent ? H7(t.min, r, t.max) : r;
										let i = H7(t.minEdge, t.getEdge(r), t.maxEdge);
										return (r = t.getOffsetAxis(i, s)), { [t.edgeName]: i, [t.axis]: r };
									},
									a = (t, n, s, o) => {
										const a = i[n],
											l = r[t] - i[t],
											u = (c = n).charAt(0).toUpperCase() + c.slice(1);
										var c;
										return {
											axis: s,
											edgeName: n,
											min: o ? l : -a,
											max: o ? a : l,
											minEdge: e[`min${u}`],
											maxEdge: e[`max${u}`],
											getEdge: (e) => i[n] - e * (o ? 1 : -1),
											getOffsetAxis: (e, t) => {
												const r = i[n] - e;
												return t ? (o ? r : 0) : ((o ? 1 : -1) * r) / 2;
											}
										};
									},
									l = { t: ["top", "height", "y", !0], b: ["bottom", "height", "y", !1], l: ["left", "width", "x", !0], r: ["right", "width", "x", !1] };
								let c = { x: 0, y: 0 };
								return (
									t.split("").forEach((e) => {
										const t = a(...l[e]);
										c = u(u({}, c), o(t));
									}),
									c
								);
							})(o, g, c, h, d)),
							d ? ((s = h.top - c.top + g.y), (v = h.left - c.left + g.x)) : ((s = p + g.y), (v = f + g.x)),
							a === r && e.fitParent && ((s = H7(m.minTop, s, m.maxTop)), (v = H7(m.minLeft, v, m.maxLeft)));
						const b = u(
							u(u({ position: "relative", top: s + "px", left: v + "px", margin: "unset", touchAction: "none" }, d && { position: "absolute", transform: "unset", width: h.width + "px", height: h.height + "px" }), g.width && { width: g.width + "px" }),
							g.height && { height: g.height + "px" }
						);
						y.value = u(u({}, y.value), b);
					},
					b = (e) => {
						e.stopPropagation(),
							a === n && v && v(),
							setTimeout(() => {
								D(e, a, "end");
							}),
							$7("move", document, g),
							$7("up", document, b);
					};
				z7("move", document, g), z7("up", document, b);
			}
			function H() {
				z7("down", s.value, F), (y.value.touchAction = "none");
			}
			function V() {
				$7("down", s.value, F);
			}
			function U() {
				(p.resize = !0),
					ns(() => {
						z7("down", o.value, F);
					});
			}
			function z() {
				$7("down", o.value, F), (p.resize = !1);
			}
			return (
				ds(
					() => e.modelValue,
					(e) => {
						if (v.value) v.value = !1;
						else if ((I(), !e)) {
							if (N("before-close", !0)) return void w("hide");
							R();
						}
					}
				),
				ds(() => e.lockScroll, L),
				ds(
					() => e.hideOverlay,
					(t) => {
						e.modelValue && !t && (p.overlay = !0);
					}
				),
				ds(() => e.attach, I),
				ds(
					E,
					(e) => {
						e && ((d.value = !1), (i.value.style.display = "none"));
					},
					{ flush: "post" }
				),
				ds(
					() => e.drag,
					(e) => {
						d.value && (e ? H() : V());
					}
				),
				ds(
					() => e.resize,
					(e) => {
						d.value && (e ? U() : z());
					}
				),
				ds(
					() => e.keepChangedStyle,
					(e) => {
						e || (y.value = {});
					}
				),
				e.api.modals.push(M()),
				Vn(() => {
					I();
				}),
				$n(() => {
					var t;
					R(), e.lockScroll && i.value && n9(i.value), null == (t = null == r ? void 0 : r.value) || t.remove();
					let s = e.api.modals.findIndex((e) => e.uid === n);
					e.api.modals.splice(s, 1);
				}),
				{
					root: r,
					vfmContainer: i,
					vfmContent: s,
					vfmResize: o,
					vfmOverlayTransition: a,
					vfmTransition: l,
					computedOverlayTransition: C,
					computedTransition: S,
					visible: d,
					visibility: p,
					params: g,
					calculateZIndex: T,
					bindStyle: k,
					bindContentStyle: A,
					beforeOverlayEnter: function () {
						f.value = s9;
					},
					afterOverlayEnter: function () {
						f.value = i9;
					},
					beforeOverlayLeave: function () {
						f.value = a9;
					},
					afterOverlayLeave: function () {
						f.value = o9;
					},
					beforeModalEnter: function () {
						m.value = s9;
					},
					afterModalEnter: function () {
						(m.value = i9), (e.focusRetain || e.focusTrap) && i.value.focus(), e.focusTrap && h.enable(i.value), e.drag && H(), e.resize && U(), t("_opened"), t("opened", P({ type: "opened" })), _("show");
					},
					beforeModalLeave: function () {
						(m.value = a9), h.enabled() && h.disable();
					},
					afterModalLeave: function () {
						(m.value = o9), (c.value = null), e.lockScroll && n9(i.value), e.keepChangedStyle || (y.value = {});
						let n = !1;
						const r = P({
							type: "closed",
							stop() {
								n = !0;
							}
						});
						t("_closed"), t("closed", r), _("hide"), n || (g.value = {});
					},
					onMousedown: function (e) {
						x.value = null == e ? void 0 : e.target;
					},
					onMouseupContainer: function () {
						x.value === i.value && "resize:move" !== b.value && (t("click-outside", P({ type: "click-outside" })), e.clickToClose && t("update:modelValue", !1));
					},
					onEsc: function () {
						d.value && e.escToClose && t("update:modelValue", !1);
					}
				}
			);
		}
	},
	c9 = ["aria-expanded"],
	h9 = { key: 0, ref: "vfmResize", class: "vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none" },
	d9 = ["direction"];
(u9.render = function (e, t, n, r, i, s) {
	return n.ssr || r.visible
		? yr(
				(Wr(),
				Kr(
					"div",
					{ key: 0, ref: "root", style: pt(r.bindStyle), class: gt(["vfm vfm--inset", [!1 === n.attach ? "vfm--fixed" : "vfm--absolute", { "vfm--prevent-none": n.preventClick }]]), onKeydown: t[3] || (t[3] = jo((...e) => r.onEsc && r.onEsc(...e), ["esc"])) },
					[
						ri(
							lo,
							hi(r.computedOverlayTransition, { onBeforeEnter: r.beforeOverlayEnter, onAfterEnter: r.afterOverlayEnter, onBeforeLeave: r.beforeOverlayLeave, onAfterLeave: r.afterOverlayLeave }),
							{ default: cn(() => [!n.hideOverlay && r.visibility.overlay ? (Wr(), Kr("div", { key: 0, class: gt(["vfm__overlay vfm--overlay vfm--absolute vfm--inset", n.overlayClass]), style: pt(n.overlayStyle) }, null, 6)) : ai("", !0)]), _: 1 },
							16,
							["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]
						),
						ri(
							lo,
							hi(r.computedTransition, { onBeforeEnter: r.beforeModalEnter, onAfterEnter: r.afterModalEnter, onBeforeLeave: r.beforeModalLeave, onAfterLeave: r.afterModalLeave }),
							{
								default: cn(() => [
									yr(
										ni(
											"div",
											{
												ref: "vfmContainer",
												class: gt(["vfm__container vfm--absolute vfm--inset vfm--outline-none", n.classes]),
												style: pt(n.styles),
												"aria-expanded": r.visibility.modal.toString(),
												role: "dialog",
												"aria-modal": "true",
												tabindex: "-1",
												onMouseup: t[1] || (t[1] = zo((...e) => r.onMouseupContainer && r.onMouseupContainer(...e), ["self"])),
												onMousedown: t[2] || (t[2] = zo((...e) => r.onMousedown && r.onMousedown(...e), ["self"]))
											},
											[
												ni(
													"div",
													{ ref: "vfmContent", class: gt(["vfm__content", [n.contentClass, { "vfm--prevent-auto": n.preventClick }]]), style: pt(r.bindContentStyle), onMousedown: t[0] || (t[0] = (e) => r.onMousedown(null)) },
													[
														mi(e.$slots, "default", { params: r.params, close: () => e.$emit("update:modelValue", !1) }, void 0, !0),
														r.visibility.resize && r.visibility.modal
															? (Wr(),
															  Kr(
																	"div",
																	h9,
																	[
																		(Wr(!0),
																		Kr(
																			Hr,
																			null,
																			pi(n.resizeDirections, (e) => (Wr(), Kr("div", { key: e, direction: e, class: gt([`vfm--resize-${e}`, "vfm--absolute vfm--prevent-auto"]) }, null, 10, d9))),
																			128
																		))
																	],
																	512
															  ))
															: ai("", !0)
													],
													38
												)
											],
											46,
											c9
										),
										[[Wo, r.visibility.modal]]
									)
								]),
								_: 3
							},
							16,
							["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]
						)
					],
					38
				)),
				[[Wo, !n.ssr || r.visible]]
		  )
		: ai("", !0);
}),
	(u9.__scopeId = "data-v-6917f53d");
const p9 = {
		props: {},
		methods: {
			slice(e) {
				this.api.dynamicModals.splice(e, 1);
			},
			async beforeOpen(e, t, n) {
				(e.ref.params.value = t.params), await this.$nextTick(), await this.$nextTick(), t.value || (this.slice(n), t.reject("show"));
			},
			isString: (e) => "string" == typeof e
		}
	},
	f9 = { class: "modals-container" },
	m9 = ["innerHTML"];
function v9(e, t) {
	const n = c(u({}, e), { props: u({}, e.props) });
	return Object.assign(n.props, { api: { type: Object, default: () => t } }), n;
}
function g9(e) {
	const t = v9(u9, e);
	return e._setDefaultModal(t), t;
}
function y9(e) {
	return v9(p9, e);
}
p9.render = function (e, t, n, r, i, s) {
	return (
		Wr(),
		Kr("div", f9, [
			(Wr(!0),
			Kr(
				Hr,
				null,
				pi(
					e.api.dynamicModals,
					(e, t) => (
						Wr(),
						qr(
							Nr(e.component),
							hi({ key: e.id }, e.bind, { modelValue: e.value, "onUpdate:modelValue": (t) => (e.value = t) }, gi(e.on), { on_closed: (e) => s.slice(t), on_beforeOpen: (t) => s.beforeOpen(t, e), on_opened: e.opened }),
							fi({ _: 2 }, [pi(e.slots, (e, t) => ({ name: t, fn: cn(() => [s.isString(e) ? (Wr(), Kr("div", { key: 0, innerHTML: e }, null, 8, m9)) : (Wr(), qr(Nr(e.component), hi({ key: 1 }, e.bind, gi(e.on || {})), null, 16))]) }))]),
							1040,
							["modelValue", "onUpdate:modelValue", "on_closed", "on_beforeOpen", "on_opened"]
						)
					)
				),
				128
			))
		])
	);
};
let b9 = 0;
const x9 = () => {
		let e = (function () {
			let e = null;
			return {
				show(t, ...n) {
					switch (typeof t) {
						case "string":
							return this.toggle(t, !0, ...n);
						case "object":
							return Promise.allSettled([
								new Promise((r, i) => {
									const s = {
										value: !0,
										id: Symbol("dynamicModal"),
										component: e,
										bind: {},
										slots: {},
										on: {},
										params: n[0],
										reject: i,
										opened() {
											r("show");
										}
									};
									this.dynamicModals.push(He(Object.assign(s, t)));
								})
							]);
					}
				},
				hide(...e) {
					return this.toggle(e, !1);
				},
				hideAll() {
					return this.hide(...this.openedModals.map((e) => e.props.name));
				},
				toggle(e, ...t) {
					const n = Array.isArray(e) ? this.get(...e) : this.get(e);
					return Promise.allSettled(n.map((e) => e.toggle(...t)));
				},
				get(...e) {
					return this.modals.filter((t) => e.includes(t.props.name));
				},
				dynamicModals: He([]),
				openedModals: [],
				modals: [],
				_setDefaultModal(t) {
					e = t;
				}
			};
		})();
		return { $vfm: e, VueFinalModal: g9(e), ModalsContainer: y9(e) };
	},
	_9 = x9(),
	w9 = (e, t = {}) => {
		const { $vfm: n, VueFinalModal: r, ModalsContainer: i } = 0 === b9 ? _9 : x9();
		b9 += 1;
		const s = t.key || "$vfm",
			o = t.componentName || "VueFinalModal",
			a = t.dynamicContainerName || "ModalsContainer";
		Object.defineProperty(e.config.globalProperties, s, { get: () => n }), e.provide(s, n), e.component(o, r), e.component(a, i);
	},
	C9 = (e) => ({
		install(t, n) {
			const r = Object.assign({}, e, n);
			w9(t, r);
		}
	});
/*!
 * perfect-scrollbar v1.5.0
 * Copyright 2020 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function S9(e) {
	return getComputedStyle(e);
}
function E9(e, t) {
	for (var n in t) {
		var r = t[n];
		"number" == typeof r && (r += "px"), (e.style[n] = r);
	}
	return e;
}
function T9(e) {
	var t = document.createElement("div");
	return (t.className = e), t;
}
C9.install = w9;
var k9 = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function A9(e, t) {
	if (!k9) throw new Error("No element matching method supported");
	return k9.call(e, t);
}
function M9(e) {
	e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e);
}
function I9(e, t) {
	return Array.prototype.filter.call(e.children, function (e) {
		return A9(e, t);
	});
}
var R9 = "ps",
	L9 = "ps__rtl",
	O9 = {
		thumb: function (e) {
			return "ps__thumb-" + e;
		},
		rail: function (e) {
			return "ps__rail-" + e;
		},
		consuming: "ps__child--consume"
	},
	P9 = {
		focus: "ps--focus",
		clicking: "ps--clicking",
		active: function (e) {
			return "ps--active-" + e;
		},
		scrolling: function (e) {
			return "ps--scrolling-" + e;
		}
	},
	N9 = { x: null, y: null };
function D9(e, t) {
	var n = e.element.classList,
		r = P9.scrolling(t);
	n.contains(r) ? clearTimeout(N9[t]) : n.add(r);
}
function B9(e, t) {
	N9[t] = setTimeout(function () {
		return e.isAlive && e.element.classList.remove(P9.scrolling(t));
	}, e.settings.scrollingThreshold);
}
var F9 = function (e) {
		(this.element = e), (this.handlers = {});
	},
	H9 = { isEmpty: { configurable: !0 } };
(F9.prototype.bind = function (e, t) {
	void 0 === this.handlers[e] && (this.handlers[e] = []), this.handlers[e].push(t), this.element.addEventListener(e, t, !1);
}),
	(F9.prototype.unbind = function (e, t) {
		var n = this;
		this.handlers[e] = this.handlers[e].filter(function (r) {
			return !(!t || r === t) || (n.element.removeEventListener(e, r, !1), !1);
		});
	}),
	(F9.prototype.unbindAll = function () {
		for (var e in this.handlers) this.unbind(e);
	}),
	(H9.isEmpty.get = function () {
		var e = this;
		return Object.keys(this.handlers).every(function (t) {
			return 0 === e.handlers[t].length;
		});
	}),
	Object.defineProperties(F9.prototype, H9);
var V9 = function () {
	this.eventElements = [];
};
function U9(e) {
	if ("function" == typeof window.CustomEvent) return new CustomEvent(e);
	var t = document.createEvent("CustomEvent");
	return t.initCustomEvent(e, !1, !1, void 0), t;
}
function z9(e, t, n, r, i) {
	var s;
	if ((void 0 === r && (r = !0), void 0 === i && (i = !1), "top" === t)) s = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
	else {
		if ("left" !== t) throw new Error("A proper axis should be provided");
		s = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
	}
	!(function (e, t, n, r, i) {
		var s = n[0],
			o = n[1],
			a = n[2],
			l = n[3],
			u = n[4],
			c = n[5];
		void 0 === r && (r = !0);
		void 0 === i && (i = !1);
		var h = e.element;
		(e.reach[l] = null), h[a] < 1 && (e.reach[l] = "start");
		h[a] > e[s] - e[o] - 1 && (e.reach[l] = "end");
		t &&
			(h.dispatchEvent(U9("ps-scroll-" + l)),
			t < 0 ? h.dispatchEvent(U9("ps-scroll-" + u)) : t > 0 && h.dispatchEvent(U9("ps-scroll-" + c)),
			r &&
				(function (e, t) {
					D9(e, t), B9(e, t);
				})(e, l));
		e.reach[l] && (t || i) && h.dispatchEvent(U9("ps-" + l + "-reach-" + e.reach[l]));
	})(e, n, s, r, i);
}
function $9(e) {
	return parseInt(e, 10) || 0;
}
(V9.prototype.eventElement = function (e) {
	var t = this.eventElements.filter(function (t) {
		return t.element === e;
	})[0];
	return t || ((t = new F9(e)), this.eventElements.push(t)), t;
}),
	(V9.prototype.bind = function (e, t, n) {
		this.eventElement(e).bind(t, n);
	}),
	(V9.prototype.unbind = function (e, t, n) {
		var r = this.eventElement(e);
		r.unbind(t, n), r.isEmpty && this.eventElements.splice(this.eventElements.indexOf(r), 1);
	}),
	(V9.prototype.unbindAll = function () {
		this.eventElements.forEach(function (e) {
			return e.unbindAll();
		}),
			(this.eventElements = []);
	}),
	(V9.prototype.once = function (e, t, n) {
		var r = this.eventElement(e),
			i = function (e) {
				r.unbind(t, i), n(e);
			};
		r.bind(t, i);
	});
var j9 = {
	isWebKit: "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style,
	supportsTouch: "undefined" != typeof window && ("ontouchstart" in window || ("maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0) || (window.DocumentTouch && document instanceof window.DocumentTouch)),
	supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
	isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
};
function W9(e) {
	var t = e.element,
		n = Math.floor(t.scrollTop),
		r = t.getBoundingClientRect();
	(e.containerWidth = Math.ceil(r.width)),
		(e.containerHeight = Math.ceil(r.height)),
		(e.contentWidth = t.scrollWidth),
		(e.contentHeight = t.scrollHeight),
		t.contains(e.scrollbarXRail) ||
			(I9(t, O9.rail("x")).forEach(function (e) {
				return M9(e);
			}),
			t.appendChild(e.scrollbarXRail)),
		t.contains(e.scrollbarYRail) ||
			(I9(t, O9.rail("y")).forEach(function (e) {
				return M9(e);
			}),
			t.appendChild(e.scrollbarYRail)),
		!e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth
			? ((e.scrollbarXActive = !0),
			  (e.railXWidth = e.containerWidth - e.railXMarginWidth),
			  (e.railXRatio = e.containerWidth / e.railXWidth),
			  (e.scrollbarXWidth = G9(e, $9((e.railXWidth * e.containerWidth) / e.contentWidth))),
			  (e.scrollbarXLeft = $9(((e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth)) / (e.contentWidth - e.containerWidth))))
			: (e.scrollbarXActive = !1),
		!e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight
			? ((e.scrollbarYActive = !0),
			  (e.railYHeight = e.containerHeight - e.railYMarginHeight),
			  (e.railYRatio = e.containerHeight / e.railYHeight),
			  (e.scrollbarYHeight = G9(e, $9((e.railYHeight * e.containerHeight) / e.contentHeight))),
			  (e.scrollbarYTop = $9((n * (e.railYHeight - e.scrollbarYHeight)) / (e.contentHeight - e.containerHeight))))
			: (e.scrollbarYActive = !1),
		e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth),
		e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight),
		(function (e, t) {
			var n = { width: t.railXWidth },
				r = Math.floor(e.scrollTop);
			t.isRtl ? (n.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth) : (n.left = e.scrollLeft);
			t.isScrollbarXUsingBottom ? (n.bottom = t.scrollbarXBottom - r) : (n.top = t.scrollbarXTop + r);
			E9(t.scrollbarXRail, n);
			var i = { top: r, height: t.railYHeight };
			t.isScrollbarYUsingRight
				? t.isRtl
					? (i.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9)
					: (i.right = t.scrollbarYRight - e.scrollLeft)
				: t.isRtl
				? (i.left = t.negativeScrollAdjustment + e.scrollLeft + 2 * t.containerWidth - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth)
				: (i.left = t.scrollbarYLeft + e.scrollLeft);
			E9(t.scrollbarYRail, i), E9(t.scrollbarX, { left: t.scrollbarXLeft, width: t.scrollbarXWidth - t.railBorderXWidth }), E9(t.scrollbarY, { top: t.scrollbarYTop, height: t.scrollbarYHeight - t.railBorderYWidth });
		})(t, e),
		e.scrollbarXActive ? t.classList.add(P9.active("x")) : (t.classList.remove(P9.active("x")), (e.scrollbarXWidth = 0), (e.scrollbarXLeft = 0), (t.scrollLeft = !0 === e.isRtl ? e.contentWidth : 0)),
		e.scrollbarYActive ? t.classList.add(P9.active("y")) : (t.classList.remove(P9.active("y")), (e.scrollbarYHeight = 0), (e.scrollbarYTop = 0), (t.scrollTop = 0));
}
function G9(e, t) {
	return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)), e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)), t;
}
function Y9(e, t) {
	var n = t[0],
		r = t[1],
		i = t[2],
		s = t[3],
		o = t[4],
		a = t[5],
		l = t[6],
		u = t[7],
		c = t[8],
		h = e.element,
		d = null,
		p = null,
		f = null;
	function m(t) {
		t.touches && t.touches[0] && (t[i] = t.touches[0].pageY), (h[l] = d + f * (t[i] - p)), D9(e, u), W9(e), t.stopPropagation(), t.preventDefault();
	}
	function v() {
		B9(e, u), e[c].classList.remove(P9.clicking), e.event.unbind(e.ownerDocument, "mousemove", m);
	}
	function g(t, o) {
		(d = h[l]),
			o && t.touches && (t[i] = t.touches[0].pageY),
			(p = t[i]),
			(f = (e[r] - e[n]) / (e[s] - e[a])),
			o ? e.event.bind(e.ownerDocument, "touchmove", m) : (e.event.bind(e.ownerDocument, "mousemove", m), e.event.once(e.ownerDocument, "mouseup", v), t.preventDefault()),
			e[c].classList.add(P9.clicking),
			t.stopPropagation();
	}
	e.event.bind(e[o], "mousedown", function (e) {
		g(e);
	}),
		e.event.bind(e[o], "touchstart", function (e) {
			g(e, !0);
		});
}
var X9 = {
		"click-rail": function (e) {
			e.element,
				e.event.bind(e.scrollbarY, "mousedown", function (e) {
					return e.stopPropagation();
				}),
				e.event.bind(e.scrollbarYRail, "mousedown", function (t) {
					var n = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top > e.scrollbarYTop ? 1 : -1;
					(e.element.scrollTop += n * e.containerHeight), W9(e), t.stopPropagation();
				}),
				e.event.bind(e.scrollbarX, "mousedown", function (e) {
					return e.stopPropagation();
				}),
				e.event.bind(e.scrollbarXRail, "mousedown", function (t) {
					var n = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left > e.scrollbarXLeft ? 1 : -1;
					(e.element.scrollLeft += n * e.containerWidth), W9(e), t.stopPropagation();
				});
		},
		"drag-thumb": function (e) {
			Y9(e, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]), Y9(e, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"]);
		},
		keyboard: function (e) {
			var t = e.element;
			e.event.bind(e.ownerDocument, "keydown", function (n) {
				if (!((n.isDefaultPrevented && n.isDefaultPrevented()) || n.defaultPrevented) && (A9(t, ":hover") || A9(e.scrollbarX, ":focus") || A9(e.scrollbarY, ":focus"))) {
					var r,
						i = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
					if (i) {
						if ("IFRAME" === i.tagName) i = i.contentDocument.activeElement;
						else for (; i.shadowRoot; ) i = i.shadowRoot.activeElement;
						if (A9((r = i), "input,[contenteditable]") || A9(r, "select,[contenteditable]") || A9(r, "textarea,[contenteditable]") || A9(r, "button,[contenteditable]")) return;
					}
					var s = 0,
						o = 0;
					switch (n.which) {
						case 37:
							s = n.metaKey ? -e.contentWidth : n.altKey ? -e.containerWidth : -30;
							break;
						case 38:
							o = n.metaKey ? e.contentHeight : n.altKey ? e.containerHeight : 30;
							break;
						case 39:
							s = n.metaKey ? e.contentWidth : n.altKey ? e.containerWidth : 30;
							break;
						case 40:
							o = n.metaKey ? -e.contentHeight : n.altKey ? -e.containerHeight : -30;
							break;
						case 32:
							o = n.shiftKey ? e.containerHeight : -e.containerHeight;
							break;
						case 33:
							o = e.containerHeight;
							break;
						case 34:
							o = -e.containerHeight;
							break;
						case 36:
							o = e.contentHeight;
							break;
						case 35:
							o = -e.contentHeight;
							break;
						default:
							return;
					}
					(e.settings.suppressScrollX && 0 !== s) ||
						(e.settings.suppressScrollY && 0 !== o) ||
						((t.scrollTop -= o),
						(t.scrollLeft += s),
						W9(e),
						(function (n, r) {
							var i = Math.floor(t.scrollTop);
							if (0 === n) {
								if (!e.scrollbarYActive) return !1;
								if ((0 === i && r > 0) || (i >= e.contentHeight - e.containerHeight && r < 0)) return !e.settings.wheelPropagation;
							}
							var s = t.scrollLeft;
							if (0 === r) {
								if (!e.scrollbarXActive) return !1;
								if ((0 === s && n < 0) || (s >= e.contentWidth - e.containerWidth && n > 0)) return !e.settings.wheelPropagation;
							}
							return !0;
						})(s, o) && n.preventDefault());
				}
			});
		},
		wheel: function (e) {
			var t = e.element;
			function n(n) {
				var r = (function (e) {
						var t = e.deltaX,
							n = -1 * e.deltaY;
						return (void 0 !== t && void 0 !== n) || ((t = (-1 * e.wheelDeltaX) / 6), (n = e.wheelDeltaY / 6)), e.deltaMode && 1 === e.deltaMode && ((t *= 10), (n *= 10)), t != t && n != n && ((t = 0), (n = e.wheelDelta)), e.shiftKey ? [-n, -t] : [t, n];
					})(n),
					i = r[0],
					s = r[1];
				if (
					!(function (e, n, r) {
						if (!j9.isWebKit && t.querySelector("select:focus")) return !0;
						if (!t.contains(e)) return !1;
						for (var i = e; i && i !== t; ) {
							if (i.classList.contains(O9.consuming)) return !0;
							var s = S9(i);
							if (r && s.overflowY.match(/(scroll|auto)/)) {
								var o = i.scrollHeight - i.clientHeight;
								if (o > 0 && ((i.scrollTop > 0 && r < 0) || (i.scrollTop < o && r > 0))) return !0;
							}
							if (n && s.overflowX.match(/(scroll|auto)/)) {
								var a = i.scrollWidth - i.clientWidth;
								if (a > 0 && ((i.scrollLeft > 0 && n < 0) || (i.scrollLeft < a && n > 0))) return !0;
							}
							i = i.parentNode;
						}
						return !1;
					})(n.target, i, s)
				) {
					var o = !1;
					e.settings.useBothWheelAxes
						? e.scrollbarYActive && !e.scrollbarXActive
							? (s ? (t.scrollTop -= s * e.settings.wheelSpeed) : (t.scrollTop += i * e.settings.wheelSpeed), (o = !0))
							: e.scrollbarXActive && !e.scrollbarYActive && (i ? (t.scrollLeft += i * e.settings.wheelSpeed) : (t.scrollLeft -= s * e.settings.wheelSpeed), (o = !0))
						: ((t.scrollTop -= s * e.settings.wheelSpeed), (t.scrollLeft += i * e.settings.wheelSpeed)),
						W9(e),
						(o =
							o ||
							(function (n, r) {
								var i = Math.floor(t.scrollTop),
									s = 0 === t.scrollTop,
									o = i + t.offsetHeight === t.scrollHeight,
									a = 0 === t.scrollLeft,
									l = t.scrollLeft + t.offsetWidth === t.scrollWidth;
								return !(Math.abs(r) > Math.abs(n) ? s || o : a || l) || !e.settings.wheelPropagation;
							})(i, s)) &&
							!n.ctrlKey &&
							(n.stopPropagation(), n.preventDefault());
				}
			}
			void 0 !== window.onwheel ? e.event.bind(t, "wheel", n) : void 0 !== window.onmousewheel && e.event.bind(t, "mousewheel", n);
		},
		touch: function (e) {
			if (j9.supportsTouch || j9.supportsIePointer) {
				var t = e.element,
					n = {},
					r = 0,
					i = {},
					s = null;
				j9.supportsTouch
					? (e.event.bind(t, "touchstart", u), e.event.bind(t, "touchmove", c), e.event.bind(t, "touchend", h))
					: j9.supportsIePointer &&
					  (window.PointerEvent ? (e.event.bind(t, "pointerdown", u), e.event.bind(t, "pointermove", c), e.event.bind(t, "pointerup", h)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", u), e.event.bind(t, "MSPointerMove", c), e.event.bind(t, "MSPointerUp", h)));
			}
			function o(n, r) {
				(t.scrollTop -= r), (t.scrollLeft -= n), W9(e);
			}
			function a(e) {
				return e.targetTouches ? e.targetTouches[0] : e;
			}
			function l(e) {
				return (!e.pointerType || "pen" !== e.pointerType || 0 !== e.buttons) && (!(!e.targetTouches || 1 !== e.targetTouches.length) || !(!e.pointerType || "mouse" === e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE));
			}
			function u(e) {
				if (l(e)) {
					var t = a(e);
					(n.pageX = t.pageX), (n.pageY = t.pageY), (r = new Date().getTime()), null !== s && clearInterval(s);
				}
			}
			function c(s) {
				if (l(s)) {
					var u = a(s),
						c = { pageX: u.pageX, pageY: u.pageY },
						h = c.pageX - n.pageX,
						d = c.pageY - n.pageY;
					if (
						(function (e, n, r) {
							if (!t.contains(e)) return !1;
							for (var i = e; i && i !== t; ) {
								if (i.classList.contains(O9.consuming)) return !0;
								var s = S9(i);
								if (r && s.overflowY.match(/(scroll|auto)/)) {
									var o = i.scrollHeight - i.clientHeight;
									if (o > 0 && ((i.scrollTop > 0 && r < 0) || (i.scrollTop < o && r > 0))) return !0;
								}
								if (n && s.overflowX.match(/(scroll|auto)/)) {
									var a = i.scrollWidth - i.clientWidth;
									if (a > 0 && ((i.scrollLeft > 0 && n < 0) || (i.scrollLeft < a && n > 0))) return !0;
								}
								i = i.parentNode;
							}
							return !1;
						})(s.target, h, d)
					)
						return;
					o(h, d), (n = c);
					var p = new Date().getTime(),
						f = p - r;
					f > 0 && ((i.x = h / f), (i.y = d / f), (r = p)),
						(function (n, r) {
							var i = Math.floor(t.scrollTop),
								s = t.scrollLeft,
								o = Math.abs(n),
								a = Math.abs(r);
							if (a > o) {
								if ((r < 0 && i === e.contentHeight - e.containerHeight) || (r > 0 && 0 === i)) return 0 === window.scrollY && r > 0 && j9.isChrome;
							} else if (o > a && ((n < 0 && s === e.contentWidth - e.containerWidth) || (n > 0 && 0 === s))) return !0;
							return !0;
						})(h, d) && s.preventDefault();
				}
			}
			function h() {
				e.settings.swipeEasing &&
					(clearInterval(s),
					(s = setInterval(function () {
						e.isInitialized ? clearInterval(s) : i.x || i.y ? (Math.abs(i.x) < 0.01 && Math.abs(i.y) < 0.01 ? clearInterval(s) : (o(30 * i.x, 30 * i.y), (i.x *= 0.8), (i.y *= 0.8))) : clearInterval(s);
					}, 10)));
			}
		}
	},
	K9 = function (e, t) {
		var n = this;
		if ((void 0 === t && (t = {}), "string" == typeof e && (e = document.querySelector(e)), !e || !e.nodeName)) throw new Error("no element is specified to initialize PerfectScrollbar");
		for (var r in ((this.element = e),
		e.classList.add(R9),
		(this.settings = {
			handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
			maxScrollbarLength: null,
			minScrollbarLength: null,
			scrollingThreshold: 1e3,
			scrollXMarginOffset: 0,
			scrollYMarginOffset: 0,
			suppressScrollX: !1,
			suppressScrollY: !1,
			swipeEasing: !0,
			useBothWheelAxes: !1,
			wheelPropagation: !0,
			wheelSpeed: 1
		}),
		t))
			this.settings[r] = t[r];
		(this.containerWidth = null), (this.containerHeight = null), (this.contentWidth = null), (this.contentHeight = null);
		var i,
			s,
			o = function () {
				return e.classList.add(P9.focus);
			},
			a = function () {
				return e.classList.remove(P9.focus);
			};
		(this.isRtl = "rtl" === S9(e).direction),
			!0 === this.isRtl && e.classList.add(L9),
			(this.isNegativeScroll = ((s = e.scrollLeft), (e.scrollLeft = -1), (i = e.scrollLeft < 0), (e.scrollLeft = s), i)),
			(this.negativeScrollAdjustment = this.isNegativeScroll ? e.scrollWidth - e.clientWidth : 0),
			(this.event = new V9()),
			(this.ownerDocument = e.ownerDocument || document),
			(this.scrollbarXRail = T9(O9.rail("x"))),
			e.appendChild(this.scrollbarXRail),
			(this.scrollbarX = T9(O9.thumb("x"))),
			this.scrollbarXRail.appendChild(this.scrollbarX),
			this.scrollbarX.setAttribute("tabindex", 0),
			this.event.bind(this.scrollbarX, "focus", o),
			this.event.bind(this.scrollbarX, "blur", a),
			(this.scrollbarXActive = null),
			(this.scrollbarXWidth = null),
			(this.scrollbarXLeft = null);
		var l = S9(this.scrollbarXRail);
		(this.scrollbarXBottom = parseInt(l.bottom, 10)),
			isNaN(this.scrollbarXBottom) ? ((this.isScrollbarXUsingBottom = !1), (this.scrollbarXTop = $9(l.top))) : (this.isScrollbarXUsingBottom = !0),
			(this.railBorderXWidth = $9(l.borderLeftWidth) + $9(l.borderRightWidth)),
			E9(this.scrollbarXRail, { display: "block" }),
			(this.railXMarginWidth = $9(l.marginLeft) + $9(l.marginRight)),
			E9(this.scrollbarXRail, { display: "" }),
			(this.railXWidth = null),
			(this.railXRatio = null),
			(this.scrollbarYRail = T9(O9.rail("y"))),
			e.appendChild(this.scrollbarYRail),
			(this.scrollbarY = T9(O9.thumb("y"))),
			this.scrollbarYRail.appendChild(this.scrollbarY),
			this.scrollbarY.setAttribute("tabindex", 0),
			this.event.bind(this.scrollbarY, "focus", o),
			this.event.bind(this.scrollbarY, "blur", a),
			(this.scrollbarYActive = null),
			(this.scrollbarYHeight = null),
			(this.scrollbarYTop = null);
		var u = S9(this.scrollbarYRail);
		(this.scrollbarYRight = parseInt(u.right, 10)),
			isNaN(this.scrollbarYRight) ? ((this.isScrollbarYUsingRight = !1), (this.scrollbarYLeft = $9(u.left))) : (this.isScrollbarYUsingRight = !0),
			(this.scrollbarYOuterWidth = this.isRtl
				? (function (e) {
						var t = S9(e);
						return $9(t.width) + $9(t.paddingLeft) + $9(t.paddingRight) + $9(t.borderLeftWidth) + $9(t.borderRightWidth);
				  })(this.scrollbarY)
				: null),
			(this.railBorderYWidth = $9(u.borderTopWidth) + $9(u.borderBottomWidth)),
			E9(this.scrollbarYRail, { display: "block" }),
			(this.railYMarginHeight = $9(u.marginTop) + $9(u.marginBottom)),
			E9(this.scrollbarYRail, { display: "" }),
			(this.railYHeight = null),
			(this.railYRatio = null),
			(this.reach = { x: e.scrollLeft <= 0 ? "start" : e.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null, y: e.scrollTop <= 0 ? "start" : e.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null }),
			(this.isAlive = !0),
			this.settings.handlers.forEach(function (e) {
				return X9[e](n);
			}),
			(this.lastScrollTop = Math.floor(e.scrollTop)),
			(this.lastScrollLeft = e.scrollLeft),
			this.event.bind(this.element, "scroll", function (e) {
				return n.onScroll(e);
			}),
			W9(this);
	};
(K9.prototype.update = function () {
	this.isAlive &&
		((this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0),
		E9(this.scrollbarXRail, { display: "block" }),
		E9(this.scrollbarYRail, { display: "block" }),
		(this.railXMarginWidth = $9(S9(this.scrollbarXRail).marginLeft) + $9(S9(this.scrollbarXRail).marginRight)),
		(this.railYMarginHeight = $9(S9(this.scrollbarYRail).marginTop) + $9(S9(this.scrollbarYRail).marginBottom)),
		E9(this.scrollbarXRail, { display: "none" }),
		E9(this.scrollbarYRail, { display: "none" }),
		W9(this),
		z9(this, "top", 0, !1, !0),
		z9(this, "left", 0, !1, !0),
		E9(this.scrollbarXRail, { display: "" }),
		E9(this.scrollbarYRail, { display: "" }));
}),
	(K9.prototype.onScroll = function (e) {
		this.isAlive && (W9(this), z9(this, "top", this.element.scrollTop - this.lastScrollTop), z9(this, "left", this.element.scrollLeft - this.lastScrollLeft), (this.lastScrollTop = Math.floor(this.element.scrollTop)), (this.lastScrollLeft = this.element.scrollLeft));
	}),
	(K9.prototype.destroy = function () {
		this.isAlive &&
			(this.event.unbindAll(),
			M9(this.scrollbarX),
			M9(this.scrollbarY),
			M9(this.scrollbarXRail),
			M9(this.scrollbarYRail),
			this.removePsClasses(),
			(this.element = null),
			(this.scrollbarX = null),
			(this.scrollbarY = null),
			(this.scrollbarXRail = null),
			(this.scrollbarYRail = null),
			(this.isAlive = !1));
	}),
	(K9.prototype.removePsClasses = function () {
		this.element.className = this.element.className
			.split(" ")
			.filter(function (e) {
				return !e.match(/^ps([-_].+|)$/);
			})
			.join(" ");
	});
const q9 = ["scroll", "ps-scroll-y", "ps-scroll-x", "ps-scroll-up", "ps-scroll-down", "ps-scroll-left", "ps-scroll-right", "ps-y-reach-start", "ps-y-reach-end", "ps-x-reach-start", "ps-x-reach-end"];
var Z9 = {
		name: "PerfectScrollbar",
		props: { options: { type: Object, required: !1, default: () => {} }, tag: { type: String, required: !1, default: "div" }, watchOptions: { type: Boolean, required: !1, default: !1 } },
		emits: q9,
		data: () => ({ ps: null }),
		watch: {
			watchOptions(e) {
				!e && this.watcher ? this.watcher() : this.createWatcher();
			}
		},
		mounted() {
			this.create(), this.watchOptions && this.createWatcher();
		},
		updated() {
			this.$nextTick(() => {
				this.update();
			});
		},
		beforeUnmount() {
			this.destroy();
		},
		methods: {
			create() {
				(this.ps && this.$isServer) ||
					((this.ps = new K9(this.$el, this.options)),
					q9.forEach((e) => {
						this.ps.element.addEventListener(e, (t) => this.$emit(e, t));
					}));
			},
			createWatcher() {
				this.watcher = this.$watch(
					"options",
					() => {
						this.destroy(), this.create();
					},
					{ deep: !0 }
				);
			},
			update() {
				this.ps && this.ps.update();
			},
			destroy() {
				this.ps && (this.ps.destroy(), (this.ps = null));
			}
		},
		render() {
			return xs(this.tag, { class: "ps" }, this.$slots.default && this.$slots.default());
		}
	},
	J9 = {
		install: (e, t) => {
			t &&
				(t.name && "string" == typeof t.name && (Z9.name = t.name),
				t.options && "object" == typeof t.options && (Z9.props.options.default = () => t.options),
				t.tag && "string" == typeof t.tag && (Z9.props.tag.default = t.tag),
				t.watchOptions && "boolean" == typeof t.watchOptions && (Z9.props.watchOptions = t.watchOptions)),
				e.component(Z9.name, Z9);
		}
	};
/*!
 * shared v9.2.0-beta.16
 * (c) 2021 kazuya kawaguchi
 * Released under the MIT License.
 */
const Q9 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
	eee = (e) => (Q9 ? Symbol(e) : e),
	tee = (e) =>
		JSON.stringify(e)
			.replace(/\u2028/g, "\\u2028")
			.replace(/\u2029/g, "\\u2029")
			.replace(/\u0027/g, "\\u0027"),
	nee = (e) => "number" == typeof e && isFinite(e),
	ree = (e) => "[object RegExp]" === yee(e),
	iee = (e) => bee(e) && 0 === Object.keys(e).length;
function see(e, t) {
	"undefined" != typeof console && (console.warn("[intlify] " + e), t && console.warn(t.stack));
}
const oee = Object.assign;
let aee;
const lee = () => aee || (aee = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
function uee(e) {
	return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const cee = Object.prototype.hasOwnProperty;
function hee(e, t) {
	return cee.call(e, t);
}
const dee = Array.isArray,
	pee = (e) => "function" == typeof e,
	fee = (e) => "string" == typeof e,
	mee = (e) => "boolean" == typeof e,
	vee = (e) => null !== e && "object" == typeof e,
	gee = Object.prototype.toString,
	yee = (e) => gee.call(e),
	bee = (e) => "[object Object]" === yee(e),
	xee = 1,
	_ee = 2,
	wee = 3,
	Cee = 4,
	See = 5,
	Eee = 6,
	Tee = 7,
	kee = 8,
	Aee = 9,
	Mee = 10,
	Iee = 11,
	Ree = 12,
	Lee = 13,
	Oee = 14,
	Pee = 15;
function Nee(e, t, n = {}) {
	const { domain: r, messages: i, args: s } = n,
		o = new SyntaxError(String(e));
	return (o.code = e), t && (o.location = t), (o.domain = r), o;
}
function Dee(e) {
	throw e;
}
function Bee(e, t, n) {
	const r = { start: e, end: t };
	return null != n && (r.source = n), r;
}
const Fee = String.fromCharCode(8232),
	Hee = String.fromCharCode(8233);
function Vee(e) {
	const t = e;
	let n = 0,
		r = 1,
		i = 1,
		s = 0;
	const o = (e) => "\r" === t[e] && "\n" === t[e + 1],
		a = (e) => t[e] === Hee,
		l = (e) => t[e] === Fee,
		u = (e) => o(e) || ((e) => "\n" === t[e])(e) || a(e) || l(e),
		c = (e) => (o(e) || a(e) || l(e) ? "\n" : t[e]);
	function h() {
		return (s = 0), u(n) && (r++, (i = 0)), o(n) && n++, n++, i++, t[n];
	}
	return {
		index: () => n,
		line: () => r,
		column: () => i,
		peekOffset: () => s,
		charAt: c,
		currentChar: () => c(n),
		currentPeek: () => c(n + s),
		next: h,
		peek: function () {
			return o(n + s) && s++, s++, t[n + s];
		},
		reset: function () {
			(n = 0), (r = 1), (i = 1), (s = 0);
		},
		resetPeek: function (e = 0) {
			s = e;
		},
		skipToPeek: function () {
			const e = n + s;
			for (; e !== n; ) h();
			s = 0;
		}
	};
}
const Uee = void 0;
function zee(e, t = {}) {
	const n = !1 !== t.location,
		r = Vee(e),
		i = () => r.index(),
		s = () => {
			return (e = r.line()), (t = r.column()), (n = r.index()), { line: e, column: t, offset: n };
			var e, t, n;
		},
		o = s(),
		a = i(),
		l = { currentType: 14, offset: a, startLoc: o, endLoc: o, lastType: 14, lastOffset: a, lastStartLoc: o, lastEndLoc: o, braceNest: 0, inLinked: !1, text: "" },
		u = () => l,
		{ onError: c } = t;
	function h(e, t, n, ...r) {
		const i = u();
		if (((t.column += n), (t.offset += n), c)) {
			const n = Nee(e, Bee(i.startLoc, t), { domain: "tokenizer", args: r });
			c(n);
		}
	}
	function d(e, t, r) {
		(e.endLoc = s()), (e.currentType = t);
		const i = { type: t };
		return n && (i.loc = Bee(e.startLoc, e.endLoc)), null != r && (i.value = r), i;
	}
	const p = (e) => d(e, 14);
	function f(e, t) {
		return e.currentChar() === t ? (e.next(), t) : (h(xee, s(), 0, t), "");
	}
	function m(e) {
		let t = "";
		for (; " " === e.currentPeek() || "\n" === e.currentPeek(); ) (t += e.currentPeek()), e.peek();
		return t;
	}
	function v(e) {
		const t = m(e);
		return e.skipToPeek(), t;
	}
	function g(e) {
		if (e === Uee) return !1;
		const t = e.charCodeAt(0);
		return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || 95 === t;
	}
	function y(e, t) {
		const { currentType: n } = t;
		if (2 !== n) return !1;
		m(e);
		const r = (function (e) {
			if (e === Uee) return !1;
			const t = e.charCodeAt(0);
			return t >= 48 && t <= 57;
		})("-" === e.currentPeek() ? e.peek() : e.currentPeek());
		return e.resetPeek(), r;
	}
	function b(e) {
		m(e);
		const t = "|" === e.currentPeek();
		return e.resetPeek(), t;
	}
	function x(e, t = !0) {
		const n = (t = !1, r = "", i = !1) => {
				const s = e.currentPeek();
				return "{" === s ? "%" !== r && t : "@" !== s && s ? ("%" === s ? (e.peek(), n(t, "%", !0)) : "|" === s ? !("%" !== r && !i) || !(" " === r || "\n" === r) : " " === s ? (e.peek(), n(!0, " ", i)) : "\n" !== s || (e.peek(), n(!0, "\n", i))) : "%" === r || t;
			},
			r = n();
		return t && e.resetPeek(), r;
	}
	function _(e, t) {
		const n = e.currentChar();
		return n === Uee ? Uee : t(n) ? (e.next(), n) : null;
	}
	function w(e) {
		return _(e, (e) => {
			const t = e.charCodeAt(0);
			return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || (t >= 48 && t <= 57) || 95 === t || 36 === t;
		});
	}
	function C(e) {
		return _(e, (e) => {
			const t = e.charCodeAt(0);
			return t >= 48 && t <= 57;
		});
	}
	function S(e) {
		return _(e, (e) => {
			const t = e.charCodeAt(0);
			return (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102);
		});
	}
	function E(e) {
		let t = "",
			n = "";
		for (; (t = C(e)); ) n += t;
		return n;
	}
	function T(e) {
		const t = e.currentChar();
		switch (t) {
			case "\\":
			case "'":
				return e.next(), `\\${t}`;
			case "u":
				return k(e, t, 4);
			case "U":
				return k(e, t, 6);
			default:
				return h(Cee, s(), 0, t), "";
		}
	}
	function k(e, t, n) {
		f(e, t);
		let r = "";
		for (let i = 0; i < n; i++) {
			const n = S(e);
			if (!n) {
				h(See, s(), 0, `\\${t}${r}${e.currentChar()}`);
				break;
			}
			r += n;
		}
		return `\\${t}${r}`;
	}
	function A(e) {
		v(e);
		const t = f(e, "|");
		return v(e), t;
	}
	function M(e, t) {
		let n = null;
		switch (e.currentChar()) {
			case "{":
				return t.braceNest >= 1 && h(Aee, s(), 0), e.next(), (n = d(t, 2, "{")), v(e), t.braceNest++, n;
			case "}":
				return t.braceNest > 0 && 2 === t.currentType && h(kee, s(), 0), e.next(), (n = d(t, 3, "}")), t.braceNest--, t.braceNest > 0 && v(e), t.inLinked && 0 === t.braceNest && (t.inLinked = !1), n;
			case "@":
				return t.braceNest > 0 && h(Tee, s(), 0), (n = I(e, t) || p(t)), (t.braceNest = 0), n;
			default:
				let r = !0,
					i = !0,
					o = !0;
				if (b(e)) return t.braceNest > 0 && h(Tee, s(), 0), (n = d(t, 1, A(e))), (t.braceNest = 0), (t.inLinked = !1), n;
				if (t.braceNest > 0 && (5 === t.currentType || 6 === t.currentType || 7 === t.currentType)) return h(Tee, s(), 0), (t.braceNest = 0), R(e, t);
				if (
					(r = (function (e, t) {
						const { currentType: n } = t;
						if (2 !== n) return !1;
						m(e);
						const r = g(e.currentPeek());
						return e.resetPeek(), r;
					})(e, t))
				)
					return (
						(n = d(
							t,
							5,
							(function (e) {
								v(e);
								let t = "",
									n = "";
								for (; (t = w(e)); ) n += t;
								return e.currentChar() === Uee && h(Tee, s(), 0), n;
							})(e)
						)),
						v(e),
						n
					);
				if ((i = y(e, t)))
					return (
						(n = d(
							t,
							6,
							(function (e) {
								v(e);
								let t = "";
								return "-" === e.currentChar() ? (e.next(), (t += `-${E(e)}`)) : (t += E(e)), e.currentChar() === Uee && h(Tee, s(), 0), t;
							})(e)
						)),
						v(e),
						n
					);
				if (
					(o = (function (e, t) {
						const { currentType: n } = t;
						if (2 !== n) return !1;
						m(e);
						const r = "'" === e.currentPeek();
						return e.resetPeek(), r;
					})(e, t))
				)
					return (
						(n = d(
							t,
							7,
							(function (e) {
								v(e), f(e, "'");
								let t = "",
									n = "";
								const r = (e) => "'" !== e && "\n" !== e;
								for (; (t = _(e, r)); ) n += "\\" === t ? T(e) : t;
								const i = e.currentChar();
								return "\n" === i || i === Uee ? (h(wee, s(), 0), "\n" === i && (e.next(), f(e, "'")), n) : (f(e, "'"), n);
							})(e)
						)),
						v(e),
						n
					);
				if (!r && !i && !o)
					return (
						(n = d(
							t,
							13,
							(function (e) {
								v(e);
								let t = "",
									n = "";
								const r = (e) => "{" !== e && "}" !== e && " " !== e && "\n" !== e;
								for (; (t = _(e, r)); ) n += t;
								return n;
							})(e)
						)),
						h(_ee, s(), 0, n.value),
						v(e),
						n
					);
		}
		return n;
	}
	function I(e, t) {
		const { currentType: n } = t;
		let r = null;
		const i = e.currentChar();
		switch (((8 !== n && 9 !== n && 12 !== n && 10 !== n) || ("\n" !== i && " " !== i) || h(Mee, s(), 0), i)) {
			case "@":
				return e.next(), (r = d(t, 8, "@")), (t.inLinked = !0), r;
			case ".":
				return v(e), e.next(), d(t, 9, ".");
			case ":":
				return v(e), e.next(), d(t, 10, ":");
			default:
				return b(e)
					? ((r = d(t, 1, A(e))), (t.braceNest = 0), (t.inLinked = !1), r)
					: (function (e, t) {
							const { currentType: n } = t;
							if (8 !== n) return !1;
							m(e);
							const r = "." === e.currentPeek();
							return e.resetPeek(), r;
					  })(e, t) ||
					  (function (e, t) {
							const { currentType: n } = t;
							if (8 !== n && 12 !== n) return !1;
							m(e);
							const r = ":" === e.currentPeek();
							return e.resetPeek(), r;
					  })(e, t)
					? (v(e), I(e, t))
					: (function (e, t) {
							const { currentType: n } = t;
							if (9 !== n) return !1;
							m(e);
							const r = g(e.currentPeek());
							return e.resetPeek(), r;
					  })(e, t)
					? (v(e),
					  d(
							t,
							12,
							(function (e) {
								let t = "",
									n = "";
								for (; (t = w(e)); ) n += t;
								return n;
							})(e)
					  ))
					: (function (e, t) {
							const { currentType: n } = t;
							if (10 !== n) return !1;
							const r = () => {
									const t = e.currentPeek();
									return "{" === t ? g(e.peek()) : !("@" === t || "%" === t || "|" === t || ":" === t || "." === t || " " === t || !t) && ("\n" === t ? (e.peek(), r()) : g(t));
								},
								i = r();
							return e.resetPeek(), i;
					  })(e, t)
					? (v(e),
					  "{" === i
							? M(e, t) || r
							: d(
									t,
									11,
									(function (e) {
										const t = (n = !1, r) => {
											const i = e.currentChar();
											return "{" !== i && "%" !== i && "@" !== i && "|" !== i && i ? (" " === i ? r : "\n" === i ? ((r += i), e.next(), t(n, r)) : ((r += i), e.next(), t(!0, r))) : r;
										};
										return t(!1, "");
									})(e)
							  ))
					: (8 === n && h(Mee, s(), 0), (t.braceNest = 0), (t.inLinked = !1), R(e, t));
		}
	}
	function R(e, t) {
		let n = { type: 14 };
		if (t.braceNest > 0) return M(e, t) || p(t);
		if (t.inLinked) return I(e, t) || p(t);
		const r = e.currentChar();
		switch (r) {
			case "{":
				return M(e, t) || p(t);
			case "}":
				return h(Eee, s(), 0), e.next(), d(t, 3, "}");
			case "@":
				return I(e, t) || p(t);
			default:
				if (b(e)) return (n = d(t, 1, A(e))), (t.braceNest = 0), (t.inLinked = !1), n;
				if (x(e))
					return d(
						t,
						0,
						(function (e) {
							let t = "";
							for (;;) {
								const n = e.currentChar();
								if ("{" === n || "}" === n || "@" === n || "|" === n || !n) break;
								if ("%" === n) {
									if (!x(e)) break;
									(t += n), e.next();
								} else if (" " === n || "\n" === n)
									if (x(e)) (t += n), e.next();
									else {
										if (b(e)) break;
										(t += n), e.next();
									}
								else (t += n), e.next();
							}
							return t;
						})(e)
					);
				if ("%" === r) return e.next(), d(t, 4, "%");
		}
		return n;
	}
	return {
		nextToken: function () {
			const { currentType: e, offset: t, startLoc: n, endLoc: o } = l;
			return (l.lastType = e), (l.lastOffset = t), (l.lastStartLoc = n), (l.lastEndLoc = o), (l.offset = i()), (l.startLoc = s()), r.currentChar() === Uee ? d(l, 14) : R(r, l);
		},
		currentOffset: i,
		currentPosition: s,
		context: u
	};
}
const $ee = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function jee(e, t, n) {
	switch (e) {
		case "\\\\":
			return "\\";
		case "\\'":
			return "'";
		default: {
			const e = parseInt(t || n, 16);
			return e <= 55295 || e >= 57344 ? String.fromCodePoint(e) : "�";
		}
	}
}
function Wee(e = {}) {
	const t = !1 !== e.location,
		{ onError: n } = e;
	function r(e, t, r, i, ...s) {
		const o = e.currentPosition();
		if (((o.offset += i), (o.column += i), n)) {
			const e = Nee(t, Bee(r, o), { domain: "parser", args: s });
			n(e);
		}
	}
	function i(e, n, r) {
		const i = { type: e, start: n, end: n };
		return t && (i.loc = { start: r, end: r }), i;
	}
	function s(e, n, r, i) {
		(e.end = n), i && (e.type = i), t && e.loc && (e.loc.end = r);
	}
	function o(e, t) {
		const n = e.context(),
			r = i(3, n.offset, n.startLoc);
		return (r.value = t), s(r, e.currentOffset(), e.currentPosition()), r;
	}
	function a(e, t) {
		const n = e.context(),
			{ lastOffset: r, lastStartLoc: o } = n,
			a = i(5, r, o);
		return (a.index = parseInt(t, 10)), e.nextToken(), s(a, e.currentOffset(), e.currentPosition()), a;
	}
	function l(e, t) {
		const n = e.context(),
			{ lastOffset: r, lastStartLoc: o } = n,
			a = i(4, r, o);
		return (a.key = t), e.nextToken(), s(a, e.currentOffset(), e.currentPosition()), a;
	}
	function u(e, t) {
		const n = e.context(),
			{ lastOffset: r, lastStartLoc: o } = n,
			a = i(9, r, o);
		return (a.value = t.replace($ee, jee)), e.nextToken(), s(a, e.currentOffset(), e.currentPosition()), a;
	}
	function c(e) {
		const t = e.context(),
			n = i(6, t.offset, t.startLoc);
		let o = e.nextToken();
		if (9 === o.type) {
			const t = (function (e) {
				const t = e.nextToken(),
					n = e.context(),
					{ lastOffset: o, lastStartLoc: a } = n,
					l = i(8, o, a);
				return 12 !== t.type ? (r(e, Ree, n.lastStartLoc, 0), (l.value = ""), s(l, o, a), { nextConsumeToken: t, node: l }) : (null == t.value && r(e, Oee, n.lastStartLoc, 0, Gee(t)), (l.value = t.value || ""), s(l, e.currentOffset(), e.currentPosition()), { node: l });
			})(e);
			(n.modifier = t.node), (o = t.nextConsumeToken || e.nextToken());
		}
		switch ((10 !== o.type && r(e, Oee, t.lastStartLoc, 0, Gee(o)), (o = e.nextToken()), 2 === o.type && (o = e.nextToken()), o.type)) {
			case 11:
				null == o.value && r(e, Oee, t.lastStartLoc, 0, Gee(o)),
					(n.key = (function (e, t) {
						const n = e.context(),
							r = i(7, n.offset, n.startLoc);
						return (r.value = t), s(r, e.currentOffset(), e.currentPosition()), r;
					})(e, o.value || ""));
				break;
			case 5:
				null == o.value && r(e, Oee, t.lastStartLoc, 0, Gee(o)), (n.key = l(e, o.value || ""));
				break;
			case 6:
				null == o.value && r(e, Oee, t.lastStartLoc, 0, Gee(o)), (n.key = a(e, o.value || ""));
				break;
			case 7:
				null == o.value && r(e, Oee, t.lastStartLoc, 0, Gee(o)), (n.key = u(e, o.value || ""));
				break;
			default:
				r(e, Lee, t.lastStartLoc, 0);
				const c = e.context(),
					h = i(7, c.offset, c.startLoc);
				return (h.value = ""), s(h, c.offset, c.startLoc), (n.key = h), s(n, c.offset, c.startLoc), { nextConsumeToken: o, node: n };
		}
		return s(n, e.currentOffset(), e.currentPosition()), { node: n };
	}
	function h(e) {
		const t = e.context(),
			n = i(2, 1 === t.currentType ? e.currentOffset() : t.offset, 1 === t.currentType ? t.endLoc : t.startLoc);
		n.items = [];
		let h = null;
		do {
			const i = h || e.nextToken();
			switch (((h = null), i.type)) {
				case 0:
					null == i.value && r(e, Oee, t.lastStartLoc, 0, Gee(i)), n.items.push(o(e, i.value || ""));
					break;
				case 6:
					null == i.value && r(e, Oee, t.lastStartLoc, 0, Gee(i)), n.items.push(a(e, i.value || ""));
					break;
				case 5:
					null == i.value && r(e, Oee, t.lastStartLoc, 0, Gee(i)), n.items.push(l(e, i.value || ""));
					break;
				case 7:
					null == i.value && r(e, Oee, t.lastStartLoc, 0, Gee(i)), n.items.push(u(e, i.value || ""));
					break;
				case 8:
					const s = c(e);
					n.items.push(s.node), (h = s.nextConsumeToken || null);
			}
		} while (14 !== t.currentType && 1 !== t.currentType);
		return s(n, 1 === t.currentType ? t.lastOffset : e.currentOffset(), 1 === t.currentType ? t.lastEndLoc : e.currentPosition()), n;
	}
	function d(e) {
		const t = e.context(),
			{ offset: n, startLoc: o } = t,
			a = h(e);
		return 14 === t.currentType
			? a
			: (function (e, t, n, o) {
					const a = e.context();
					let l = 0 === o.items.length;
					const u = i(1, t, n);
					(u.cases = []), u.cases.push(o);
					do {
						const t = h(e);
						l || (l = 0 === t.items.length), u.cases.push(t);
					} while (14 !== a.currentType);
					return l && r(e, Iee, n, 0), s(u, e.currentOffset(), e.currentPosition()), u;
			  })(e, n, o, a);
	}
	return {
		parse: function (n) {
			const o = zee(n, oee({}, e)),
				a = o.context(),
				l = i(0, a.offset, a.startLoc);
			return t && l.loc && (l.loc.source = n), (l.body = d(o)), 14 !== a.currentType && r(o, Oee, a.lastStartLoc, 0, n[a.offset] || ""), s(l, o.currentOffset(), o.currentPosition()), l;
		}
	};
}
function Gee(e) {
	if (14 === e.type) return "EOF";
	const t = (e.value || "").replace(/\r?\n/gu, "\\n");
	return t.length > 10 ? t.slice(0, 9) + "…" : t;
}
function Yee(e, t) {
	for (let n = 0; n < e.length; n++) Xee(e[n], t);
}
function Xee(e, t) {
	switch (e.type) {
		case 1:
			Yee(e.cases, t), t.helper("plural");
			break;
		case 2:
			Yee(e.items, t);
			break;
		case 6:
			Xee(e.key, t), t.helper("linked");
			break;
		case 5:
			t.helper("interpolate"), t.helper("list");
			break;
		case 4:
			t.helper("interpolate"), t.helper("named");
	}
}
function Kee(e, t = {}) {
	const n = (function (e, t = {}) {
		const n = { ast: e, helpers: new Set() };
		return { context: () => n, helper: (e) => (n.helpers.add(e), e) };
	})(e);
	n.helper("normalize"), e.body && Xee(e.body, n);
	const r = n.context();
	e.helpers = Array.from(r.helpers);
}
function qee(e, t) {
	const { helper: n } = e;
	switch (t.type) {
		case 0:
			!(function (e, t) {
				t.body ? qee(e, t.body) : e.push("null");
			})(e, t);
			break;
		case 1:
			!(function (e, t) {
				const { helper: n, needIndent: r } = e;
				if (t.cases.length > 1) {
					e.push(`${n("plural")}([`), e.indent(r());
					const i = t.cases.length;
					for (let n = 0; n < i && (qee(e, t.cases[n]), n !== i - 1); n++) e.push(", ");
					e.deindent(r()), e.push("])");
				}
			})(e, t);
			break;
		case 2:
			!(function (e, t) {
				const { helper: n, needIndent: r } = e;
				e.push(`${n("normalize")}([`), e.indent(r());
				const i = t.items.length;
				for (let s = 0; s < i && (qee(e, t.items[s]), s !== i - 1); s++) e.push(", ");
				e.deindent(r()), e.push("])");
			})(e, t);
			break;
		case 6:
			!(function (e, t) {
				const { helper: n } = e;
				e.push(`${n("linked")}(`), qee(e, t.key), t.modifier && (e.push(", "), qee(e, t.modifier)), e.push(")");
			})(e, t);
			break;
		case 8:
		case 7:
			e.push(JSON.stringify(t.value), t);
			break;
		case 5:
			e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
			break;
		case 4:
			e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
			break;
		case 9:
		case 3:
			e.push(JSON.stringify(t.value), t);
	}
}
function Zee(e, t = {}) {
	const n = oee({}, t),
		r = Wee(n).parse(e);
	return (
		Kee(r, n),
		((e, t = {}) => {
			const n = fee(t.mode) ? t.mode : "normal",
				r = fee(t.filename) ? t.filename : "message.intl",
				i = !!t.sourceMap,
				s = null != t.breakLineCode ? t.breakLineCode : "arrow" === n ? ";" : "\n",
				o = t.needIndent ? t.needIndent : "arrow" !== n,
				a = e.helpers || [],
				l = (function (e, t) {
					const { sourceMap: n, filename: r, breakLineCode: i, needIndent: s } = t,
						o = { source: e.loc.source, filename: r, code: "", column: 1, line: 1, offset: 0, map: void 0, breakLineCode: i, needIndent: s, indentLevel: 0 };
					function a(e, t) {
						o.code += e;
					}
					function l(e, t = !0) {
						const n = t ? i : "";
						a(s ? n + "    ".repeat(e) : n);
					}
					return {
						context: () => o,
						push: a,
						indent: function (e = !0) {
							const t = ++o.indentLevel;
							e && l(t);
						},
						deindent: function (e = !0) {
							const t = --o.indentLevel;
							e && l(t);
						},
						newline: function () {
							l(o.indentLevel);
						},
						helper: (e) => `_${e}`,
						needIndent: () => o.needIndent
					};
				})(e, { mode: n, filename: r, sourceMap: i, breakLineCode: s, needIndent: o });
			l.push("normal" === n ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${a.map((e) => `${e}: _${e}`).join(", ")} } = ctx`), l.newline()), l.push("return "), qee(l, e), l.deindent(o), l.push("}");
			const { code: u, map: c } = l.context();
			return { ast: e, code: u, map: c ? c.toJSON() : void 0 };
		})(r, n)
	);
}
/*!
 * devtools-if v9.2.0-beta.16
 * (c) 2021 kazuya kawaguchi
 * Released under the MIT License.
 */ const Jee = "i18n:init",
	Qee = "function:translate",
	ete = [];
/*!
 * core-base v9.2.0-beta.16
 * (c) 2021 kazuya kawaguchi
 * Released under the MIT License.
 */ (ete[0] = { w: [0], i: [3, 0], "[": [4], o: [7] }),
	(ete[1] = { w: [1], ".": [2], "[": [4], o: [7] }),
	(ete[2] = { w: [2], i: [3, 0], 0: [3, 0] }),
	(ete[3] = { i: [3, 0], 0: [3, 0], w: [1, 1], ".": [2, 1], "[": [4, 1], o: [7, 1] }),
	(ete[4] = { "'": [5, 0], '"': [6, 0], "[": [4, 2], "]": [1, 3], o: 8, l: [4, 0] }),
	(ete[5] = { "'": [4, 0], o: 8, l: [5, 0] }),
	(ete[6] = { '"': [4, 0], o: 8, l: [6, 0] });
const tte = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function nte(e) {
	if (null == e) return "o";
	switch (e.charCodeAt(0)) {
		case 91:
		case 93:
		case 46:
		case 34:
		case 39:
			return e;
		case 95:
		case 36:
		case 45:
			return "i";
		case 9:
		case 10:
		case 13:
		case 160:
		case 65279:
		case 8232:
		case 8233:
			return "w";
	}
	return "i";
}
function rte(e) {
	const t = e.trim();
	return (
		("0" !== e.charAt(0) || !isNaN(parseInt(e))) &&
		((n = t),
		tte.test(n)
			? (function (e) {
					const t = e.charCodeAt(0);
					return t !== e.charCodeAt(e.length - 1) || (34 !== t && 39 !== t) ? e : e.slice(1, -1);
			  })(t)
			: "*" + t)
	);
	var n;
}
const ite = new Map();
function ste(e, t) {
	return vee(e) ? e[t] : null;
}
const ote = (e) => e,
	ate = (e) => "",
	lte = (e) => (0 === e.length ? "" : e.join("")),
	ute = (e) => (null == e ? "" : dee(e) || (bee(e) && e.toString === gee) ? JSON.stringify(e, null, 2) : String(e));
function cte(e, t) {
	return (e = Math.abs(e)), 2 === t ? (e ? (e > 1 ? 1 : 0) : 1) : e ? Math.min(e, 2) : 0;
}
function hte(e = {}) {
	const t = e.locale,
		n = (function (e) {
			const t = nee(e.pluralIndex) ? e.pluralIndex : -1;
			return e.named && (nee(e.named.count) || nee(e.named.n)) ? (nee(e.named.count) ? e.named.count : nee(e.named.n) ? e.named.n : t) : t;
		})(e),
		r = vee(e.pluralRules) && fee(t) && pee(e.pluralRules[t]) ? e.pluralRules[t] : cte,
		i = vee(e.pluralRules) && fee(t) && pee(e.pluralRules[t]) ? cte : void 0,
		s = e.list || [],
		o = e.named || {};
	nee(e.pluralIndex) &&
		(function (e, t) {
			t.count || (t.count = e), t.n || (t.n = e);
		})(n, o);
	function a(t) {
		const n = pee(e.messages) ? e.messages(t) : !!vee(e.messages) && e.messages[t];
		return n || (e.parent ? e.parent.message(t) : ate);
	}
	const l = bee(e.processor) && pee(e.processor.normalize) ? e.processor.normalize : lte,
		u = bee(e.processor) && pee(e.processor.interpolate) ? e.processor.interpolate : ute,
		c = {
			list: (e) => s[e],
			named: (e) => o[e],
			plural: (e) => e[r(n, e.length, i)],
			linked: (t, n) => {
				const r = a(t)(c);
				return fee(n) ? ((i = n), e.modifiers ? e.modifiers[i] : ote)(r) : r;
				var i;
			},
			message: a,
			type: bee(e.processor) && fee(e.processor.type) ? e.processor.type : "text",
			interpolate: u,
			normalize: l
		};
	return c;
}
let dte = null;
const pte = fte(Qee);
function fte(e) {
	return (t) => dte && dte.emit(e, t);
}
function mte(e, t, n) {
	return [...new Set([n, ...(dee(t) ? t : vee(t) ? Object.keys(t) : fee(t) ? [t] : [n])])];
}
function vte(e, t, n) {
	const r = fee(n) ? n : xte,
		i = e;
	i.__localeChainCache || (i.__localeChainCache = new Map());
	let s = i.__localeChainCache.get(r);
	if (!s) {
		s = [];
		let e = [n];
		for (; dee(e); ) e = gte(s, e, t);
		const o = dee(t) || !bee(t) ? t : t.default ? t.default : null;
		(e = fee(o) ? [o] : o), dee(e) && gte(s, e, !1), i.__localeChainCache.set(r, s);
	}
	return s;
}
function gte(e, t, n) {
	let r = !0;
	for (let i = 0; i < t.length && mee(r); i++) {
		const s = t[i];
		fee(s) && (r = yte(e, t[i], n));
	}
	return r;
}
function yte(e, t, n) {
	let r;
	const i = t.split("-");
	do {
		(r = bte(e, i.join("-"), n)), i.splice(-1, 1);
	} while (i.length && !0 === r);
	return r;
}
function bte(e, t, n) {
	let r = !1;
	if (!e.includes(t) && ((r = !0), t)) {
		r = "!" !== t[t.length - 1];
		const i = t.replace(/!/g, "");
		e.push(i), (dee(n) || bee(n)) && n[i] && (r = n[i]);
	}
	return r;
}
const xte = "en-US";
let _te, wte, Cte;
let Ste = null;
const Ete = (e) => {
	Ste = e;
};
let Tte = 0;
function kte(e = {}) {
	const t = fee(e.version) ? e.version : "9.2.0-beta.16",
		n = fee(e.locale) ? e.locale : xte,
		r = dee(e.fallbackLocale) || bee(e.fallbackLocale) || fee(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : n,
		i = bee(e.messages) ? e.messages : { [n]: {} },
		s = bee(e.datetimeFormats) ? e.datetimeFormats : { [n]: {} },
		o = bee(e.numberFormats) ? e.numberFormats : { [n]: {} },
		a = oee({}, e.modifiers || {}, { upper: (e) => (fee(e) ? e.toUpperCase() : e), lower: (e) => (fee(e) ? e.toLowerCase() : e), capitalize: (e) => (fee(e) ? `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}` : e) }),
		l = e.pluralRules || {},
		u = pee(e.missing) ? e.missing : null,
		c = (!mee(e.missingWarn) && !ree(e.missingWarn)) || e.missingWarn,
		h = (!mee(e.fallbackWarn) && !ree(e.fallbackWarn)) || e.fallbackWarn,
		d = !!e.fallbackFormat,
		p = !!e.unresolving,
		f = pee(e.postTranslation) ? e.postTranslation : null,
		m = bee(e.processor) ? e.processor : null,
		v = !mee(e.warnHtmlMessage) || e.warnHtmlMessage,
		g = !!e.escapeParameter,
		y = pee(e.messageCompiler) ? e.messageCompiler : _te,
		b = pee(e.messageResolver) ? e.messageResolver : wte || ste,
		x = pee(e.localeFallbacker) ? e.localeFallbacker : Cte || mte,
		_ = pee(e.onWarn) ? e.onWarn : see,
		w = e,
		C = vee(w.__datetimeFormatters) ? w.__datetimeFormatters : new Map(),
		S = vee(w.__numberFormatters) ? w.__numberFormatters : new Map(),
		E = vee(w.__meta) ? w.__meta : {};
	Tte++;
	const T = {
		version: t,
		cid: Tte,
		locale: n,
		fallbackLocale: r,
		messages: i,
		modifiers: a,
		pluralRules: l,
		missing: u,
		missingWarn: c,
		fallbackWarn: h,
		fallbackFormat: d,
		unresolving: p,
		postTranslation: f,
		processor: m,
		warnHtmlMessage: v,
		escapeParameter: g,
		messageCompiler: y,
		messageResolver: b,
		localeFallbacker: x,
		onWarn: _,
		__meta: E
	};
	return (
		(T.datetimeFormats = s),
		(T.numberFormats = o),
		(T.__datetimeFormatters = C),
		(T.__numberFormatters = S),
		__INTLIFY_PROD_DEVTOOLS__ &&
			(function (e, t, n) {
				dte && dte.emit(Jee, { timestamp: Date.now(), i18n: e, version: t, meta: n });
			})(T, t, E),
		T
	);
}
function Ate(e, t, n, r, i) {
	const { missing: s, onWarn: o } = e;
	if (null !== s) {
		const r = s(e, n, t, i);
		return fee(r) ? r : t;
	}
	return t;
}
function Mte(e, t, n) {
	(e.__localeChainCache = new Map()), e.localeFallbacker(e, n, t);
}
const Ite = (e) => e;
let Rte = Object.create(null);
let Lte = Pee;
const Ote = () => Lte++,
	Pte = { INVALID_ARGUMENT: Lte, INVALID_DATE_ARGUMENT: Ote(), INVALID_ISO_DATE_ARGUMENT: Ote(), __EXTEND_POINT__: Ote() };
function Nte(e) {
	return Nee(e, null, void 0);
}
const Dte = () => "",
	Bte = (e) => pee(e);
function Fte(e, ...t) {
	const { fallbackFormat: n, postTranslation: r, unresolving: i, fallbackLocale: s, messages: o } = e,
		[a, l] = Vte(...t),
		u = (mee(l.missingWarn) ? l.missingWarn : e.missingWarn, mee(l.fallbackWarn) ? l.fallbackWarn : e.fallbackWarn, mee(l.escapeParameter) ? l.escapeParameter : e.escapeParameter),
		c = !!l.resolvedMessage,
		h = fee(l.default) || mee(l.default) ? (mee(l.default) ? a : l.default) : n ? a : "",
		d = n || "" !== h,
		p = fee(l.locale) ? l.locale : e.locale;
	u &&
		(function (e) {
			dee(e.list)
				? (e.list = e.list.map((e) => (fee(e) ? uee(e) : e)))
				: vee(e.named) &&
				  Object.keys(e.named).forEach((t) => {
						fee(e.named[t]) && (e.named[t] = uee(e.named[t]));
				  });
		})(l);
	let [f, m, v] = c
			? [a, p, o[p] || {}]
			: (function (e, t, n, r, i, s) {
					const { messages: o, onWarn: a, messageResolver: l, localeFallbacker: u } = e,
						c = u(e, r, n);
					let h,
						d = {},
						p = null;
					const f = "translate";
					for (let m = 0; m < c.length && ((h = c[m]), (d = o[h] || {}), null === (p = l(d, t)) && (p = d[t]), !fee(p) && !pee(p)); m++) {
						const n = Ate(e, t, h, 0, f);
						n !== t && (p = n);
					}
					return [p, h, d];
			  })(e, a, p, s),
		g = f,
		y = a;
	if ((c || fee(g) || Bte(g) || (d && ((g = h), (y = g))), !(c || ((fee(g) || Bte(g)) && fee(m))))) return i ? -1 : a;
	let b = !1;
	const x = Bte(g)
		? g
		: Hte(e, a, m, g, y, () => {
				b = !0;
		  });
	if (b) return g;
	const _ = (function (e, t, n) {
			return t(n);
		})(
			0,
			x,
			hte(
				(function (e, t, n, r) {
					const { modifiers: i, pluralRules: s, messageResolver: o } = e,
						a = {
							locale: t,
							modifiers: i,
							pluralRules: s,
							messages: (r) => {
								const i = o(n, r);
								if (fee(i)) {
									let n = !1;
									const s = Hte(e, r, t, i, r, () => {
										n = !0;
									});
									return n ? Dte : s;
								}
								return Bte(i) ? i : Dte;
							}
						};
					e.processor && (a.processor = e.processor);
					r.list && (a.list = r.list);
					r.named && (a.named = r.named);
					nee(r.plural) && (a.pluralIndex = r.plural);
					return a;
				})(e, m, v, l)
			)
		),
		w = r ? r(_) : _;
	if (__INTLIFY_PROD_DEVTOOLS__) {
		const t = { timestamp: Date.now(), key: fee(a) ? a : Bte(g) ? g.key : "", locale: m || (Bte(g) ? g.locale : ""), format: fee(g) ? g : Bte(g) ? g.source : "", message: w };
		(t.meta = oee({}, e.__meta, Ste || {})), pte(t);
	}
	return w;
}
function Hte(e, t, n, r, i, s) {
	const { messageCompiler: o, warnHtmlMessage: a } = e;
	if (Bte(r)) {
		const e = r;
		return (e.locale = e.locale || n), (e.key = e.key || t), e;
	}
	const l = o(
		r,
		(function (e, t, n, r, i, s) {
			return {
				warnHtmlMessage: i,
				onError: (e) => {
					throw (s && s(e), e);
				},
				onCacheKey: (e) => ((e, t, n) => tee({ l: e, k: t, s: n }))(t, n, e)
			};
		})(0, n, i, 0, a, s)
	);
	return (l.locale = n), (l.key = t), (l.source = r), l;
}
function Vte(...e) {
	const [t, n, r] = e,
		i = {};
	if (!fee(t) && !nee(t) && !Bte(t)) throw Nte(Pte.INVALID_ARGUMENT);
	const s = nee(t) ? String(t) : (Bte(t), t);
	return nee(n) ? (i.plural = n) : fee(n) ? (i.default = n) : bee(n) && !iee(n) ? (i.named = n) : dee(n) && (i.list = n), nee(r) ? (i.plural = r) : fee(r) ? (i.default = r) : bee(r) && oee(i, r), [s, i];
}
function Ute(e, ...t) {
	const { datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = e,
		{ __datetimeFormatters: a } = e,
		[l, u, c, h] = zte(...t);
	mee(c.missingWarn) ? c.missingWarn : e.missingWarn;
	mee(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
	const d = !!c.part,
		p = fee(c.locale) ? c.locale : e.locale,
		f = o(e, i, p);
	if (!fee(l) || "" === l) return new Intl.DateTimeFormat(p).format(u);
	let m,
		v = {},
		g = null;
	for (let x = 0; x < f.length && ((m = f[x]), (v = n[m] || {}), (g = v[l]), !bee(g)); x++) Ate(e, l, m, 0, "datetime format");
	if (!bee(g) || !fee(m)) return r ? -1 : l;
	let y = `${m}__${l}`;
	iee(h) || (y = `${y}__${JSON.stringify(h)}`);
	let b = a.get(y);
	return b || ((b = new Intl.DateTimeFormat(m, oee({}, g, h))), a.set(y, b)), d ? b.formatToParts(u) : b.format(u);
}
function zte(...e) {
	const [t, n, r, i] = e;
	let s,
		o = {},
		a = {};
	if (fee(t)) {
		const e = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
		if (!e) throw Nte(Pte.INVALID_ISO_DATE_ARGUMENT);
		const n = e[3] ? (e[3].trim().startsWith("T") ? `${e[1].trim()}${e[3].trim()}` : `${e[1].trim()}T${e[3].trim()}`) : e[1].trim();
		s = new Date(n);
		try {
			s.toISOString();
		} catch (Kj) {
			throw Nte(Pte.INVALID_ISO_DATE_ARGUMENT);
		}
	} else if ("[object Date]" === yee(t)) {
		if (isNaN(t.getTime())) throw Nte(Pte.INVALID_DATE_ARGUMENT);
		s = t;
	} else {
		if (!nee(t)) throw Nte(Pte.INVALID_ARGUMENT);
		s = t;
	}
	return fee(n) ? (o.key = n) : bee(n) && (o = n), fee(r) ? (o.locale = r) : bee(r) && (a = r), bee(i) && (a = i), [o.key || "", s, o, a];
}
function $te(e, t, n) {
	const r = e;
	for (const i in n) {
		const e = `${t}__${i}`;
		r.__datetimeFormatters.has(e) && r.__datetimeFormatters.delete(e);
	}
}
function jte(e, ...t) {
	const { numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = e,
		{ __numberFormatters: a } = e,
		[l, u, c, h] = Wte(...t);
	mee(c.missingWarn) ? c.missingWarn : e.missingWarn;
	mee(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
	const d = !!c.part,
		p = fee(c.locale) ? c.locale : e.locale,
		f = o(e, i, p);
	if (!fee(l) || "" === l) return new Intl.NumberFormat(p).format(u);
	let m,
		v = {},
		g = null;
	for (let x = 0; x < f.length && ((m = f[x]), (v = n[m] || {}), (g = v[l]), !bee(g)); x++) Ate(e, l, m, 0, "number format");
	if (!bee(g) || !fee(m)) return r ? -1 : l;
	let y = `${m}__${l}`;
	iee(h) || (y = `${y}__${JSON.stringify(h)}`);
	let b = a.get(y);
	return b || ((b = new Intl.NumberFormat(m, oee({}, g, h))), a.set(y, b)), d ? b.formatToParts(u) : b.format(u);
}
function Wte(...e) {
	const [t, n, r, i] = e;
	let s = {},
		o = {};
	if (!nee(t)) throw Nte(Pte.INVALID_ARGUMENT);
	const a = t;
	return fee(n) ? (s.key = n) : bee(n) && (s = n), fee(r) ? (s.locale = r) : bee(r) && (o = r), bee(i) && (o = i), [s.key || "", a, s, o];
}
function Gte(e, t, n) {
	const r = e;
	for (const i in n) {
		const e = `${t}__${i}`;
		r.__numberFormatters.has(e) && r.__numberFormatters.delete(e);
	}
}
"boolean" != typeof __INTLIFY_PROD_DEVTOOLS__ && (lee().__INTLIFY_PROD_DEVTOOLS__ = !1);
let Yte = Pee;
const Xte = () => Yte++,
	Kte = {
		UNEXPECTED_RETURN_TYPE: Yte,
		INVALID_ARGUMENT: Xte(),
		MUST_BE_CALL_SETUP_TOP: Xte(),
		NOT_INSLALLED: Xte(),
		NOT_AVAILABLE_IN_LEGACY_MODE: Xte(),
		REQUIRED_VALUE: Xte(),
		INVALID_VALUE: Xte(),
		CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Xte(),
		NOT_INSLALLED_WITH_PROVIDE: Xte(),
		UNEXPECTED_ERROR: Xte(),
		NOT_COMPATIBLE_LEGACY_VUE_I18N: Xte(),
		BRIDGE_SUPPORT_VUE_2_ONLY: Xte(),
		__EXTEND_POINT__: Xte()
	};
function qte(e, ...t) {
	return Nee(e, null, void 0);
}
const Zte = eee("__transrateVNode"),
	Jte = eee("__datetimeParts"),
	Qte = eee("__numberParts"),
	ene = eee("__setPluralRules");
eee("__intlifyMeta");
const tne = eee("__injectWithOption");
function nne(e) {
	if (!vee(e)) return e;
	for (const t in e)
		if (hee(e, t))
			if (t.includes(".")) {
				const n = t.split("."),
					r = n.length - 1;
				let i = e;
				for (let e = 0; e < r; e++) n[e] in i || (i[n[e]] = {}), (i = i[n[e]]);
				(i[n[r]] = e[t]), delete e[t], vee(i[n[r]]) && nne(i[n[r]]);
			} else vee(e[t]) && nne(e[t]);
	return e;
}
function rne(e, t) {
	const { messages: n, __i18n: r, messageResolver: i, flatJson: s } = t,
		o = bee(n) ? n : dee(r) ? {} : { [e]: {} };
	if (
		(dee(r) &&
			r.forEach((e) => {
				if ("locale" in e && "resource" in e) {
					const { locale: t, resource: n } = e;
					t ? ((o[t] = o[t] || {}), sne(n, o[t])) : sne(n, o);
				} else fee(e) && sne(JSON.parse(e), o);
			}),
		null == i && s)
	)
		for (const a in o) hee(o, a) && nne(o[a]);
	return o;
}
const ine = (e) => !vee(e) || dee(e);
function sne(e, t) {
	if (ine(e) || ine(t)) throw qte(Kte.INVALID_VALUE);
	for (const n in e) hee(e, n) && (ine(e[n]) || ine(t[n]) ? (t[n] = e[n]) : sne(e[n], t[n]));
}
function one(e) {
	return e.type;
}
let ane = 0;
function lne(e) {
	return (t, n, r, i) => e(n, r, Si() || void 0, i);
}
function une(e = {}, t) {
	const { __root: n } = e,
		r = void 0 === n;
	let i = !mee(e.inheritLocale) || e.inheritLocale;
	const s = Qe(n && i ? n.locale.value : fee(e.locale) ? e.locale : xte),
		o = Qe(n && i ? n.fallbackLocale.value : fee(e.fallbackLocale) || dee(e.fallbackLocale) || bee(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : s.value),
		a = Qe(rne(s.value, e)),
		l = Qe(bee(e.datetimeFormats) ? e.datetimeFormats : { [s.value]: {} }),
		u = Qe(bee(e.numberFormats) ? e.numberFormats : { [s.value]: {} });
	let c = n ? n.missingWarn : (!mee(e.missingWarn) && !ree(e.missingWarn)) || e.missingWarn,
		h = n ? n.fallbackWarn : (!mee(e.fallbackWarn) && !ree(e.fallbackWarn)) || e.fallbackWarn,
		d = n ? n.fallbackRoot : !mee(e.fallbackRoot) || e.fallbackRoot,
		p = !!e.fallbackFormat,
		f = pee(e.missing) ? e.missing : null,
		m = pee(e.missing) ? lne(e.missing) : null,
		v = pee(e.postTranslation) ? e.postTranslation : null,
		g = !mee(e.warnHtmlMessage) || e.warnHtmlMessage,
		y = !!e.escapeParameter;
	const b = n ? n.modifiers : bee(e.modifiers) ? e.modifiers : {};
	let x,
		_ = e.pluralRules || (n && n.pluralRules);
	(x = (function () {
		const t = {
			version: "9.2.0-beta.16",
			locale: s.value,
			fallbackLocale: o.value,
			messages: a.value,
			modifiers: b,
			pluralRules: _,
			missing: null === m ? void 0 : m,
			missingWarn: c,
			fallbackWarn: h,
			fallbackFormat: p,
			unresolving: !0,
			postTranslation: null === v ? void 0 : v,
			warnHtmlMessage: g,
			escapeParameter: y,
			messageResolver: e.messageResolver,
			__meta: { framework: "vue" }
		};
		return (t.datetimeFormats = l.value), (t.numberFormats = u.value), (t.__datetimeFormatters = bee(x) ? x.__datetimeFormatters : void 0), (t.__numberFormatters = bee(x) ? x.__numberFormatters : void 0), kte(t);
	})()),
		Mte(x, s.value, o.value);
	const w = ht({
			get: () => s.value,
			set: (e) => {
				(s.value = e), (x.locale = s.value);
			}
		}),
		C = ht({
			get: () => o.value,
			set: (e) => {
				(o.value = e), (x.fallbackLocale = o.value), Mte(x, s.value, e);
			}
		}),
		S = ht(() => a.value),
		E = ht(() => l.value),
		T = ht(() => u.value);
	function k(e, t, r, i, c, h) {
		let p;
		if ((s.value, o.value, a.value, l.value, u.value, __INTLIFY_PROD_DEVTOOLS__))
			try {
				Ete(
					(() => {
						const e = Si();
						let t = null;
						return e && (t = one(e).__INTLIFY_META__) ? { __INTLIFY_META__: t } : null;
					})()
				),
					(p = e(x));
			} finally {
				Ete(null);
			}
		else p = e(x);
		if (nee(p) && -1 === p) {
			const [e, r] = t();
			return n && d ? i(n) : c(e);
		}
		if (h(p)) return p;
		throw qte(Kte.UNEXPECTED_RETURN_TYPE);
	}
	function A(...e) {
		return k(
			(t) => Reflect.apply(Fte, null, [t, ...e]),
			() => Vte(...e),
			0,
			(t) => Reflect.apply(t.t, t, [...e]),
			(e) => e,
			(e) => fee(e)
		);
	}
	const M = {
		normalize: function (e) {
			return e.map((e) => (fee(e) ? ri(Vr, null, e, 0) : e));
		},
		interpolate: (e) => e,
		type: "vnode"
	};
	function I(e) {
		return a.value[e] || {};
	}
	ane++,
		n &&
			(ds(n.locale, (e) => {
				i && ((s.value = e), (x.locale = e), Mte(x, s.value, o.value));
			}),
			ds(n.fallbackLocale, (e) => {
				i && ((o.value = e), (x.fallbackLocale = e), Mte(x, s.value, o.value));
			}));
	const R = {
		id: ane,
		locale: w,
		fallbackLocale: C,
		get inheritLocale() {
			return i;
		},
		set inheritLocale(e) {
			(i = e), e && n && ((s.value = n.locale.value), (o.value = n.fallbackLocale.value), Mte(x, s.value, o.value));
		},
		get availableLocales() {
			return Object.keys(a.value).sort();
		},
		messages: S,
		get modifiers() {
			return b;
		},
		get pluralRules() {
			return _ || {};
		},
		get isGlobal() {
			return r;
		},
		get missingWarn() {
			return c;
		},
		set missingWarn(e) {
			(c = e), (x.missingWarn = c);
		},
		get fallbackWarn() {
			return h;
		},
		set fallbackWarn(e) {
			(h = e), (x.fallbackWarn = h);
		},
		get fallbackRoot() {
			return d;
		},
		set fallbackRoot(e) {
			d = e;
		},
		get fallbackFormat() {
			return p;
		},
		set fallbackFormat(e) {
			(p = e), (x.fallbackFormat = p);
		},
		get warnHtmlMessage() {
			return g;
		},
		set warnHtmlMessage(e) {
			(g = e), (x.warnHtmlMessage = e);
		},
		get escapeParameter() {
			return y;
		},
		set escapeParameter(e) {
			(y = e), (x.escapeParameter = e);
		},
		t: A,
		getLocaleMessage: I,
		setLocaleMessage: function (e, t) {
			(a.value[e] = t), (x.messages = a.value);
		},
		mergeLocaleMessage: function (e, t) {
			(a.value[e] = a.value[e] || {}), sne(t, a.value[e]), (x.messages = a.value);
		},
		getPostTranslationHandler: function () {
			return pee(v) ? v : null;
		},
		setPostTranslationHandler: function (e) {
			(v = e), (x.postTranslation = e);
		},
		getMissingHandler: function () {
			return f;
		},
		setMissingHandler: function (e) {
			null !== e && (m = lne(e)), (f = e), (x.missing = m);
		},
		[ene]: function (e) {
			(_ = e), (x.pluralRules = _);
		}
	};
	return (
		(R.datetimeFormats = E),
		(R.numberFormats = T),
		(R.rt = function (...e) {
			const [t, n, r] = e;
			if (r && !vee(r)) throw qte(Kte.INVALID_ARGUMENT);
			return A(t, n, oee({ resolvedMessage: !0 }, r || {}));
		}),
		(R.te = function (e, t) {
			const n = I(fee(t) ? t : s.value);
			return null !== x.messageResolver(n, e);
		}),
		(R.tm = function (e) {
			const t = (function (e) {
				let t = null;
				const n = vte(x, o.value, s.value);
				for (let r = 0; r < n.length; r++) {
					const i = a.value[n[r]] || {},
						s = x.messageResolver(i, e);
					if (null != s) {
						t = s;
						break;
					}
				}
				return t;
			})(e);
			return null != t ? t : (n && n.tm(e)) || {};
		}),
		(R.d = function (...e) {
			return k(
				(t) => Reflect.apply(Ute, null, [t, ...e]),
				() => zte(...e),
				0,
				(t) => Reflect.apply(t.d, t, [...e]),
				() => "",
				(e) => fee(e)
			);
		}),
		(R.n = function (...e) {
			return k(
				(t) => Reflect.apply(jte, null, [t, ...e]),
				() => Wte(...e),
				0,
				(t) => Reflect.apply(t.n, t, [...e]),
				() => "",
				(e) => fee(e)
			);
		}),
		(R.getDateTimeFormat = function (e) {
			return l.value[e] || {};
		}),
		(R.setDateTimeFormat = function (e, t) {
			(l.value[e] = t), (x.datetimeFormats = l.value), $te(x, e, t);
		}),
		(R.mergeDateTimeFormat = function (e, t) {
			(l.value[e] = oee(l.value[e] || {}, t)), (x.datetimeFormats = l.value), $te(x, e, t);
		}),
		(R.getNumberFormat = function (e) {
			return u.value[e] || {};
		}),
		(R.setNumberFormat = function (e, t) {
			(u.value[e] = t), (x.numberFormats = u.value), Gte(x, e, t);
		}),
		(R.mergeNumberFormat = function (e, t) {
			(u.value[e] = oee(u.value[e] || {}, t)), (x.numberFormats = u.value), Gte(x, e, t);
		}),
		(R[tne] = e.__injectWithOption),
		(R[Zte] = function (...e) {
			return k(
				(t) => {
					let n;
					const r = t;
					try {
						(r.processor = M), (n = Reflect.apply(Fte, null, [r, ...e]));
					} finally {
						r.processor = null;
					}
					return n;
				},
				() => Vte(...e),
				0,
				(t) => t[Zte](...e),
				(e) => [ri(Vr, null, e, 0)],
				(e) => dee(e)
			);
		}),
		(R[Qte] = function (...e) {
			return k(
				(t) => Reflect.apply(jte, null, [t, ...e]),
				() => Wte(...e),
				0,
				(t) => t[Qte](...e),
				() => [],
				(e) => fee(e) || dee(e)
			);
		}),
		(R[Jte] = function (...e) {
			return k(
				(t) => Reflect.apply(Ute, null, [t, ...e]),
				() => zte(...e),
				0,
				(t) => t[Jte](...e),
				() => [],
				(e) => fee(e) || dee(e)
			);
		}),
		R
	);
}
function cne(e = {}, t) {
	{
		const t = une(
				(function (e) {
					const t = fee(e.locale) ? e.locale : xte,
						n = fee(e.fallbackLocale) || dee(e.fallbackLocale) || bee(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : t,
						r = pee(e.missing) ? e.missing : void 0,
						i = (!mee(e.silentTranslationWarn) && !ree(e.silentTranslationWarn)) || !e.silentTranslationWarn,
						s = (!mee(e.silentFallbackWarn) && !ree(e.silentFallbackWarn)) || !e.silentFallbackWarn,
						o = !mee(e.fallbackRoot) || e.fallbackRoot,
						a = !!e.formatFallbackMessages,
						l = bee(e.modifiers) ? e.modifiers : {},
						u = e.pluralizationRules,
						c = pee(e.postTranslation) ? e.postTranslation : void 0,
						h = !fee(e.warnHtmlInMessage) || "off" !== e.warnHtmlInMessage,
						d = !!e.escapeParameterHtml,
						p = !mee(e.sync) || e.sync;
					let f = e.messages;
					if (bee(e.sharedMessages)) {
						const t = e.sharedMessages;
						f = Object.keys(t).reduce((e, n) => {
							const r = e[n] || (e[n] = {});
							return oee(r, t[n]), e;
						}, f || {});
					}
					const { __i18n: m, __root: v, __injectWithOption: g } = e,
						y = e.datetimeFormats,
						b = e.numberFormats;
					return {
						locale: t,
						fallbackLocale: n,
						messages: f,
						flatJson: e.flatJson,
						datetimeFormats: y,
						numberFormats: b,
						missing: r,
						missingWarn: i,
						fallbackWarn: s,
						fallbackRoot: o,
						fallbackFormat: a,
						modifiers: l,
						pluralRules: u,
						postTranslation: c,
						warnHtmlMessage: h,
						escapeParameter: d,
						messageResolver: e.messageResolver,
						inheritLocale: p,
						__i18n: m,
						__root: v,
						__injectWithOption: g
					};
				})(e)
			),
			n = {
				id: t.id,
				get locale() {
					return t.locale.value;
				},
				set locale(e) {
					t.locale.value = e;
				},
				get fallbackLocale() {
					return t.fallbackLocale.value;
				},
				set fallbackLocale(e) {
					t.fallbackLocale.value = e;
				},
				get messages() {
					return t.messages.value;
				},
				get datetimeFormats() {
					return t.datetimeFormats.value;
				},
				get numberFormats() {
					return t.numberFormats.value;
				},
				get availableLocales() {
					return t.availableLocales;
				},
				get formatter() {
					return { interpolate: () => [] };
				},
				set formatter(e) {},
				get missing() {
					return t.getMissingHandler();
				},
				set missing(e) {
					t.setMissingHandler(e);
				},
				get silentTranslationWarn() {
					return mee(t.missingWarn) ? !t.missingWarn : t.missingWarn;
				},
				set silentTranslationWarn(e) {
					t.missingWarn = mee(e) ? !e : e;
				},
				get silentFallbackWarn() {
					return mee(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn;
				},
				set silentFallbackWarn(e) {
					t.fallbackWarn = mee(e) ? !e : e;
				},
				get modifiers() {
					return t.modifiers;
				},
				get formatFallbackMessages() {
					return t.fallbackFormat;
				},
				set formatFallbackMessages(e) {
					t.fallbackFormat = e;
				},
				get postTranslation() {
					return t.getPostTranslationHandler();
				},
				set postTranslation(e) {
					t.setPostTranslationHandler(e);
				},
				get sync() {
					return t.inheritLocale;
				},
				set sync(e) {
					t.inheritLocale = e;
				},
				get warnHtmlInMessage() {
					return t.warnHtmlMessage ? "warn" : "off";
				},
				set warnHtmlInMessage(e) {
					t.warnHtmlMessage = "off" !== e;
				},
				get escapeParameterHtml() {
					return t.escapeParameter;
				},
				set escapeParameterHtml(e) {
					t.escapeParameter = e;
				},
				get preserveDirectiveContent() {
					return !0;
				},
				set preserveDirectiveContent(e) {},
				get pluralizationRules() {
					return t.pluralRules || {};
				},
				__composer: t,
				t(...e) {
					const [n, r, i] = e,
						s = {};
					let o = null,
						a = null;
					if (!fee(n)) throw qte(Kte.INVALID_ARGUMENT);
					const l = n;
					return fee(r) ? (s.locale = r) : dee(r) ? (o = r) : bee(r) && (a = r), dee(i) ? (o = i) : bee(i) && (a = i), Reflect.apply(t.t, t, [l, o || a || {}, s]);
				},
				rt: (...e) => Reflect.apply(t.rt, t, [...e]),
				tc(...e) {
					const [n, r, i] = e,
						s = { plural: 1 };
					let o = null,
						a = null;
					if (!fee(n)) throw qte(Kte.INVALID_ARGUMENT);
					const l = n;
					return fee(r) ? (s.locale = r) : nee(r) ? (s.plural = r) : dee(r) ? (o = r) : bee(r) && (a = r), fee(i) ? (s.locale = i) : dee(i) ? (o = i) : bee(i) && (a = i), Reflect.apply(t.t, t, [l, o || a || {}, s]);
				},
				te: (e, n) => t.te(e, n),
				tm: (e) => t.tm(e),
				getLocaleMessage: (e) => t.getLocaleMessage(e),
				setLocaleMessage(e, n) {
					t.setLocaleMessage(e, n);
				},
				mergeLocaleMessage(e, n) {
					t.mergeLocaleMessage(e, n);
				},
				d: (...e) => Reflect.apply(t.d, t, [...e]),
				getDateTimeFormat: (e) => t.getDateTimeFormat(e),
				setDateTimeFormat(e, n) {
					t.setDateTimeFormat(e, n);
				},
				mergeDateTimeFormat(e, n) {
					t.mergeDateTimeFormat(e, n);
				},
				n: (...e) => Reflect.apply(t.n, t, [...e]),
				getNumberFormat: (e) => t.getNumberFormat(e),
				setNumberFormat(e, n) {
					t.setNumberFormat(e, n);
				},
				mergeNumberFormat(e, n) {
					t.mergeNumberFormat(e, n);
				},
				getChoiceIndex: (e, t) => -1,
				__onComponentInstanceCreated(t) {
					const { componentInstanceCreatedListener: r } = e;
					r && r(t, n);
				}
			};
		return n;
	}
}
const hne = { tag: { type: [String, Object] }, locale: { type: String }, scope: { type: String, validator: (e) => "parent" === e || "global" === e, default: "parent" }, i18n: { type: Object } },
	dne = Tn({
		name: "i18n-t",
		props: oee({ keypath: { type: String, required: !0 }, plural: { type: [Number, String], validator: (e) => nee(e) || !isNaN(e) } }, hne),
		setup(e, t) {
			const { slots: n, attrs: r } = t,
				i = e.i18n || Cne({ useScope: e.scope, __useComponent: !0 }),
				s = Object.keys(n).filter((e) => "_" !== e);
			return () => {
				const n = {};
				e.locale && (n.locale = e.locale), void 0 !== e.plural && (n.plural = fee(e.plural) ? +e.plural : e.plural);
				const o = (function ({ slots: e }, t) {
						return 1 === t.length && "default" === t[0]
							? e.default
								? e.default()
								: []
							: t.reduce((t, n) => {
									const r = e[n];
									return r && (t[n] = r()), t;
							  }, {});
					})(t, s),
					a = i[Zte](e.keypath, o, n),
					l = oee({}, r);
				return xs(fee(e.tag) || vee(e.tag) ? e.tag : Hr, l, a);
			};
		}
	});
function pne(e, t, n, r) {
	const { slots: i, attrs: s } = t;
	return () => {
		const t = { part: !0 };
		let o = {};
		e.locale && (t.locale = e.locale), fee(e.format) ? (t.key = e.format) : vee(e.format) && (fee(e.format.key) && (t.key = e.format.key), (o = Object.keys(e.format).reduce((t, r) => (n.includes(r) ? oee({}, t, { [r]: e.format[r] }) : t), {})));
		const a = r(e.value, t, o);
		let l = [t.key];
		dee(a)
			? (l = a.map((e, t) => {
					const n = i[e.type];
					return n ? n({ [e.type]: e.value, index: t, parts: a }) : [e.value];
			  }))
			: fee(a) && (l = [a]);
		const u = oee({}, s);
		return xs(fee(e.tag) || vee(e.tag) ? e.tag : Hr, u, l);
	};
}
const fne = ["localeMatcher", "style", "unit", "unitDisplay", "currency", "currencyDisplay", "useGrouping", "numberingSystem", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "notation", "formatMatcher"],
	mne = Tn({
		name: "i18n-n",
		props: oee({ value: { type: Number, required: !0 }, format: { type: [String, Object] } }, hne),
		setup(e, t) {
			const n = e.i18n || Cne({ useScope: "parent", __useComponent: !0 });
			return pne(e, t, fne, (...e) => n[Qte](...e));
		}
	}),
	vne = ["dateStyle", "timeStyle", "fractionalSecondDigits", "calendar", "dayPeriod", "numberingSystem", "localeMatcher", "timeZone", "hour12", "hourCycle", "formatMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"],
	gne = Tn({
		name: "i18n-d",
		props: oee({ value: { type: [Number, Date], required: !0 }, format: { type: [String, Object] } }, hne),
		setup(e, t) {
			const n = e.i18n || Cne({ useScope: "parent", __useComponent: !0 });
			return pne(e, t, vne, (...e) => n[Jte](...e));
		}
	});
function yne(e) {
	const t = (t, { instance: n, value: r, modifiers: i }) => {
		if (!n || !n.$) throw qte(Kte.UNEXPECTED_ERROR);
		const s = (function (e, t) {
				const n = e;
				if ("composition" === e.mode) return n.__getInstance(t) || e.global;
				{
					const r = n.__getInstance(t);
					return null != r ? r.__composer : e.global.__composer;
				}
			})(e, n.$),
			o = (function (e) {
				if (fee(e)) return { path: e };
				if (bee(e)) {
					if (!("path" in e)) throw qte(Kte.REQUIRED_VALUE);
					return e;
				}
				throw qte(Kte.INVALID_VALUE);
			})(r);
		t.textContent = Reflect.apply(s.t, s, [...bne(o)]);
	};
	return { beforeMount: t, beforeUpdate: t };
}
function bne(e) {
	const { path: t, locale: n, args: r, choice: i, plural: s } = e,
		o = {},
		a = r || {};
	return fee(n) && (o.locale = n), nee(i) && (o.plural = i), nee(s) && (o.plural = s), [t, a, o];
}
function xne(e, t) {
	(e.locale = t.locale || e.locale),
		(e.fallbackLocale = t.fallbackLocale || e.fallbackLocale),
		(e.missing = t.missing || e.missing),
		(e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn),
		(e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn),
		(e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages),
		(e.postTranslation = t.postTranslation || e.postTranslation),
		(e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage),
		(e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml),
		(e.sync = t.sync || e.sync),
		e.__composer[ene](t.pluralizationRules || e.pluralizationRules);
	const n = rne(e.locale, { messages: t.messages, __i18n: t.__i18n });
	return Object.keys(n).forEach((t) => e.mergeLocaleMessage(t, n[t])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((n) => e.mergeDateTimeFormat(n, t.datetimeFormats[n])), t.numberFormats && Object.keys(t.numberFormats).forEach((n) => e.mergeNumberFormat(n, t.numberFormats[n])), e;
}
const _ne = eee("global-vue-i18n");
function wne(e = {}, t) {
	const n = __VUE_I18N_LEGACY_API__ && mee(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__,
		r = !!e.globalInjection,
		i = new Map(),
		s = (function (e, t, n) {
			return __VUE_I18N_LEGACY_API__ && t ? cne(e) : une(e);
		})(e, n),
		o = eee("");
	{
		const e = {
			get mode() {
				return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
			},
			async install(t, ...i) {
				(t.__VUE_I18N_SYMBOL__ = o),
					t.provide(t.__VUE_I18N_SYMBOL__, e),
					!n &&
						r &&
						(function (e, t) {
							const n = Object.create(null);
							Sne.forEach((e) => {
								const r = Object.getOwnPropertyDescriptor(t, e);
								if (!r) throw qte(Kte.UNEXPECTED_ERROR);
								const i = Je(r.value)
									? {
											get: () => r.value.value,
											set(e) {
												r.value.value = e;
											}
									  }
									: { get: () => r.get && r.get() };
								Object.defineProperty(n, e, i);
							}),
								(e.config.globalProperties.$i18n = n),
								Ene.forEach((n) => {
									const r = Object.getOwnPropertyDescriptor(t, n);
									if (!r || !r.value) throw qte(Kte.UNEXPECTED_ERROR);
									Object.defineProperty(e.config.globalProperties, `$${n}`, r);
								});
						})(t, e.global),
					__VUE_I18N_FULL_INSTALL__ &&
						(function (e, t, ...n) {
							const r = bee(n[0]) ? n[0] : {},
								i = !!r.useI18nComponentName;
							(!mee(r.globalInstall) || r.globalInstall) && (e.component(i ? "i18n" : dne.name, dne), e.component(mne.name, mne), e.component(gne.name, gne)), e.directive("t", yne(t));
						})(t, e, ...i),
					__VUE_I18N_LEGACY_API__ &&
						n &&
						t.mixin(
							(function (e, t, n) {
								return {
									beforeCreate() {
										const r = Si();
										if (!r) throw qte(Kte.UNEXPECTED_ERROR);
										const i = this.$options;
										if (i.i18n) {
											const n = i.i18n;
											i.__i18n && (n.__i18n = i.__i18n), (n.__root = t), this === this.$root ? (this.$i18n = xne(e, n)) : ((n.__injectWithOption = !0), (this.$i18n = cne(n)));
										} else i.__i18n ? (this === this.$root ? (this.$i18n = xne(e, i)) : (this.$i18n = cne({ __i18n: i.__i18n, __injectWithOption: !0, __root: t }))) : (this.$i18n = e);
										e.__onComponentInstanceCreated(this.$i18n),
											n.__setInstance(r, this.$i18n),
											(this.$t = (...e) => this.$i18n.t(...e)),
											(this.$rt = (...e) => this.$i18n.rt(...e)),
											(this.$tc = (...e) => this.$i18n.tc(...e)),
											(this.$te = (e, t) => this.$i18n.te(e, t)),
											(this.$d = (...e) => this.$i18n.d(...e)),
											(this.$n = (...e) => this.$i18n.n(...e)),
											(this.$tm = (e) => this.$i18n.tm(e));
									},
									mounted() {},
									unmounted() {
										const e = Si();
										if (!e) throw qte(Kte.UNEXPECTED_ERROR);
										ns(() => {
											delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, n.__deleteInstance(e), delete this.$i18n;
										});
									}
								};
							})(s, s.__composer, e)
						);
			},
			get global() {
				return s;
			},
			__instances: i,
			__getInstance: function (e) {
				return i.get(e) || null;
			},
			__setInstance: function (e, t) {
				i.set(e, t);
			},
			__deleteInstance: function (e) {
				i.delete(e);
			}
		};
		return e;
	}
}
function Cne(e = {}) {
	const t = Si();
	if (null == t) throw qte(Kte.MUST_BE_CALL_SETUP_TOP);
	if (!t.isCE && null != t.appContext.app && !t.appContext.app.__VUE_I18N_SYMBOL__) throw qte(Kte.NOT_INSLALLED);
	const n = (function (e) {
			{
				const t = vn(e.isCE ? _ne : e.appContext.app.__VUE_I18N_SYMBOL__);
				if (!t) throw qte(e.isCE ? Kte.NOT_INSLALLED_WITH_PROVIDE : Kte.UNEXPECTED_ERROR);
				return t;
			}
		})(t),
		r = (function (e) {
			return "composition" === e.mode ? e.global : e.global.__composer;
		})(n),
		i = one(t),
		s = (function (e, t) {
			return iee(e) ? ("__i18n" in t ? "local" : "global") : e.useScope ? e.useScope : "local";
		})(e, i);
	if ("global" === s)
		return (
			(function (e, t, n) {
				let r = vee(t.messages) ? t.messages : {};
				"__i18nGlobal" in n && (r = rne(e.locale.value, { messages: r, __i18n: n.__i18nGlobal }));
				const i = Object.keys(r);
				i.length &&
					i.forEach((t) => {
						e.mergeLocaleMessage(t, r[t]);
					});
				if (vee(t.datetimeFormats)) {
					const n = Object.keys(t.datetimeFormats);
					n.length &&
						n.forEach((n) => {
							e.mergeDateTimeFormat(n, t.datetimeFormats[n]);
						});
				}
				if (vee(t.numberFormats)) {
					const n = Object.keys(t.numberFormats);
					n.length &&
						n.forEach((n) => {
							e.mergeNumberFormat(n, t.numberFormats[n]);
						});
				}
			})(r, e, i),
			r
		);
	if ("parent" === s) {
		let i = (function (e, t, n = !1) {
			let r = null;
			const i = t.root;
			let s = t.parent;
			for (; null != s; ) {
				const t = e;
				if ("composition" === e.mode) r = t.__getInstance(s);
				else if (__VUE_I18N_LEGACY_API__) {
					const e = t.__getInstance(s);
					null != e && ((r = e.__composer), n && r && !r[tne] && (r = null));
				}
				if (null != r) break;
				if (i === s) break;
				s = s.parent;
			}
			return r;
		})(n, t, e.__useComponent);
		return null == i && (i = r), i;
	}
	if ("legacy" === n.mode) throw qte(Kte.NOT_AVAILABLE_IN_LEGACY_MODE);
	const o = n;
	let a = o.__getInstance(t);
	if (null == a) {
		const n = oee({}, e);
		"__i18n" in i && (n.__i18n = i.__i18n),
			r && (n.__root = r),
			(a = une(n)),
			(function (e, t, n) {
				Vn(() => {}, t),
					jn(() => {
						e.__deleteInstance(t);
					}, t);
			})(o, t),
			o.__setInstance(t, a);
	}
	return a;
}
const Sne = ["locale", "fallbackLocale", "availableLocales"],
	Ene = ["t", "rt", "d", "n", "tm"];
var Tne;
if (
	((_te = function (e, t = {}) {
		{
			const n = (t.onCacheKey || Ite)(e),
				r = Rte[n];
			if (r) return r;
			let i = !1;
			const s = t.onError || Dee;
			t.onError = (e) => {
				(i = !0), s(e);
			};
			const { code: o } = Zee(e, t),
				a = new Function(`return ${o}`)();
			return i ? a : (Rte[n] = a);
		}
	}),
	(wte = function (e, t) {
		if (!vee(e)) return null;
		let n = ite.get(t);
		if (
			(n ||
				((n = (function (e) {
					const t = [];
					let n,
						r,
						i,
						s,
						o,
						a,
						l,
						u = -1,
						c = 0,
						h = 0;
					const d = [];
					function p() {
						const t = e[u + 1];
						if ((5 === c && "'" === t) || (6 === c && '"' === t)) return u++, (i = "\\" + t), d[0](), !0;
					}
					for (
						d[0] = () => {
							void 0 === r ? (r = i) : (r += i);
						},
							d[1] = () => {
								void 0 !== r && (t.push(r), (r = void 0));
							},
							d[2] = () => {
								d[0](), h++;
							},
							d[3] = () => {
								if (h > 0) h--, (c = 4), d[0]();
								else {
									if (((h = 0), void 0 === r)) return !1;
									if (((r = rte(r)), !1 === r)) return !1;
									d[1]();
								}
							};
						null !== c;

					)
						if ((u++, (n = e[u]), "\\" !== n || !p())) {
							if (((s = nte(n)), (l = ete[c]), (o = l[s] || l.l || 8), 8 === o)) return;
							if (((c = o[0]), void 0 !== o[1] && ((a = d[o[1]]), a && ((i = n), !1 === a())))) return;
							if (7 === c) return t;
						}
				})(t)),
				n && ite.set(t, n)),
			!n)
		)
			return null;
		const r = n.length;
		let i = e,
			s = 0;
		for (; s < r; ) {
			const e = i[n[s]];
			if (void 0 === e) return null;
			(i = e), s++;
		}
		return i;
	}),
	(Cte = vte),
	"boolean" != typeof __VUE_I18N_FULL_INSTALL__ && (lee().__VUE_I18N_FULL_INSTALL__ = !0),
	"boolean" != typeof __VUE_I18N_LEGACY_API__ && (lee().__VUE_I18N_LEGACY_API__ = !0),
	"boolean" != typeof __INTLIFY_PROD_DEVTOOLS__ && (lee().__INTLIFY_PROD_DEVTOOLS__ = !1),
	__INTLIFY_PROD_DEVTOOLS__)
) {
	const e = lee();
	(e.__INTLIFY__ = !0), (Tne = e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__), (dte = Tne);
}
function kne(e, t, n) {
	return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : (e[t] = n), e;
}
function Ane(e, t) {
	var n = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(e);
		t &&
			(r = r.filter(function (t) {
				return Object.getOwnPropertyDescriptor(e, t).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function Mne(e) {
	for (var t = 1; t < arguments.length; t++) {
		var n = null != arguments[t] ? arguments[t] : {};
		t % 2
			? Ane(Object(n), !0).forEach(function (t) {
					kne(e, t, n[t]);
			  })
			: Object.getOwnPropertyDescriptors
			? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
			: Ane(Object(n)).forEach(function (t) {
					Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
			  });
	}
	return e;
}
var Ine = function e(t) {
		for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
		if (!r.length) return t;
		var s = r.shift();
		if (IR(t) && IR(s)) {
			for (var o in s) IR(s[o]) ? (t[o] || Object.assign(t, kne({}, o, {})), e(t[o], s[o])) : Object.assign(t, kne({}, o, s[o]));
			return e.apply(void 0, [t].concat(r));
		}
	},
	Rne = function () {
		return "undefined" != typeof window && "undefined" != typeof document;
	},
	Lne = function (e) {
		Rne();
	},
	One = function () {
		var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
		return Lne('Missing "appName" property inside the plugin options.', null == e.app_name), Lne('Missing "name" property in the route.', null == e.screen_name), e;
	};
function Pne() {
	var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
		t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
		n = e.split("/"),
		r = t.split("/");
	return "" === n[0] && "/" === t[t.length - 1] && n.shift(), r.join("/") + n.join("/");
}
var Nne,
	Dne = {},
	Bne = function () {
		var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
			t = {
				bootstrap: !0,
				onReady: null,
				onError: null,
				onBeforeTrack: null,
				onAfterTrack: null,
				pageTrackerTemplate: null,
				customResourceURL: "https://www.googletagmanager.com/gtag/js",
				customPreconnectOrigin: "https://www.googletagmanager.com",
				deferScriptLoad: !1,
				pageTrackerExcludedRoutes: [],
				pageTrackerEnabled: !0,
				enabled: !0,
				disableScriptLoad: !1,
				pageTrackerScreenviewEnabled: !1,
				appName: null,
				pageTrackerUseFullPath: !1,
				pageTrackerPrependBase: !0,
				pageTrackerSkipSamePath: !0,
				globalDataLayerName: "dataLayer",
				globalObjectName: "gtag",
				defaultGroupName: "default",
				includes: null,
				config: { id: null, params: { send_page_view: !1 } }
			};
		Dne = Ine(t, e);
	},
	Fne = function () {
		return Dne;
	},
	Hne = function () {
		var e,
			t = Fne(),
			n = t.globalObjectName;
		Rne() && void 0 !== window[n] && (e = window)[n].apply(e, arguments);
	},
	Vne = function () {
		for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
		var r = Fne(),
			i = r.config,
			s = r.includes;
		Hne.apply(void 0, ["config", i.id].concat(t)),
			Array.isArray(s) &&
				s.forEach(function (e) {
					Hne.apply(void 0, ["config", e.id].concat(t));
				});
	},
	Une = function (e, t) {
		Rne() && (window["ga-disable-".concat(e)] = t);
	},
	zne = function () {
		var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
			t = Fne(),
			n = t.config,
			r = t.includes;
		Une(n.id, e),
			Array.isArray(r) &&
				r.forEach(function (t) {
					return Une(t.id, e);
				});
	},
	$ne = function () {
		zne(!0);
	},
	jne = function (e) {
		Nne = e;
	},
	Wne = function () {
		return Nne;
	},
	Gne = function (e) {
		var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
			n = Fne(),
			r = n.includes,
			i = n.defaultGroupName;
		null == t.send_to &&
			Array.isArray(r) &&
			r.length &&
			(t.send_to = r
				.map(function (e) {
					return e.id;
				})
				.concat(i)),
			Hne("event", e, t);
	},
	Yne = function (e) {
		if (Rne()) {
			var t;
			if ("string" == typeof e) t = { page_path: e };
			else if (e.path || e.fullPath) {
				var n = Fne(),
					r = n.pageTrackerUseFullPath,
					i = n.pageTrackerPrependBase,
					s = Wne(),
					o = s && s.options.base,
					a = r ? e.fullPath : e.path;
				t = Mne(Mne({}, e.name && { page_title: e.name }), {}, { page_path: i ? Pne(a, o) : a });
			} else t = e;
			null == t.page_location && (t.page_location = window.location.href), null == t.send_page_view && (t.send_page_view = !0), Gne("page_view", t);
		}
	},
	Xne = function (e) {
		var t,
			n = Fne().appName;
		e && (((t = "string" == typeof e ? { screen_name: e } : e).app_name = t.app_name || n), Gne("screen_view", t));
	},
	Kne = function () {
		for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
		Gne.apply(void 0, ["exception"].concat(t));
	},
	qne = Object.freeze({
		__proto__: null,
		query: Hne,
		config: Vne,
		optOut: $ne,
		optIn: function () {
			zne(!1);
		},
		pageview: Yne,
		screenview: Xne,
		exception: Kne,
		linker: function (e) {
			Vne("linker", e);
		},
		time: function (e) {
			Gne("timing_complete", e);
		},
		set: function () {
			for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
			Hne.apply(void 0, ["set"].concat(t));
		},
		refund: function () {
			for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
			Gne.apply(void 0, ["refund"].concat(t));
		},
		purchase: function (e) {
			Gne("purchase", e);
		},
		customMap: function (e) {
			Vne({ custom_map: e });
		},
		event: Gne
	}),
	Zne = function (e) {
		e.config.globalProperties.$gtag = qne;
	},
	Jne = function (e) {
		return Mne({ send_page_view: !1 }, e);
	},
	Qne = function () {
		var e = Fne(),
			t = e.config,
			n = e.includes;
		Hne("config", t.id, Jne(t.params)),
			Array.isArray(n) &&
				n.forEach(function (e) {
					Hne("config", e.id, Jne(e.params));
				});
	},
	ere = function () {
		var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
			t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
			n = Fne(),
			r = n.appName,
			i = n.pageTrackerTemplate,
			s = n.pageTrackerScreenviewEnabled,
			o = n.pageTrackerSkipSamePath;
		if (!o || e.path !== t.path) {
			var a = e;
			CR(i) ? (a = i(e, t)) : s && (a = One({ app_name: r, screen_name: e.name })), s ? Xne(a) : Yne(a);
		}
	},
	tre = function (e) {
		var t = Fne().pageTrackerExcludedRoutes;
		return t.includes(e.path) || t.includes(e.name);
	},
	nre = function () {
		var e,
			t,
			n,
			r,
			i = Fne(),
			s = i.onReady,
			o = i.onError,
			a = i.globalObjectName,
			l = i.globalDataLayerName,
			u = i.config,
			c = i.customResourceURL,
			h = i.customPreconnectOrigin,
			d = i.deferScriptLoad,
			p = i.pageTrackerEnabled,
			f = i.disableScriptLoad,
			m = Boolean(p && Wne());
		if (
			((function () {
				if (Rne()) {
					var e = Fne(),
						t = e.enabled,
						n = e.globalObjectName,
						r = e.globalDataLayerName;
					null == window[n] &&
						((window[r] = window[r] || []),
						(window[n] = function () {
							window[r].push(arguments);
						})),
						window[n]("js", new Date()),
						t || $ne(),
						window[n];
				}
			})(),
			m
				? ((e = Fne()),
				  (t = e.onBeforeTrack),
				  (n = e.onAfterTrack),
				  (r = Wne()).isReady().then(function () {
						ns().then(function () {
							var e = r.currentRoute;
							Qne(), tre(e.value) || ere(e.value);
						}),
							r.afterEach(function (e, r) {
								ns().then(function () {
									tre(e) || (CR(t) && t(e, r), ere(e, r), CR(n) && n(e, r));
								});
							});
				  }))
				: Qne(),
			!f)
		)
			return (function (e) {
				var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
				return new Promise(function (n, r) {
					if ("undefined" != typeof document) {
						var i = document.head || document.getElementsByTagName("head")[0],
							s = document.createElement("script");
						if (((s.async = !0), (s.src = e), (s.defer = t.defer), t.preconnectOrigin)) {
							var o = document.createElement("link");
							(o.href = t.preconnectOrigin), (o.rel = "preconnect"), i.appendChild(o);
						}
						i.appendChild(s), (s.onload = n), (s.onerror = r);
					}
				});
			})("".concat(c, "?id=").concat(u.id, "&l=").concat(l), { preconnectOrigin: h, defer: d })
				.then(function () {
					s && s(window[a]);
				})
				.catch(function (e) {
					return o && o(e), e;
				});
	},
	rre = function (e) {
		var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
			n = arguments.length > 2 ? arguments[2] : void 0;
		Zne(e), Bne(t), jne(n), Fne().bootstrap && nre();
	};
function ire(e) {
	return -1 !== e.type.indexOf("mouse") ? e.clientX : e.touches[0].clientX;
}
function sre(e) {
	return -1 !== e.type.indexOf("mouse") ? e.clientY : e.touches[0].clientY;
}
var ore = (function () {
		var e = !1;
		try {
			var t = Object.defineProperty({}, "passive", {
				get: function () {
					e = !0;
				}
			});
			window.addEventListener("test", null, t);
		} catch (Kj) {}
		return e;
	})(),
	are = {
		install: function (e, t) {
			var n = Object.assign({}, { disableClick: !1, tapTolerance: 10, swipeTolerance: 30, touchHoldTolerance: 400, longTapTimeInterval: 400, touchClass: "", dragFrequency: 100, rollOverFrequency: 100 }, t);
			function r(e) {
				var t = this.$$touchObj,
					n = e.type.indexOf("touch") >= 0,
					r = e.type.indexOf("mouse") >= 0,
					i = this;
				n && (t.lastTouchStartTime = e.timeStamp),
					(r && t.lastTouchStartTime && e.timeStamp - t.lastTouchStartTime < 350) ||
						t.touchStarted ||
						(h(this),
						(t.touchStarted = !0),
						(t.touchMoved = !1),
						(t.swipeOutBounded = !1),
						(t.startX = ire(e)),
						(t.startY = sre(e)),
						(t.currentX = 0),
						(t.currentY = 0),
						(t.touchStartTime = e.timeStamp),
						(t.hasSwipe = u(this, "swipe") || u(this, "swipe.left") || u(this, "swipe.right") || u(this, "swipe.top") || u(this, "swipe.bottom")),
						u(this, "hold") &&
							(t.touchHoldTimer = setTimeout(function () {
								(t.touchHoldTimer = null), c(e, i, "hold");
							}, t.options.touchHoldTolerance)),
						c(e, this, "press"));
			}
			function i(e) {
				var t = this.$$touchObj,
					n = ire(e),
					r = sre(e),
					i = t.currentX != n || t.currentY != r;
				if (((t.currentX = n), (t.currentY = r), t.touchMoved)) {
					if (t.hasSwipe && !t.swipeOutBounded) {
						var s = t.options.swipeTolerance;
						t.swipeOutBounded = Math.abs(t.startX - t.currentX) > s && Math.abs(t.startY - t.currentY) > s;
					}
				} else {
					var o = t.options.tapTolerance;
					(t.touchMoved = Math.abs(t.startX - t.currentX) > o || Math.abs(t.startY - t.currentY) > o), t.touchMoved && (p(t), c(e, this, "drag.once"));
				}
				if (u(this, "rollover") && i) {
					var a = e.timeStamp,
						l = t.options.rollOverFrequency;
					(null == t.touchRollTime || a > t.touchRollTime + l) && ((t.touchRollTime = a), c(e, this, "rollover"));
				}
				if (u(this, "drag") && t.touchStarted && t.touchMoved && i) {
					(a = e.timeStamp), (l = t.options.dragFrequency);
					(null == t.touchDragTime || a > t.touchDragTime + l) && ((t.touchDragTime = a), c(e, this, "drag"));
				}
			}
			function s() {
				var e = this.$$touchObj;
				p(e), d(this), (e.touchStarted = e.touchMoved = !1), (e.startX = e.startY = 0);
			}
			function o(e) {
				var t = this.$$touchObj,
					n = e.type.indexOf("touch") >= 0,
					r = e.type.indexOf("mouse") >= 0;
				n && (t.lastTouchEndTime = e.timeStamp);
				var i = n && !t.touchHoldTimer;
				if ((p(t), (t.touchStarted = !1), d(this), !(r && t.lastTouchEndTime && e.timeStamp - t.lastTouchEndTime < 350)))
					if ((c(e, this, "release"), t.touchMoved)) {
						if (t.hasSwipe && !t.swipeOutBounded) {
							var s,
								o = t.options.swipeTolerance,
								a = Math.abs(t.startY - t.currentY),
								l = Math.abs(t.startX - t.currentX);
							(a > o || l > o) && (u(this, "swipe." + (s = a > o ? (t.startY > t.currentY ? "top" : "bottom") : t.startX > t.currentX ? "left" : "right")) ? c(e, this, "swipe." + s, s) : c(e, this, "swipe", s));
						}
					} else if (u(this, "longtap") && e.timeStamp - t.touchStartTime > t.options.longTapTimeInterval) e.cancelable && e.preventDefault(), c(e, this, "longtap");
					else {
						if (u(this, "hold") && i) return void (e.cancelable && e.preventDefault());
						c(e, this, "tap");
					}
			}
			function a() {
				h(this);
			}
			function l() {
				d(this);
			}
			function u(e, t) {
				var n = e.$$touchObj.callbacks[t];
				return null != n && n.length > 0;
			}
			function c(e, t, n, r) {
				var i = t.$$touchObj.callbacks[n];
				if (null == i || 0 === i.length) return null;
				for (var s = 0; s < i.length; s++) {
					var o = i[s];
					o.modifiers.stop && e.stopPropagation(), o.modifiers.prevent && e.preventDefault(), (o.modifiers.self && e.target !== e.currentTarget) || ("function" == typeof o.value && (r ? o.value(r, e) : o.value(e)));
				}
			}
			function h(e) {
				var t = e.$$touchObj.options.touchClass;
				t && e.classList.add(t);
			}
			function d(e) {
				var t = e.$$touchObj.options.touchClass;
				t && e.classList.remove(t);
			}
			function p(e) {
				e.touchHoldTimer && (clearTimeout(e.touchHoldTimer), (e.touchHoldTimer = null));
			}
			function f(e, t) {
				var r = e.$$touchObj || { callbacks: {}, hasBindTouchEvents: !1, options: n };
				return t && (r.options = Object.assign({}, r.options, t)), (e.$$touchObj = r), e.$$touchObj;
			}
			e.directive("touch", {
				beforeMount: function (e, t) {
					var n = f(e),
						u = !!ore && { passive: !0 },
						c = t.arg || "tap";
					switch (c) {
						case "swipe":
							var h = t.modifiers;
							if (h.left || h.right || h.top || h.bottom) {
								for (var d in t.modifiers)
									if (["left", "right", "top", "bottom"].indexOf(d) >= 0) {
										var p = "swipe." + d;
										(n.callbacks[p] = n.callbacks[p] || []), n.callbacks[p].push(t);
									}
							} else (n.callbacks.swipe = n.callbacks.swipe || []), n.callbacks.swipe.push(t);
							break;
						case "press":
						case "drag":
							t.modifiers.disablePassive && (u = !1);
						default:
							(n.callbacks[c] = n.callbacks[c] || []), n.callbacks[c].push(t);
					}
					n.hasBindTouchEvents ||
						(e.addEventListener("touchstart", r, u),
						e.addEventListener("touchmove", i, u),
						e.addEventListener("touchcancel", s),
						e.addEventListener("touchend", o),
						n.options.disableClick || (e.addEventListener("mousedown", r), e.addEventListener("mousemove", i), e.addEventListener("mouseup", o), e.addEventListener("mouseenter", a), e.addEventListener("mouseleave", l)),
						(n.hasBindTouchEvents = !0));
				},
				unmounted: function (e) {
					e.removeEventListener("touchstart", r),
						e.removeEventListener("touchmove", i),
						e.removeEventListener("touchcancel", s),
						e.removeEventListener("touchend", o),
						e.$$touchObj && !e.$$touchObj.options.disableClick && (e.removeEventListener("mousedown", r), e.removeEventListener("mousemove", i), e.removeEventListener("mouseup", o), e.removeEventListener("mouseenter", a), e.removeEventListener("mouseleave", l)),
						delete e.$$touchObj;
				}
			}),
				e.directive("touch-class", {
					beforeMount: function (e, t) {
						f(e, { touchClass: t.value });
					}
				}),
				e.directive("touch-options", {
					beforeMount: function (e, t) {
						f(e, t.value);
					}
				});
		}
	},
	lre = { exports: {} };
"undefined" != typeof self && self;
var ure = Qo(
	(lre.exports = (function (e) {
		var t = {};
		function n(r) {
			if (t[r]) return t[r].exports;
			var i = (t[r] = { i: r, l: !1, exports: {} });
			return e[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
		}
		return (
			(n.m = e),
			(n.c = t),
			(n.d = function (e, t, r) {
				n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: r });
			}),
			(n.r = function (e) {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
			}),
			(n.t = function (e, t) {
				if ((1 & t && (e = n(e)), 8 & t)) return e;
				if (4 & t && "object" == typeof e && e && e.__esModule) return e;
				var r = Object.create(null);
				if ((n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e))
					for (var i in e)
						n.d(
							r,
							i,
							function (t) {
								return e[t];
							}.bind(null, i)
						);
				return r;
			}),
			(n.n = function (e) {
				var t =
					e && e.__esModule
						? function () {
								return e.default;
						  }
						: function () {
								return e;
						  };
				return n.d(t, "a", t), t;
			}),
			(n.o = function (e, t) {
				return Object.prototype.hasOwnProperty.call(e, t);
			}),
			(n.p = ""),
			n((n.s = 12))
		);
	})([
		function (e, t) {
			function n(e) {
				if (e)
					return (function (e) {
						for (var t in n.prototype) e[t] = n.prototype[t];
						return e;
					})(e);
			}
			(t.Emitter = n),
				(n.prototype.on = n.prototype.addEventListener =
					function (e, t) {
						return (this._callbacks = this._callbacks || {}), (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this;
					}),
				(n.prototype.once = function (e, t) {
					function n() {
						this.off(e, n), t.apply(this, arguments);
					}
					return (n.fn = t), this.on(e, n), this;
				}),
				(n.prototype.off =
					n.prototype.removeListener =
					n.prototype.removeAllListeners =
					n.prototype.removeEventListener =
						function (e, t) {
							if (((this._callbacks = this._callbacks || {}), 0 == arguments.length)) return (this._callbacks = {}), this;
							var n,
								r = this._callbacks["$" + e];
							if (!r) return this;
							if (1 == arguments.length) return delete this._callbacks["$" + e], this;
							for (var i = 0; i < r.length; i++)
								if ((n = r[i]) === t || n.fn === t) {
									r.splice(i, 1);
									break;
								}
							return 0 === r.length && delete this._callbacks["$" + e], this;
						}),
				(n.prototype.emit = function (e) {
					this._callbacks = this._callbacks || {};
					for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
					if (n) {
						r = 0;
						for (var i = (n = n.slice(0)).length; r < i; ++r) n[r].apply(this, t);
					}
					return this;
				}),
				(n.prototype.emitReserved = n.prototype.emit),
				(n.prototype.listeners = function (e) {
					return (this._callbacks = this._callbacks || {}), this._callbacks["$" + e] || [];
				}),
				(n.prototype.hasListeners = function (e) {
					return !!this.listeners(e).length;
				});
		},
		function (e, t, n) {
			t.a = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")();
		},
		function (e, t, n) {
			n.d(t, "b", function () {
				return i;
			}),
				n.d(t, "a", function () {
					return a;
				});
			var r = n(1);
			function i(e, ...t) {
				return t.reduce((t, n) => (e.hasOwnProperty(n) && (t[n] = e[n]), t), {});
			}
			const s = setTimeout,
				o = clearTimeout;
			function a(e, t) {
				t.useNativeTimers ? ((e.setTimeoutFn = s.bind(r.a)), (e.clearTimeoutFn = o.bind(r.a))) : ((e.setTimeoutFn = setTimeout.bind(r.a)), (e.clearTimeoutFn = clearTimeout.bind(r.a)));
			}
		},
		function (e, t, n) {
			n.d(t, "c", function () {
				return i;
			}),
				n.d(t, "a", function () {
					return s;
				}),
				n.d(t, "d", function () {
					return o;
				}),
				n.d(t, "b", function () {
					return a;
				});
			var r = n(1);
			const i = "function" == typeof Promise && "function" == typeof Promise.resolve ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0),
				s = r.a.WebSocket || r.a.MozWebSocket,
				o = !0,
				a = "arraybuffer";
		},
		function (e, t, n) {
			n.d(t, "e", function () {
				return x;
			}),
				n.d(t, "c", function () {
					return u;
				}),
				n.d(t, "d", function () {
					return y;
				}),
				n.d(t, "a", function () {
					return v;
				}),
				n.d(t, "b", function () {
					return b;
				});
			const r = Object.create(null);
			(r.open = "0"), (r.close = "1"), (r.ping = "2"), (r.pong = "3"), (r.message = "4"), (r.upgrade = "5"), (r.noop = "6");
			const i = Object.create(null);
			Object.keys(r).forEach((e) => {
				i[r[e]] = e;
			});
			const s = { type: "error", data: "parser error" },
				o = "function" == typeof Blob || ("undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob)),
				a = "function" == typeof ArrayBuffer,
				l = (e, t) => {
					const n = new FileReader();
					return (
						(n.onload = function () {
							const e = n.result.split(",")[1];
							t("b" + e);
						}),
						n.readAsDataURL(e)
					);
				};
			for (
				var u = ({ type: e, data: t }, n, i) => {
						return o && t instanceof Blob ? (n ? i(t) : l(t, i)) : a && (t instanceof ArrayBuffer || ((s = t), "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(s) : s && s.buffer instanceof ArrayBuffer)) ? (n ? i(t) : l(new Blob([t]), i)) : i(r[e] + (t || ""));
						var s;
					},
					c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
					h = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
					d = 0;
				d < c.length;
				d++
			)
				h[c.charCodeAt(d)] = d;
			const p = "function" == typeof ArrayBuffer,
				f = (e, t) => {
					if (p) {
						const n = (function (e) {
							var t,
								n,
								r,
								i,
								s,
								o = 0.75 * e.length,
								a = e.length,
								l = 0;
							"=" === e[e.length - 1] && (o--, "=" === e[e.length - 2] && o--);
							var u = new ArrayBuffer(o),
								c = new Uint8Array(u);
							for (t = 0; t < a; t += 4) (n = h[e.charCodeAt(t)]), (r = h[e.charCodeAt(t + 1)]), (i = h[e.charCodeAt(t + 2)]), (s = h[e.charCodeAt(t + 3)]), (c[l++] = (n << 2) | (r >> 4)), (c[l++] = ((15 & r) << 4) | (i >> 2)), (c[l++] = ((3 & i) << 6) | (63 & s));
							return u;
						})(e);
						return m(n, t);
					}
					return { base64: !0, data: e };
				},
				m = (e, t) => {
					switch (t) {
						case "blob":
							return e instanceof ArrayBuffer ? new Blob([e]) : e;
						case "arraybuffer":
						default:
							return e;
					}
				};
			var v = (e, t) => {
				if ("string" != typeof e) return { type: "message", data: m(e, t) };
				const n = e.charAt(0);
				return "b" === n ? { type: "message", data: f(e.substring(1), t) } : i[n] ? (e.length > 1 ? { type: i[n], data: e.substring(1) } : { type: i[n] }) : s;
			};
			const g = String.fromCharCode(30),
				y = (e, t) => {
					const n = e.length,
						r = new Array(n);
					let i = 0;
					e.forEach((e, s) => {
						u(e, !1, (e) => {
							(r[s] = e), ++i === n && t(r.join(g));
						});
					});
				},
				b = (e, t) => {
					const n = e.split(g),
						r = [];
					for (let i = 0; i < n.length; i++) {
						const e = v(n[i], t);
						if ((r.push(e), "error" === e.type)) break;
					}
					return r;
				},
				x = 4;
		},
		function (e, t, n) {
			n.d(t, "a", function () {
				return o;
			});
			var r = n(4),
				i = n(0),
				s = n(2);
			class o extends i.Emitter {
				constructor(e) {
					super(), (this.writable = !1), Object(s.a)(this, e), (this.opts = e), (this.query = e.query), (this.readyState = ""), (this.socket = e.socket);
				}
				onError(e, t) {
					const n = new Error(e);
					return (n.type = "TransportError"), (n.description = t), super.emit("error", n), this;
				}
				open() {
					return ("closed" !== this.readyState && "" !== this.readyState) || ((this.readyState = "opening"), this.doOpen()), this;
				}
				close() {
					return ("opening" !== this.readyState && "open" !== this.readyState) || (this.doClose(), this.onClose()), this;
				}
				send(e) {
					"open" === this.readyState && this.write(e);
				}
				onOpen() {
					(this.readyState = "open"), (this.writable = !0), super.emit("open");
				}
				onData(e) {
					const t = Object(r.a)(e, this.socket.binaryType);
					this.onPacket(t);
				}
				onPacket(e) {
					super.emit("packet", e);
				}
				onClose() {
					(this.readyState = "closed"), super.emit("close");
				}
			}
		},
		function (e, t) {
			(t.encode = function (e) {
				var t = "";
				for (var n in e) e.hasOwnProperty(n) && (t.length && (t += "&"), (t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n])));
				return t;
			}),
				(t.decode = function (e) {
					for (var t = {}, n = e.split("&"), r = 0, i = n.length; r < i; r++) {
						var s = n[r].split("=");
						t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);
					}
					return t;
				});
		},
		function (e, t) {
			var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
				r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
			e.exports = function (e) {
				var t,
					i,
					s = e,
					o = e.indexOf("["),
					a = e.indexOf("]");
				-1 != o && -1 != a && (e = e.substring(0, o) + e.substring(o, a).replace(/:/g, ";") + e.substring(a, e.length));
				for (var l, u, c = n.exec(e || ""), h = {}, d = 14; d--; ) h[r[d]] = c[d] || "";
				return (
					-1 != o && -1 != a && ((h.source = s), (h.host = h.host.substring(1, h.host.length - 1).replace(/;/g, ":")), (h.authority = h.authority.replace("[", "").replace("]", "").replace(/;/g, ":")), (h.ipv6uri = !0)),
					(h.pathNames = ((t = h.path), (i = t.replace(/\/{2,9}/g, "/").split("/")), ("/" != t.substr(0, 1) && 0 !== t.length) || i.splice(0, 1), "/" == t.substr(t.length - 1, 1) && i.splice(i.length - 1, 1), i)),
					(h.queryKey =
						((l = h.query),
						(u = {}),
						l.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (e, t, n) {
							t && (u[t] = n);
						}),
						u)),
					h
				);
			};
		},
		function (e, t, n) {
			var r,
				i = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
				s = {},
				o = 0,
				a = 0;
			function l(e) {
				var t = "";
				do {
					(t = i[e % 64] + t), (e = Math.floor(e / 64));
				} while (e > 0);
				return t;
			}
			function u() {
				var e = l(+new Date());
				return e !== r ? ((o = 0), (r = e)) : e + "." + l(o++);
			}
			for (; a < 64; a++) s[i[a]] = a;
			(u.encode = l),
				(u.decode = function (e) {
					var t = 0;
					for (a = 0; a < e.length; a++) t = 64 * t + s[e.charAt(a)];
					return t;
				}),
				(e.exports = u);
		},
		function (e, t) {
			try {
				e.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
			} catch (n) {
				e.exports = !1;
			}
		},
		function (e, t, n) {
			(function (e) {
				n.d(t, "a", function () {
					return d;
				});
				var r = n(5),
					i = n(6),
					s = n.n(i),
					o = n(8),
					a = n.n(o),
					l = n(2),
					u = n(3),
					c = n(4);
				const h = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase();
				class d extends r.a {
					constructor(e) {
						super(e), (this.supportsBinary = !e.forceBase64);
					}
					get name() {
						return "websocket";
					}
					doOpen() {
						if (!this.check()) return;
						const e = this.uri(),
							t = this.opts.protocols,
							n = h ? {} : Object(l.b)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
						this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
						try {
							this.ws = u.d && !h ? (t ? new u.a(e, t) : new u.a(e)) : new u.a(e, t, n);
						} catch (r) {
							return this.emit("error", r);
						}
						(this.ws.binaryType = this.socket.binaryType || u.b), this.addEventListeners();
					}
					addEventListeners() {
						(this.ws.onopen = () => {
							this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
						}),
							(this.ws.onclose = this.onClose.bind(this)),
							(this.ws.onmessage = (e) => this.onData(e.data)),
							(this.ws.onerror = (e) => this.onError("websocket error", e));
					}
					write(t) {
						this.writable = !1;
						for (let n = 0; n < t.length; n++) {
							const r = t[n],
								i = n === t.length - 1;
							Object(c.c)(r, this.supportsBinary, (t) => {
								const n = {};
								!u.d && (r.options && (n.compress = r.options.compress), this.opts.perMessageDeflate) && ("string" == typeof t ? e.byteLength(t) : t.length) < this.opts.perMessageDeflate.threshold && (n.compress = !1);
								try {
									u.d ? this.ws.send(t) : this.ws.send(t, n);
								} catch (s) {}
								i &&
									Object(u.c)(() => {
										(this.writable = !0), this.emit("drain");
									}, this.setTimeoutFn);
							});
						}
					}
					doClose() {
						void 0 !== this.ws && (this.ws.close(), (this.ws = null));
					}
					uri() {
						let e = this.query || {};
						const t = this.opts.secure ? "wss" : "ws";
						let n = "";
						this.opts.port && (("wss" === t && 443 !== Number(this.opts.port)) || ("ws" === t && 80 !== Number(this.opts.port))) && (n = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = a()()), this.supportsBinary || (e.b64 = 1);
						const r = s.a.encode(e);
						return t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + n + this.opts.path + (r.length ? "?" + r : "");
					}
					check() {
						return !(!u.a || ("__initialize" in u.a && this.name === d.prototype.name));
					}
				}
			}).call(this, n(13).Buffer);
		},
		function (e, t) {
			function n(e) {
				(e = e || {}), (this.ms = e.min || 100), (this.max = e.max || 1e4), (this.factor = e.factor || 2), (this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0), (this.attempts = 0);
			}
			(e.exports = n),
				(n.prototype.duration = function () {
					var e = this.ms * Math.pow(this.factor, this.attempts++);
					if (this.jitter) {
						var t = Math.random(),
							n = Math.floor(t * this.jitter * e);
						e = 0 == (1 & Math.floor(10 * t)) ? e - n : e + n;
					}
					return 0 | Math.min(e, this.max);
				}),
				(n.prototype.reset = function () {
					this.attempts = 0;
				}),
				(n.prototype.setMin = function (e) {
					this.ms = e;
				}),
				(n.prototype.setMax = function (e) {
					this.max = e;
				}),
				(n.prototype.setJitter = function (e) {
					this.jitter = e;
				});
		},
		function (e, t, n) {
			e.exports = n(18);
		},
		function (e, t, n) {
			(function (e) {
				/*!
				 * The buffer module from node.js, for the browser.
				 *
				 * @author     Feross Aboukhadijeh <http://feross.org>
				 * @license    MIT
				 */
				var r = n(15),
					i = n(16),
					s = n(17);
				function o() {
					return l.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
				}
				function a(e, t) {
					if (o() < t) throw new RangeError("Invalid typed array length");
					return l.TYPED_ARRAY_SUPPORT ? ((e = new Uint8Array(t)).__proto__ = l.prototype) : (null === e && (e = new l(t)), (e.length = t)), e;
				}
				function l(e, t, n) {
					if (!(l.TYPED_ARRAY_SUPPORT || this instanceof l)) return new l(e, t, n);
					if ("number" == typeof e) {
						if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
						return h(this, e);
					}
					return u(this, e, t, n);
				}
				function u(e, t, n, r) {
					if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
					return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer
						? (function (e, t, n, r) {
								if ((t.byteLength, n < 0 || t.byteLength < n)) throw new RangeError("'offset' is out of bounds");
								if (t.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
								return (t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r)), l.TYPED_ARRAY_SUPPORT ? ((e = t).__proto__ = l.prototype) : (e = d(e, t)), e;
						  })(e, t, n, r)
						: "string" == typeof t
						? (function (e, t, n) {
								if ((("string" == typeof n && "" !== n) || (n = "utf8"), !l.isEncoding(n))) throw new TypeError('"encoding" must be a valid string encoding');
								var r = 0 | f(t, n),
									i = (e = a(e, r)).write(t, n);
								return i !== r && (e = e.slice(0, i)), e;
						  })(e, t, n)
						: (function (e, t) {
								if (l.isBuffer(t)) {
									var n = 0 | p(t.length);
									return 0 === (e = a(e, n)).length || t.copy(e, 0, 0, n), e;
								}
								if (t) {
									if (("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer) || "length" in t) return "number" != typeof t.length || (r = t.length) != r ? a(e, 0) : d(e, t);
									if ("Buffer" === t.type && s(t.data)) return d(e, t.data);
								}
								var r;
								throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
						  })(e, t);
				}
				function c(e) {
					if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
					if (e < 0) throw new RangeError('"size" argument must not be negative');
				}
				function h(e, t) {
					if ((c(t), (e = a(e, t < 0 ? 0 : 0 | p(t))), !l.TYPED_ARRAY_SUPPORT)) for (var n = 0; n < t; ++n) e[n] = 0;
					return e;
				}
				function d(e, t) {
					var n = t.length < 0 ? 0 : 0 | p(t.length);
					e = a(e, n);
					for (var r = 0; r < n; r += 1) e[r] = 255 & t[r];
					return e;
				}
				function p(e) {
					if (e >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes");
					return 0 | e;
				}
				function f(e, t) {
					if (l.isBuffer(e)) return e.length;
					if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
					"string" != typeof e && (e = "" + e);
					var n = e.length;
					if (0 === n) return 0;
					for (var r = !1; ; )
						switch (t) {
							case "ascii":
							case "latin1":
							case "binary":
								return n;
							case "utf8":
							case "utf-8":
							case void 0:
								return V(e).length;
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								return 2 * n;
							case "hex":
								return n >>> 1;
							case "base64":
								return U(e).length;
							default:
								if (r) return V(e).length;
								(t = ("" + t).toLowerCase()), (r = !0);
						}
				}
				function m(e, t, n) {
					var r = !1;
					if (((void 0 === t || t < 0) && (t = 0), t > this.length)) return "";
					if (((void 0 === n || n > this.length) && (n = this.length), n <= 0)) return "";
					if ((n >>>= 0) <= (t >>>= 0)) return "";
					for (e || (e = "utf8"); ; )
						switch (e) {
							case "hex":
								return M(this, t, n);
							case "utf8":
							case "utf-8":
								return T(this, t, n);
							case "ascii":
								return k(this, t, n);
							case "latin1":
							case "binary":
								return A(this, t, n);
							case "base64":
								return E(this, t, n);
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								return I(this, t, n);
							default:
								if (r) throw new TypeError("Unknown encoding: " + e);
								(e = (e + "").toLowerCase()), (r = !0);
						}
				}
				function v(e, t, n) {
					var r = e[t];
					(e[t] = e[n]), (e[n] = r);
				}
				function g(e, t, n, r, i) {
					if (0 === e.length) return -1;
					if (("string" == typeof n ? ((r = n), (n = 0)) : n > 2147483647 ? (n = 2147483647) : n < -2147483648 && (n = -2147483648), (n = +n), isNaN(n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length)) {
						if (i) return -1;
						n = e.length - 1;
					} else if (n < 0) {
						if (!i) return -1;
						n = 0;
					}
					if (("string" == typeof t && (t = l.from(t, r)), l.isBuffer(t))) return 0 === t.length ? -1 : y(e, t, n, r, i);
					if ("number" == typeof t) return (t &= 255), l.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? (i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n)) : y(e, [t], n, r, i);
					throw new TypeError("val must be string, number or Buffer");
				}
				function y(e, t, n, r, i) {
					var s,
						o = 1,
						a = e.length,
						l = t.length;
					if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
						if (e.length < 2 || t.length < 2) return -1;
						(o = 2), (a /= 2), (l /= 2), (n /= 2);
					}
					function u(e, t) {
						return 1 === o ? e[t] : e.readUInt16BE(t * o);
					}
					if (i) {
						var c = -1;
						for (s = n; s < a; s++)
							if (u(e, s) === u(t, -1 === c ? 0 : s - c)) {
								if ((-1 === c && (c = s), s - c + 1 === l)) return c * o;
							} else -1 !== c && (s -= s - c), (c = -1);
					} else
						for (n + l > a && (n = a - l), s = n; s >= 0; s--) {
							for (var h = !0, d = 0; d < l; d++)
								if (u(e, s + d) !== u(t, d)) {
									h = !1;
									break;
								}
							if (h) return s;
						}
					return -1;
				}
				function b(e, t, n, r) {
					n = Number(n) || 0;
					var i = e.length - n;
					r ? (r = Number(r)) > i && (r = i) : (r = i);
					var s = t.length;
					if (s % 2 != 0) throw new TypeError("Invalid hex string");
					r > s / 2 && (r = s / 2);
					for (var o = 0; o < r; ++o) {
						var a = parseInt(t.substr(2 * o, 2), 16);
						if (isNaN(a)) return o;
						e[n + o] = a;
					}
					return o;
				}
				function x(e, t, n, r) {
					return z(V(t, e.length - n), e, n, r);
				}
				function _(e, t, n, r) {
					return z(
						(function (e) {
							for (var t = [], n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
							return t;
						})(t),
						e,
						n,
						r
					);
				}
				function w(e, t, n, r) {
					return _(e, t, n, r);
				}
				function C(e, t, n, r) {
					return z(U(t), e, n, r);
				}
				function S(e, t, n, r) {
					return z(
						(function (e, t) {
							for (var n, r, i, s = [], o = 0; o < e.length && !((t -= 2) < 0); ++o) (r = (n = e.charCodeAt(o)) >> 8), (i = n % 256), s.push(i), s.push(r);
							return s;
						})(t, e.length - n),
						e,
						n,
						r
					);
				}
				function E(e, t, n) {
					return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n));
				}
				function T(e, t, n) {
					n = Math.min(e.length, n);
					for (var r = [], i = t; i < n; ) {
						var s,
							o,
							a,
							l,
							u = e[i],
							c = null,
							h = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
						if (i + h <= n)
							switch (h) {
								case 1:
									u < 128 && (c = u);
									break;
								case 2:
									128 == (192 & (s = e[i + 1])) && (l = ((31 & u) << 6) | (63 & s)) > 127 && (c = l);
									break;
								case 3:
									(s = e[i + 1]), (o = e[i + 2]), 128 == (192 & s) && 128 == (192 & o) && (l = ((15 & u) << 12) | ((63 & s) << 6) | (63 & o)) > 2047 && (l < 55296 || l > 57343) && (c = l);
									break;
								case 4:
									(s = e[i + 1]), (o = e[i + 2]), (a = e[i + 3]), 128 == (192 & s) && 128 == (192 & o) && 128 == (192 & a) && (l = ((15 & u) << 18) | ((63 & s) << 12) | ((63 & o) << 6) | (63 & a)) > 65535 && l < 1114112 && (c = l);
							}
						null === c ? ((c = 65533), (h = 1)) : c > 65535 && ((c -= 65536), r.push(((c >>> 10) & 1023) | 55296), (c = 56320 | (1023 & c))), r.push(c), (i += h);
					}
					return (function (e) {
						var t = e.length;
						if (t <= 4096) return String.fromCharCode.apply(String, e);
						for (var n = "", r = 0; r < t; ) n += String.fromCharCode.apply(String, e.slice(r, (r += 4096)));
						return n;
					})(r);
				}
				function k(e, t, n) {
					var r = "";
					n = Math.min(e.length, n);
					for (var i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
					return r;
				}
				function A(e, t, n) {
					var r = "";
					n = Math.min(e.length, n);
					for (var i = t; i < n; ++i) r += String.fromCharCode(e[i]);
					return r;
				}
				function M(e, t, n) {
					var r = e.length;
					(!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
					for (var i = "", s = t; s < n; ++s) i += H(e[s]);
					return i;
				}
				function I(e, t, n) {
					for (var r = e.slice(t, n), i = "", s = 0; s < r.length; s += 2) i += String.fromCharCode(r[s] + 256 * r[s + 1]);
					return i;
				}
				function R(e, t, n) {
					if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
					if (e + t > n) throw new RangeError("Trying to access beyond buffer length");
				}
				function L(e, t, n, r, i, s) {
					if (!l.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
					if (t > i || t < s) throw new RangeError('"value" argument is out of bounds');
					if (n + r > e.length) throw new RangeError("Index out of range");
				}
				function O(e, t, n, r) {
					t < 0 && (t = 65535 + t + 1);
					for (var i = 0, s = Math.min(e.length - n, 2); i < s; ++i) e[n + i] = (t & (255 << (8 * (r ? i : 1 - i)))) >>> (8 * (r ? i : 1 - i));
				}
				function P(e, t, n, r) {
					t < 0 && (t = 4294967295 + t + 1);
					for (var i = 0, s = Math.min(e.length - n, 4); i < s; ++i) e[n + i] = (t >>> (8 * (r ? i : 3 - i))) & 255;
				}
				function N(e, t, n, r, i, s) {
					if (n + r > e.length) throw new RangeError("Index out of range");
					if (n < 0) throw new RangeError("Index out of range");
				}
				function D(e, t, n, r, s) {
					return s || N(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4;
				}
				function B(e, t, n, r, s) {
					return s || N(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8;
				}
				(t.Buffer = l),
					(t.SlowBuffer = function (e) {
						return +e != e && (e = 0), l.alloc(+e);
					}),
					(t.INSPECT_MAX_BYTES = 50),
					(l.TYPED_ARRAY_SUPPORT =
						void 0 !== e.TYPED_ARRAY_SUPPORT
							? e.TYPED_ARRAY_SUPPORT
							: (function () {
									try {
										var e = new Uint8Array(1);
										return (
											(e.__proto__ = {
												__proto__: Uint8Array.prototype,
												foo: function () {
													return 42;
												}
											}),
											42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
										);
									} catch (t) {
										return !1;
									}
							  })()),
					(t.kMaxLength = o()),
					(l.poolSize = 8192),
					(l._augment = function (e) {
						return (e.__proto__ = l.prototype), e;
					}),
					(l.from = function (e, t, n) {
						return u(null, e, t, n);
					}),
					l.TYPED_ARRAY_SUPPORT && ((l.prototype.__proto__ = Uint8Array.prototype), (l.__proto__ = Uint8Array), "undefined" != typeof Symbol && Symbol.species && l[Symbol.species] === l && Object.defineProperty(l, Symbol.species, { value: null, configurable: !0 })),
					(l.alloc = function (e, t, n) {
						return (r = null), (s = t), (o = n), c((i = e)), i <= 0 ? a(r, i) : void 0 !== s ? ("string" == typeof o ? a(r, i).fill(s, o) : a(r, i).fill(s)) : a(r, i);
						var r, i, s, o;
					}),
					(l.allocUnsafe = function (e) {
						return h(null, e);
					}),
					(l.allocUnsafeSlow = function (e) {
						return h(null, e);
					}),
					(l.isBuffer = function (e) {
						return !(null == e || !e._isBuffer);
					}),
					(l.compare = function (e, t) {
						if (!l.isBuffer(e) || !l.isBuffer(t)) throw new TypeError("Arguments must be Buffers");
						if (e === t) return 0;
						for (var n = e.length, r = t.length, i = 0, s = Math.min(n, r); i < s; ++i)
							if (e[i] !== t[i]) {
								(n = e[i]), (r = t[i]);
								break;
							}
						return n < r ? -1 : r < n ? 1 : 0;
					}),
					(l.isEncoding = function (e) {
						switch (String(e).toLowerCase()) {
							case "hex":
							case "utf8":
							case "utf-8":
							case "ascii":
							case "latin1":
							case "binary":
							case "base64":
							case "ucs2":
							case "ucs-2":
							case "utf16le":
							case "utf-16le":
								return !0;
							default:
								return !1;
						}
					}),
					(l.concat = function (e, t) {
						if (!s(e)) throw new TypeError('"list" argument must be an Array of Buffers');
						if (0 === e.length) return l.alloc(0);
						var n;
						if (void 0 === t) for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
						var r = l.allocUnsafe(t),
							i = 0;
						for (n = 0; n < e.length; ++n) {
							var o = e[n];
							if (!l.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
							o.copy(r, i), (i += o.length);
						}
						return r;
					}),
					(l.byteLength = f),
					(l.prototype._isBuffer = !0),
					(l.prototype.swap16 = function () {
						var e = this.length;
						if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
						for (var t = 0; t < e; t += 2) v(this, t, t + 1);
						return this;
					}),
					(l.prototype.swap32 = function () {
						var e = this.length;
						if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
						for (var t = 0; t < e; t += 4) v(this, t, t + 3), v(this, t + 1, t + 2);
						return this;
					}),
					(l.prototype.swap64 = function () {
						var e = this.length;
						if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
						for (var t = 0; t < e; t += 8) v(this, t, t + 7), v(this, t + 1, t + 6), v(this, t + 2, t + 5), v(this, t + 3, t + 4);
						return this;
					}),
					(l.prototype.toString = function () {
						var e = 0 | this.length;
						return 0 === e ? "" : 0 === arguments.length ? T(this, 0, e) : m.apply(this, arguments);
					}),
					(l.prototype.equals = function (e) {
						if (!l.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
						return this === e || 0 === l.compare(this, e);
					}),
					(l.prototype.inspect = function () {
						var e = "",
							n = t.INSPECT_MAX_BYTES;
						return this.length > 0 && ((e = this.toString("hex", 0, n).match(/.{2}/g).join(" ")), this.length > n && (e += " ... ")), "<Buffer " + e + ">";
					}),
					(l.prototype.compare = function (e, t, n, r, i) {
						if (!l.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
						if ((void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length)) throw new RangeError("out of range index");
						if (r >= i && t >= n) return 0;
						if (r >= i) return -1;
						if (t >= n) return 1;
						if (this === e) return 0;
						for (var s = (i >>>= 0) - (r >>>= 0), o = (n >>>= 0) - (t >>>= 0), a = Math.min(s, o), u = this.slice(r, i), c = e.slice(t, n), h = 0; h < a; ++h)
							if (u[h] !== c[h]) {
								(s = u[h]), (o = c[h]);
								break;
							}
						return s < o ? -1 : o < s ? 1 : 0;
					}),
					(l.prototype.includes = function (e, t, n) {
						return -1 !== this.indexOf(e, t, n);
					}),
					(l.prototype.indexOf = function (e, t, n) {
						return g(this, e, t, n, !0);
					}),
					(l.prototype.lastIndexOf = function (e, t, n) {
						return g(this, e, t, n, !1);
					}),
					(l.prototype.write = function (e, t, n, r) {
						if (void 0 === t) (r = "utf8"), (n = this.length), (t = 0);
						else if (void 0 === n && "string" == typeof t) (r = t), (n = this.length), (t = 0);
						else {
							if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
							(t |= 0), isFinite(n) ? ((n |= 0), void 0 === r && (r = "utf8")) : ((r = n), (n = void 0));
						}
						var i = this.length - t;
						if (((void 0 === n || n > i) && (n = i), (e.length > 0 && (n < 0 || t < 0)) || t > this.length)) throw new RangeError("Attempt to write outside buffer bounds");
						r || (r = "utf8");
						for (var s = !1; ; )
							switch (r) {
								case "hex":
									return b(this, e, t, n);
								case "utf8":
								case "utf-8":
									return x(this, e, t, n);
								case "ascii":
									return _(this, e, t, n);
								case "latin1":
								case "binary":
									return w(this, e, t, n);
								case "base64":
									return C(this, e, t, n);
								case "ucs2":
								case "ucs-2":
								case "utf16le":
								case "utf-16le":
									return S(this, e, t, n);
								default:
									if (s) throw new TypeError("Unknown encoding: " + r);
									(r = ("" + r).toLowerCase()), (s = !0);
							}
					}),
					(l.prototype.toJSON = function () {
						return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
					}),
					(l.prototype.slice = function (e, t) {
						var n,
							r = this.length;
						if (((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), l.TYPED_ARRAY_SUPPORT)) (n = this.subarray(e, t)).__proto__ = l.prototype;
						else {
							var i = t - e;
							n = new l(i, void 0);
							for (var s = 0; s < i; ++s) n[s] = this[s + e];
						}
						return n;
					}),
					(l.prototype.readUIntLE = function (e, t, n) {
						(e |= 0), (t |= 0), n || R(e, t, this.length);
						for (var r = this[e], i = 1, s = 0; ++s < t && (i *= 256); ) r += this[e + s] * i;
						return r;
					}),
					(l.prototype.readUIntBE = function (e, t, n) {
						(e |= 0), (t |= 0), n || R(e, t, this.length);
						for (var r = this[e + --t], i = 1; t > 0 && (i *= 256); ) r += this[e + --t] * i;
						return r;
					}),
					(l.prototype.readUInt8 = function (e, t) {
						return t || R(e, 1, this.length), this[e];
					}),
					(l.prototype.readUInt16LE = function (e, t) {
						return t || R(e, 2, this.length), this[e] | (this[e + 1] << 8);
					}),
					(l.prototype.readUInt16BE = function (e, t) {
						return t || R(e, 2, this.length), (this[e] << 8) | this[e + 1];
					}),
					(l.prototype.readUInt32LE = function (e, t) {
						return t || R(e, 4, this.length), (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) + 16777216 * this[e + 3];
					}),
					(l.prototype.readUInt32BE = function (e, t) {
						return t || R(e, 4, this.length), 16777216 * this[e] + ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]);
					}),
					(l.prototype.readIntLE = function (e, t, n) {
						(e |= 0), (t |= 0), n || R(e, t, this.length);
						for (var r = this[e], i = 1, s = 0; ++s < t && (i *= 256); ) r += this[e + s] * i;
						return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)), r;
					}),
					(l.prototype.readIntBE = function (e, t, n) {
						(e |= 0), (t |= 0), n || R(e, t, this.length);
						for (var r = t, i = 1, s = this[e + --r]; r > 0 && (i *= 256); ) s += this[e + --r] * i;
						return s >= (i *= 128) && (s -= Math.pow(2, 8 * t)), s;
					}),
					(l.prototype.readInt8 = function (e, t) {
						return t || R(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
					}),
					(l.prototype.readInt16LE = function (e, t) {
						t || R(e, 2, this.length);
						var n = this[e] | (this[e + 1] << 8);
						return 32768 & n ? 4294901760 | n : n;
					}),
					(l.prototype.readInt16BE = function (e, t) {
						t || R(e, 2, this.length);
						var n = this[e + 1] | (this[e] << 8);
						return 32768 & n ? 4294901760 | n : n;
					}),
					(l.prototype.readInt32LE = function (e, t) {
						return t || R(e, 4, this.length), this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24);
					}),
					(l.prototype.readInt32BE = function (e, t) {
						return t || R(e, 4, this.length), (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3];
					}),
					(l.prototype.readFloatLE = function (e, t) {
						return t || R(e, 4, this.length), i.read(this, e, !0, 23, 4);
					}),
					(l.prototype.readFloatBE = function (e, t) {
						return t || R(e, 4, this.length), i.read(this, e, !1, 23, 4);
					}),
					(l.prototype.readDoubleLE = function (e, t) {
						return t || R(e, 8, this.length), i.read(this, e, !0, 52, 8);
					}),
					(l.prototype.readDoubleBE = function (e, t) {
						return t || R(e, 8, this.length), i.read(this, e, !1, 52, 8);
					}),
					(l.prototype.writeUIntLE = function (e, t, n, r) {
						(e = +e), (t |= 0), (n |= 0), r || L(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
						var i = 1,
							s = 0;
						for (this[t] = 255 & e; ++s < n && (i *= 256); ) this[t + s] = (e / i) & 255;
						return t + n;
					}),
					(l.prototype.writeUIntBE = function (e, t, n, r) {
						(e = +e), (t |= 0), (n |= 0), r || L(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
						var i = n - 1,
							s = 1;
						for (this[t + i] = 255 & e; --i >= 0 && (s *= 256); ) this[t + i] = (e / s) & 255;
						return t + n;
					}),
					(l.prototype.writeUInt8 = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 1, 255, 0), l.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), (this[t] = 255 & e), t + 1;
					}),
					(l.prototype.writeUInt16LE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? ((this[t] = 255 & e), (this[t + 1] = e >>> 8)) : O(this, e, t, !0), t + 2;
					}),
					(l.prototype.writeUInt16BE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 2, 65535, 0), l.TYPED_ARRAY_SUPPORT ? ((this[t] = e >>> 8), (this[t + 1] = 255 & e)) : O(this, e, t, !1), t + 2;
					}),
					(l.prototype.writeUInt32LE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? ((this[t + 3] = e >>> 24), (this[t + 2] = e >>> 16), (this[t + 1] = e >>> 8), (this[t] = 255 & e)) : P(this, e, t, !0), t + 4;
					}),
					(l.prototype.writeUInt32BE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 4, 4294967295, 0), l.TYPED_ARRAY_SUPPORT ? ((this[t] = e >>> 24), (this[t + 1] = e >>> 16), (this[t + 2] = e >>> 8), (this[t + 3] = 255 & e)) : P(this, e, t, !1), t + 4;
					}),
					(l.prototype.writeIntLE = function (e, t, n, r) {
						if (((e = +e), (t |= 0), !r)) {
							var i = Math.pow(2, 8 * n - 1);
							L(this, e, t, n, i - 1, -i);
						}
						var s = 0,
							o = 1,
							a = 0;
						for (this[t] = 255 & e; ++s < n && (o *= 256); ) e < 0 && 0 === a && 0 !== this[t + s - 1] && (a = 1), (this[t + s] = (((e / o) >> 0) - a) & 255);
						return t + n;
					}),
					(l.prototype.writeIntBE = function (e, t, n, r) {
						if (((e = +e), (t |= 0), !r)) {
							var i = Math.pow(2, 8 * n - 1);
							L(this, e, t, n, i - 1, -i);
						}
						var s = n - 1,
							o = 1,
							a = 0;
						for (this[t + s] = 255 & e; --s >= 0 && (o *= 256); ) e < 0 && 0 === a && 0 !== this[t + s + 1] && (a = 1), (this[t + s] = (((e / o) >> 0) - a) & 255);
						return t + n;
					}),
					(l.prototype.writeInt8 = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 1, 127, -128), l.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), (this[t] = 255 & e), t + 1;
					}),
					(l.prototype.writeInt16LE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? ((this[t] = 255 & e), (this[t + 1] = e >>> 8)) : O(this, e, t, !0), t + 2;
					}),
					(l.prototype.writeInt16BE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 2, 32767, -32768), l.TYPED_ARRAY_SUPPORT ? ((this[t] = e >>> 8), (this[t + 1] = 255 & e)) : O(this, e, t, !1), t + 2;
					}),
					(l.prototype.writeInt32LE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 4, 2147483647, -2147483648), l.TYPED_ARRAY_SUPPORT ? ((this[t] = 255 & e), (this[t + 1] = e >>> 8), (this[t + 2] = e >>> 16), (this[t + 3] = e >>> 24)) : P(this, e, t, !0), t + 4;
					}),
					(l.prototype.writeInt32BE = function (e, t, n) {
						return (e = +e), (t |= 0), n || L(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), l.TYPED_ARRAY_SUPPORT ? ((this[t] = e >>> 24), (this[t + 1] = e >>> 16), (this[t + 2] = e >>> 8), (this[t + 3] = 255 & e)) : P(this, e, t, !1), t + 4;
					}),
					(l.prototype.writeFloatLE = function (e, t, n) {
						return D(this, e, t, !0, n);
					}),
					(l.prototype.writeFloatBE = function (e, t, n) {
						return D(this, e, t, !1, n);
					}),
					(l.prototype.writeDoubleLE = function (e, t, n) {
						return B(this, e, t, !0, n);
					}),
					(l.prototype.writeDoubleBE = function (e, t, n) {
						return B(this, e, t, !1, n);
					}),
					(l.prototype.copy = function (e, t, n, r) {
						if ((n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n)) return 0;
						if (0 === e.length || 0 === this.length) return 0;
						if (t < 0) throw new RangeError("targetStart out of bounds");
						if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
						if (r < 0) throw new RangeError("sourceEnd out of bounds");
						r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
						var i,
							s = r - n;
						if (this === e && n < t && t < r) for (i = s - 1; i >= 0; --i) e[i + t] = this[i + n];
						else if (s < 1e3 || !l.TYPED_ARRAY_SUPPORT) for (i = 0; i < s; ++i) e[i + t] = this[i + n];
						else Uint8Array.prototype.set.call(e, this.subarray(n, n + s), t);
						return s;
					}),
					(l.prototype.fill = function (e, t, n, r) {
						if ("string" == typeof e) {
							if (("string" == typeof t ? ((r = t), (t = 0), (n = this.length)) : "string" == typeof n && ((r = n), (n = this.length)), 1 === e.length)) {
								var i = e.charCodeAt(0);
								i < 256 && (e = i);
							}
							if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
							if ("string" == typeof r && !l.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
						} else "number" == typeof e && (e &= 255);
						if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
						if (n <= t) return this;
						var s;
						if (((t >>>= 0), (n = void 0 === n ? this.length : n >>> 0), e || (e = 0), "number" == typeof e)) for (s = t; s < n; ++s) this[s] = e;
						else {
							var o = l.isBuffer(e) ? e : V(new l(e, r).toString()),
								a = o.length;
							for (s = 0; s < n - t; ++s) this[s + t] = o[s % a];
						}
						return this;
					});
				var F = /[^+\/0-9A-Za-z-_]/g;
				function H(e) {
					return e < 16 ? "0" + e.toString(16) : e.toString(16);
				}
				function V(e, t) {
					var n;
					t = t || 1 / 0;
					for (var r = e.length, i = null, s = [], o = 0; o < r; ++o) {
						if ((n = e.charCodeAt(o)) > 55295 && n < 57344) {
							if (!i) {
								if (n > 56319) {
									(t -= 3) > -1 && s.push(239, 191, 189);
									continue;
								}
								if (o + 1 === r) {
									(t -= 3) > -1 && s.push(239, 191, 189);
									continue;
								}
								i = n;
								continue;
							}
							if (n < 56320) {
								(t -= 3) > -1 && s.push(239, 191, 189), (i = n);
								continue;
							}
							n = 65536 + (((i - 55296) << 10) | (n - 56320));
						} else i && (t -= 3) > -1 && s.push(239, 191, 189);
						if (((i = null), n < 128)) {
							if ((t -= 1) < 0) break;
							s.push(n);
						} else if (n < 2048) {
							if ((t -= 2) < 0) break;
							s.push((n >> 6) | 192, (63 & n) | 128);
						} else if (n < 65536) {
							if ((t -= 3) < 0) break;
							s.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
						} else {
							if (!(n < 1114112)) throw new Error("Invalid code point");
							if ((t -= 4) < 0) break;
							s.push((n >> 18) | 240, ((n >> 12) & 63) | 128, ((n >> 6) & 63) | 128, (63 & n) | 128);
						}
					}
					return s;
				}
				function U(e) {
					return r.toByteArray(
						(function (e) {
							if ((e = ((t = e), t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")).replace(F, "")).length < 2) return "";
							for (var t; e.length % 4 != 0; ) e += "=";
							return e;
						})(e)
					);
				}
				function z(e, t, n, r) {
					for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i) t[i + n] = e[i];
					return i;
				}
			}).call(this, n(14));
		},
		function (e, t) {
			var n;
			n = (function () {
				return this;
			})();
			try {
				n = n || new Function("return this")();
			} catch (r) {
				"object" == typeof window && (n = window);
			}
			e.exports = n;
		},
		function (e, t, n) {
			(t.byteLength = function (e) {
				var t = u(e),
					n = t[0],
					r = t[1];
				return (3 * (n + r)) / 4 - r;
			}),
				(t.toByteArray = function (e) {
					var t,
						n,
						r,
						o = u(e),
						a = o[0],
						l = o[1],
						c = new s((3 * (a + (r = l))) / 4 - r),
						h = 0,
						d = l > 0 ? a - 4 : a;
					for (n = 0; n < d; n += 4) (t = (i[e.charCodeAt(n)] << 18) | (i[e.charCodeAt(n + 1)] << 12) | (i[e.charCodeAt(n + 2)] << 6) | i[e.charCodeAt(n + 3)]), (c[h++] = (t >> 16) & 255), (c[h++] = (t >> 8) & 255), (c[h++] = 255 & t);
					return 2 === l && ((t = (i[e.charCodeAt(n)] << 2) | (i[e.charCodeAt(n + 1)] >> 4)), (c[h++] = 255 & t)), 1 === l && ((t = (i[e.charCodeAt(n)] << 10) | (i[e.charCodeAt(n + 1)] << 4) | (i[e.charCodeAt(n + 2)] >> 2)), (c[h++] = (t >> 8) & 255), (c[h++] = 255 & t)), c;
				}),
				(t.fromByteArray = function (e) {
					for (var t, n = e.length, i = n % 3, s = [], o = 0, a = n - i; o < a; o += 16383) s.push(c(e, o, o + 16383 > a ? a : o + 16383));
					return 1 === i ? ((t = e[n - 1]), s.push(r[t >> 2] + r[(t << 4) & 63] + "==")) : 2 === i && ((t = (e[n - 2] << 8) + e[n - 1]), s.push(r[t >> 10] + r[(t >> 4) & 63] + r[(t << 2) & 63] + "=")), s.join("");
				});
			for (var r = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = o.length; a < l; ++a) (r[a] = o[a]), (i[o.charCodeAt(a)] = a);
			function u(e) {
				var t = e.length;
				if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
				var n = e.indexOf("=");
				return -1 === n && (n = t), [n, n === t ? 0 : 4 - (n % 4)];
			}
			function c(e, t, n) {
				for (var i, s, o = [], a = t; a < n; a += 3) (i = ((e[a] << 16) & 16711680) + ((e[a + 1] << 8) & 65280) + (255 & e[a + 2])), o.push(r[((s = i) >> 18) & 63] + r[(s >> 12) & 63] + r[(s >> 6) & 63] + r[63 & s]);
				return o.join("");
			}
			(i["-".charCodeAt(0)] = 62), (i["_".charCodeAt(0)] = 63);
		},
		function (e, t) {
			/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
			(t.read = function (e, t, n, r, i) {
				var s,
					o,
					a = 8 * i - r - 1,
					l = (1 << a) - 1,
					u = l >> 1,
					c = -7,
					h = n ? i - 1 : 0,
					d = n ? -1 : 1,
					p = e[t + h];
				for (h += d, s = p & ((1 << -c) - 1), p >>= -c, c += a; c > 0; s = 256 * s + e[t + h], h += d, c -= 8);
				for (o = s & ((1 << -c) - 1), s >>= -c, c += r; c > 0; o = 256 * o + e[t + h], h += d, c -= 8);
				if (0 === s) s = 1 - u;
				else {
					if (s === l) return o ? NaN : (1 / 0) * (p ? -1 : 1);
					(o += Math.pow(2, r)), (s -= u);
				}
				return (p ? -1 : 1) * o * Math.pow(2, s - r);
			}),
				(t.write = function (e, t, n, r, i, s) {
					var o,
						a,
						l,
						u = 8 * s - i - 1,
						c = (1 << u) - 1,
						h = c >> 1,
						d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
						p = r ? 0 : s - 1,
						f = r ? 1 : -1,
						m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
					for (
						t = Math.abs(t),
							isNaN(t) || t === 1 / 0
								? ((a = isNaN(t) ? 1 : 0), (o = c))
								: ((o = Math.floor(Math.log(t) / Math.LN2)),
								  t * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
								  (t += o + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (o++, (l /= 2)),
								  o + h >= c ? ((a = 0), (o = c)) : o + h >= 1 ? ((a = (t * l - 1) * Math.pow(2, i)), (o += h)) : ((a = t * Math.pow(2, h - 1) * Math.pow(2, i)), (o = 0)));
						i >= 8;
						e[n + p] = 255 & a, p += f, a /= 256, i -= 8
					);
					for (o = (o << i) | a, u += i; u > 0; e[n + p] = 255 & o, p += f, o /= 256, u -= 8);
					e[n + p - f] |= 128 * m;
				});
		},
		function (e, t) {
			var n = {}.toString;
			e.exports =
				Array.isArray ||
				function (e) {
					return "[object Array]" == n.call(e);
				};
		},
		function (e, t, n) {
			n.r(t),
				n.d(t, "default", function () {
					return re;
				});
			var r = {};
			n.r(r),
				n.d(r, "protocol", function () {
					return z;
				}),
				n.d(r, "PacketType", function () {
					return $;
				}),
				n.d(r, "Encoder", function () {
					return W;
				}),
				n.d(r, "Decoder", function () {
					return G;
				});
			var i = {
				beforeCreate() {
					this.sockets || (this.sockets = {}),
						(this.sockets.subscribe = (e, t) => {
							this.$vueSocketIo.emitter.addListener(e, t, this);
						}),
						(this.sockets.unsubscribe = (e) => {
							this.$vueSocketIo.emitter.removeListener(e, this);
						});
				},
				mounted() {
					this.$options.sockets &&
						Object.keys(this.$options.sockets).forEach((e) => {
							"subscribe" !== e && "unsubscribe" !== e && this.$vueSocketIo.emitter.addListener(e, this.$options.sockets[e], this);
						});
				},
				beforeDestroy() {
					this.$options.sockets &&
						Object.keys(this.$options.sockets).forEach((e) => {
							this.$vueSocketIo.emitter.removeListener(e, this);
						});
				}
			};
			function s(e, t) {
				for (var n = 0; n < t.length; n++) {
					var r = t[n];
					(r.enumerable = r.enumerable || !1), (r.configurable = !0), "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
				}
			}
			var o = new ((function () {
				function e() {
					!(function (e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
					})(this, e),
						(this.debug = !1),
						(this.prefix = "%cVue-Socket.io: ");
				}
				var t;
				return (
					(t = [
						{
							key: "info",
							value: function (e, t = "") {
								this.debug && window.console.info(this.prefix + "%c" + e, "color: blue; font-weight: 600", "color: #333333", t);
							}
						},
						{
							key: "error",
							value: function () {
								this.debug && window.console.error(this.prefix, ...arguments);
							}
						},
						{
							key: "warn",
							value: function () {
								this.debug && window.console.warn(this.prefix, ...arguments);
							}
						},
						{
							key: "event",
							value: function (e, t = "") {
								this.debug && window.console.info(this.prefix + "%c" + e, "color: blue; font-weight: 600", "color: #333333", t);
							}
						}
					]) && s(e.prototype, t),
					e
				);
			})())();
			function a(e, t) {
				for (var n = 0; n < t.length; n++) {
					var r = t[n];
					(r.enumerable = r.enumerable || !1), (r.configurable = !0), "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
				}
			}
			let l = (function () {
				function e(t, n) {
					!(function (e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
					})(this, e),
						(this.io = t),
						this.register(),
						(this.emitter = n);
				}
				var t;
				return (
					(t = [
						{
							key: "register",
							value: function () {
								(this.io.onevent = (e) => {
									let [t, ...n] = e.data;
									1 === n.length && (n = n[0]), this.onEvent(t, n);
								}),
									e.staticEvents.forEach((e) => this.io.on(e, (t) => this.onEvent(e, t)));
							}
						},
						{
							key: "onEvent",
							value: function (e, t) {
								this.emitter.emit(e, t);
							}
						}
					]) && a(e.prototype, t),
					e
				);
			})();
			var u, c, h;
			function d(e, t) {
				for (var n = 0; n < t.length; n++) {
					var r = t[n];
					(r.enumerable = r.enumerable || !1), (r.configurable = !0), "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
				}
			}
			(h = ["connect", "error", "disconnect", "reconnect", "reconnect_attempt", "reconnecting", "reconnect_error", "reconnect_failed", "connect_error", "connect_timeout", "connecting", "ping", "pong"]),
				(c = "staticEvents") in (u = l) ? Object.defineProperty(u, c, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : (u[c] = h);
			let p = (function () {
				function e(t = {}) {
					!(function (e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
					})(this, e),
						o.info(t ? "Vuex adapter enabled" : "Vuex adapter disabled"),
						o.info(t.mutationPrefix ? "Vuex socket mutations enabled" : "Vuex socket mutations disabled"),
						o.info(t ? "Vuex socket actions enabled" : "Vuex socket actions disabled"),
						(this.store = t.store),
						(this.actionPrefix = t.actionPrefix ? t.actionPrefix : "SOCKET_"),
						(this.mutationPrefix = t.mutationPrefix),
						(this.listeners = new Map());
				}
				var t;
				return (
					(t = [
						{
							key: "addListener",
							value: function (e, t, n) {
								if ("function" != typeof t) throw new Error("callback must be a function");
								this.listeners.has(e) || this.listeners.set(e, []), this.listeners.get(e).push({ callback: t, component: n }), o.info(`#${e} subscribe, component: ${n.$options.name}`);
							}
						},
						{
							key: "removeListener",
							value: function (e, t) {
								if (this.listeners.has(e)) {
									const n = this.listeners.get(e).filter((e) => e.component !== t);
									n.length > 0 ? this.listeners.set(e, n) : this.listeners.delete(e), o.info(`#${e} unsubscribe, component: ${t.$options.name}`);
								}
							}
						},
						{
							key: "emit",
							value: function (e, t) {
								this.listeners.has(e) &&
									(o.info(`Broadcasting: #${e}, Data:`, t),
									this.listeners.get(e).forEach((e) => {
										e.callback.call(e.component, t);
									})),
									"ping" !== e && "pong" !== e && this.dispatchStore(e, t);
							}
						},
						{
							key: "dispatchStore",
							value: function (e, t) {
								if (this.store && this.store._actions) {
									let n = this.actionPrefix + e;
									for (let e in this.store._actions) e.split("/").pop() === n && (o.info(`Dispatching Action: ${e}, Data:`, t), this.store.dispatch(e, t));
									if (this.mutationPrefix) {
										let n = this.mutationPrefix + e;
										for (let e in this.store._mutations) e.split("/").pop() === n && (o.info(`Commiting Mutation: ${e}, Data:`, t), this.store.commit(e, t));
									}
								}
							}
						}
					]) && d(e.prototype, t),
					e
				);
			})();
			var f = n(7),
				m = n.n(f),
				v = n(9),
				g = n.n(v),
				y = n(1),
				b = function (e) {
					const t = e.xdomain;
					try {
						if ("undefined" != typeof XMLHttpRequest && (!t || g.a)) return new XMLHttpRequest();
					} catch (n) {}
					if (!t)
						try {
							return new y.a[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
						} catch (n) {}
				},
				x = n(2),
				_ = n(0),
				w = n(5),
				C = n(8),
				S = n.n(C),
				E = n(6),
				T = n.n(E),
				k = n(4);
			class A extends w.a {
				constructor() {
					super(...arguments), (this.polling = !1);
				}
				get name() {
					return "polling";
				}
				doOpen() {
					this.poll();
				}
				pause(e) {
					this.readyState = "pausing";
					const t = () => {
						(this.readyState = "paused"), e();
					};
					if (this.polling || !this.writable) {
						let e = 0;
						this.polling &&
							(e++,
							this.once("pollComplete", function () {
								--e || t();
							})),
							this.writable ||
								(e++,
								this.once("drain", function () {
									--e || t();
								}));
					} else t();
				}
				poll() {
					(this.polling = !0), this.doPoll(), this.emit("poll");
				}
				onData(e) {
					Object(k.b)(e, this.socket.binaryType).forEach((e) => {
						if (("opening" === this.readyState && "open" === e.type && this.onOpen(), "close" === e.type)) return this.onClose(), !1;
						this.onPacket(e);
					}),
						"closed" !== this.readyState && ((this.polling = !1), this.emit("pollComplete"), "open" === this.readyState && this.poll());
				}
				doClose() {
					const e = () => {
						this.write([{ type: "close" }]);
					};
					"open" === this.readyState ? e() : this.once("open", e);
				}
				write(e) {
					(this.writable = !1),
						Object(k.d)(e, (e) => {
							this.doWrite(e, () => {
								(this.writable = !0), this.emit("drain");
							});
						});
				}
				uri() {
					let e = this.query || {};
					const t = this.opts.secure ? "https" : "http";
					let n = "";
					!1 !== this.opts.timestampRequests && (e[this.opts.timestampParam] = S()()), this.supportsBinary || e.sid || (e.b64 = 1), this.opts.port && (("https" === t && 443 !== Number(this.opts.port)) || ("http" === t && 80 !== Number(this.opts.port))) && (n = ":" + this.opts.port);
					const r = T.a.encode(e);
					return t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + n + this.opts.path + (r.length ? "?" + r : "");
				}
			}
			function M() {}
			const I = null != new b({ xdomain: !1 }).responseType;
			class R extends _.Emitter {
				constructor(e, t) {
					super(), Object(x.a)(this, t), (this.opts = t), (this.method = t.method || "GET"), (this.uri = e), (this.async = !1 !== t.async), (this.data = void 0 !== t.data ? t.data : null), this.create();
				}
				create() {
					const e = Object(x.b)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
					(e.xdomain = !!this.opts.xd), (e.xscheme = !!this.opts.xs);
					const t = (this.xhr = new b(e));
					try {
						t.open(this.method, this.uri, this.async);
						try {
							if (this.opts.extraHeaders) {
								t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
								for (let e in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(e) && t.setRequestHeader(e, this.opts.extraHeaders[e]);
							}
						} catch (n) {}
						if ("POST" === this.method)
							try {
								t.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
							} catch (n) {}
						try {
							t.setRequestHeader("Accept", "*/*");
						} catch (n) {}
						"withCredentials" in t && (t.withCredentials = this.opts.withCredentials),
							this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout),
							(t.onreadystatechange = () => {
								4 === t.readyState &&
									(200 === t.status || 1223 === t.status
										? this.onLoad()
										: this.setTimeoutFn(() => {
												this.onError("number" == typeof t.status ? t.status : 0);
										  }, 0));
							}),
							t.send(this.data);
					} catch (n) {
						return void this.setTimeoutFn(() => {
							this.onError(n);
						}, 0);
					}
					"undefined" != typeof document && ((this.index = R.requestsCount++), (R.requests[this.index] = this));
				}
				onSuccess() {
					this.emit("success"), this.cleanup();
				}
				onData(e) {
					this.emit("data", e), this.onSuccess();
				}
				onError(e) {
					this.emit("error", e), this.cleanup(!0);
				}
				cleanup(e) {
					if (void 0 !== this.xhr && null !== this.xhr) {
						if (((this.xhr.onreadystatechange = M), e))
							try {
								this.xhr.abort();
							} catch (t) {}
						"undefined" != typeof document && delete R.requests[this.index], (this.xhr = null);
					}
				}
				onLoad() {
					const e = this.xhr.responseText;
					null !== e && this.onData(e);
				}
				abort() {
					this.cleanup();
				}
			}
			if (((R.requestsCount = 0), (R.requests = {}), "undefined" != typeof document))
				if ("function" == typeof attachEvent) attachEvent("onunload", L);
				else if ("function" == typeof addEventListener) {
					const e = "onpagehide" in y.a ? "pagehide" : "unload";
					addEventListener(e, L, !1);
				}
			function L() {
				for (let e in R.requests) R.requests.hasOwnProperty(e) && R.requests[e].abort();
			}
			const O = {
				websocket: n(10).a,
				polling: class extends A {
					constructor(e) {
						if ((super(e), "undefined" != typeof location)) {
							const t = "https:" === location.protocol;
							let n = location.port;
							n || (n = t ? "443" : "80"), (this.xd = ("undefined" != typeof location && e.hostname !== location.hostname) || n !== e.port), (this.xs = e.secure !== t);
						}
						const t = e && e.forceBase64;
						this.supportsBinary = I && !t;
					}
					request(e = {}) {
						return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new R(this.uri(), e);
					}
					doWrite(e, t) {
						const n = this.request({ method: "POST", data: e });
						n.on("success", t),
							n.on("error", (e) => {
								this.onError("xhr post error", e);
							});
					}
					doPoll() {
						const e = this.request();
						e.on("data", this.onData.bind(this)),
							e.on("error", (e) => {
								this.onError("xhr poll error", e);
							}),
							(this.pollXhr = e);
					}
				}
			};
			class P extends _.Emitter {
				constructor(e, t = {}) {
					super(),
						e && "object" == typeof e && ((t = e), (e = null)),
						e ? ((e = m()(e)), (t.hostname = e.host), (t.secure = "https" === e.protocol || "wss" === e.protocol), (t.port = e.port), e.query && (t.query = e.query)) : t.host && (t.hostname = m()(t.host).host),
						Object(x.a)(this, t),
						(this.secure = null != t.secure ? t.secure : "undefined" != typeof location && "https:" === location.protocol),
						t.hostname && !t.port && (t.port = this.secure ? "443" : "80"),
						(this.hostname = t.hostname || ("undefined" != typeof location ? location.hostname : "localhost")),
						(this.port = t.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? "443" : "80")),
						(this.transports = t.transports || ["polling", "websocket"]),
						(this.readyState = ""),
						(this.writeBuffer = []),
						(this.prevBufferLen = 0),
						(this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, t)),
						(this.opts.path = this.opts.path.replace(/\/$/, "") + "/"),
						"string" == typeof this.opts.query && (this.opts.query = T.a.decode(this.opts.query)),
						(this.id = null),
						(this.upgrades = null),
						(this.pingInterval = null),
						(this.pingTimeout = null),
						(this.pingTimeoutTimer = null),
						"function" == typeof addEventListener &&
							(this.opts.closeOnBeforeunload &&
								addEventListener(
									"beforeunload",
									() => {
										this.transport && (this.transport.removeAllListeners(), this.transport.close());
									},
									!1
								),
							"localhost" !== this.hostname &&
								((this.offlineEventListener = () => {
									this.onClose("transport close");
								}),
								addEventListener("offline", this.offlineEventListener, !1))),
						this.open();
				}
				createTransport(e) {
					const t = (function (e) {
						const t = {};
						for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
						return t;
					})(this.opts.query);
					(t.EIO = k.e), (t.transport = e), this.id && (t.sid = this.id);
					const n = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port });
					return new O[e](n);
				}
				open() {
					let e;
					if (this.opts.rememberUpgrade && P.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) e = "websocket";
					else {
						if (0 === this.transports.length)
							return void this.setTimeoutFn(() => {
								this.emitReserved("error", "No transports available");
							}, 0);
						e = this.transports[0];
					}
					this.readyState = "opening";
					try {
						e = this.createTransport(e);
					} catch (t) {
						return this.transports.shift(), void this.open();
					}
					e.open(), this.setTransport(e);
				}
				setTransport(e) {
					this.transport && this.transport.removeAllListeners(),
						(this.transport = e),
						e
							.on("drain", this.onDrain.bind(this))
							.on("packet", this.onPacket.bind(this))
							.on("error", this.onError.bind(this))
							.on("close", () => {
								this.onClose("transport close");
							});
				}
				probe(e) {
					let t = this.createTransport(e),
						n = !1;
					P.priorWebsocketSuccess = !1;
					const r = () => {
						n ||
							(t.send([{ type: "ping", data: "probe" }]),
							t.once("packet", (e) => {
								if (!n)
									if ("pong" === e.type && "probe" === e.data) {
										if (((this.upgrading = !0), this.emitReserved("upgrading", t), !t)) return;
										(P.priorWebsocketSuccess = "websocket" === t.name),
											this.transport.pause(() => {
												n || ("closed" !== this.readyState && (u(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), (t = null), (this.upgrading = !1), this.flush()));
											});
									} else {
										const e = new Error("probe error");
										(e.transport = t.name), this.emitReserved("upgradeError", e);
									}
							}));
					};
					function i() {
						n || ((n = !0), u(), t.close(), (t = null));
					}
					const s = (e) => {
						const n = new Error("probe error: " + e);
						(n.transport = t.name), i(), this.emitReserved("upgradeError", n);
					};
					function o() {
						s("transport closed");
					}
					function a() {
						s("socket closed");
					}
					function l(e) {
						t && e.name !== t.name && i();
					}
					const u = () => {
						t.removeListener("open", r), t.removeListener("error", s), t.removeListener("close", o), this.off("close", a), this.off("upgrading", l);
					};
					t.once("open", r), t.once("error", s), t.once("close", o), this.once("close", a), this.once("upgrading", l), t.open();
				}
				onOpen() {
					if (((this.readyState = "open"), (P.priorWebsocketSuccess = "websocket" === this.transport.name), this.emitReserved("open"), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause)) {
						let e = 0;
						const t = this.upgrades.length;
						for (; e < t; e++) this.probe(this.upgrades[e]);
					}
				}
				onPacket(e) {
					if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState)
						switch ((this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type)) {
							case "open":
								this.onHandshake(JSON.parse(e.data));
								break;
							case "ping":
								this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
								break;
							case "error":
								const t = new Error("server error");
								(t.code = e.data), this.onError(t);
								break;
							case "message":
								this.emitReserved("data", e.data), this.emitReserved("message", e.data);
						}
				}
				onHandshake(e) {
					this.emitReserved("handshake", e),
						(this.id = e.sid),
						(this.transport.query.sid = e.sid),
						(this.upgrades = this.filterUpgrades(e.upgrades)),
						(this.pingInterval = e.pingInterval),
						(this.pingTimeout = e.pingTimeout),
						this.onOpen(),
						"closed" !== this.readyState && this.resetPingTimeout();
				}
				resetPingTimeout() {
					this.clearTimeoutFn(this.pingTimeoutTimer),
						(this.pingTimeoutTimer = this.setTimeoutFn(() => {
							this.onClose("ping timeout");
						}, this.pingInterval + this.pingTimeout)),
						this.opts.autoUnref && this.pingTimeoutTimer.unref();
				}
				onDrain() {
					this.writeBuffer.splice(0, this.prevBufferLen), (this.prevBufferLen = 0), 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush();
				}
				flush() {
					"closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (this.transport.send(this.writeBuffer), (this.prevBufferLen = this.writeBuffer.length), this.emitReserved("flush"));
				}
				write(e, t, n) {
					return this.sendPacket("message", e, t, n), this;
				}
				send(e, t, n) {
					return this.sendPacket("message", e, t, n), this;
				}
				sendPacket(e, t, n, r) {
					if (("function" == typeof t && ((r = t), (t = void 0)), "function" == typeof n && ((r = n), (n = null)), "closing" === this.readyState || "closed" === this.readyState)) return;
					(n = n || {}).compress = !1 !== n.compress;
					const i = { type: e, data: t, options: n };
					this.emitReserved("packetCreate", i), this.writeBuffer.push(i), r && this.once("flush", r), this.flush();
				}
				close() {
					const e = () => {
							this.onClose("forced close"), this.transport.close();
						},
						t = () => {
							this.off("upgrade", t), this.off("upgradeError", t), e();
						},
						n = () => {
							this.once("upgrade", t), this.once("upgradeError", t);
						};
					return (
						("opening" !== this.readyState && "open" !== this.readyState) ||
							((this.readyState = "closing"),
							this.writeBuffer.length
								? this.once("drain", () => {
										this.upgrading ? n() : e();
								  })
								: this.upgrading
								? n()
								: e()),
						this
					);
				}
				onError(e) {
					(P.priorWebsocketSuccess = !1), this.emitReserved("error", e), this.onClose("transport error", e);
				}
				onClose(e, t) {
					("opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState) ||
						(this.clearTimeoutFn(this.pingTimeoutTimer),
						this.transport.removeAllListeners("close"),
						this.transport.close(),
						this.transport.removeAllListeners(),
						"function" == typeof removeEventListener && removeEventListener("offline", this.offlineEventListener, !1),
						(this.readyState = "closed"),
						(this.id = null),
						this.emitReserved("close", e, t),
						(this.writeBuffer = []),
						(this.prevBufferLen = 0));
				}
				filterUpgrades(e) {
					const t = [];
					let n = 0;
					const r = e.length;
					for (; n < r; n++) ~this.transports.indexOf(e[n]) && t.push(e[n]);
					return t;
				}
			}
			(P.protocol = k.e), P.protocol;
			const N = "function" == typeof ArrayBuffer,
				D = Object.prototype.toString,
				B = "function" == typeof Blob || ("undefined" != typeof Blob && "[object BlobConstructor]" === D.call(Blob)),
				F = "function" == typeof File || ("undefined" != typeof File && "[object FileConstructor]" === D.call(File));
			function H(e) {
				return (N && (e instanceof ArrayBuffer || ((t = e), "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer))) || (B && e instanceof Blob) || (F && e instanceof File);
				var t;
			}
			function V(e) {
				const t = [],
					n = e.data,
					r = e;
				return (
					(r.data = (function e(t, n) {
						if (!t) return t;
						if (H(t)) {
							const e = { _placeholder: !0, num: n.length };
							return n.push(t), e;
						}
						if (Array.isArray(t)) {
							const r = new Array(t.length);
							for (let i = 0; i < t.length; i++) r[i] = e(t[i], n);
							return r;
						}
						if ("object" == typeof t && !(t instanceof Date)) {
							const r = {};
							for (const i in t) t.hasOwnProperty(i) && (r[i] = e(t[i], n));
							return r;
						}
						return t;
					})(n, t)),
					(r.attachments = t.length),
					{ packet: r, buffers: t }
				);
			}
			function U(e, t) {
				return (
					(e.data = (function e(t, n) {
						if (!t) return t;
						if (t && t._placeholder) return n[t.num];
						if (Array.isArray(t)) for (let r = 0; r < t.length; r++) t[r] = e(t[r], n);
						else if ("object" == typeof t) for (const r in t) t.hasOwnProperty(r) && (t[r] = e(t[r], n));
						return t;
					})(e.data, t)),
					(e.attachments = void 0),
					e
				);
			}
			const z = 5;
			var $, j;
			((j = $ || ($ = {}))[(j.CONNECT = 0)] = "CONNECT"), (j[(j.DISCONNECT = 1)] = "DISCONNECT"), (j[(j.EVENT = 2)] = "EVENT"), (j[(j.ACK = 3)] = "ACK"), (j[(j.CONNECT_ERROR = 4)] = "CONNECT_ERROR"), (j[(j.BINARY_EVENT = 5)] = "BINARY_EVENT"), (j[(j.BINARY_ACK = 6)] = "BINARY_ACK");
			class W {
				encode(e) {
					return (e.type !== $.EVENT && e.type !== $.ACK) ||
						!(function e(t, n) {
							if (!t || "object" != typeof t) return !1;
							if (Array.isArray(t)) {
								for (let n = 0, r = t.length; n < r; n++) if (e(t[n])) return !0;
								return !1;
							}
							if (H(t)) return !0;
							if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return e(t.toJSON(), !0);
							for (const r in t) if (Object.prototype.hasOwnProperty.call(t, r) && e(t[r])) return !0;
							return !1;
						})(e)
						? [this.encodeAsString(e)]
						: ((e.type = e.type === $.EVENT ? $.BINARY_EVENT : $.BINARY_ACK), this.encodeAsBinary(e));
				}
				encodeAsString(e) {
					let t = "" + e.type;
					return (e.type !== $.BINARY_EVENT && e.type !== $.BINARY_ACK) || (t += e.attachments + "-"), e.nsp && "/" !== e.nsp && (t += e.nsp + ","), null != e.id && (t += e.id), null != e.data && (t += JSON.stringify(e.data)), t;
				}
				encodeAsBinary(e) {
					const t = V(e),
						n = this.encodeAsString(t.packet),
						r = t.buffers;
					return r.unshift(n), r;
				}
			}
			class G extends _.Emitter {
				constructor() {
					super();
				}
				add(e) {
					let t;
					if ("string" == typeof e) (t = this.decodeString(e)), t.type === $.BINARY_EVENT || t.type === $.BINARY_ACK ? ((this.reconstructor = new Y(t)), 0 === t.attachments && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
					else {
						if (!H(e) && !e.base64) throw new Error("Unknown type: " + e);
						if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
						(t = this.reconstructor.takeBinaryData(e)), t && ((this.reconstructor = null), super.emitReserved("decoded", t));
					}
				}
				decodeString(e) {
					let t = 0;
					const n = { type: Number(e.charAt(0)) };
					if (void 0 === $[n.type]) throw new Error("unknown packet type " + n.type);
					if (n.type === $.BINARY_EVENT || n.type === $.BINARY_ACK) {
						const r = t + 1;
						for (; "-" !== e.charAt(++t) && t != e.length; );
						const i = e.substring(r, t);
						if (i != Number(i) || "-" !== e.charAt(t)) throw new Error("Illegal attachments");
						n.attachments = Number(i);
					}
					if ("/" === e.charAt(t + 1)) {
						const r = t + 1;
						for (; ++t && "," !== e.charAt(t) && t !== e.length; );
						n.nsp = e.substring(r, t);
					} else n.nsp = "/";
					const r = e.charAt(t + 1);
					if ("" !== r && Number(r) == r) {
						const r = t + 1;
						for (; ++t; ) {
							const n = e.charAt(t);
							if (null == n || Number(n) != n) {
								--t;
								break;
							}
							if (t === e.length) break;
						}
						n.id = Number(e.substring(r, t + 1));
					}
					if (e.charAt(++t)) {
						const r = (function (e) {
							try {
								return JSON.parse(e);
							} catch (t) {
								return !1;
							}
						})(e.substr(t));
						if (!G.isPayloadValid(n.type, r)) throw new Error("invalid payload");
						n.data = r;
					}
					return n;
				}
				static isPayloadValid(e, t) {
					switch (e) {
						case $.CONNECT:
							return "object" == typeof t;
						case $.DISCONNECT:
							return void 0 === t;
						case $.CONNECT_ERROR:
							return "string" == typeof t || "object" == typeof t;
						case $.EVENT:
						case $.BINARY_EVENT:
							return Array.isArray(t) && t.length > 0;
						case $.ACK:
						case $.BINARY_ACK:
							return Array.isArray(t);
					}
				}
				destroy() {
					this.reconstructor && this.reconstructor.finishedReconstruction();
				}
			}
			class Y {
				constructor(e) {
					(this.packet = e), (this.buffers = []), (this.reconPack = e);
				}
				takeBinaryData(e) {
					if ((this.buffers.push(e), this.buffers.length === this.reconPack.attachments)) {
						const e = U(this.reconPack, this.buffers);
						return this.finishedReconstruction(), e;
					}
					return null;
				}
				finishedReconstruction() {
					(this.reconPack = null), (this.buffers = []);
				}
			}
			function X(e, t, n) {
				return (
					e.on(t, n),
					function () {
						e.off(t, n);
					}
				);
			}
			const K = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 });
			class q extends _.Emitter {
				constructor(e, t, n) {
					super(), (this.connected = !1), (this.disconnected = !0), (this.receiveBuffer = []), (this.sendBuffer = []), (this.ids = 0), (this.acks = {}), (this.flags = {}), (this.io = e), (this.nsp = t), n && n.auth && (this.auth = n.auth), this.io._autoConnect && this.open();
				}
				subEvents() {
					if (this.subs) return;
					const e = this.io;
					this.subs = [X(e, "open", this.onopen.bind(this)), X(e, "packet", this.onpacket.bind(this)), X(e, "error", this.onerror.bind(this)), X(e, "close", this.onclose.bind(this))];
				}
				get active() {
					return !!this.subs;
				}
				connect() {
					return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this;
				}
				open() {
					return this.connect();
				}
				send(...e) {
					return e.unshift("message"), this.emit.apply(this, e), this;
				}
				emit(e, ...t) {
					if (K.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name');
					t.unshift(e);
					const n = { type: $.EVENT, data: t, options: {} };
					(n.options.compress = !1 !== this.flags.compress), "function" == typeof t[t.length - 1] && ((this.acks[this.ids] = t.pop()), (n.id = this.ids++));
					const r = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
					return (this.flags.volatile && (!r || !this.connected)) || (this.connected ? this.packet(n) : this.sendBuffer.push(n)), (this.flags = {}), this;
				}
				packet(e) {
					(e.nsp = this.nsp), this.io._packet(e);
				}
				onopen() {
					"function" == typeof this.auth
						? this.auth((e) => {
								this.packet({ type: $.CONNECT, data: e });
						  })
						: this.packet({ type: $.CONNECT, data: this.auth });
				}
				onerror(e) {
					this.connected || this.emitReserved("connect_error", e);
				}
				onclose(e) {
					(this.connected = !1), (this.disconnected = !0), delete this.id, this.emitReserved("disconnect", e);
				}
				onpacket(e) {
					if (e.nsp === this.nsp)
						switch (e.type) {
							case $.CONNECT:
								if (e.data && e.data.sid) {
									const t = e.data.sid;
									this.onconnect(t);
								} else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
								break;
							case $.EVENT:
							case $.BINARY_EVENT:
								this.onevent(e);
								break;
							case $.ACK:
							case $.BINARY_ACK:
								this.onack(e);
								break;
							case $.DISCONNECT:
								this.ondisconnect();
								break;
							case $.CONNECT_ERROR:
								const t = new Error(e.data.message);
								(t.data = e.data.data), this.emitReserved("connect_error", t);
						}
				}
				onevent(e) {
					const t = e.data || [];
					null != e.id && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
				}
				emitEvent(e) {
					if (this._anyListeners && this._anyListeners.length) {
						const t = this._anyListeners.slice();
						for (const n of t) n.apply(this, e);
					}
					super.emit.apply(this, e);
				}
				ack(e) {
					const t = this;
					let n = !1;
					return function (...r) {
						n || ((n = !0), t.packet({ type: $.ACK, id: e, data: r }));
					};
				}
				onack(e) {
					const t = this.acks[e.id];
					"function" == typeof t && (t.apply(this, e.data), delete this.acks[e.id]);
				}
				onconnect(e) {
					(this.id = e), (this.connected = !0), (this.disconnected = !1), this.emitBuffered(), this.emitReserved("connect");
				}
				emitBuffered() {
					this.receiveBuffer.forEach((e) => this.emitEvent(e)), (this.receiveBuffer = []), this.sendBuffer.forEach((e) => this.packet(e)), (this.sendBuffer = []);
				}
				ondisconnect() {
					this.destroy(), this.onclose("io server disconnect");
				}
				destroy() {
					this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)), this.io._destroy(this);
				}
				disconnect() {
					return this.connected && this.packet({ type: $.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
				}
				close() {
					return this.disconnect();
				}
				compress(e) {
					return (this.flags.compress = e), this;
				}
				get volatile() {
					return (this.flags.volatile = !0), this;
				}
				onAny(e) {
					return (this._anyListeners = this._anyListeners || []), this._anyListeners.push(e), this;
				}
				prependAny(e) {
					return (this._anyListeners = this._anyListeners || []), this._anyListeners.unshift(e), this;
				}
				offAny(e) {
					if (!this._anyListeners) return this;
					if (e) {
						const t = this._anyListeners;
						for (let n = 0; n < t.length; n++) if (e === t[n]) return t.splice(n, 1), this;
					} else this._anyListeners = [];
					return this;
				}
				listenersAny() {
					return this._anyListeners || [];
				}
			}
			var Z = n(11),
				J = n.n(Z);
			class Q extends _.Emitter {
				constructor(e, t) {
					var n;
					super(),
						(this.nsps = {}),
						(this.subs = []),
						e && "object" == typeof e && ((t = e), (e = void 0)),
						((t = t || {}).path = t.path || "/socket.io"),
						(this.opts = t),
						Object(x.a)(this, t),
						this.reconnection(!1 !== t.reconnection),
						this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0),
						this.reconnectionDelay(t.reconnectionDelay || 1e3),
						this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3),
						this.randomizationFactor(null !== (n = t.randomizationFactor) && void 0 !== n ? n : 0.5),
						(this.backoff = new J.a({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() })),
						this.timeout(null == t.timeout ? 2e4 : t.timeout),
						(this._readyState = "closed"),
						(this.uri = e);
					const i = t.parser || r;
					(this.encoder = new i.Encoder()), (this.decoder = new i.Decoder()), (this._autoConnect = !1 !== t.autoConnect), this._autoConnect && this.open();
				}
				reconnection(e) {
					return arguments.length ? ((this._reconnection = !!e), this) : this._reconnection;
				}
				reconnectionAttempts(e) {
					return void 0 === e ? this._reconnectionAttempts : ((this._reconnectionAttempts = e), this);
				}
				reconnectionDelay(e) {
					var t;
					return void 0 === e ? this._reconnectionDelay : ((this._reconnectionDelay = e), null === (t = this.backoff) || void 0 === t || t.setMin(e), this);
				}
				randomizationFactor(e) {
					var t;
					return void 0 === e ? this._randomizationFactor : ((this._randomizationFactor = e), null === (t = this.backoff) || void 0 === t || t.setJitter(e), this);
				}
				reconnectionDelayMax(e) {
					var t;
					return void 0 === e ? this._reconnectionDelayMax : ((this._reconnectionDelayMax = e), null === (t = this.backoff) || void 0 === t || t.setMax(e), this);
				}
				timeout(e) {
					return arguments.length ? ((this._timeout = e), this) : this._timeout;
				}
				maybeReconnectOnOpen() {
					!this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
				}
				open(e) {
					if (~this._readyState.indexOf("open")) return this;
					this.engine = new P(this.uri, this.opts);
					const t = this.engine,
						n = this;
					(this._readyState = "opening"), (this.skipReconnect = !1);
					const r = X(t, "open", function () {
							n.onopen(), e && e();
						}),
						i = X(t, "error", (t) => {
							n.cleanup(), (n._readyState = "closed"), this.emitReserved("error", t), e ? e(t) : n.maybeReconnectOnOpen();
						});
					if (!1 !== this._timeout) {
						const e = this._timeout;
						0 === e && r();
						const n = this.setTimeoutFn(() => {
							r(), t.close(), t.emit("error", new Error("timeout"));
						}, e);
						this.opts.autoUnref && n.unref(),
							this.subs.push(function () {
								clearTimeout(n);
							});
					}
					return this.subs.push(r), this.subs.push(i), this;
				}
				connect(e) {
					return this.open(e);
				}
				onopen() {
					this.cleanup(), (this._readyState = "open"), this.emitReserved("open");
					const e = this.engine;
					this.subs.push(X(e, "ping", this.onping.bind(this)), X(e, "data", this.ondata.bind(this)), X(e, "error", this.onerror.bind(this)), X(e, "close", this.onclose.bind(this)), X(this.decoder, "decoded", this.ondecoded.bind(this)));
				}
				onping() {
					this.emitReserved("ping");
				}
				ondata(e) {
					this.decoder.add(e);
				}
				ondecoded(e) {
					this.emitReserved("packet", e);
				}
				onerror(e) {
					this.emitReserved("error", e);
				}
				socket(e, t) {
					let n = this.nsps[e];
					return n || ((n = new q(this, e, t)), (this.nsps[e] = n)), n;
				}
				_destroy(e) {
					const t = Object.keys(this.nsps);
					for (const n of t) if (this.nsps[n].active) return;
					this._close();
				}
				_packet(e) {
					const t = this.encoder.encode(e);
					for (let n = 0; n < t.length; n++) this.engine.write(t[n], e.options);
				}
				cleanup() {
					this.subs.forEach((e) => e()), (this.subs.length = 0), this.decoder.destroy();
				}
				_close() {
					(this.skipReconnect = !0), (this._reconnecting = !1), "opening" === this._readyState && this.cleanup(), this.backoff.reset(), (this._readyState = "closed"), this.engine && this.engine.close();
				}
				disconnect() {
					return this._close();
				}
				onclose(e) {
					this.cleanup(), this.backoff.reset(), (this._readyState = "closed"), this.emitReserved("close", e), this._reconnection && !this.skipReconnect && this.reconnect();
				}
				reconnect() {
					if (this._reconnecting || this.skipReconnect) return this;
					const e = this;
					if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), (this._reconnecting = !1);
					else {
						const t = this.backoff.duration();
						this._reconnecting = !0;
						const n = this.setTimeoutFn(() => {
							e.skipReconnect ||
								(this.emitReserved("reconnect_attempt", e.backoff.attempts),
								e.skipReconnect ||
									e.open((t) => {
										t ? ((e._reconnecting = !1), e.reconnect(), this.emitReserved("reconnect_error", t)) : e.onreconnect();
									}));
						}, t);
						this.opts.autoUnref && n.unref(),
							this.subs.push(function () {
								clearTimeout(n);
							});
					}
				}
				onreconnect() {
					const e = this.backoff.attempts;
					(this._reconnecting = !1), this.backoff.reset(), this.emitReserved("reconnect", e);
				}
			}
			const ee = {};
			function te(e, t) {
				"object" == typeof e && ((t = e), (e = void 0));
				const n = (function (e, t = "", n) {
						let r = e;
						(n = n || ("undefined" != typeof location && location)),
							null == e && (e = n.protocol + "//" + n.host),
							"string" == typeof e && ("/" === e.charAt(0) && (e = "/" === e.charAt(1) ? n.protocol + e : n.host + e), /^(https?|wss?):\/\//.test(e) || (e = void 0 !== n ? n.protocol + "//" + e : "https://" + e), (r = m()(e))),
							r.port || (/^(http|ws)$/.test(r.protocol) ? (r.port = "80") : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
							(r.path = r.path || "/");
						const i = -1 !== r.host.indexOf(":") ? "[" + r.host + "]" : r.host;
						return (r.id = r.protocol + "://" + i + ":" + r.port + t), (r.href = r.protocol + "://" + i + (n && n.port === r.port ? "" : ":" + r.port)), r;
					})(e, (t = t || {}).path || "/socket.io"),
					r = n.source,
					i = n.id,
					s = n.path,
					o = ee[i] && s in ee[i].nsps;
				let a;
				return t.forceNew || t["force new connection"] || !1 === t.multiplex || o ? (a = new Q(r, t)) : (ee[i] || (ee[i] = new Q(r, t)), (a = ee[i])), n.query && !t.query && (t.query = n.queryKey), a.socket(n.path, t);
			}
			function ne(e, t) {
				for (var n = 0; n < t.length; n++) {
					var r = t[n];
					(r.enumerable = r.enumerable || !1), (r.configurable = !0), "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
				}
			}
			Object.assign(te, { Manager: Q, Socket: q, io: te, connect: te });
			let re = (function () {
				function e({ connection: t, vuex: n, debug: r, options: i }) {
					!(function (e, t) {
						if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
					})(this, e),
						(o.debug = r),
						(this.io = this.connect(t, i)),
						(this.emitter = new p(n)),
						(this.listener = new l(this.io, this.emitter));
				}
				var t;
				return (
					(t = [
						{
							key: "install",
							value: function (e) {
								3 <= +e.version.split(".")[0] ? ((e.config.globalProperties.$socket = this.io), e.provide("socket", this.io), (e.config.globalProperties.$vueSocketIo = this)) : ((e.prototype.$socket = this.io), (e.prototype.$vueSocketIo = this)),
									e.mixin(i),
									o.info("Vue-Socket.io plugin enabled");
							}
						},
						{
							key: "connect",
							value: function (e, t) {
								if (e && "object" == typeof e) return o.info("Received socket.io-client instance"), e;
								if ("string" == typeof e) return o.info("Received connection string"), (this.io = te(e, t));
								throw new Error("Unsupported connection type");
							}
						}
					]) && ne(e.prototype, t),
					e
				);
			})();
		}
	]).default)
);
export {
	T_ as $,
	gw as A,
	nw as B,
	V_ as C,
	bw as D,
	f_ as E,
	Hr as F,
	Dw as G,
	Pw as H,
	Rw as I,
	Lw as J,
	Ow as K,
	Nw as L,
	Aw as M,
	x_ as N,
	__ as O,
	$_ as P,
	A_ as Q,
	z_ as R,
	O_ as S,
	L_ as T,
	I_ as U,
	R_ as V,
	K_ as W,
	Bw as X,
	k_ as Y,
	E_ as Z,
	t_ as _,
	yl as a,
	ds as a$,
	S_ as a0,
	Vw as a1,
	fw as a2,
	pw as a3,
	Uw as a4,
	N_ as a5,
	p_ as a6,
	sw as a7,
	Ew as a8,
	B_ as a9,
	mw as aA,
	vw as aB,
	m_ as aC,
	v_ as aD,
	h_ as aE,
	d_ as aF,
	c_ as aG,
	yw as aH,
	q_ as aI,
	Iw as aJ,
	g_ as aK,
	_w as aL,
	Sw as aM,
	ww as aN,
	Cw as aO,
	Mw as aP,
	P_ as aQ,
	iw as aR,
	xw as aS,
	G_ as aT,
	Fw as aU,
	aw as aV,
	Tw as aW,
	tw as aX,
	b_ as aY,
	y_ as aZ,
	mk as a_,
	ow as aa,
	C_ as ab,
	Q_ as ac,
	cw as ad,
	lw as ae,
	hw as af,
	uw as ag,
	w_ as ah,
	U_ as ai,
	j_ as aj,
	Z_ as ak,
	dw as al,
	u_ as am,
	s_ as an,
	a_ as ao,
	o_ as ap,
	H_ as aq,
	l_ as ar,
	X_ as as,
	ew as at,
	Hw as au,
	W_ as av,
	Y_ as aw,
	rw as ax,
	D_ as ay,
	J_ as az,
	Or as b,
	bm as b$,
	Ye as b0,
	Fe as b1,
	vE as b2,
	UE as b3,
	Ue as b4,
	at as b5,
	Ve as b6,
	it as b7,
	Jx as b8,
	hi as b9,
	G3 as bA,
	a3 as bB,
	cs as bC,
	zo as bD,
	OQ as bE,
	Qx as bF,
	et as bG,
	Nr as bH,
	$n as bI,
	lo as bJ,
	Lr as bK,
	Wo as bL,
	Mn as bM,
	R5 as bN,
	L5 as bO,
	ut as bP,
	so as bQ,
	P5 as bR,
	e5 as bS,
	h5 as bT,
	s5 as bU,
	t5 as bV,
	Hn as bW,
	Jf as bX,
	ed as bY,
	Jh as bZ,
	Sm as b_,
	gi as ba,
	He as bb,
	TT as bc,
	yk as bd,
	bk as be,
	qh as bf,
	iy as bg,
	xl as bh,
	Al as bi,
	tm as bj,
	lp as bk,
	Nv as bl,
	_I as bm,
	SI as bn,
	Vl as bo,
	pt as bp,
	ns as bq,
	vn as br,
	Dr as bs,
	yr as bt,
	v5 as bu,
	mn as bv,
	c5 as bw,
	n5 as bx,
	jo as by,
	y3 as bz,
	qr as c,
	vm as c0,
	Wc as c1,
	pm as c2,
	z5 as c3,
	tb as c4,
	ch as c5,
	jm as c6,
	Py as c7,
	sd as c8,
	Fu as c9,
	C9 as cA,
	Ud as cB,
	zd as cC,
	$6 as cD,
	U6 as cE,
	J9 as cF,
	X3 as cG,
	wne as cH,
	rre as cI,
	Kne as cJ,
	are as cK,
	ure as cL,
	Zo as cM,
	O7 as cN,
	n6 as ca,
	Y6 as cb,
	_b as cc,
	Dm as cd,
	Qm as ce,
	K6 as cf,
	O8 as cg,
	mf as ch,
	df as ci,
	B8 as cj,
	lk as ck,
	V8 as cl,
	yt as cm,
	ii as cn,
	Rn as co,
	Ln as cp,
	o5 as cq,
	jn as cr,
	E7 as cs,
	qx as ct,
	ex as cu,
	m5 as cv,
	p5 as cw,
	P7 as cx,
	N7 as cy,
	I3 as cz,
	Tn as d,
	fi as e,
	Kr as f,
	pi as g,
	ri as h,
	Vn as i,
	ni as j,
	ai as k,
	oi as l,
	un as m,
	gt as n,
	Wr as o,
	ln as p,
	mi as q,
	Qe as r,
	ht as s,
	bt as t,
	xh as u,
	i_ as v,
	cn as w,
	M_ as x,
	kw as y,
	F_ as z
};